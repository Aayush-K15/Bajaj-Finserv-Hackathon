
from .util import (
    MapWindow,
    MapRegion,
    MapRegionList,
    is_64_bit,
)

import sys
from functools import reduce

__all__ = ["StaticWindowMapManager", "SlidingWindowMapManager", "WindowCursor"]





class WindowCursor:

    
    __slots__ = (
        '_manager',  
        '_rlist',   
        '_region',  
        '_ofs',     
        '_size'     
    )

    def __init__(self, manager=None, regions=None):
        self._manager = manager
        self._rlist = regions
        self._region = None
        self._ofs = 0
        self._size = 0

    def __del__(self):
        self._destroy()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self._destroy()

    def _destroy(self):
        
        self.unuse_region()

        if self._rlist is not None:
            
            
            try:
                if len(self._rlist) == 0:
                    
                    self._manager._fdict.pop(self._rlist.path_or_fd())
                
            except (TypeError, KeyError):
                
                
                
                
                pass
            
        

    def _copy_from(self, rhs):
        
        self._manager = rhs._manager
        self._rlist = type(rhs._rlist)(rhs._rlist)
        self._region = rhs._region
        self._ofs = rhs._ofs
        self._size = rhs._size

        for region in self._rlist:
            region.increment_client_count()

        if self._region is not None:
            self._region.increment_client_count()
        

    def __copy__(self):
        
        cpy = type(self)()
        cpy._copy_from(self)
        return cpy

    
    def assign(self, rhs):
        
        self._destroy()
        self._copy_from(rhs)

    def use_region(self, offset=0, size=0, flags=0):
        
        need_region = True
        man = self._manager
        fsize = self._rlist.file_size()
        size = min(size or fsize, man.window_size() or fsize)   

        if self._region is not None:
            if self._region.includes_ofs(offset):
                need_region = False
            else:
                self.unuse_region()
            
        

        
        if offset >= fsize:
            return self
        

        if need_region:
            self._region = man._obtain_region(self._rlist, offset, size, flags, False)
            self._region.increment_client_count()
        

        self._ofs = offset - self._region._b
        self._size = min(size, self._region.ofs_end() - offset)

        return self

    def unuse_region(self):
        
        if self._region is not None:
            self._region.increment_client_count(-1)
        self._region = None
        
        

    def buffer(self):
        
        return memoryview(self._region.buffer())[self._ofs:self._ofs+self._size]

    def map(self):
        
        return self._region.map()

    def is_valid(self):
        
        return self._region is not None

    def is_associated(self):
        
        return self._rlist is not None

    def ofs_begin(self):
        
        return self._region._b + self._ofs

    def ofs_end(self):
        
        
        return self._region._b + self._ofs + self._size

    def size(self):
        
        return self._size

    def region(self):
        
        return self._region

    def includes_ofs(self, ofs):
        
        
        return (self._region._b + self._ofs) <= ofs < (self._region._b + self._ofs + self._size)

    def file_size(self):
        
        return self._rlist.file_size()

    def path_or_fd(self):
        
        return self._rlist.path_or_fd()

    def path(self):
        
        if isinstance(self._rlist.path_or_fd(), int):
            raise ValueError("Path queried although mapping was applied to a file descriptor")
        
        return self._rlist.path_or_fd()

    def fd(self):
        
        if isinstance(self._rlist.path_or_fd(), str):
            raise ValueError("File descriptor queried although mapping was generated from path")
        
        return self._rlist.path_or_fd()

    


class StaticWindowMapManager:

    

    __slots__ = [
        '_fdict',           
        '_window_size',     
        '_max_memory_size',  
        '_max_handle_count',        
        '_memory_size',     
        '_handle_count',        
    ]

    
    MapRegionListCls = MapRegionList
    MapWindowCls = MapWindow
    MapRegionCls = MapRegion
    WindowCursorCls = WindowCursor
    

    _MB_in_bytes = 1024 * 1024

    def __init__(self, window_size=0, max_memory_size=0, max_open_handles=sys.maxsize):
        
        self._fdict = dict()
        self._window_size = window_size
        self._max_memory_size = max_memory_size
        self._max_handle_count = max_open_handles
        self._memory_size = 0
        self._handle_count = 0

        if window_size < 0:
            coeff = 64
            if is_64_bit():
                coeff = 1024
            
            self._window_size = coeff * self._MB_in_bytes
        

        if max_memory_size == 0:
            coeff = 1024
            if is_64_bit():
                coeff = 8192
            
            self._max_memory_size = coeff * self._MB_in_bytes
        

    

    def _collect_lru_region(self, size):
        
        num_found = 0
        while (size == 0) or (self._memory_size + size > self._max_memory_size):
            lru_region = None
            lru_list = None
            for regions in self._fdict.values():
                for region in regions:
                    
                    if (region.client_count() == 1 and
                            (lru_region is None or region._uc < lru_region._uc)):
                        lru_region = region
                        lru_list = regions
                    
                
            

            if lru_region is None:
                break
            

            num_found += 1
            del(lru_list[lru_list.index(lru_region)])
            lru_region.increment_client_count(-1)
            self._memory_size -= lru_region.size()
            self._handle_count -= 1
        
        return num_found

    def _obtain_region(self, a, offset, size, flags, is_recursive):
        
        if self._memory_size + size > self._max_memory_size:
            self._collect_lru_region(size)
        

        r = None
        if a:
            assert len(a) == 1
            r = a[0]
        else:
            try:
                r = self.MapRegionCls(a.path_or_fd(), 0, sys.maxsize, flags)
            except Exception:
                
                
                
                
                if is_recursive:
                    
                    
                    raise
                
                self._collect_lru_region(0)
                return self._obtain_region(a, offset, size, flags, True)
            

            self._handle_count += 1
            self._memory_size += r.size()
            a.append(r)
        

        assert r.includes_ofs(offset)
        return r

    

    
    def make_cursor(self, path_or_fd):
        
        regions = self._fdict.get(path_or_fd)
        if regions is None:
            regions = self.MapRegionListCls(path_or_fd)
            self._fdict[path_or_fd] = regions
        
        return self.WindowCursorCls(self, regions)

    def collect(self):
        
        return self._collect_lru_region(0)

    def num_file_handles(self):
        
        return self._handle_count

    def num_open_files(self):
        
        return reduce(lambda x, y: x + y, (1 for rlist in self._fdict.values() if len(rlist) > 0), 0)

    def window_size(self):
        
        return self._window_size

    def mapped_memory_size(self):
        
        return self._memory_size

    def max_file_handles(self):
        
        return self._max_handle_count

    def max_mapped_memory_size(self):
        
        return self._max_memory_size

    

    

    def force_map_handle_removal_win(self, base_path):
        
        if sys.platform != 'win32':
            return
        

        num_closed = 0
        for path, rlist in self._fdict.items():
            if path.startswith(base_path):
                for region in rlist:
                    region.release()
                    num_closed += 1
            
        
        return num_closed
    


class SlidingWindowMapManager(StaticWindowMapManager):

    

    __slots__ = tuple()

    def __init__(self, window_size=-1, max_memory_size=0, max_open_handles=sys.maxsize):
        
        super().__init__(window_size, max_memory_size, max_open_handles)

    def _obtain_region(self, a, offset, size, flags, is_recursive):
        
        
        r = None
        lo = 0
        hi = len(a)
        while lo < hi:
            mid = (lo + hi) // 2
            ofs = a[mid]._b
            if ofs <= offset:
                if a[mid].includes_ofs(offset):
                    r = a[mid]
                    break
                
                lo = mid + 1
            else:
                hi = mid
            
        

        if r is None:
            window_size = self._window_size
            left = self.MapWindowCls(0, 0)
            mid = self.MapWindowCls(offset, size)
            right = self.MapWindowCls(a.file_size(), 0)

            
            
            
            if self._memory_size + window_size > self._max_memory_size:
                self._collect_lru_region(window_size)
            

            
            insert_pos = 0
            len_regions = len(a)
            if len_regions == 1:
                if a[0]._b <= offset:
                    insert_pos = 1
                
            else:
                
                insert_pos = len_regions
                for i, region in enumerate(a):
                    if region._b > offset:
                        insert_pos = i
                        break
                    
                
            

            
            
            if insert_pos == 0:
                if len_regions:
                    right = self.MapWindowCls.from_region(a[insert_pos])
                
            else:
                if insert_pos != len_regions:
                    right = self.MapWindowCls.from_region(a[insert_pos])
                
                left = self.MapWindowCls.from_region(a[insert_pos - 1])
            

            mid.extend_left_to(left, window_size)
            mid.extend_right_to(right, window_size)
            mid.align()

            
            if mid.ofs_end() > right.ofs:
                mid.size = right.ofs - mid.ofs
            

            
            try:
                if self._handle_count >= self._max_handle_count:
                    raise Exception
                
                r = self.MapRegionCls(a.path_or_fd(), mid.ofs, mid.size, flags)
            except Exception:
                
                
                
                
                if is_recursive:
                    
                    
                    raise
                
                self._collect_lru_region(0)
                return self._obtain_region(a, offset, size, flags, True)
            

            self._handle_count += 1
            self._memory_size += r.size()
            a.insert(insert_pos, r)
        
        return r
