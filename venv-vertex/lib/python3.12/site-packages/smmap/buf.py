
import sys

__all__ = ["SlidingWindowMapBuffer"]


class SlidingWindowMapBuffer:

    
    __slots__ = (
        '_c',           
        '_size',        
    )

    def __init__(self, cursor=None, offset=0, size=sys.maxsize, flags=0):
        
        self._c = cursor
        if cursor and not self.begin_access(cursor, offset, size, flags):
            raise ValueError("Failed to allocate the buffer - probably the given offset is out of bounds")
        

    def __del__(self):
        self.end_access()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.end_access()

    def __len__(self):
        return self._size

    def __getitem__(self, i):
        if isinstance(i, slice):
            return self.__getslice__(i.start or 0, i.stop or self._size)
        c = self._c
        assert c.is_valid()
        if i < 0:
            i = self._size + i
        if not c.includes_ofs(i):
            c.use_region(i, 1)
        
        return c.buffer()[i - c.ofs_begin()]

    def __getslice__(self, i, j):
        c = self._c
        
        
        assert c.is_valid()
        if i < 0:
            i = self._size + i
        if j == sys.maxsize:
            j = self._size
        if j < 0:
            j = self._size + j
        if (c.ofs_begin() <= i) and (j < c.ofs_end()):
            b = c.ofs_begin()
            return c.buffer()[i - b:j - b]
        else:
            l = j - i                 
            ofs = i
            
            
            md = list()
            while l:
                c.use_region(ofs, l)
                assert c.is_valid()
                d = c.buffer()[:l]
                ofs += len(d)
                l -= len(d)
                
                
                if hasattr(d, 'tobytes'):
                    d = d.tobytes()
                md.append(d)
            
            return b''.join(md)
        
    

    def begin_access(self, cursor=None, offset=0, size=sys.maxsize, flags=0):
        
        if cursor:
            self._c = cursor
        

        
        if self._c is not None and self._c.is_associated():
            res = self._c.use_region(offset, size, flags).is_valid()
            if res:
                
                
                
                
                if size > self._c.file_size():
                    size = self._c.file_size() - offset
                
                self._size = size
            
            return res
        
        return False

    def end_access(self):
        
        self._size = 0
        if self._c is not None:
            self._c.unuse_region()
        

    def cursor(self):
        
        return self._c

    
