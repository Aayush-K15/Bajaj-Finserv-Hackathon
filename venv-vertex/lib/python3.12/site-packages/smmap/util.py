
import os
import sys

from mmap import mmap, ACCESS_READ
from mmap import ALLOCATIONGRANULARITY

__all__ = ["align_to_mmap", "is_64_bit",
           "MapWindow", "MapRegion", "MapRegionList", "ALLOCATIONGRANULARITY"]




def align_to_mmap(num, round_up):
    
    res = (num // ALLOCATIONGRANULARITY) * ALLOCATIONGRANULARITY
    if round_up and (res != num):
        res += ALLOCATIONGRANULARITY
    
    return res


def is_64_bit():
    
    return sys.maxsize > (1 << 32) - 1






class MapWindow:

    
    __slots__ = (
        'ofs',      
        'size'              
    )

    def __init__(self, offset, size):
        self.ofs = offset
        self.size = size

    def __repr__(self):
        return "MapWindow(%i, %i)" % (self.ofs, self.size)

    @classmethod
    def from_region(cls, region):
        
        return cls(region._b, region.size())

    def ofs_end(self):
        return self.ofs + self.size

    def align(self):
        
        nofs = align_to_mmap(self.ofs, 0)
        self.size += self.ofs - nofs    
        self.ofs = nofs
        self.size = align_to_mmap(self.size, 1)

    def extend_left_to(self, window, max_size):
        
        rofs = self.ofs - window.ofs_end()
        nsize = rofs + self.size
        rofs -= nsize - min(nsize, max_size)
        self.ofs -= rofs
        self.size += rofs

    def extend_right_to(self, window, max_size):
        
        self.size = min(self.size + (window.ofs - self.ofs_end()), max_size)


class MapRegion:

    
    __slots__ = [
        '_b',   
        '_mf',  
        '_uc',  
        '_size',  
        '__weakref__'
    ]

    
    

    def __init__(self, path_or_fd, ofs, size, flags=0):
        
        self._b = ofs
        self._size = 0
        self._uc = 0

        if isinstance(path_or_fd, int):
            fd = path_or_fd
        else:
            fd = os.open(path_or_fd, os.O_RDONLY | getattr(os, 'O_BINARY', 0) | flags)
        

        try:
            kwargs = dict(access=ACCESS_READ, offset=ofs)
            corrected_size = size
            sizeofs = ofs

            
            
            
            actual_size = min(os.fstat(fd).st_size - sizeofs, corrected_size)
            self._mf = mmap(fd, actual_size, **kwargs)
            

            self._size = len(self._mf)
        finally:
            if isinstance(path_or_fd, str):
                os.close(fd)
            
        
        
        self.increment_client_count()

    def __repr__(self):
        return "MapRegion<%i, %i>" % (self._b, self.size())

    

    def buffer(self):
        
        return self._mf

    def map(self):
        
        return self._mf

    def ofs_begin(self):
        
        return self._b

    def size(self):
        
        return self._size

    def ofs_end(self):
        
        return self._b + self._size

    def includes_ofs(self, ofs):
        
        return self._b <= ofs < self._b + self._size

    def client_count(self):
        
        return self._uc

    def increment_client_count(self, ofs = 1):
        
        self._uc += ofs
        assert self._uc > -1, "Increments must match decrements, usage counter negative: %i" % self._uc

        if self.client_count() == 0:
            self.release()
            return True
        else:
            return False
        

    def release(self):
        
        self._mf.close()

    


class MapRegionList(list):

    
    __slots__ = (
        '_path_or_fd',  
        '_file_size'    
    )

    def __new__(cls, path):
        return super().__new__(cls)

    def __init__(self, path_or_fd):
        self._path_or_fd = path_or_fd
        self._file_size = None

    def path_or_fd(self):
        
        return self._path_or_fd

    def file_size(self):
        
        if self._file_size is None:
            if isinstance(self._path_or_fd, str):
                self._file_size = os.stat(self._path_or_fd).st_size
            else:
                self._file_size = os.fstat(self._path_or_fd).st_size
            
        
        return self._file_size


