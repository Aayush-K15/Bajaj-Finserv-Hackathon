

from __future__ import annotations

from collections import abc
from numbers import Number
import re
from re import Pattern
from typing import TYPE_CHECKING

import numpy as np

from pandas._libs import lib

if TYPE_CHECKING:
    from collections.abc import Hashable

    from pandas._typing import TypeGuard

is_bool = lib.is_bool

is_integer = lib.is_integer

is_float = lib.is_float

is_complex = lib.is_complex

is_scalar = lib.is_scalar

is_decimal = lib.is_decimal

is_interval = lib.is_interval

is_list_like = lib.is_list_like

is_iterator = lib.is_iterator


def is_number(obj) -> TypeGuard[Number | np.number]:
    
    return isinstance(obj, (Number, np.number))


def iterable_not_string(obj) -> bool:
    
    return isinstance(obj, abc.Iterable) and not isinstance(obj, str)


def is_file_like(obj) -> bool:
    
    if not (hasattr(obj, "read") or hasattr(obj, "write")):
        return False

    return bool(hasattr(obj, "__iter__"))


def is_re(obj) -> TypeGuard[Pattern]:
    
    return isinstance(obj, Pattern)


def is_re_compilable(obj) -> bool:
    
    try:
        re.compile(obj)
    except TypeError:
        return False
    else:
        return True


def is_array_like(obj) -> bool:
    
    return is_list_like(obj) and hasattr(obj, "dtype")


def is_nested_list_like(obj) -> bool:
    
    return (
        is_list_like(obj)
        and hasattr(obj, "__len__")
        and len(obj) > 0
        and all(is_list_like(item) for item in obj)
    )


def is_dict_like(obj) -> bool:
    
    dict_like_attrs = ("__getitem__", "keys", "__contains__")
    return (
        all(hasattr(obj, attr) for attr in dict_like_attrs)
        
        and not isinstance(obj, type)
    )


def is_named_tuple(obj) -> bool:
    
    return isinstance(obj, abc.Sequence) and hasattr(obj, "_fields")


def is_hashable(obj) -> TypeGuard[Hashable]:
    
    
    
    

    
    

    try:
        hash(obj)
    except TypeError:
        return False
    else:
        return True


def is_sequence(obj) -> bool:
    
    try:
        iter(obj)  
        len(obj)  
        return not isinstance(obj, (str, bytes))
    except (TypeError, AttributeError):
        return False


def is_dataclass(item) -> bool:
    
    try:
        import dataclasses

        return dataclasses.is_dataclass(item) and not isinstance(item, type)
    except ImportError:
        return False
