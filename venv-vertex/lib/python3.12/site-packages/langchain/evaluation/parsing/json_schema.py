from typing import Any, Union

from langchain_core.utils.json import parse_json_markdown
from typing_extensions import override

from langchain.evaluation.schema import StringEvaluator


class JsonSchemaEvaluator(StringEvaluator):
      

    def __init__(self, **kwargs: Any) -> None:
        
        super().__init__()
        try:
            import jsonschema  
        except ImportError as e:
            msg = (
                "The JsonSchemaEvaluator requires the jsonschema package."
                " Please install it with `pip install jsonschema`."
            )
            raise ImportError(msg) from e

    @property
    def requires_input(self) -> bool:
        
        return False

    @property
    def requires_reference(self) -> bool:
        
        return True

    @property
    def evaluation_name(self) -> str:
        
        return "json_schema_validation"

    def _parse_json(self, node: Any) -> Union[dict, list, None, float, bool, int, str]:
        if isinstance(node, str):
            return parse_json_markdown(node)
        if hasattr(node, "model_json_schema") and callable(node.model_json_schema):
            
            return node.model_json_schema()
        if hasattr(node, "schema") and callable(node.schema):
            
            return node.schema()
        return node

    def _validate(self, prediction: Any, schema: Any) -> dict:
        from jsonschema import ValidationError, validate

        try:
            validate(instance=prediction, schema=schema)
        except ValidationError as e:
            return {"score": False, "reasoning": repr(e)}
        return {"score": True}

    @override
    def _evaluate_strings(
        self,
        prediction: Union[str, Any],
        input: Union[str, Any] = None,
        reference: Union[str, Any] = None,
        **kwargs: Any,
    ) -> dict:
        parsed_prediction = self._parse_json(prediction)
        schema = self._parse_json(reference)
        return self._validate(parsed_prediction, schema)
