import os
import re
import time
from collections.abc import Iterator, Sequence
from pathlib import Path
from typing import Optional, Union

from langchain_core.stores import ByteStore

from langchain.storage.exceptions import InvalidKeyException


class LocalFileStore(ByteStore):
    

    def __init__(
        self,
        root_path: Union[str, Path],
        *,
        chmod_file: Optional[int] = None,
        chmod_dir: Optional[int] = None,
        update_atime: bool = False,
    ) -> None:
        
        self.root_path = Path(root_path).absolute()
        self.chmod_file = chmod_file
        self.chmod_dir = chmod_dir
        self.update_atime = update_atime

    def _get_full_path(self, key: str) -> Path:
        
        if not re.match(r"^[a-zA-Z0-9_.\-/]+$", key):
            msg = f"Invalid characters in key: {key}"
            raise InvalidKeyException(msg)
        full_path = (self.root_path / key).resolve()
        root_path = self.root_path.resolve()
        common_path = os.path.commonpath([root_path, full_path])
        if common_path != str(root_path):
            msg = (
                f"Invalid key: {key}. Key should be relative to the full path. "
                f"{root_path} vs. {common_path} and full path of {full_path}"
            )
            raise InvalidKeyException(msg)

        return full_path

    def _mkdir_for_store(self, dir_path: Path) -> None:
        
        if not dir_path.exists():
            self._mkdir_for_store(dir_path.parent)
            dir_path.mkdir(exist_ok=True)
            if self.chmod_dir is not None:
                dir_path.chmod(self.chmod_dir)

    def mget(self, keys: Sequence[str]) -> list[Optional[bytes]]:
        
        values: list[Optional[bytes]] = []
        for key in keys:
            full_path = self._get_full_path(key)
            if full_path.exists():
                value = full_path.read_bytes()
                values.append(value)
                if self.update_atime:
                    
                    os.utime(full_path, (time.time(), full_path.stat().st_mtime))
            else:
                values.append(None)
        return values

    def mset(self, key_value_pairs: Sequence[tuple[str, bytes]]) -> None:
        
        for key, value in key_value_pairs:
            full_path = self._get_full_path(key)
            self._mkdir_for_store(full_path.parent)
            full_path.write_bytes(value)
            if self.chmod_file is not None:
                full_path.chmod(self.chmod_file)

    def mdelete(self, keys: Sequence[str]) -> None:
        
        for key in keys:
            full_path = self._get_full_path(key)
            if full_path.exists():
                full_path.unlink()

    def yield_keys(self, prefix: Optional[str] = None) -> Iterator[str]:
        
        prefix_path = self._get_full_path(prefix) if prefix else self.root_path
        for file in prefix_path.rglob("*"):
            if file.is_file():
                relative_path = file.relative_to(self.root_path)
                yield str(relative_path)
