

from __future__ import annotations

from collections.abc import Sequence
from typing import Optional

from langchain_core.language_models.llms import BaseLLM
from langchain_core.prompts.prompt import PromptTemplate
from langchain_core.utils.input import get_color_mapping, print_text

from langchain.chains.base import Chain
from langchain.chains.llm import LLMChain


class ModelLaboratory:
    

    def __init__(self, chains: Sequence[Chain], names: Optional[list[str]] = None):
        
        for chain in chains:
            if not isinstance(chain, Chain):
                msg = (
                    "ModelLaboratory should now be initialized with Chains. "
                    "If you want to initialize with LLMs, use the `from_llms` method "
                    "instead (`ModelLaboratory.from_llms(...)`)"
                )
                raise ValueError(msg)  
            if len(chain.input_keys) != 1:
                msg = (
                    "Currently only support chains with one input variable, "
                    f"got {chain.input_keys}"
                )
                raise ValueError(msg)
            if len(chain.output_keys) != 1:
                msg = (
                    "Currently only support chains with one output variable, "
                    f"got {chain.output_keys}"
                )
        if names is not None and len(names) != len(chains):
            msg = "Length of chains does not match length of names."
            raise ValueError(msg)
        self.chains = chains
        chain_range = [str(i) for i in range(len(self.chains))]
        self.chain_colors = get_color_mapping(chain_range)
        self.names = names

    @classmethod
    def from_llms(
        cls,
        llms: list[BaseLLM],
        prompt: Optional[PromptTemplate] = None,
    ) -> ModelLaboratory:
        
        if prompt is None:
            prompt = PromptTemplate(input_variables=["_input"], template="{_input}")
        chains = [LLMChain(llm=llm, prompt=prompt) for llm in llms]
        names = [str(llm) for llm in llms]
        return cls(chains, names=names)

    def compare(self, text: str) -> None:
        
        print(f"\033[1mInput:\033[0m\n{text}\n")  
        for i, chain in enumerate(self.chains):
            name = self.names[i] if self.names is not None else str(chain)
            print_text(name, end="\n")
            output = chain.run(text)
            print_text(output, color=self.chain_colors[str(i)], end="\n\n")
