

from __future__ import annotations

from collections.abc import Sequence
from typing import Any, Optional
from urllib.parse import urlparse

from langchain_core._api import deprecated
from langchain_core.callbacks import (
    AsyncCallbackManagerForChainRun,
    CallbackManagerForChainRun,
)
from langchain_core.language_models import BaseLanguageModel
from langchain_core.prompts import BasePromptTemplate
from pydantic import Field, model_validator
from typing_extensions import Self

from langchain.chains.api.prompt import API_RESPONSE_PROMPT, API_URL_PROMPT
from langchain.chains.base import Chain
from langchain.chains.llm import LLMChain


def _extract_scheme_and_domain(url: str) -> tuple[str, str]:
    
    parsed_uri = urlparse(url)
    return parsed_uri.scheme, parsed_uri.netloc


def _check_in_allowed_domain(url: str, limit_to_domains: Sequence[str]) -> bool:
    
    scheme, domain = _extract_scheme_and_domain(url)

    for allowed_domain in limit_to_domains:
        allowed_scheme, allowed_domain_ = _extract_scheme_and_domain(allowed_domain)
        if scheme == allowed_scheme and domain == allowed_domain_:
            return True
    return False


try:
    from langchain_community.utilities.requests import TextRequestsWrapper

    @deprecated(
        since="0.2.13",
        message=(
            "This class is deprecated and will be removed in langchain 1.0. "
            "See API reference for replacement: "
            "https://api.python.langchain.com/en/latest/chains/langchain.chains.api.base.APIChain.html"
        ),
        removal="1.0",
    )
    class APIChain(Chain):
          

        api_request_chain: LLMChain
        api_answer_chain: LLMChain
        requests_wrapper: TextRequestsWrapper = Field(exclude=True)
        api_docs: str
        question_key: str = "question"  
        output_key: str = "output"  
        limit_to_domains: Optional[Sequence[str]] = Field(default_factory=list)  
        

        @property
        def input_keys(self) -> list[str]:
            
            return [self.question_key]

        @property
        def output_keys(self) -> list[str]:
            
            return [self.output_key]

        @model_validator(mode="after")
        def validate_api_request_prompt(self) -> Self:
            
            input_vars = self.api_request_chain.prompt.input_variables
            expected_vars = {"question", "api_docs"}
            if set(input_vars) != expected_vars:
                msg = f"Input variables should be {expected_vars}, got {input_vars}"
                raise ValueError(msg)
            return self

        @model_validator(mode="before")
        @classmethod
        def validate_limit_to_domains(cls, values: dict) -> Any:
            
            
            
            if "limit_to_domains" not in values:
                msg = (
                    "You must specify a list of domains to limit access using "
                    "`limit_to_domains`"
                )
                raise ValueError(msg)
            if (
                not values["limit_to_domains"]
                and values["limit_to_domains"] is not None
            ):
                msg = (
                    "Please provide a list of domains to limit access using "
                    "`limit_to_domains`."
                )
                raise ValueError(msg)
            return values

        @model_validator(mode="after")
        def validate_api_answer_prompt(self) -> Self:
            
            input_vars = self.api_answer_chain.prompt.input_variables
            expected_vars = {"question", "api_docs", "api_url", "api_response"}
            if set(input_vars) != expected_vars:
                msg = f"Input variables should be {expected_vars}, got {input_vars}"
                raise ValueError(msg)
            return self

        def _call(
            self,
            inputs: dict[str, Any],
            run_manager: Optional[CallbackManagerForChainRun] = None,
        ) -> dict[str, str]:
            _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()
            question = inputs[self.question_key]
            api_url = self.api_request_chain.predict(
                question=question,
                api_docs=self.api_docs,
                callbacks=_run_manager.get_child(),
            )
            _run_manager.on_text(api_url, color="green", end="\n", verbose=self.verbose)
            api_url = api_url.strip()
            if self.limit_to_domains and not _check_in_allowed_domain(
                api_url,
                self.limit_to_domains,
            ):
                msg = (
                    f"{api_url} is not in the allowed domains: {self.limit_to_domains}"
                )
                raise ValueError(msg)
            api_response = self.requests_wrapper.get(api_url)
            _run_manager.on_text(
                str(api_response),
                color="yellow",
                end="\n",
                verbose=self.verbose,
            )
            answer = self.api_answer_chain.predict(
                question=question,
                api_docs=self.api_docs,
                api_url=api_url,
                api_response=api_response,
                callbacks=_run_manager.get_child(),
            )
            return {self.output_key: answer}

        async def _acall(
            self,
            inputs: dict[str, Any],
            run_manager: Optional[AsyncCallbackManagerForChainRun] = None,
        ) -> dict[str, str]:
            _run_manager = (
                run_manager or AsyncCallbackManagerForChainRun.get_noop_manager()
            )
            question = inputs[self.question_key]
            api_url = await self.api_request_chain.apredict(
                question=question,
                api_docs=self.api_docs,
                callbacks=_run_manager.get_child(),
            )
            await _run_manager.on_text(
                api_url,
                color="green",
                end="\n",
                verbose=self.verbose,
            )
            api_url = api_url.strip()
            if self.limit_to_domains and not _check_in_allowed_domain(
                api_url,
                self.limit_to_domains,
            ):
                msg = (
                    f"{api_url} is not in the allowed domains: {self.limit_to_domains}"
                )
                raise ValueError(msg)
            api_response = await self.requests_wrapper.aget(api_url)
            await _run_manager.on_text(
                str(api_response),
                color="yellow",
                end="\n",
                verbose=self.verbose,
            )
            answer = await self.api_answer_chain.apredict(
                question=question,
                api_docs=self.api_docs,
                api_url=api_url,
                api_response=api_response,
                callbacks=_run_manager.get_child(),
            )
            return {self.output_key: answer}

        @classmethod
        def from_llm_and_api_docs(
            cls,
            llm: BaseLanguageModel,
            api_docs: str,
            headers: Optional[dict] = None,
            api_url_prompt: BasePromptTemplate = API_URL_PROMPT,
            api_response_prompt: BasePromptTemplate = API_RESPONSE_PROMPT,
            limit_to_domains: Optional[Sequence[str]] = (),
            **kwargs: Any,
        ) -> APIChain:
            
            get_request_chain = LLMChain(llm=llm, prompt=api_url_prompt)
            requests_wrapper = TextRequestsWrapper(headers=headers)
            get_answer_chain = LLMChain(llm=llm, prompt=api_response_prompt)
            return cls(
                api_request_chain=get_request_chain,
                api_answer_chain=get_answer_chain,
                requests_wrapper=requests_wrapper,
                api_docs=api_docs,
                limit_to_domains=limit_to_domains,
                **kwargs,
            )

        @property
        def _chain_type(self) -> str:
            return "api_chain"

except ImportError:

    class APIChain:  
        def __init__(self, *args: Any, **kwargs: Any) -> None:
            msg = (
                "To use the APIChain, you must install the langchain_community package."
                "pip install langchain_community"
            )
            raise ImportError(msg)
