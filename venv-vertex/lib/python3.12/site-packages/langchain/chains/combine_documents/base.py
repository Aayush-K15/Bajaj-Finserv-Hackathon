

from abc import ABC, abstractmethod
from typing import Any, Optional

from langchain_core._api import deprecated
from langchain_core.callbacks import (
    AsyncCallbackManagerForChainRun,
    CallbackManagerForChainRun,
)
from langchain_core.documents import Document
from langchain_core.prompts import BasePromptTemplate, PromptTemplate
from langchain_core.runnables.config import RunnableConfig
from langchain_core.utils.pydantic import create_model
from langchain_text_splitters import RecursiveCharacterTextSplitter, TextSplitter
from pydantic import BaseModel, Field

from langchain.chains.base import Chain

DEFAULT_DOCUMENT_SEPARATOR = "\n\n"
DOCUMENTS_KEY = "context"
DEFAULT_DOCUMENT_PROMPT = PromptTemplate.from_template("{page_content}")


def _validate_prompt(prompt: BasePromptTemplate, document_variable_name: str) -> None:
    if document_variable_name not in prompt.input_variables:
        msg = (
            f"Prompt must accept {document_variable_name} as an input variable. "
            f"Received prompt with input variables: {prompt.input_variables}"
        )
        raise ValueError(msg)


class BaseCombineDocumentsChain(Chain, ABC):
    

    input_key: str = "input_documents"  
    output_key: str = "output_text"  

    def get_input_schema(
        self,
        config: Optional[RunnableConfig] = None,
    ) -> type[BaseModel]:
        return create_model(
            "CombineDocumentsInput",
            **{self.input_key: (list[Document], None)},
        )

    def get_output_schema(
        self,
        config: Optional[RunnableConfig] = None,
    ) -> type[BaseModel]:
        return create_model(
            "CombineDocumentsOutput",
            **{self.output_key: (str, None)},
        )

    @property
    def input_keys(self) -> list[str]:
        
        return [self.input_key]

    @property
    def output_keys(self) -> list[str]:
        
        return [self.output_key]

    def prompt_length(self, docs: list[Document], **kwargs: Any) -> Optional[int]:
        
        return None

    @abstractmethod
    def combine_docs(self, docs: list[Document], **kwargs: Any) -> tuple[str, dict]:
        

    @abstractmethod
    async def acombine_docs(
        self,
        docs: list[Document],
        **kwargs: Any,
    ) -> tuple[str, dict]:
        

    def _call(
        self,
        inputs: dict[str, list[Document]],
        run_manager: Optional[CallbackManagerForChainRun] = None,
    ) -> dict[str, str]:
        
        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()
        docs = inputs[self.input_key]
        
        other_keys = {k: v for k, v in inputs.items() if k != self.input_key}
        output, extra_return_dict = self.combine_docs(
            docs,
            callbacks=_run_manager.get_child(),
            **other_keys,
        )
        extra_return_dict[self.output_key] = output
        return extra_return_dict

    async def _acall(
        self,
        inputs: dict[str, list[Document]],
        run_manager: Optional[AsyncCallbackManagerForChainRun] = None,
    ) -> dict[str, str]:
        
        _run_manager = run_manager or AsyncCallbackManagerForChainRun.get_noop_manager()
        docs = inputs[self.input_key]
        
        other_keys = {k: v for k, v in inputs.items() if k != self.input_key}
        output, extra_return_dict = await self.acombine_docs(
            docs,
            callbacks=_run_manager.get_child(),
            **other_keys,
        )
        extra_return_dict[self.output_key] = output
        return extra_return_dict


@deprecated(
    since="0.2.7",
    alternative=(
        "example in API reference with more detail: "
        "https://api.python.langchain.com/en/latest/chains/langchain.chains.combine_documents.base.AnalyzeDocumentChain.html"
    ),
    removal="1.0",
)
class AnalyzeDocumentChain(Chain):
    

    input_key: str = "input_document"  
    text_splitter: TextSplitter = Field(default_factory=RecursiveCharacterTextSplitter)
    combine_docs_chain: BaseCombineDocumentsChain

    @property
    def input_keys(self) -> list[str]:
        
        return [self.input_key]

    @property
    def output_keys(self) -> list[str]:
        
        return self.combine_docs_chain.output_keys

    def get_input_schema(
        self,
        config: Optional[RunnableConfig] = None,
    ) -> type[BaseModel]:
        return create_model(
            "AnalyzeDocumentChain",
            **{self.input_key: (str, None)},
        )

    def get_output_schema(
        self,
        config: Optional[RunnableConfig] = None,
    ) -> type[BaseModel]:
        return self.combine_docs_chain.get_output_schema(config)

    def _call(
        self,
        inputs: dict[str, str],
        run_manager: Optional[CallbackManagerForChainRun] = None,
    ) -> dict[str, str]:
        
        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()
        document = inputs[self.input_key]
        docs = self.text_splitter.create_documents([document])
        
        other_keys: dict = {k: v for k, v in inputs.items() if k != self.input_key}
        other_keys[self.combine_docs_chain.input_key] = docs
        return self.combine_docs_chain(
            other_keys,
            return_only_outputs=True,
            callbacks=_run_manager.get_child(),
        )
