

import functools
import logging
from collections.abc import Awaitable
from typing import Any, Callable, Optional

from langchain_core.callbacks import (
    AsyncCallbackManagerForChainRun,
    CallbackManagerForChainRun,
)
from pydantic import Field

from langchain.chains.base import Chain

logger = logging.getLogger(__name__)


class TransformChain(Chain):
    

    input_variables: list[str]
    
    output_variables: list[str]
    
    transform_cb: Callable[[dict[str, str]], dict[str, str]] = Field(alias="transform")
    
    atransform_cb: Optional[Callable[[dict[str, Any]], Awaitable[dict[str, Any]]]] = (
        Field(None, alias="atransform")
    )
    

    @staticmethod
    @functools.lru_cache
    def _log_once(msg: str) -> None:
        
        logger.warning(msg)

    @property
    def input_keys(self) -> list[str]:
        
        return self.input_variables

    @property
    def output_keys(self) -> list[str]:
        
        return self.output_variables

    def _call(
        self,
        inputs: dict[str, str],
        run_manager: Optional[CallbackManagerForChainRun] = None,
    ) -> dict[str, str]:
        return self.transform_cb(inputs)

    async def _acall(
        self,
        inputs: dict[str, Any],
        run_manager: Optional[AsyncCallbackManagerForChainRun] = None,
    ) -> dict[str, Any]:
        if self.atransform_cb is not None:
            return await self.atransform_cb(inputs)
        self._log_once(
            "TransformChain's atransform is not provided, falling"
            " back to synchronous transform",
        )
        return self.transform_cb(inputs)
