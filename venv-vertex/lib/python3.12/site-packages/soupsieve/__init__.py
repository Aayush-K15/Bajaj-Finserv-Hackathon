
from __future__ import annotations
from .__meta__ import __version__, __version_info__  
from . import css_parser as cp
from . import css_match as cm
from . import css_types as ct
from .util import DEBUG, SelectorSyntaxError  
import bs4
from typing import Any, Iterator, Iterable

__all__ = (
    'DEBUG', 'SelectorSyntaxError', 'SoupSieve',
    'closest', 'compile', 'filter', 'iselect',
    'match', 'select', 'select_one'
)

SoupSieve = cm.SoupSieve


def compile(  
    pattern: str,
    namespaces: dict[str, str] | None = None,
    flags: int = 0,
    *,
    custom: dict[str, str] | None = None,
    **kwargs: Any
) -> cm.SoupSieve:
    

    if isinstance(pattern, SoupSieve):
        if flags:
            raise ValueError("Cannot process 'flags' argument on a compiled selector list")
        elif namespaces is not None:
            raise ValueError("Cannot process 'namespaces' argument on a compiled selector list")
        elif custom is not None:
            raise ValueError("Cannot process 'custom' argument on a compiled selector list")
        return pattern

    return cp._cached_css_compile(
        pattern,
        ct.Namespaces(namespaces) if namespaces is not None else namespaces,
        ct.CustomSelectors(custom) if custom is not None else custom,
        flags
    )


def purge() -> None:
    

    cp._purge_cache()


def closest(
    select: str,
    tag: bs4.Tag,
    namespaces: dict[str, str] | None = None,
    flags: int = 0,
    *,
    custom: dict[str, str] | None = None,
    **kwargs: Any
) -> bs4.Tag | None:
    

    return compile(select, namespaces, flags, **kwargs).closest(tag)


def match(
    select: str,
    tag: bs4.Tag,
    namespaces: dict[str, str] | None = None,
    flags: int = 0,
    *,
    custom: dict[str, str] | None = None,
    **kwargs: Any
) -> bool:
    

    return compile(select, namespaces, flags, **kwargs).match(tag)


def filter(  
    select: str,
    iterable: Iterable[bs4.Tag],
    namespaces: dict[str, str] | None = None,
    flags: int = 0,
    *,
    custom: dict[str, str] | None = None,
    **kwargs: Any
) -> list[bs4.Tag]:
    

    return compile(select, namespaces, flags, **kwargs).filter(iterable)


def select_one(
    select: str,
    tag: bs4.Tag,
    namespaces: dict[str, str] | None = None,
    flags: int = 0,
    *,
    custom: dict[str, str] | None = None,
    **kwargs: Any
) -> bs4.Tag | None:
    

    return compile(select, namespaces, flags, **kwargs).select_one(tag)


def select(
    select: str,
    tag: bs4.Tag,
    namespaces: dict[str, str] | None = None,
    limit: int = 0,
    flags: int = 0,
    *,
    custom: dict[str, str] | None = None,
    **kwargs: Any
) -> list[bs4.Tag]:
    

    return compile(select, namespaces, flags, **kwargs).select(tag, limit)


def iselect(
    select: str,
    tag: bs4.Tag,
    namespaces: dict[str, str] | None = None,
    limit: int = 0,
    flags: int = 0,
    *,
    custom: dict[str, str] | None = None,
    **kwargs: Any
) -> Iterator[bs4.Tag]:
    

    yield from compile(select, namespaces, flags, **kwargs).iselect(tag, limit)


def escape(ident: str) -> str:
    

    return cp.escape(ident)
