

from typing import Any, Dict

import sys


from typing import _type_check  


def _check_fails(cls, other):
    try:
        if sys._getframe(1).f_globals['__name__'] not in ['abc', 'functools', 'typing']:
            
            raise TypeError('TypedDict does not support instance and class checks')
    except (AttributeError, ValueError):
        pass
    return False


def _dict_new(cls, *args, **kwargs):
    return dict(*args, **kwargs)


def _typeddict_new(cls, _typename, _fields=None, **kwargs):
    total = kwargs.pop('total', True)
    if _fields is None:
        _fields = kwargs
    elif kwargs:
        raise TypeError("TypedDict takes either a dict or keyword arguments,"
                        " but not both")

    ns = {'__annotations__': dict(_fields), '__total__': total}
    try:
        
        ns['__module__'] = sys._getframe(1).f_globals.get('__name__', '__main__')
    except (AttributeError, ValueError):
        pass

    return _TypedDictMeta(_typename, (), ns, _from_functional_call=True)


class _TypedDictMeta(type):
    def __new__(cls, name, bases, ns, total=True, _from_functional_call=False):
        
        
        
        
        
        

        
        
        if 'TypedDict' in globals():
            import warnings
            warnings.warn(
                (
                    "mypy_extensions.TypedDict is deprecated, "
                    "and will be removed in a future version. "
                    "Use typing.TypedDict or typing_extensions.TypedDict instead."
                ),
                DeprecationWarning,
                stacklevel=(3 if _from_functional_call else 2)
            )

        ns['__new__'] = _typeddict_new if name == 'TypedDict' else _dict_new
        tp_dict = super(_TypedDictMeta, cls).__new__(cls, name, (dict,), ns)

        anns = ns.get('__annotations__', {})
        msg = "TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type"
        anns = {n: _type_check(tp, msg) for n, tp in anns.items()}
        for base in bases:
            anns.update(base.__dict__.get('__annotations__', {}))
        tp_dict.__annotations__ = anns
        if not hasattr(tp_dict, '__total__'):
            tp_dict.__total__ = total
        return tp_dict

    __instancecheck__ = __subclasscheck__ = _check_fails


TypedDict = _TypedDictMeta('TypedDict', (dict,), {})
TypedDict.__module__ = __name__
TypedDict.__doc__ = \
    






def Arg(type=Any, name=None):
    
    return type


def DefaultArg(type=Any, name=None):
    
    return type


def NamedArg(type=Any, name=None):
    
    return type


def DefaultNamedArg(type=Any, name=None):
    
    return type


def VarArg(type=Any):
    
    return type


def KwArg(type=Any):
    
    return type




class _DEPRECATED_NoReturn: pass


def trait(cls):
    return cls


def mypyc_attr(*attrs, **kwattrs):
    return lambda x: x




class _FlexibleAliasClsApplied:
    def __init__(self, val):
        self.val = val

    def __getitem__(self, args):
        return self.val


class _FlexibleAliasCls:
    def __getitem__(self, args):
        return _FlexibleAliasClsApplied(args[-1])


FlexibleAlias = _FlexibleAliasCls()


class _NativeIntMeta(type):
    def __instancecheck__(cls, inst):
        return isinstance(inst, int)


_sentinel = object()


class i64(metaclass=_NativeIntMeta):
    def __new__(cls, x=0, base=_sentinel):
        if base is not _sentinel:
            return int(x, base)
        return int(x)


class i32(metaclass=_NativeIntMeta):
    def __new__(cls, x=0, base=_sentinel):
        if base is not _sentinel:
            return int(x, base)
        return int(x)


class i16(metaclass=_NativeIntMeta):
    def __new__(cls, x=0, base=_sentinel):
        if base is not _sentinel:
            return int(x, base)
        return int(x)


class u8(metaclass=_NativeIntMeta):
    def __new__(cls, x=0, base=_sentinel):
        if base is not _sentinel:
            return int(x, base)
        return int(x)


for _int_type in i64, i32, i16, u8:
    _int_type.__doc__ = \
        .format(name=_int_type.__name__)
del _int_type


def _warn_deprecation(name: str, module_globals: Dict[str, Any]) -> Any:
    if (val := module_globals.get(f"_DEPRECATED_{name}")) is None:
        msg = f"module '{__name__}' has no attribute '{name}'"
        raise AttributeError(msg)
    module_globals[name] = val
    if name in {"NoReturn"}:
        msg = (
            f"'mypy_extensions.{name}' is deprecated, "
            "and will be removed in a future version. "
            f"Use 'typing.{name}' or 'typing_extensions.{name}' instead"
        )
    else:
        assert False, f"Add deprecation message for 'mypy_extensions.{name}'"
    import warnings
    warnings.warn(msg, DeprecationWarning, stacklevel=3)
    return val


def __getattr__(name: str) -> Any:
    return _warn_deprecation(name, module_globals=globals())
