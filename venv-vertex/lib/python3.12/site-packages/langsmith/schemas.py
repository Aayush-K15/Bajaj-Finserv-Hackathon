

from __future__ import annotations

from datetime import datetime, timedelta, timezone
from decimal import Decimal
from enum import Enum
from typing import (
    Any,
    NamedTuple,
    Optional,
    Protocol,
    Union,
    runtime_checkable,
)
from uuid import UUID

from typing_extensions import NotRequired, TypedDict

try:
    from pydantic.v1 import (
        BaseModel,
        Field,  
        PrivateAttr,
        StrictBool,
        StrictFloat,
        StrictInt,
    )
except ImportError:
    from pydantic import (  
        BaseModel,
        Field,
        PrivateAttr,
        StrictBool,
        StrictFloat,
        StrictInt,
    )

from pathlib import Path

from typing_extensions import Literal

SCORE_TYPE = Union[StrictBool, StrictInt, StrictFloat, None]
VALUE_TYPE = Union[dict, str, None]


class Attachment(NamedTuple):
    

    mime_type: str
    data: Union[bytes, Path]


Attachments = dict[str, Union[tuple[str, bytes], Attachment, tuple[str, Path]]]



@runtime_checkable
class BinaryIOLike(Protocol):
    

    def read(self, size: int = -1) -> bytes:
        
        ...

    def seek(self, offset: int, whence: int = 0) -> int:
        
        ...

    def getvalue(self) -> bytes:
        
        ...


class ExampleBase(BaseModel):
    

    dataset_id: UUID
    inputs: Optional[dict[str, Any]] = Field(default=None)
    outputs: Optional[dict[str, Any]] = Field(default=None)
    metadata: Optional[dict[str, Any]] = Field(default=None)

    class Config:
        

        frozen = True
        arbitrary_types_allowed = True


class _AttachmentDict(TypedDict):
    mime_type: str
    data: Union[bytes, Path]


_AttachmentLike = Union[
    Attachment, _AttachmentDict, tuple[str, bytes], tuple[str, Path]
]


class ExampleCreate(BaseModel):
    

    id: Optional[UUID]
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    inputs: Optional[dict[str, Any]] = Field(default=None)
    outputs: Optional[dict[str, Any]] = Field(default=None)
    metadata: Optional[dict[str, Any]] = Field(default=None)
    split: Optional[Union[str, list[str]]] = None
    attachments: Optional[dict[str, _AttachmentLike]] = None
    use_source_run_io: bool = False
    use_source_run_attachments: Optional[list[str]] = None
    source_run_id: Optional[UUID] = None

    def __init__(self, **data):
        
        super().__init__(**data)


ExampleUploadWithAttachments = ExampleCreate


class ExampleUpsertWithAttachments(ExampleCreate):
    

    dataset_id: UUID


class AttachmentInfo(TypedDict):
    

    presigned_url: str
    reader: BinaryIOLike
    mime_type: Optional[str]


class Example(ExampleBase):
    

    id: UUID
    created_at: datetime = Field(
        default_factory=lambda: datetime.fromtimestamp(0, tz=timezone.utc)
    )
    dataset_id: UUID = Field(default=UUID("00000000-0000-0000-0000-000000000000"))
    modified_at: Optional[datetime] = Field(default=None)
    runs: list[Run] = Field(default_factory=list)
    source_run_id: Optional[UUID] = None
    attachments: Optional[dict[str, AttachmentInfo]] = Field(default=None)
    
    _host_url: Optional[str] = PrivateAttr(default=None)
    _tenant_id: Optional[UUID] = PrivateAttr(default=None)

    def __init__(
        self,
        _host_url: Optional[str] = None,
        _tenant_id: Optional[UUID] = None,
        **kwargs: Any,
    ) -> None:
        
        super().__init__(**kwargs)
        self._host_url = _host_url
        self._tenant_id = _tenant_id

    @property
    def url(self) -> Optional[str]:
        
        if self._host_url:
            path = f"/datasets/{self.dataset_id}/e/{self.id}"
            if self._tenant_id:
                return f"{self._host_url}/o/{str(self._tenant_id)}{path}"
            return f"{self._host_url}{path}"
        return None

    def __repr__(self):
        
        return f"{self.__class__}(id={self.id}, dataset_id={self.dataset_id}, link='{self.url}')"


class ExampleSearch(ExampleBase):
    

    id: UUID


class AttachmentsOperations(BaseModel):
    

    rename: dict[str, str] = Field(
        default_factory=dict, description="Mapping of old attachment names to new names"
    )
    retain: list[str] = Field(
        default_factory=list, description="List of attachment names to keep"
    )


class ExampleUpdate(BaseModel):
    

    id: UUID
    dataset_id: Optional[UUID] = None
    inputs: Optional[dict[str, Any]] = Field(default=None)
    outputs: Optional[dict[str, Any]] = Field(default=None)
    metadata: Optional[dict[str, Any]] = Field(default=None)
    split: Optional[Union[str, list[str]]] = None
    attachments: Optional[Attachments] = None
    attachments_operations: Optional[AttachmentsOperations] = None

    class Config:
        

        frozen = True

    def __init__(self, **data):
        
        super().__init__(**data)


ExampleUpdateWithAttachments = ExampleUpdate


class DataType(str, Enum):
    

    kv = "kv"
    llm = "llm"
    chat = "chat"


class DatasetBase(BaseModel):
    

    name: str
    description: Optional[str] = None
    data_type: Optional[DataType] = None

    class Config:
        

        frozen = True


DatasetTransformationType = Literal[
    "remove_system_messages",
    "convert_to_openai_message",
    "convert_to_openai_tool",
    "remove_extra_fields",
    "extract_tools_from_run",
]


class DatasetTransformation(TypedDict, total=False):
    

    path: list[str]
    transformation_type: Union[DatasetTransformationType, str]


class Dataset(DatasetBase):
    

    id: UUID
    created_at: datetime
    modified_at: Optional[datetime] = Field(default=None)
    example_count: Optional[int] = None
    session_count: Optional[int] = None
    last_session_start_time: Optional[datetime] = None
    inputs_schema: Optional[dict[str, Any]] = None
    outputs_schema: Optional[dict[str, Any]] = None
    transformations: Optional[list[DatasetTransformation]] = None
    _host_url: Optional[str] = PrivateAttr(default=None)
    _tenant_id: Optional[UUID] = PrivateAttr(default=None)
    _public_path: Optional[str] = PrivateAttr(default=None)

    def __init__(
        self,
        _host_url: Optional[str] = None,
        _tenant_id: Optional[UUID] = None,
        _public_path: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        
        if "inputs_schema_definition" in kwargs:
            kwargs["inputs_schema"] = kwargs.pop("inputs_schema_definition")

        if "outputs_schema_definition" in kwargs:
            kwargs["outputs_schema"] = kwargs.pop("outputs_schema_definition")

        super().__init__(**kwargs)
        self._host_url = _host_url
        self._tenant_id = _tenant_id
        self._public_path = _public_path

    @property
    def url(self) -> Optional[str]:
        
        if self._host_url:
            if self._public_path:
                return f"{self._host_url}{self._public_path}"
            if self._tenant_id:
                return f"{self._host_url}/o/{str(self._tenant_id)}/datasets/{self.id}"
            return f"{self._host_url}/datasets/{self.id}"
        return None


class DatasetVersion(BaseModel):
    

    tags: Optional[list[str]] = None
    as_of: datetime


def _default_extra():
    return {"metadata": {}}


class RunBase(BaseModel):
    

    id: UUID
    

    name: str
    

    start_time: datetime
    

    run_type: str
    

    end_time: Optional[datetime] = None
    

    extra: Optional[dict] = Field(default_factory=_default_extra)
    

    error: Optional[str] = None
    

    serialized: Optional[dict] = None
    

    events: Optional[list[dict]] = None
    

    inputs: dict = Field(default_factory=dict)
    

    outputs: Optional[dict] = None
    

    reference_example_id: Optional[UUID] = None
    

    parent_run_id: Optional[UUID] = None
    

    tags: Optional[list[str]] = None
    

    attachments: Union[Attachments, dict[str, AttachmentInfo]] = Field(
        default_factory=dict
    )
    

    @property
    def metadata(self) -> dict[str, Any]:
        
        if self.extra is None:
            self.extra = {}
        return self.extra.setdefault("metadata", {})

    @property
    def revision_id(self) -> Optional[UUID]:
        
        return self.metadata.get("revision_id")

    def __repr__(self):
        
        return f"{self.__class__}(id={self.id}, name='{self.name}', run_type='{self.run_type}')"

    class Config:
        

        arbitrary_types_allowed = True


class Run(RunBase):
    

    session_id: Optional[UUID] = None
    
    child_run_ids: Optional[list[UUID]] = None
    
    child_runs: Optional[list[Run]] = None
    
    feedback_stats: Optional[dict[str, Any]] = None
    
    app_path: Optional[str] = None
    
    manifest_id: Optional[UUID] = None
    
    status: Optional[str] = None
    
    prompt_tokens: Optional[int] = None
    
    completion_tokens: Optional[int] = None
    
    total_tokens: Optional[int] = None
    
    prompt_token_details: Optional[dict[str, int]] = None
    
    completion_token_details: Optional[dict[str, int]] = None
    
    first_token_time: Optional[datetime] = None
    
    total_cost: Optional[Decimal] = None
    
    prompt_cost: Optional[Decimal] = None
    
    completion_cost: Optional[Decimal] = None
    
    prompt_cost_details: Optional[dict[str, Decimal]] = None
    
    completion_cost_details: Optional[dict[str, Decimal]] = None
    
    parent_run_ids: Optional[list[UUID]] = None
    
    trace_id: UUID
    
    dotted_order: str = Field(default="")
      
    in_dataset: Optional[bool] = None
    
    _host_url: Optional[str] = PrivateAttr(default=None)

    def __init__(self, _host_url: Optional[str] = None, **kwargs: Any) -> None:
        
        if not kwargs.get("trace_id"):
            kwargs = {"trace_id": kwargs.get("id"), **kwargs}
        inputs = kwargs.pop("inputs", None) or {}
        super().__init__(**kwargs, inputs=inputs)
        self._host_url = _host_url
        if not self.dotted_order.strip() and not self.parent_run_id:
            self.dotted_order = f"{self.start_time.isoformat()}{self.id}"

    @property
    def url(self) -> Optional[str]:
        
        if self._host_url and self.app_path:
            return f"{self._host_url}{self.app_path}"
        return None

    @property
    def input_tokens(self) -> int | None:
        
        return self.prompt_tokens

    @property
    def output_tokens(self) -> int | None:
        
        return self.completion_tokens

    @property
    def input_cost(self) -> Decimal | None:
        
        return self.prompt_cost

    @property
    def output_cost(self) -> Decimal | None:
        
        return self.completion_cost

    @property
    def input_token_details(self) -> dict[str, int] | None:
        
        return self.prompt_token_details

    @property
    def output_token_details(self) -> dict[str, int] | None:
        
        return self.completion_token_details

    @property
    def input_cost_details(self) -> dict[str, Decimal] | None:
        
        return self.prompt_cost_details

    @property
    def output_cost_details(self) -> dict[str, Decimal] | None:
        
        return self.completion_cost_details


class RunTypeEnum(str, Enum):
    

    tool = "tool"
    chain = "chain"
    llm = "llm"
    retriever = "retriever"
    embedding = "embedding"
    prompt = "prompt"
    parser = "parser"


class RunLikeDict(TypedDict, total=False):
    

    name: str
    run_type: RunTypeEnum
    start_time: datetime
    inputs: Optional[dict]
    outputs: Optional[dict]
    end_time: Optional[datetime]
    extra: Optional[dict]
    error: Optional[str]
    serialized: Optional[dict]
    parent_run_id: Optional[UUID]
    manifest_id: Optional[UUID]
    events: Optional[list[dict]]
    tags: Optional[list[str]]
    inputs_s3_urls: Optional[dict]
    outputs_s3_urls: Optional[dict]
    id: Optional[UUID]
    session_id: Optional[UUID]
    session_name: Optional[str]
    reference_example_id: Optional[UUID]
    input_attachments: Optional[dict]
    output_attachments: Optional[dict]
    trace_id: UUID
    dotted_order: str
    attachments: Attachments


class RunWithAnnotationQueueInfo(RunBase):
    

    last_reviewed_time: Optional[datetime] = None
    
    added_at: Optional[datetime] = None
    


class FeedbackSourceBase(BaseModel):
    

    type: str
    
    metadata: Optional[dict[str, Any]] = Field(default_factory=dict)
    
    user_id: Optional[Union[UUID, str]] = None
    
    user_name: Optional[str] = None
    


class APIFeedbackSource(FeedbackSourceBase):
    

    type: Literal["api"] = "api"


class ModelFeedbackSource(FeedbackSourceBase):
    

    type: Literal["model"] = "model"


class FeedbackSourceType(Enum):
    

    API = "api"
    
    MODEL = "model"
    


class FeedbackBase(BaseModel):
    

    id: UUID
    
    created_at: Optional[datetime] = None
    
    modified_at: Optional[datetime] = None
    
    run_id: Optional[UUID]
    
    trace_id: Optional[UUID]
    
    key: str
    
    score: SCORE_TYPE = None
    
    value: VALUE_TYPE = None
    
    comment: Optional[str] = None
    
    correction: Union[str, dict, None] = None
    
    feedback_source: Optional[FeedbackSourceBase] = None
    
    session_id: Optional[UUID] = None
    
    comparative_experiment_id: Optional[UUID] = None
    
    feedback_group_id: Optional[UUID] = None
    
    extra: Optional[dict] = None
    

    class Config:
        

        frozen = True


class FeedbackCategory(TypedDict, total=False):
    

    value: float
    
    label: Optional[str]
    


class FeedbackConfig(TypedDict, total=False):
    

    type: Literal["continuous", "categorical", "freeform"]
    
    min: Optional[float]
    
    max: Optional[float]
    
    categories: Optional[list[FeedbackCategory]]
      


class FeedbackCreate(FeedbackBase):
    

    feedback_source: FeedbackSourceBase
    
    feedback_config: Optional[FeedbackConfig] = None
    
    error: Optional[bool] = None


class Feedback(FeedbackBase):
    

    id: UUID
    created_at: datetime
    
    modified_at: datetime
    
    feedback_source: Optional[FeedbackSourceBase] = None
    


class TracerSession(BaseModel):
    

    id: UUID
    
    start_time: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    
    end_time: Optional[datetime] = None
    
    description: Optional[str] = None
    
    name: Optional[str] = None
    
    extra: Optional[dict[str, Any]] = None
    
    tenant_id: UUID
    
    reference_dataset_id: Optional[UUID]
    

    _host_url: Optional[str] = PrivateAttr(default=None)

    def __init__(self, _host_url: Optional[str] = None, **kwargs: Any) -> None:
        
        super().__init__(**kwargs)
        self._host_url = _host_url
        if self.start_time.tzinfo is None:
            self.start_time = self.start_time.replace(tzinfo=timezone.utc)

    @property
    def url(self) -> Optional[str]:
        
        if self._host_url:
            return f"{self._host_url}/o/{self.tenant_id}/projects/p/{self.id}"
        return None

    @property
    def metadata(self) -> dict[str, Any]:
        
        if self.extra is None or "metadata" not in self.extra:
            return {}
        return self.extra["metadata"]

    @property
    def tags(self) -> list[str]:
        
        if self.extra is None or "tags" not in self.extra:
            return []
        return self.extra["tags"]


class TracerSessionResult(TracerSession):
    

    run_count: Optional[int]
    
    latency_p50: Optional[timedelta]
    
    latency_p99: Optional[timedelta]
    
    total_tokens: Optional[int]
    
    prompt_tokens: Optional[int]
    
    completion_tokens: Optional[int]
    
    last_run_start_time: Optional[datetime]
    
    feedback_stats: Optional[dict[str, Any]]
    
    run_facets: Optional[list[dict[str, Any]]]
    
    total_cost: Optional[Decimal]
    
    prompt_cost: Optional[Decimal]
    
    completion_cost: Optional[Decimal]
    
    first_token_p50: Optional[timedelta]
    
    first_token_p99: Optional[timedelta]
    
    error_rate: Optional[float]
    


@runtime_checkable
class BaseMessageLike(Protocol):
    

    content: str
    
    additional_kwargs: dict[Any, Any]
    

    @property
    def type(self) -> str:
        


class DatasetShareSchema(TypedDict, total=False):
    

    dataset_id: UUID
    
    share_token: UUID
    
    url: str
    


class AnnotationQueue(BaseModel):
    

    id: UUID
    
    name: str
    
    description: Optional[str] = None
    
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    
    tenant_id: UUID
    


class AnnotationQueueWithDetails(AnnotationQueue):
    

    rubric_instructions: Optional[str] = None
    


class BatchIngestConfig(TypedDict, total=False):
    

    use_multipart_endpoint: bool
    
    scale_up_qsize_trigger: int
    
    scale_up_nthreads_limit: int
    
    scale_down_nempty_trigger: int
    
    size_limit: int
    
    size_limit_bytes: Optional[int]
    


class LangSmithInfo(BaseModel):
    

    version: str = ""
    
    license_expiration_time: Optional[datetime] = None
    
    batch_ingest_config: Optional[BatchIngestConfig] = None
    
    instance_flags: Optional[dict[str, Any]] = None


Example.update_forward_refs()


class LangSmithSettings(BaseModel):
    

    id: str
    
    display_name: str
    
    created_at: datetime
    
    tenant_handle: Optional[str] = None


class FeedbackIngestToken(BaseModel):
    

    id: UUID
    
    url: str
    
    expires_at: datetime
    


class RunEvent(TypedDict, total=False):
    

    name: str
    
    time: Union[datetime, str]
    
    kwargs: Optional[dict[str, Any]]
    


class TimeDeltaInput(TypedDict, total=False):
    

    days: int
    
    hours: int
    
    minutes: int
    


class DatasetDiffInfo(BaseModel):
    

    examples_modified: list[UUID]
    
    examples_added: list[UUID]
    
    examples_removed: list[UUID]
    


class ComparativeExperiment(BaseModel):
    

    id: UUID
    
    name: Optional[str] = None
    
    description: Optional[str] = None
    
    tenant_id: UUID
    
    created_at: datetime
    
    modified_at: datetime
    
    reference_dataset_id: UUID
    
    extra: Optional[dict[str, Any]] = None
    
    experiments_info: Optional[list[dict]] = None
    
    feedback_stats: Optional[dict[str, Any]] = None
    

    @property
    def metadata(self) -> dict[str, Any]:
        
        if self.extra is None or "metadata" not in self.extra:
            return {}
        return self.extra["metadata"]


class PromptCommit(BaseModel):
    

    owner: str
    
    repo: str
    
    commit_hash: str
    
    manifest: dict[str, Any]
    
    examples: list[dict]
    


class ListedPromptCommit(BaseModel):
    

    id: UUID
    

    owner: str
    

    repo: str
    

    manifest_id: Optional[UUID] = None
    

    repo_id: Optional[UUID] = None
    

    parent_id: Optional[UUID] = None
    

    commit_hash: Optional[str] = None
    

    created_at: Optional[datetime] = None
    

    updated_at: Optional[datetime] = None
    

    example_run_ids: Optional[list[UUID]] = Field(default_factory=list)
    

    num_downloads: Optional[int] = 0
    

    num_views: Optional[int] = 0
    

    parent_commit_hash: Optional[str] = None
    


class Prompt(BaseModel):
    

    repo_handle: str
    
    description: Optional[str] = None
    
    readme: Optional[str] = None
    
    id: str
    
    tenant_id: str
    
    created_at: datetime
    
    updated_at: datetime
    
    is_public: bool
    
    is_archived: bool
    
    tags: list[str]
    
    original_repo_id: Optional[str] = None
    
    upstream_repo_id: Optional[str] = None
    
    owner: Optional[str]
    
    full_name: str
    
    num_likes: int
    
    num_downloads: int
    
    num_views: int
    
    liked_by_auth_user: Optional[bool] = None
    
    last_commit_hash: Optional[str] = None
    
    num_commits: int
    
    original_repo_full_name: Optional[str] = None
    
    upstream_repo_full_name: Optional[str] = None
    


class ListPromptsResponse(BaseModel):
    

    repos: list[Prompt]
    
    total: int
    


class PromptSortField(str, Enum):
    

    num_downloads = "num_downloads"
    
    num_views = "num_views"
    
    updated_at = "updated_at"
    
    num_likes = "num_likes"
    


class InputTokenDetails(TypedDict, total=False):
    

    audio: int
    
    cache_creation: int
    
    cache_read: int
    


class OutputTokenDetails(TypedDict, total=False):
    

    audio: int
    
    reasoning: int
    


class InputCostDetails(TypedDict, total=False):
    

    audio: float
    
    cache_creation: float
    
    cache_read: float
    


class OutputCostDetails(TypedDict, total=False):
    

    audio: float
    
    reasoning: float
    


class UsageMetadata(TypedDict):
    

    input_tokens: int
    
    output_tokens: int
    
    total_tokens: int
    
    input_token_details: NotRequired[InputTokenDetails]
    
    output_token_details: NotRequired[OutputTokenDetails]
    
    input_cost: NotRequired[float]
    
    output_cost: NotRequired[float]
    
    total_cost: NotRequired[float]
    
    input_cost_details: NotRequired[InputCostDetails]
    
    output_cost_details: NotRequired[OutputCostDetails]
    


class ExtractedUsageMetadata(TypedDict, total=False):
    

    input_tokens: int
    
    output_tokens: int
    
    total_tokens: int
    
    input_token_details: InputTokenDetails
    
    output_token_details: OutputTokenDetails
    
    input_cost: float
    
    output_cost: float
    
    total_cost: float
    
    input_cost_details: InputCostDetails
    
    output_cost_details: OutputCostDetails
    


class UpsertExamplesResponse(TypedDict):
    

    count: int
    
    example_ids: list[str]
    
