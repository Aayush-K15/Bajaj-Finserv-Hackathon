import io
import logging
import shutil
import tempfile
from collections import namedtuple
from struct import pack, unpack

import olefile

from msoffcrypto import exceptions
from msoffcrypto.format import base
from msoffcrypto.format.common import _parse_header_RC4CryptoAPI
from msoffcrypto.method.rc4_cryptoapi import DocumentRC4CryptoAPI

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())


RecordHeader = namedtuple(
    "RecordHeader",
    [
        "recVer",
        "recInstance",
        "recType",
        "recLen",
    ],
)


def _parseRecordHeader(blob):
    
    getBitSlice = lambda bits, i, w: (bits & (2**w - 1 << i)) >> i

    blob.seek(0)

    (buf,) = unpack("<H", blob.read(2))
    recVer = getBitSlice(buf, 0, 4)
    recInstance = getBitSlice(buf, 4, 12)

    (recType,) = unpack("<H", blob.read(2))
    (recLen,) = unpack("<I", blob.read(4))

    rh = RecordHeader(
        recVer=recVer,
        recInstance=recInstance,
        recType=recType,
        recLen=recLen,
    )

    return rh


def _packRecordHeader(rh):
    setBitSlice = lambda bits, i, w, v: (bits & ~((2**w - 1) << i)) | (
        (v & (2**w - 1)) << i
    )

    blob = io.BytesIO()

    _buf = 0xFFFF
    _buf = setBitSlice(_buf, 0, 4, rh.recVer)
    _buf = setBitSlice(_buf, 4, 12, rh.recInstance)
    buf = pack("<H", _buf)
    blob.write(buf)

    buf = pack("<H", rh.recType)
    blob.write(buf)

    buf = pack("<I", rh.recLen)
    blob.write(buf)

    blob.seek(0)

    return blob


CurrentUserAtom = namedtuple(
    "CurrentUserAtom",
    [
        "rh",
        "size",
        "headerToken",
        "offsetToCurrentEdit",
        "lenUserName",
        "docFileVersion",
        "majorVersion",
        "minorVersion",
        "unused",
        "ansiUserName",
        "relVersion",
        "unicodeUserName",
    ],
)


def _parseCurrentUserAtom(blob):
    

    
    buf = io.BytesIO(blob.read(8))
    rh = _parseRecordHeader(buf)
    

    
    assert rh.recVer == 0x0
    assert rh.recInstance == 0x000
    assert rh.recType == 0x0FF6

    (size,) = unpack("<I", blob.read(4))
    

    
    assert size == 0x00000014

    
    
    (headerToken,) = unpack("<I", blob.read(4))

    

    (offsetToCurrentEdit,) = unpack("<I", blob.read(4))

    (lenUserName,) = unpack("<H", blob.read(2))
    (docFileVersion,) = unpack("<H", blob.read(2))
    (
        majorVersion,
        minorVersion,
    ) = unpack("<BB", blob.read(2))
    unused = blob.read(2)
    ansiUserName = blob.read(lenUserName)
    (relVersion,) = unpack("<I", blob.read(4))
    unicodeUserName = blob.read(2 * lenUserName)

    return CurrentUserAtom(
        rh=rh,
        size=size,
        headerToken=headerToken,
        offsetToCurrentEdit=offsetToCurrentEdit,
        lenUserName=lenUserName,
        docFileVersion=docFileVersion,
        majorVersion=majorVersion,
        minorVersion=minorVersion,
        unused=unused,
        ansiUserName=ansiUserName,
        relVersion=relVersion,
        unicodeUserName=unicodeUserName,
    )


def _packCurrentUserAtom(currentuseratom):
    blob = io.BytesIO()

    buf = _packRecordHeader(currentuseratom.rh).read()
    blob.write(buf)
    buf = pack("<I", currentuseratom.size)
    blob.write(buf)
    buf = pack("<I", currentuseratom.headerToken)
    blob.write(buf)
    buf = pack("<I", currentuseratom.offsetToCurrentEdit)
    blob.write(buf)
    buf = pack("<H", currentuseratom.lenUserName)
    blob.write(buf)
    buf = pack("<H", currentuseratom.docFileVersion)
    blob.write(buf)
    buf = pack("<BB", currentuseratom.majorVersion, currentuseratom.minorVersion)
    blob.write(buf)
    buf = currentuseratom.unused
    blob.write(buf)
    buf = currentuseratom.ansiUserName
    blob.write(buf)
    buf = pack("<I", currentuseratom.relVersion)
    blob.write(buf)
    buf = currentuseratom.unicodeUserName
    blob.write(buf)

    blob.seek(0)

    return blob


CurrentUser = namedtuple("CurrentUser", ["currentuseratom"])


def _parseCurrentUser(blob):
    
    currentuser = CurrentUser(currentuseratom=_parseCurrentUserAtom(blob))
    return currentuser


def _packCurrentUser(currentuser):
    blob = io.BytesIO()

    buf = _packCurrentUserAtom(currentuser.currentuseratom).read()
    blob.write(buf)

    blob.seek(0)

    return blob


UserEditAtom = namedtuple(
    "UserEditAtom",
    [
        "rh",
        "lastSlideIdRef",
        "version",
        "minorVersion",
        "majorVersion",
        "offsetLastEdit",
        "offsetPersistDirectory",
        "docPersistIdRef",
        "persistIdSeed",
        "lastView",
        "unused",
        "encryptSessionPersistIdRef",
    ],
)


def _parseUserEditAtom(blob):
    

    
    buf = io.BytesIO(blob.read(8))
    rh = _parseRecordHeader(buf)
    

    
    assert rh.recVer == 0x0
    assert rh.recInstance == 0x000
    assert rh.recType == 0x0FF5
    assert (
        rh.recLen == 0x0000001C or rh.recLen == 0x00000020
    )  

    (lastSlideIdRef,) = unpack("<I", blob.read(4))
    (version,) = unpack("<H", blob.read(2))
    (
        minorVersion,
        majorVersion,
    ) = unpack("<BB", blob.read(2))
    

    (offsetLastEdit,) = unpack("<I", blob.read(4))
    (offsetPersistDirectory,) = unpack("<I", blob.read(4))
    (docPersistIdRef,) = unpack("<I", blob.read(4))

    (persistIdSeed,) = unpack("<I", blob.read(4))
    (lastView,) = unpack("<H", blob.read(2))
    unused = blob.read(2)

    
    
    
    buf = blob.read(4)
    if len(buf) == 4:
        (encryptSessionPersistIdRef,) = unpack("<I", buf)
    else:
        encryptSessionPersistIdRef = None

    return UserEditAtom(
        rh=rh,
        lastSlideIdRef=lastSlideIdRef,
        version=version,
        minorVersion=minorVersion,
        majorVersion=majorVersion,
        offsetLastEdit=offsetLastEdit,
        offsetPersistDirectory=offsetPersistDirectory,
        docPersistIdRef=docPersistIdRef,
        persistIdSeed=persistIdSeed,
        lastView=lastView,
        unused=unused,
        encryptSessionPersistIdRef=encryptSessionPersistIdRef,
    )


def _packUserEditAtom(usereditatom):
    blob = io.BytesIO()

    buf = _packRecordHeader(usereditatom.rh).read()
    blob.write(buf)
    buf = pack("<I", usereditatom.lastSlideIdRef)
    blob.write(buf)
    buf = pack("<H", usereditatom.version)
    blob.write(buf)
    buf = pack("<BB", usereditatom.minorVersion, usereditatom.majorVersion)
    blob.write(buf)
    buf = pack("<I", usereditatom.offsetLastEdit)
    blob.write(buf)
    buf = pack("<I", usereditatom.offsetPersistDirectory)
    blob.write(buf)
    buf = pack("<I", usereditatom.docPersistIdRef)
    blob.write(buf)
    buf = pack("<I", usereditatom.persistIdSeed)
    blob.write(buf)
    buf = pack("<H", usereditatom.lastView)
    blob.write(buf)
    buf = usereditatom.unused
    blob.write(buf)
    
    if usereditatom.encryptSessionPersistIdRef is not None:
        buf = pack("<I", usereditatom.encryptSessionPersistIdRef)
        blob.write(buf)

    blob.seek(0)

    return blob


PersistDirectoryEntry = namedtuple(
    "PersistDirectoryEntry",
    [
        "persistId",
        "cPersist",
        "rgPersistOffset",
    ],
)


def _parsePersistDirectoryEntry(blob):
    
    getBitSlice = lambda bits, i, w: (bits & (2**w - 1 << i)) >> i

    (buf,) = unpack("<I", blob.read(4))
    persistId = getBitSlice(buf, 0, 20)
    cPersist = getBitSlice(buf, 20, 12)

    
    size_rgPersistOffset = 4 * cPersist
    _rgPersistOffset = blob.read(size_rgPersistOffset)
    _rgPersistOffset = io.BytesIO(_rgPersistOffset)
    rgPersistOffset = []
    pos = 0
    while pos < size_rgPersistOffset:
        (persistoffsetentry,) = unpack("<I", _rgPersistOffset.read(4))
        rgPersistOffset.append(persistoffsetentry)
        pos += 4

    return PersistDirectoryEntry(
        persistId=persistId,
        cPersist=cPersist,
        rgPersistOffset=rgPersistOffset,
    )


def _packPersistDirectoryEntry(directoryentry):
    setBitSlice = lambda bits, i, w, v: (bits & ~((2**w - 1) << i)) | (
        (v & (2**w - 1)) << i
    )

    blob = io.BytesIO()

    _buf = 0xFFFFFFFF
    _buf = setBitSlice(_buf, 0, 20, directoryentry.persistId)
    _buf = setBitSlice(_buf, 20, 12, directoryentry.cPersist)
    buf = pack("<I", _buf)
    blob.write(buf)

    for v in directoryentry.rgPersistOffset:
        buf = pack("<I", v)
        blob.write(buf)

    blob.seek(0)

    return blob


PersistDirectoryAtom = namedtuple(
    "PersistDirectoryAtom",
    [
        "rh",
        "rgPersistDirEntry",
    ],
)


def _parsePersistDirectoryAtom(blob):
    

    
    buf = io.BytesIO(blob.read(8))
    rh = _parseRecordHeader(buf)
    

    
    assert rh.recVer == 0x0
    assert rh.recInstance == 0x000
    assert rh.recType == 0x1772

    _rgPersistDirEntry = blob.read(rh.recLen)
    _rgPersistDirEntry = io.BytesIO(_rgPersistDirEntry)
    rgPersistDirEntry = []
    pos = 0
    while pos < rh.recLen:
        persistdirectoryentry = _parsePersistDirectoryEntry(_rgPersistDirEntry)
        size_persistdirectoryentry = 4 + 4 * len(persistdirectoryentry.rgPersistOffset)
        
        rgPersistDirEntry.append(persistdirectoryentry)
        pos += size_persistdirectoryentry

    return PersistDirectoryAtom(
        rh=rh,
        rgPersistDirEntry=rgPersistDirEntry,
    )


def _packPersistDirectoryAtom(directoryatom):
    blob = io.BytesIO()

    buf = _packRecordHeader(directoryatom.rh).read()
    blob.write(buf)

    for v in directoryatom.rgPersistDirEntry:
        buf = _packPersistDirectoryEntry(v)
        blob.write(buf.read())

    blob.seek(0)

    return blob


def _parseCryptSession10Container(blob):
    

    CryptSession10Container = namedtuple(
        "CryptSession10Container",
        [
            "rh",
            "data",
        ],
    )

    
    buf = io.BytesIO(blob.read(8))
    rh = _parseRecordHeader(buf)
    

    
    assert rh.recVer == 0xF
    
    
    assert rh.recType == 0x2F14

    data = blob.read(rh.recLen)

    return CryptSession10Container(
        rh=rh,
        data=data,
    )


def construct_persistobjectdirectory(data):
    

    
    data.currentuser.seek(0)
    currentuser = _parseCurrentUser(data.currentuser)
    

    
    
    data.powerpointdocument.seek(currentuser.currentuseratom.offsetToCurrentEdit)

    persistdirectoryatom_stack = []

    
    
    for i in range(1):
        
        usereditatom = _parseUserEditAtom(data.powerpointdocument)
        

        
        data.powerpointdocument.seek(usereditatom.offsetPersistDirectory)

        
        persistdirectoryatom = _parsePersistDirectoryAtom(data.powerpointdocument)
        
        persistdirectoryatom_stack.append(persistdirectoryatom)

        
        
        if usereditatom.offsetLastEdit == 0x00000000:
            break
        else:
            data.powerpointdocument.seek(usereditatom.offsetLastEdit)

    
    persistobjectdirectory = {}

    
    
    
    
    
    
    
    
    
    
    while len(persistdirectoryatom_stack) > 0:
        persistdirectoryatom = persistdirectoryatom_stack.pop()
        for entry in persistdirectoryatom.rgPersistDirEntry:
            
            for i, offset in enumerate(entry.rgPersistOffset):
                persistobjectdirectory[entry.persistId + i] = offset

    return persistobjectdirectory


class Ppt97File(base.BaseOfficeFile):
    

    def __init__(self, file):
        self.file = file
        ole = olefile.OleFileIO(file)  
        self.ole = ole
        self.format = "ppt97"
        self.keyTypes = ["password"]
        self.key = None
        self.salt = None

        
        currentuser = ole.openstream("Current User")
        powerpointdocument = ole.openstream("PowerPoint Document")

        Data = namedtuple("Data", ["currentuser", "powerpointdocument"])
        self.data = Data(
            currentuser=currentuser,
            powerpointdocument=powerpointdocument,
        )

    def __del__(self):
        
        if hasattr(self, "data") and self.data:
            if self.data.currentuser:
                self.data.currentuser.close()
            if self.data.powerpointdocument:
                self.data.powerpointdocument.close()

    def load_key(self, password=None):
        persistobjectdirectory = construct_persistobjectdirectory(self.data)
        logger.debug("[*] persistobjectdirectory: {}".format(persistobjectdirectory))

        self.data.currentuser.seek(0)
        currentuser = _parseCurrentUser(self.data.currentuser)
        logger.debug("[*] currentuser: {}".format(currentuser))

        self.data.powerpointdocument.seek(
            currentuser.currentuseratom.offsetToCurrentEdit
        )
        usereditatom = _parseUserEditAtom(self.data.powerpointdocument)
        logger.debug("[*] usereditatom: {}".format(usereditatom))

        
        cryptsession10container_offset = persistobjectdirectory[
            usereditatom.encryptSessionPersistIdRef
        ]
        logger.debug(
            "[*] cryptsession10container_offset: {}".format(
                cryptsession10container_offset
            )
        )

        self.data.powerpointdocument.seek(cryptsession10container_offset)
        cryptsession10container = _parseCryptSession10Container(
            self.data.powerpointdocument
        )
        logger.debug("[*] cryptsession10container: {}".format(cryptsession10container))

        encryptionInfo = io.BytesIO(cryptsession10container.data)

        encryptionVersionInfo = encryptionInfo.read(4)
        vMajor, vMinor = unpack("<HH", encryptionVersionInfo)
        logger.debug("[*] encryption version: {} {}".format(vMajor, vMinor))

        assert vMajor in [0x0002, 0x0003, 0x0004] and vMinor == 0x0002  

        info = _parse_header_RC4CryptoAPI(encryptionInfo)
        if DocumentRC4CryptoAPI.verifypw(
            password,
            info["salt"],
            info["keySize"],
            info["encryptedVerifier"],
            info["encryptedVerifierHash"],
        ):
            self.type = "rc4_cryptoapi"
            self.key = password
            self.salt = info["salt"]
            self.keySize = info["keySize"]
        else:
            raise exceptions.InvalidKeyError("Failed to verify password")

    def decrypt(self, outfile):
        
        self.data.currentuser.seek(0)
        currentuser = _parseCurrentUser(self.data.currentuser)
        

        cuatom = currentuser.currentuseratom

        currentuser_new = CurrentUser(
            currentuseratom=CurrentUserAtom(
                rh=cuatom.rh,
                size=cuatom.size,
                
                
                headerToken=0xE391C05F,
                offsetToCurrentEdit=cuatom.offsetToCurrentEdit,
                lenUserName=cuatom.lenUserName,
                docFileVersion=cuatom.docFileVersion,
                majorVersion=cuatom.majorVersion,
                minorVersion=cuatom.minorVersion,
                unused=cuatom.unused,
                ansiUserName=cuatom.ansiUserName,
                relVersion=cuatom.relVersion,
                unicodeUserName=cuatom.unicodeUserName,
            )
        )

        buf = _packCurrentUser(currentuser_new)
        buf.seek(0)
        currentuser_buf = buf

        

        

        self.data.powerpointdocument.seek(0)
        powerpointdocument_size = len(self.data.powerpointdocument.read())
        logger.debug("[*] powerpointdocument_size: {}".format(powerpointdocument_size))

        self.data.powerpointdocument.seek(0)
        dec_bytearray = bytearray(self.data.powerpointdocument.read())

        
        self.data.powerpointdocument.seek(
            currentuser.currentuseratom.offsetToCurrentEdit
        )
        

        self.data.powerpointdocument.seek(
            currentuser.currentuseratom.offsetToCurrentEdit
        )
        usereditatom = _parseUserEditAtom(self.data.powerpointdocument)
        
        

        rh_new = RecordHeader(
            recVer=usereditatom.rh.recVer,
            recInstance=usereditatom.rh.recInstance,
            recType=usereditatom.rh.recType,
            recLen=usereditatom.rh.recLen - 4,  
        )

        

        usereditatom_new = UserEditAtom(
            rh=rh_new,
            lastSlideIdRef=usereditatom.lastSlideIdRef,
            version=usereditatom.version,
            minorVersion=usereditatom.minorVersion,
            majorVersion=usereditatom.majorVersion,
            offsetLastEdit=usereditatom.offsetLastEdit,
            offsetPersistDirectory=usereditatom.offsetPersistDirectory,
            docPersistIdRef=usereditatom.docPersistIdRef,
            persistIdSeed=usereditatom.persistIdSeed,
            lastView=usereditatom.lastView,
            unused=usereditatom.unused,
            encryptSessionPersistIdRef=0x00000000,  
        )

        
        
        

        buf = _packUserEditAtom(usereditatom_new)
        buf.seek(0)
        buf_bytes = bytearray(buf.read())
        offset = currentuser.currentuseratom.offsetToCurrentEdit
        dec_bytearray[offset : offset + len(buf_bytes)] = buf_bytes

        
        self.data.powerpointdocument.seek(
            currentuser.currentuseratom.offsetToCurrentEdit
        )
        usereditatom = _parseUserEditAtom(self.data.powerpointdocument)
        

        self.data.powerpointdocument.seek(usereditatom.offsetPersistDirectory)
        persistdirectoryatom = _parsePersistDirectoryAtom(self.data.powerpointdocument)
        

        persistdirectoryatom_new = PersistDirectoryAtom(
            rh=persistdirectoryatom.rh,
            rgPersistDirEntry=[
                PersistDirectoryEntry(
                    persistId=persistdirectoryatom.rgPersistDirEntry[0].persistId,
                    
                    cPersist=persistdirectoryatom.rgPersistDirEntry[0].cPersist - 1,
                    rgPersistOffset=persistdirectoryatom.rgPersistDirEntry[
                        0
                    ].rgPersistOffset,
                ),
            ],
        )

        self.data.powerpointdocument.seek(usereditatom.offsetPersistDirectory)
        buf = _packPersistDirectoryAtom(persistdirectoryatom_new)
        buf_bytes = bytearray(buf.read())
        offset = usereditatom.offsetPersistDirectory
        dec_bytearray[offset : offset + len(buf_bytes)] = buf_bytes

        
        self.data.powerpointdocument.seek(0)
        persistobjectdirectory = construct_persistobjectdirectory(self.data)

        directory_items = list(persistobjectdirectory.items())

        for i, (persistId, offset) in enumerate(directory_items):
            self.data.powerpointdocument.seek(offset)
            buf = self.data.powerpointdocument.read(8)
            rh = _parseRecordHeader(io.BytesIO(buf))
            logger.debug("[*] rh: {}".format(rh))

            
            if rh.recType == 0x2F14:
                logger.debug("[*] CryptSession10Container found")
                
                dec_bytearray[offset : offset + (8 + rh.recLen)] = b"\x00" * (
                    8 + rh.recLen
                )
                continue

            
            if rh.recType in [0x0FF5, 0x1772]:
                logger.debug("[*] UserEditAtom/PersistDirectoryAtom found")
                continue

            
            recLen = directory_items[i + 1][1] - offset - 8
            logger.debug("[*] recLen: {}".format(recLen))

            self.data.powerpointdocument.seek(offset)
            enc_buf = io.BytesIO(self.data.powerpointdocument.read(8 + recLen))
            blocksize = self.keySize * (
                (8 + recLen) // self.keySize + 1
            )  
            dec = DocumentRC4CryptoAPI.decrypt(
                self.key,
                self.salt,
                self.keySize,
                enc_buf,
                blocksize=blocksize,
                block=persistId,
            )
            dec_bytes = bytearray(dec.read())
            dec_bytearray[offset : offset + len(dec_bytes)] = dec_bytes

        
        dec_buf = io.BytesIO(dec_bytearray)

        dec_buf.seek(0)
        for i, (persistId, offset) in enumerate(directory_items):
            dec_buf.seek(offset)
            buf = dec_buf.read(8)
            rh = _parseRecordHeader(io.BytesIO(buf))
            logger.debug("[*] rh: {}".format(rh))

        dec_buf.seek(0)
        logger.debug(
            "[*] powerpointdocument_size={}, len(dec_buf.read())={}".format(
                powerpointdocument_size, len(dec_buf.read())
            )
        )

        dec_buf.seek(0)
        powerpointdocument_dec_buf = dec_buf

        
        

        with tempfile.TemporaryFile() as _outfile:
            self.file.seek(0)
            shutil.copyfileobj(self.file, _outfile)
            outole = olefile.OleFileIO(_outfile, write_mode=True)

            outole.write_stream("Current User", currentuser_buf.read())
            outole.write_stream(
                "PowerPoint Document", powerpointdocument_dec_buf.read()
            )

            
            _outfile.seek(0)
            shutil.copyfileobj(_outfile, outfile)

        return

    def is_encrypted(self):
        r
        self.data.currentuser.seek(0)
        currentuser = _parseCurrentUser(self.data.currentuser)
        logger.debug("[*] currentuser: {}".format(currentuser))

        self.data.powerpointdocument.seek(
            currentuser.currentuseratom.offsetToCurrentEdit
        )
        usereditatom = _parseUserEditAtom(self.data.powerpointdocument)
        logger.debug("[*] usereditatom: {}".format(usereditatom))

        if usereditatom.rh.recLen == 0x00000020:  
            return True
        else:
            return False
