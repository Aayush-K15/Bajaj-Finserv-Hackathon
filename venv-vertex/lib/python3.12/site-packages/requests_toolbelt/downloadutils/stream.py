

import os.path
import re

from .. import exceptions as exc



_QUOTED_STRING_RE = r'"[^"\\]*(?:\\.[^"\\]*)*"'
_OPTION_HEADER_PIECE_RE = re.compile(
    r';\s*(%s|[^\s;=]+)\s*(?:=\s*(%s|[^;]+))?\s*' % (_QUOTED_STRING_RE,
                                                     _QUOTED_STRING_RE)
)
_DEFAULT_CHUNKSIZE = 512


def _get_filename(content_disposition):
    for match in _OPTION_HEADER_PIECE_RE.finditer(content_disposition):
        k, v = match.groups()
        if k == 'filename':
            
            return os.path.split(v)[1]
    return None


def get_download_file_path(response, path):
    
    path_is_dir = path and os.path.isdir(path)

    if path and not path_is_dir:
        
        filepath = path
    else:
        response_filename = _get_filename(
            response.headers.get('content-disposition', '')
        )
        if not response_filename:
            raise exc.StreamingError('No filename given to stream response to')

        if path_is_dir:
            
            filepath = os.path.join(path, response_filename)
        else:
            
            filepath = response_filename

    return filepath


def stream_response_to_file(response, path=None, chunksize=_DEFAULT_CHUNKSIZE):
    
    pre_opened = False
    fd = None
    filename = None
    if path and callable(getattr(path, 'write', None)):
        pre_opened = True
        fd = path
        filename = getattr(fd, 'name', None)
    else:
        filename = get_download_file_path(response, path)
        if os.path.exists(filename):
            raise exc.StreamingError("File already exists: %s" % filename)
        fd = open(filename, 'wb')

    for chunk in response.iter_content(chunk_size=chunksize):
        fd.write(chunk)

    if not pre_opened:
        fd.close()

    return filename
