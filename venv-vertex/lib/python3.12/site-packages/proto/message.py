













import collections
import collections.abc
import copy
import re
from typing import Any, Dict, List, Optional, Type
import warnings

import google.protobuf
from google.protobuf import descriptor_pb2
from google.protobuf import message
from google.protobuf.json_format import MessageToDict, MessageToJson, Parse

from proto import _file_info
from proto import _package_info
from proto.fields import Field
from proto.fields import MapField
from proto.fields import RepeatedField
from proto.marshal import Marshal
from proto.primitives import ProtoType
from proto.utils import has_upb


PROTOBUF_VERSION = google.protobuf.__version__

_upb = has_upb()  


class MessageMeta(type):
    

    def __new__(mcls, name, bases, attrs):
        
        if not bases:
            return super().__new__(mcls, name, bases, attrs)

        
        
        package, marshal = _package_info.compile(name, attrs)

        
        local_path = tuple(attrs.get("__qualname__", name).split("."))

        
        
        if "<locals>" in local_path:
            ix = local_path.index("<locals>")
            local_path = local_path[: ix - 1] + local_path[ix + 1 :]

        
        full_name = ".".join((package,) + local_path).lstrip(".")

        
        
        
        
        map_fields = {}
        for key, field in attrs.items():
            if not isinstance(field, MapField):
                continue

            
            msg_name = "{pascal_key}Entry".format(
                pascal_key=re.sub(
                    r"_\w",
                    lambda m: m.group()[1:].upper(),
                    key,
                ).replace(key[0], key[0].upper(), 1),
            )

            
            
            
            
            
            
            
            
            entry_attrs = collections.OrderedDict(
                {
                    "__module__": attrs.get("__module__", None),
                    "__qualname__": "{prefix}.{name}".format(
                        prefix=attrs.get("__qualname__", name),
                        name=msg_name,
                    ),
                    "_pb_options": {"map_entry": True},
                }
            )
            entry_attrs["key"] = Field(field.map_key_type, number=1)
            entry_attrs["value"] = Field(
                field.proto_type,
                number=2,
                enum=field.enum,
                message=field.message,
            )
            map_fields[msg_name] = MessageMeta(msg_name, (Message,), entry_attrs)

            
            map_fields[key] = RepeatedField(
                ProtoType.MESSAGE,
                number=field.number,
                message=map_fields[msg_name],
            )

        
        attrs.update(map_fields)

        
        
        
        fields = []
        new_attrs = {}
        oneofs = collections.OrderedDict()
        proto_imports = set()
        index = 0
        for key, field in attrs.items():
            
            if not isinstance(field, Field):
                
                new_attrs[key] = field
                continue

            
            
            
            field.mcls_data = {
                "name": key,
                "parent_name": full_name,
                "index": index,
                "package": package,
            }

            
            fields.append(field)
            
            
            if field.oneof:
                
                
                oneofs.setdefault(field.oneof, len(oneofs))
                field.descriptor.oneof_index = oneofs[field.oneof]

            
            
            
            if field.message and not isinstance(field.message, str):
                field_msg = field.message
                if hasattr(field_msg, "pb") and callable(field_msg.pb):
                    field_msg = field_msg.pb()
                
                
                
                
                
                
                if field_msg:
                    proto_imports.add(field_msg.DESCRIPTOR.file.name)

            
            elif field.enum and not isinstance(field.enum, str):
                field_enum = (
                    field.enum._meta.pb
                    if hasattr(field.enum, "_meta")
                    else field.enum.DESCRIPTOR
                )

                if field_enum:
                    proto_imports.add(field_enum.file.name)

            
            index += 1

        
        
        opt_attrs = {}
        for field in fields:
            if field.optional:
                field.oneof = "_{}".format(field.name)
                field.descriptor.oneof_index = oneofs[field.oneof] = len(oneofs)
                opt_attrs[field.name] = field.name

        
        
        
        
        
        
        
        
        
        if opt_attrs:
            mcls = type("AttrsMeta", (mcls,), opt_attrs)

        
        
        
        filename = _file_info._FileInfo.proto_file_name(
            new_attrs.get("__module__", name.lower())
        )

        
        
        file_info = _file_info._FileInfo.maybe_add_descriptor(filename, package)

        
        
        for proto_import in proto_imports:
            if proto_import not in file_info.descriptor.dependency:
                file_info.descriptor.dependency.append(proto_import)

        
        opts = descriptor_pb2.MessageOptions(**new_attrs.pop("_pb_options", {}))

        
        desc = descriptor_pb2.DescriptorProto(
            name=name,
            field=[i.descriptor for i in fields],
            oneof_decl=[
                descriptor_pb2.OneofDescriptorProto(name=i) for i in oneofs.keys()
            ],
            options=opts,
        )

        
        
        child_paths = [p for p in file_info.nested.keys() if local_path == p[:-1]]
        for child_path in child_paths:
            desc.nested_type.add().MergeFrom(file_info.nested.pop(child_path))

        
        child_paths = [p for p in file_info.nested_enum.keys() if local_path == p[:-1]]
        for child_path in child_paths:
            desc.enum_type.add().MergeFrom(file_info.nested_enum.pop(child_path))

        
        
        if len(local_path) == 1:
            file_info.descriptor.message_type.add().MergeFrom(desc)
        else:
            file_info.nested[local_path] = desc

        
        new_attrs["_meta"] = _MessageInfo(
            fields=fields,
            full_name=full_name,
            marshal=marshal,
            options=opts,
            package=package,
        )

        
        cls = super().__new__(mcls, name, bases, new_attrs)

        
        cls._meta.parent = cls
        for field in cls._meta.fields.values():
            field.parent = cls

        
        
        
        file_info.messages[full_name] = cls

        
        if file_info.ready(new_class=cls):
            file_info.generate_file_pb(new_class=cls, fallback_salt=full_name)

        
        return cls

    @classmethod
    def __prepare__(mcls, name, bases, **kwargs):
        return collections.OrderedDict()

    @property
    def meta(cls):
        return cls._meta

    def __dir__(self):
        try:
            names = set(dir(type))
            names.update(
                (
                    "meta",
                    "pb",
                    "wrap",
                    "serialize",
                    "deserialize",
                    "to_json",
                    "from_json",
                    "to_dict",
                    "copy_from",
                )
            )
            desc = self.pb().DESCRIPTOR
            names.update(t.name for t in desc.nested_types)
            names.update(e.name for e in desc.enum_types)

            return names
        except AttributeError:
            return dir(type)

    def pb(cls, obj=None, *, coerce: bool = False):
        
        if obj is None:
            return cls.meta.pb
        if not isinstance(obj, cls):
            if coerce:
                obj = cls(obj)
            else:
                raise TypeError(
                    "%r is not an instance of %s"
                    % (
                        obj,
                        cls.__name__,
                    )
                )
        return obj._pb

    def wrap(cls, pb):
        
        
        instance = cls.__new__(cls)
        super(cls, instance).__setattr__("_pb", pb)
        return instance

    def serialize(cls, instance) -> bytes:
        
        return cls.pb(instance, coerce=True).SerializeToString()

    def deserialize(cls, payload: bytes) -> "Message":
        
        return cls.wrap(cls.pb().FromString(payload))

    def _warn_if_including_default_value_fields_is_used_protobuf_5(
        cls, including_default_value_fields: Optional[bool]
    ) -> None:
        
        if (
            PROTOBUF_VERSION[0] not in ("3", "4")
            and including_default_value_fields is not None
        ):
            warnings.warn(
                ,
                DeprecationWarning,
            )

    def _raise_if_print_fields_values_are_set_and_differ(
        cls,
        always_print_fields_with_no_presence: Optional[bool],
        including_default_value_fields: Optional[bool],
    ) -> None:
        
        if (
            always_print_fields_with_no_presence is not None
            and including_default_value_fields is not None
            and always_print_fields_with_no_presence != including_default_value_fields
        ):
            raise ValueError(
                "Arguments `always_print_fields_with_no_presence` and `including_default_value_fields` must match"
            )

    def _normalize_print_fields_without_presence(
        cls,
        always_print_fields_with_no_presence: Optional[bool],
        including_default_value_fields: Optional[bool],
    ) -> bool:
        

        cls._warn_if_including_default_value_fields_is_used_protobuf_5(
            including_default_value_fields
        )
        cls._raise_if_print_fields_values_are_set_and_differ(
            always_print_fields_with_no_presence, including_default_value_fields
        )
        
        return (
            (
                always_print_fields_with_no_presence is None
                and including_default_value_fields is None
            )
            or always_print_fields_with_no_presence
            or including_default_value_fields
        )

    def to_json(
        cls,
        instance,
        *,
        use_integers_for_enums=True,
        including_default_value_fields=None,
        preserving_proto_field_name=False,
        sort_keys=False,
        indent=2,
        float_precision=None,
        always_print_fields_with_no_presence=None,
    ) -> str:
        

        print_fields = cls._normalize_print_fields_without_presence(
            always_print_fields_with_no_presence, including_default_value_fields
        )

        if PROTOBUF_VERSION[0] in ("3", "4"):
            return MessageToJson(
                cls.pb(instance),
                use_integers_for_enums=use_integers_for_enums,
                including_default_value_fields=print_fields,
                preserving_proto_field_name=preserving_proto_field_name,
                sort_keys=sort_keys,
                indent=indent,
                float_precision=float_precision,
            )
        else:
            
            
            
            
            
            return MessageToJson(
                cls.pb(instance),
                use_integers_for_enums=use_integers_for_enums,
                always_print_fields_with_no_presence=print_fields,
                preserving_proto_field_name=preserving_proto_field_name,
                sort_keys=sort_keys,
                indent=indent,
                float_precision=float_precision,
            )

    def from_json(cls, payload, *, ignore_unknown_fields=False) -> "Message":
        
        instance = cls()
        Parse(payload, instance._pb, ignore_unknown_fields=ignore_unknown_fields)
        return instance

    def to_dict(
        cls,
        instance,
        *,
        use_integers_for_enums=True,
        preserving_proto_field_name=True,
        including_default_value_fields=None,
        float_precision=None,
        always_print_fields_with_no_presence=None,
    ) -> Dict[str, Any]:
        

        print_fields = cls._normalize_print_fields_without_presence(
            always_print_fields_with_no_presence, including_default_value_fields
        )

        if PROTOBUF_VERSION[0] in ("3", "4"):
            return MessageToDict(
                cls.pb(instance),
                including_default_value_fields=print_fields,
                preserving_proto_field_name=preserving_proto_field_name,
                use_integers_for_enums=use_integers_for_enums,
                float_precision=float_precision,
            )
        else:
            
            
            
            
            
            return MessageToDict(
                cls.pb(instance),
                always_print_fields_with_no_presence=print_fields,
                preserving_proto_field_name=preserving_proto_field_name,
                use_integers_for_enums=use_integers_for_enums,
                float_precision=float_precision,
            )

    def copy_from(cls, instance, other):
        
        if isinstance(other, cls):
            
            other = Message.pb(other)
        elif isinstance(other, cls.pb()):
            
            pass
        elif isinstance(other, collections.abc.Mapping):
            
            other = cls._meta.pb(**other)
        else:
            raise TypeError(
                "invalid argument type to copy to {}: {}".format(
                    cls.__name__, other.__class__.__name__
                )
            )

        
        
        
        
        cls.pb(instance).CopyFrom(other)


class Message(metaclass=MessageMeta):
    

    def __init__(
        self,
        mapping=None,
        *,
        ignore_unknown_fields=False,
        **kwargs,
    ):
        
        
        
        
        
        if mapping is None:
            if not kwargs:
                
                super().__setattr__("_pb", self._meta.pb())
                return

            mapping = kwargs
        elif isinstance(mapping, self._meta.pb):
            
            
            
            
            
            
            
            mapping = copy.deepcopy(mapping)
            if kwargs:
                mapping.MergeFrom(self._meta.pb(**kwargs))

            super().__setattr__("_pb", mapping)
            return
        elif isinstance(mapping, type(self)):
            
            self.__init__(mapping=mapping._pb, **kwargs)
            return
        elif isinstance(mapping, collections.abc.Mapping):
            
            mapping = copy.copy(mapping)
            
            mapping.update(kwargs)
        else:
            
            raise TypeError(
                "Invalid constructor input for %s: %r"
                % (
                    self.__class__.__name__,
                    mapping,
                )
            )

        params = {}
        
        
        marshal = self._meta.marshal
        for key, value in mapping.items():
            (key, pb_type) = self._get_pb_type_from_key(key)
            if pb_type is None:
                if ignore_unknown_fields:
                    continue

                raise ValueError(
                    "Unknown field for {}: {}".format(self.__class__.__name__, key)
                )

            pb_value = marshal.to_proto(pb_type, value)

            if pb_value is not None:
                params[key] = pb_value

        
        super().__setattr__("_pb", self._meta.pb(**params))

    def _get_pb_type_from_key(self, key):
        

        pb_type = None

        try:
            pb_type = self._meta.fields[key].pb_type
        except KeyError:
            
            
            
            
            
            
            
            if f"{key}_" in self._meta.fields:
                key = f"{key}_"
                pb_type = self._meta.fields[key].pb_type

        return (key, pb_type)

    def __dir__(self):
        desc = type(self).pb().DESCRIPTOR
        names = {f_name for f_name in self._meta.fields.keys()}
        names.update(m.name for m in desc.nested_types)
        names.update(e.name for e in desc.enum_types)
        names.update(dir(object()))
        
        
        names.update(
            (
                "__bool__",
                "__contains__",
                "__dict__",
                "__getattr__",
                "__getstate__",
                "__module__",
                "__setstate__",
                "__weakref__",
            )
        )

        return names

    def __bool__(self):
        
        return any(k in self and getattr(self, k) for k in self._meta.fields.keys())

    def __contains__(self, key):
        
        pb_value = getattr(self._pb, key)
        try:
            
            
            
            
            
            
            
            return self._pb.HasField(key)
        except ValueError:
            return bool(pb_value)

    def __delattr__(self, key):
        
        self._pb.ClearField(key)

    def __eq__(self, other):
        
        
        if isinstance(other, type(self)):
            return self._pb == other._pb

        
        if isinstance(other, self._meta.pb):
            return self._pb == other

        
        return NotImplemented

    def __getattr__(self, key):
        
        (key, pb_type) = self._get_pb_type_from_key(key)
        if pb_type is None:
            raise AttributeError(
                "Unknown field for {}: {}".format(self.__class__.__name__, key)
            )
        pb_value = getattr(self._pb, key)
        marshal = self._meta.marshal
        return marshal.to_python(pb_type, pb_value, absent=key not in self)

    def __ne__(self, other):
        
        return not self == other

    def __repr__(self):
        return repr(self._pb)

    def __setattr__(self, key, value):
        
        if key[0] == "_":
            return super().__setattr__(key, value)
        marshal = self._meta.marshal
        (key, pb_type) = self._get_pb_type_from_key(key)
        if pb_type is None:
            raise AttributeError(
                "Unknown field for {}: {}".format(self.__class__.__name__, key)
            )

        pb_value = marshal.to_proto(pb_type, value)

        
        
        
        self._pb.ClearField(key)

        
        if pb_value is not None:
            self._pb.MergeFrom(self._meta.pb(**{key: pb_value}))

    def __getstate__(self):
        
        return self._pb.SerializeToString()

    def __setstate__(self, value):
        
        new_pb = self._meta.pb().FromString(value)
        super().__setattr__("_pb", new_pb)


class _MessageInfo:
    

    def __init__(
        self,
        *,
        fields: List[Field],
        package: str,
        full_name: str,
        marshal: Marshal,
        options: descriptor_pb2.MessageOptions,
    ) -> None:
        self.package = package
        self.full_name = full_name
        self.options = options
        self.fields = collections.OrderedDict((i.name, i) for i in fields)
        self.fields_by_number = collections.OrderedDict((i.number, i) for i in fields)
        self.marshal = marshal
        self._pb = None

    @property
    def pb(self) -> Type[message.Message]:
        
        return self._pb


__all__ = ("Message",)
