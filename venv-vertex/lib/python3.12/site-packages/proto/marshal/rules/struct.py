













import collections.abc

from google.protobuf import struct_pb2

from proto.marshal.collections import maps
from proto.marshal.collections import repeated


class ValueRule:
    

    def __init__(self, *, marshal):
        self._marshal = marshal

    def to_python(self, value, *, absent: bool = None):
        
        kind = value.WhichOneof("kind")
        if kind == "null_value" or absent:
            return None
        if kind == "bool_value":
            return bool(value.bool_value)
        if kind == "number_value":
            return float(value.number_value)
        if kind == "string_value":
            return str(value.string_value)
        if kind == "struct_value":
            return self._marshal.to_python(
                struct_pb2.Struct,
                value.struct_value,
                absent=False,
            )
        if kind == "list_value":
            return self._marshal.to_python(
                struct_pb2.ListValue,
                value.list_value,
                absent=False,
            )
        
        
        raise ValueError("Unexpected kind: %s" % kind)  

    def to_proto(self, value) -> struct_pb2.Value:
        
        if isinstance(value, struct_pb2.Value):
            return value
        if value is None:
            return struct_pb2.Value(null_value=0)
        if isinstance(value, bool):
            return struct_pb2.Value(bool_value=value)
        if isinstance(value, (int, float)):
            return struct_pb2.Value(number_value=float(value))
        if isinstance(value, str):
            return struct_pb2.Value(string_value=value)
        if isinstance(value, collections.abc.Sequence):
            return struct_pb2.Value(
                list_value=self._marshal.to_proto(struct_pb2.ListValue, value),
            )
        if isinstance(value, collections.abc.Mapping):
            return struct_pb2.Value(
                struct_value=self._marshal.to_proto(struct_pb2.Struct, value),
            )
        raise ValueError("Unable to coerce value: %r" % value)


class ListValueRule:
    

    def __init__(self, *, marshal):
        self._marshal = marshal

    def to_python(self, value, *, absent: bool = None):
        
        return (
            None
            if absent
            else repeated.RepeatedComposite(value.values, marshal=self._marshal)
        )

    def to_proto(self, value) -> struct_pb2.ListValue:
        
        
        if isinstance(value, struct_pb2.ListValue):
            return value
        if isinstance(value, repeated.RepeatedComposite):
            return struct_pb2.ListValue(values=[v for v in value.pb])

        
        return struct_pb2.ListValue(
            values=[self._marshal.to_proto(struct_pb2.Value, v) for v in value]
        )


class StructRule:
    

    def __init__(self, *, marshal):
        self._marshal = marshal

    def to_python(self, value, *, absent: bool = None):
        
        return (
            None if absent else maps.MapComposite(value.fields, marshal=self._marshal)
        )

    def to_proto(self, value) -> struct_pb2.Struct:
        
        
        if isinstance(value, struct_pb2.Struct):
            return value
        if isinstance(value, maps.MapComposite):
            return struct_pb2.Struct(
                fields={k: v for k, v in value.pb.items()},
            )

        
        answer = struct_pb2.Struct(
            fields={
                k: self._marshal.to_proto(struct_pb2.Value, v) for k, v in value.items()
            }
        )
        return answer
