

import io

from docx.image.constants import JPEG_MARKER_CODE, MIME_TYPE
from docx.image.helpers import BIG_ENDIAN, StreamReader
from docx.image.image import BaseImageHeader
from docx.image.tiff import Tiff


class Jpeg(BaseImageHeader):
    

    @property
    def content_type(self):
        
        return MIME_TYPE.JPEG

    @property
    def default_ext(self):
        
        return "jpg"


class Exif(Jpeg):
    

    @classmethod
    def from_stream(cls, stream):
        
        markers = _JfifMarkers.from_stream(stream)
        

        px_width = markers.sof.px_width
        px_height = markers.sof.px_height
        horz_dpi = markers.app1.horz_dpi
        vert_dpi = markers.app1.vert_dpi

        return cls(px_width, px_height, horz_dpi, vert_dpi)


class Jfif(Jpeg):
    

    @classmethod
    def from_stream(cls, stream):
        
        markers = _JfifMarkers.from_stream(stream)

        px_width = markers.sof.px_width
        px_height = markers.sof.px_height
        horz_dpi = markers.app0.horz_dpi
        vert_dpi = markers.app0.vert_dpi

        return cls(px_width, px_height, horz_dpi, vert_dpi)


class _JfifMarkers:
    

    def __init__(self, markers):
        super(_JfifMarkers, self).__init__()
        self._markers = list(markers)

    def __str__(self):  
        
        header = " offset  seglen  mc  name\n=======  ======  ==  ====="
        tmpl = "%7d  %6d  %02X  %s"
        rows = []
        for marker in self._markers:
            rows.append(
                tmpl
                % (
                    marker.offset,
                    marker.segment_length,
                    ord(marker.marker_code),
                    marker.name,
                )
            )
        lines = [header] + rows
        return "\n".join(lines)

    @classmethod
    def from_stream(cls, stream):
        
        marker_parser = _MarkerParser.from_stream(stream)
        markers = []
        for marker in marker_parser.iter_markers():
            markers.append(marker)
            if marker.marker_code == JPEG_MARKER_CODE.SOS:
                break
        return cls(markers)

    @property
    def app0(self):
        
        for m in self._markers:
            if m.marker_code == JPEG_MARKER_CODE.APP0:
                return m
        raise KeyError("no APP0 marker in image")

    @property
    def app1(self):
        
        for m in self._markers:
            if m.marker_code == JPEG_MARKER_CODE.APP1:
                return m
        raise KeyError("no APP1 marker in image")

    @property
    def sof(self):
        
        for m in self._markers:
            if m.marker_code in JPEG_MARKER_CODE.SOF_MARKER_CODES:
                return m
        raise KeyError("no start of frame (SOFn) marker in image")


class _MarkerParser:
    

    def __init__(self, stream_reader):
        super(_MarkerParser, self).__init__()
        self._stream = stream_reader

    @classmethod
    def from_stream(cls, stream):
        
        stream_reader = StreamReader(stream, BIG_ENDIAN)
        return cls(stream_reader)

    def iter_markers(self):
        
        marker_finder = _MarkerFinder.from_stream(self._stream)
        start = 0
        marker_code = None
        while marker_code != JPEG_MARKER_CODE.EOI:
            marker_code, segment_offset = marker_finder.next(start)
            marker = _MarkerFactory(marker_code, self._stream, segment_offset)
            yield marker
            start = segment_offset + marker.segment_length


class _MarkerFinder:
    

    def __init__(self, stream):
        super(_MarkerFinder, self).__init__()
        self._stream = stream

    @classmethod
    def from_stream(cls, stream):
        
        return cls(stream)

    def next(self, start):
        
        position = start
        while True:
            
            position = self._offset_of_next_ff_byte(start=position)
            
            position, byte_ = self._next_non_ff_byte(start=position + 1)
            
            if byte_ == b"\x00":
                continue
            
            marker_code, segment_offset = byte_, position + 1
            break
        return marker_code, segment_offset

    def _next_non_ff_byte(self, start):
        
        self._stream.seek(start)
        byte_ = self._read_byte()
        while byte_ == b"\xff":
            byte_ = self._read_byte()
        offset_of_non_ff_byte = self._stream.tell() - 1
        return offset_of_non_ff_byte, byte_

    def _offset_of_next_ff_byte(self, start):
        
        self._stream.seek(start)
        byte_ = self._read_byte()
        while byte_ != b"\xff":
            byte_ = self._read_byte()
        offset_of_ff_byte = self._stream.tell() - 1
        return offset_of_ff_byte

    def _read_byte(self):
        
        byte_ = self._stream.read(1)
        if not byte_:  
            raise Exception("unexpected end of file")
        return byte_


def _MarkerFactory(marker_code, stream, offset):
    
    if marker_code == JPEG_MARKER_CODE.APP0:
        marker_cls = _App0Marker
    elif marker_code == JPEG_MARKER_CODE.APP1:
        marker_cls = _App1Marker
    elif marker_code in JPEG_MARKER_CODE.SOF_MARKER_CODES:
        marker_cls = _SofMarker
    else:
        marker_cls = _Marker
    return marker_cls.from_stream(stream, marker_code, offset)


class _Marker:
    

    def __init__(self, marker_code, offset, segment_length):
        super(_Marker, self).__init__()
        self._marker_code = marker_code
        self._offset = offset
        self._segment_length = segment_length

    @classmethod
    def from_stream(cls, stream, marker_code, offset):
        
        if JPEG_MARKER_CODE.is_standalone(marker_code):
            segment_length = 0
        else:
            segment_length = stream.read_short(offset)
        return cls(marker_code, offset, segment_length)

    @property
    def marker_code(self):
        
        return self._marker_code

    @property
    def name(self):  
        return JPEG_MARKER_CODE.marker_names[self._marker_code]

    @property
    def offset(self):  
        return self._offset

    @property
    def segment_length(self):
        
        return self._segment_length


class _App0Marker(_Marker):
    

    def __init__(self, marker_code, offset, length, density_units, x_density, y_density):
        super(_App0Marker, self).__init__(marker_code, offset, length)
        self._density_units = density_units
        self._x_density = x_density
        self._y_density = y_density

    @property
    def horz_dpi(self):
        
        return self._dpi(self._x_density)

    @property
    def vert_dpi(self):
        
        return self._dpi(self._y_density)

    def _dpi(self, density):
        
        if self._density_units == 1:
            dpi = density
        elif self._density_units == 2:
            dpi = int(round(density * 2.54))
        else:
            dpi = 72
        return dpi

    @classmethod
    def from_stream(cls, stream, marker_code, offset):
        
        
        
        
        
        
        
        
        
        
        
        segment_length = stream.read_short(offset)
        density_units = stream.read_byte(offset, 9)
        x_density = stream.read_short(offset, 10)
        y_density = stream.read_short(offset, 12)
        return cls(marker_code, offset, segment_length, density_units, x_density, y_density)


class _App1Marker(_Marker):
    

    def __init__(self, marker_code, offset, length, horz_dpi, vert_dpi):
        super(_App1Marker, self).__init__(marker_code, offset, length)
        self._horz_dpi = horz_dpi
        self._vert_dpi = vert_dpi

    @classmethod
    def from_stream(cls, stream, marker_code, offset):
        
        
        
        
        
        
        
        
        
        segment_length = stream.read_short(offset)
        if cls._is_non_Exif_APP1_segment(stream, offset):
            return cls(marker_code, offset, segment_length, 72, 72)
        tiff = cls._tiff_from_exif_segment(stream, offset, segment_length)
        return cls(marker_code, offset, segment_length, tiff.horz_dpi, tiff.vert_dpi)

    @property
    def horz_dpi(self):
        
        return self._horz_dpi

    @property
    def vert_dpi(self):
        
        return self._vert_dpi

    @classmethod
    def _is_non_Exif_APP1_segment(cls, stream, offset):
        
        stream.seek(offset + 2)
        exif_signature = stream.read(6)
        return exif_signature != b"Exif\x00\x00"

    @classmethod
    def _tiff_from_exif_segment(cls, stream, offset, segment_length):
        
        
        stream.seek(offset + 8)
        segment_bytes = stream.read(segment_length - 8)
        substream = io.BytesIO(segment_bytes)
        return Tiff.from_stream(substream)


class _SofMarker(_Marker):
    

    def __init__(self, marker_code, offset, segment_length, px_width, px_height):
        super(_SofMarker, self).__init__(marker_code, offset, segment_length)
        self._px_width = px_width
        self._px_height = px_height

    @classmethod
    def from_stream(cls, stream, marker_code, offset):
        
        
        
        
        
        
        
        
        segment_length = stream.read_short(offset)
        px_height = stream.read_short(offset, 3)
        px_width = stream.read_short(offset, 5)
        return cls(marker_code, offset, segment_length, px_width, px_height)

    @property
    def px_height(self):
        
        return self._px_height

    @property
    def px_width(self):
        
        return self._px_width
