

from __future__ import annotations

import functools
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Generic,
    Iterator,
    List,
    Tuple,
    TypeVar,
    cast,
)

if TYPE_CHECKING:
    import docx.types as t
    from docx.opc.part import XmlPart
    from docx.oxml.xmlchemy import BaseOxmlElement
    from docx.parts.story import StoryPart


class Length(int):
    

    _EMUS_PER_INCH = 914400
    _EMUS_PER_CM = 360000
    _EMUS_PER_MM = 36000
    _EMUS_PER_PT = 12700
    _EMUS_PER_TWIP = 635

    def __new__(cls, emu: int):
        return int.__new__(cls, emu)

    @property
    def cm(self):
        
        return self / float(self._EMUS_PER_CM)

    @property
    def emu(self):
        
        return self

    @property
    def inches(self):
        
        return self / float(self._EMUS_PER_INCH)

    @property
    def mm(self):
        
        return self / float(self._EMUS_PER_MM)

    @property
    def pt(self):
        
        return self / float(self._EMUS_PER_PT)

    @property
    def twips(self):
        
        return int(round(self / float(self._EMUS_PER_TWIP)))


class Inches(Length):
    

    def __new__(cls, inches: float):
        emu = int(inches * Length._EMUS_PER_INCH)
        return Length.__new__(cls, emu)


class Cm(Length):
    

    def __new__(cls, cm: float):
        emu = int(cm * Length._EMUS_PER_CM)
        return Length.__new__(cls, emu)


class Emu(Length):
    

    def __new__(cls, emu: int):
        return Length.__new__(cls, int(emu))


class Mm(Length):
    

    def __new__(cls, mm: float):
        emu = int(mm * Length._EMUS_PER_MM)
        return Length.__new__(cls, emu)


class Pt(Length):
    

    def __new__(cls, points: float):
        emu = int(points * Length._EMUS_PER_PT)
        return Length.__new__(cls, emu)


class Twips(Length):
    

    def __new__(cls, twips: float):
        emu = int(twips * Length._EMUS_PER_TWIP)
        return Length.__new__(cls, emu)


class RGBColor(Tuple[int, int, int]):
    

    def __new__(cls, r: int, g: int, b: int):
        msg = "RGBColor() takes three integer values 0-255"
        for val in (r, g, b):
            if not isinstance(val, int):  
                raise TypeError(msg)
            if val < 0 or val > 255:
                raise ValueError(msg)
        return super(RGBColor, cls).__new__(cls, (r, g, b))

    def __repr__(self):
        return "RGBColor(0x%02x, 0x%02x, 0x%02x)" % self

    def __str__(self):
        
        return "%02X%02X%02X" % self

    @classmethod
    def from_string(cls, rgb_hex_str: str) -> RGBColor:
        
        r = int(rgb_hex_str[:2], 16)
        g = int(rgb_hex_str[2:4], 16)
        b = int(rgb_hex_str[4:], 16)
        return cls(r, g, b)


T = TypeVar("T")


class lazyproperty(Generic[T]):
    

    def __init__(self, fget: Callable[..., T]) -> None:
        
        
        self._fget = fget
        
        self._name = fget.__name__
        
        functools.update_wrapper(self, fget)  

    def __get__(self, obj: Any, type: Any = None) -> T:
        
        
        
        if obj is None:
            return self  

        
        
        value = obj.__dict__.get(self._name)
        if value is None:
            
            
            
            value = self._fget(obj)
            obj.__dict__[self._name] = value
        return cast(T, value)

    def __set__(self, obj: Any, value: Any) -> None:
        
        raise AttributeError("can't set attribute")


def write_only_property(f: Callable[[Any, Any], None]):
    
    docstring = f.__doc__

    return property(fset=f, doc=docstring)


class ElementProxy:
    

    def __init__(self, element: BaseOxmlElement, parent: t.ProvidesXmlPart | None = None):
        self._element = element
        self._parent = parent

    def __eq__(self, other: object):
        
        if not isinstance(other, ElementProxy):
            return False
        return self._element is other._element

    def __ne__(self, other: object):
        if not isinstance(other, ElementProxy):
            return True
        return self._element is not other._element

    @property
    def element(self):
        
        return self._element

    @property
    def part(self) -> XmlPart:
        
        if self._parent is None:
            raise ValueError("part is not accessible from this element")
        return self._parent.part


class Parented:
    

    def __init__(self, parent: t.ProvidesXmlPart):
        self._parent = parent

    @property
    def part(self) -> XmlPart:
        
        return self._parent.part


class StoryChild:
    

    def __init__(self, parent: t.ProvidesStoryPart):
        self._parent = parent

    @property
    def part(self) -> StoryPart:
        
        return self._parent.part


class TextAccumulator:
    

    def __init__(self, separator: str = ""):
        self._separator = separator
        self._texts: List[str] = []

    def push(self, text: str) -> None:
        
        self._texts.append(text)

    def pop(self) -> Iterator[str]:
        
        if not self._texts:
            return
        text = self._separator.join(self._texts)
        self._texts.clear()
        yield text
