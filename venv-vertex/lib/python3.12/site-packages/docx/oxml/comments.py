

from __future__ import annotations

import datetime as dt
from typing import TYPE_CHECKING, Callable, cast

from docx.oxml.ns import nsdecls
from docx.oxml.parser import parse_xml
from docx.oxml.simpletypes import ST_DateTime, ST_DecimalNumber, ST_String
from docx.oxml.xmlchemy import BaseOxmlElement, OptionalAttribute, RequiredAttribute, ZeroOrMore

if TYPE_CHECKING:
    from docx.oxml.table import CT_Tbl
    from docx.oxml.text.paragraph import CT_P


class CT_Comments(BaseOxmlElement):
    

    
    comment_lst: list[CT_Comment]

    comment = ZeroOrMore("w:comment")

    def add_comment(self) -> CT_Comment:
        
        next_id = self._next_available_comment_id()
        comment = cast(
            CT_Comment,
            parse_xml(
                f'<w:comment {nsdecls("w")} w:id="{next_id}" w:author="">'
                f"  <w:p>"
                f"    <w:pPr>"
                f'      <w:pStyle w:val="CommentText"/>'
                f"    </w:pPr>"
                f"    <w:r>"
                f"      <w:rPr>"
                f'        <w:rStyle w:val="CommentReference"/>'
                f"      </w:rPr>"
                f"      <w:annotationRef/>"
                f"    </w:r>"
                f"  </w:p>"
                f"</w:comment>"
            ),
        )
        self.append(comment)
        return comment

    def get_comment_by_id(self, comment_id: int) -> CT_Comment | None:
        
        comment_elms = self.xpath(f"(./w:comment[@w:id='{comment_id}'])[1]")
        return comment_elms[0] if comment_elms else None

    def _next_available_comment_id(self) -> int:
        
        used_ids = [int(x) for x in self.xpath("./w:comment/@w:id")]

        next_id = max(used_ids, default=-1) + 1

        if next_id <= 2**31 - 1:
            return next_id

        
        for expected, actual in enumerate(sorted(used_ids)):
            if expected != actual:
                return expected

        return len(used_ids)


class CT_Comment(BaseOxmlElement):
    

    
    id: int = RequiredAttribute("w:id", ST_DecimalNumber)  
    author: str = RequiredAttribute("w:author", ST_String)  
    initials: str | None = OptionalAttribute(  
        "w:initials", ST_String
    )
    date: dt.datetime | None = OptionalAttribute(  
        "w:date", ST_DateTime
    )

    

    p = ZeroOrMore("w:p", successors=())
    tbl = ZeroOrMore("w:tbl", successors=())

    

    add_p: Callable[[], CT_P]
    p_lst: list[CT_P]
    tbl_lst: list[CT_Tbl]
    _insert_tbl: Callable[[CT_Tbl], CT_Tbl]

    @property
    def inner_content_elements(self) -> list[CT_P | CT_Tbl]:
        
        return self.xpath("./w:p | ./w:tbl")
