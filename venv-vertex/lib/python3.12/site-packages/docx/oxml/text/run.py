

from __future__ import annotations

from typing import TYPE_CHECKING, Callable, Iterator, List, cast

from docx.oxml.drawing import CT_Drawing
from docx.oxml.ns import qn
from docx.oxml.parser import OxmlElement
from docx.oxml.simpletypes import ST_BrClear, ST_BrType
from docx.oxml.text.font import CT_RPr
from docx.oxml.xmlchemy import BaseOxmlElement, OptionalAttribute, ZeroOrMore, ZeroOrOne
from docx.shared import TextAccumulator

if TYPE_CHECKING:
    from docx.oxml.shape import CT_Anchor, CT_Inline
    from docx.oxml.text.pagebreak import CT_LastRenderedPageBreak
    from docx.oxml.text.parfmt import CT_TabStop





class CT_R(BaseOxmlElement):
    

    add_br: Callable[[], CT_Br]
    add_tab: Callable[[], CT_TabStop]
    get_or_add_rPr: Callable[[], CT_RPr]
    _add_drawing: Callable[[], CT_Drawing]
    _add_t: Callable[..., CT_Text]

    rPr: CT_RPr | None = ZeroOrOne("w:rPr")  
    br = ZeroOrMore("w:br")
    cr = ZeroOrMore("w:cr")
    drawing = ZeroOrMore("w:drawing")
    t = ZeroOrMore("w:t")
    tab = ZeroOrMore("w:tab")

    def add_t(self, text: str) -> CT_Text:
        
        t = self._add_t(text=text)
        if len(text.strip()) < len(text):
            t.set(qn("xml:space"), "preserve")
        return t

    def add_drawing(self, inline_or_anchor: CT_Inline | CT_Anchor) -> CT_Drawing:
        
        drawing = self._add_drawing()
        drawing.append(inline_or_anchor)
        return drawing

    def clear_content(self) -> None:
        
        
        for e in self.xpath("./*[not(self::w:rPr)]"):
            self.remove(e)

    @property
    def inner_content_items(self) -> List[str | CT_Drawing | CT_LastRenderedPageBreak]:
        
        from docx.oxml.text.pagebreak import CT_LastRenderedPageBreak

        accum = TextAccumulator()

        def iter_items() -> Iterator[str | CT_Drawing | CT_LastRenderedPageBreak]:
            for e in self.xpath(
                "w:br"
                " | w:cr"
                " | w:drawing"
                " | w:lastRenderedPageBreak"
                " | w:noBreakHyphen"
                " | w:ptab"
                " | w:t"
                " | w:tab"
            ):
                if isinstance(e, (CT_Drawing, CT_LastRenderedPageBreak)):
                    yield from accum.pop()
                    yield e
                else:
                    accum.push(str(e))

            
            yield from accum.pop()

        return list(iter_items())

    def insert_comment_range_end_and_reference_below(self, comment_id: int) -> None:
        
        self.addnext(self._new_comment_reference_run(comment_id))
        self.addnext(OxmlElement("w:commentRangeEnd", attrs={qn("w:id"): str(comment_id)}))

    def insert_comment_range_start_above(self, comment_id: int) -> None:
        
        self.addprevious(OxmlElement("w:commentRangeStart", attrs={qn("w:id"): str(comment_id)}))

    @property
    def lastRenderedPageBreaks(self) -> List[CT_LastRenderedPageBreak]:
        
        return self.xpath("./w:lastRenderedPageBreak")

    @property
    def style(self) -> str | None:
        
        rPr = self.rPr
        if rPr is None:
            return None
        return rPr.style

    @style.setter
    def style(self, style: str | None):
        
        rPr = self.get_or_add_rPr()
        rPr.style = style

    @property
    def text(self) -> str:
        
        return "".join(
            str(e) for e in self.xpath("w:br | w:cr | w:noBreakHyphen | w:ptab | w:t | w:tab")
        )

    @text.setter
    def text(self, text: str):  
        self.clear_content()
        _RunContentAppender.append_to_run_from_text(self, text)

    def _insert_rPr(self, rPr: CT_RPr) -> CT_RPr:
        self.insert(0, rPr)
        return rPr

    def _new_comment_reference_run(self, comment_id: int) -> CT_R:
        
        r = cast(CT_R, OxmlElement("w:r"))
        rPr = r.get_or_add_rPr()
        rPr.style = "CommentReference"
        r.append(OxmlElement("w:commentReference", attrs={qn("w:id"): str(comment_id)}))
        return r






class CT_Br(BaseOxmlElement):
    

    type: str | None = OptionalAttribute(  
        "w:type", ST_BrType, default="textWrapping"
    )
    clear: str | None = OptionalAttribute("w:clear", ST_BrClear)  

    def __str__(self) -> str:
        
        return "\n" if self.type == "textWrapping" else ""


class CT_Cr(BaseOxmlElement):
    

    def __str__(self) -> str:
        
        return "\n"


class CT_NoBreakHyphen(BaseOxmlElement):
    

    def __str__(self) -> str:
        
        return "-"


class CT_PTab(BaseOxmlElement):
    

    def __str__(self) -> str:
        
        return "\t"







class CT_Text(BaseOxmlElement):
    

    def __str__(self) -> str:
        
        return self.text or ""






class _RunContentAppender:
    

    def __init__(self, r: CT_R):
        self._r = r
        self._bfr: List[str] = []

    @classmethod
    def append_to_run_from_text(cls, r: CT_R, text: str):
        
        appender = cls(r)
        appender.add_text(text)

    def add_text(self, text: str):
        
        for char in text:
            self.add_char(char)
        self.flush()

    def add_char(self, char: str):
        
        if char == "\t":
            self.flush()
            self._r.add_tab()
        elif char in "\r\n":
            self.flush()
            self._r.add_br()
        else:
            self._bfr.append(char)

    def flush(self):
        text = "".join(self._bfr)
        if text:
            self._r.add_t(text)
        self._bfr.clear()
