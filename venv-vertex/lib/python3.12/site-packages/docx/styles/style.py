

from __future__ import annotations

from typing import Type

from docx.enum.style import WD_STYLE_TYPE
from docx.oxml.styles import CT_Style
from docx.shared import ElementProxy
from docx.styles import BabelFish
from docx.text.font import Font
from docx.text.parfmt import ParagraphFormat


def StyleFactory(style_elm: CT_Style) -> BaseStyle:
    
    style_cls: Type[BaseStyle] = {
        WD_STYLE_TYPE.PARAGRAPH: ParagraphStyle,
        WD_STYLE_TYPE.CHARACTER: CharacterStyle,
        WD_STYLE_TYPE.TABLE: _TableStyle,
        WD_STYLE_TYPE.LIST: _NumberingStyle,
    }[style_elm.type]

    return style_cls(style_elm)


class BaseStyle(ElementProxy):
    

    def __init__(self, style_elm: CT_Style):
        super().__init__(style_elm)
        self._style_elm = style_elm

    @property
    def builtin(self):
        
        return not self._element.customStyle

    def delete(self):
        
        self._element.delete()
        self._element = None

    @property
    def hidden(self):
        
        return self._element.semiHidden_val

    @hidden.setter
    def hidden(self, value):
        self._element.semiHidden_val = value

    @property
    def locked(self):
        
        return self._element.locked_val

    @locked.setter
    def locked(self, value):
        self._element.locked_val = value

    @property
    def name(self):
        
        name = self._element.name_val
        if name is None:
            return None
        return BabelFish.internal2ui(name)

    @name.setter
    def name(self, value):
        self._element.name_val = value

    @property
    def priority(self):
        
        return self._element.uiPriority_val

    @priority.setter
    def priority(self, value):
        self._element.uiPriority_val = value

    @property
    def quick_style(self):
        
        return self._element.qFormat_val

    @quick_style.setter
    def quick_style(self, value):
        self._element.qFormat_val = value

    @property
    def style_id(self) -> str:
        
        return self._style_elm.styleId

    @style_id.setter
    def style_id(self, value):
        self._element.styleId = value

    @property
    def type(self):
        
        type = self._style_elm.type
        if type is None:
            return WD_STYLE_TYPE.PARAGRAPH
        return type

    @property
    def unhide_when_used(self):
        
        return self._element.unhideWhenUsed_val

    @unhide_when_used.setter
    def unhide_when_used(self, value):
        self._element.unhideWhenUsed_val = value


class CharacterStyle(BaseStyle):
    

    @property
    def base_style(self):
        
        base_style = self._element.base_style
        if base_style is None:
            return None
        return StyleFactory(base_style)

    @base_style.setter
    def base_style(self, style):
        style_id = style.style_id if style is not None else None
        self._element.basedOn_val = style_id

    @property
    def font(self):
        
        return Font(self._element)



_CharacterStyle = CharacterStyle


class ParagraphStyle(CharacterStyle):
    

    def __repr__(self):
        return "_ParagraphStyle('%s') id: %s" % (self.name, id(self))

    @property
    def next_paragraph_style(self):
        
        next_style_elm = self._element.next_style
        if next_style_elm is None:
            return self
        if next_style_elm.type != WD_STYLE_TYPE.PARAGRAPH:
            return self
        return StyleFactory(next_style_elm)

    @next_paragraph_style.setter
    def next_paragraph_style(self, style):
        if style is None or style.style_id == self.style_id:
            self._element._remove_next()
        else:
            self._element.get_or_add_next().val = style.style_id

    @property
    def paragraph_format(self):
        
        return ParagraphFormat(self._element)



_ParagraphStyle = ParagraphStyle


class _TableStyle(ParagraphStyle):
    

    def __repr__(self):
        return "_TableStyle('%s') id: %s" % (self.name, id(self))


class _NumberingStyle(BaseStyle):
    
