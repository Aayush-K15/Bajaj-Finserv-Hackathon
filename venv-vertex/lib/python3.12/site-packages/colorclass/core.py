

from colorclass.codes import ANSICodeMapping
from colorclass.parse import parse_input, RE_SPLIT
from colorclass.search import build_color_index, find_char_color

PARENT_CLASS = type(u'')


def apply_text(incoming, func):
    
    split = RE_SPLIT.split(incoming)
    for i, item in enumerate(split):
        if not item or RE_SPLIT.match(item):
            continue
        split[i] = func(item)
    return incoming.__class__().join(split)


class ColorBytes(bytes):
    

    def __new__(cls, *args, **kwargs):
        
        original_class = kwargs.pop('original_class')
        combined_args = [cls] + list(args)
        instance = bytes.__new__(*combined_args, **kwargs)
        instance.original_class = original_class
        return instance

    def decode(self, encoding='utf-8', errors='strict'):
        
        original_class = getattr(self, 'original_class')
        return original_class(super(ColorBytes, self).decode(encoding, errors))


class ColorStr(PARENT_CLASS):
    

    def __new__(cls, *args, **kwargs):
        
        keep_tags = kwargs.pop('keep_tags', False)

        
        value_markup = args[0] if args else PARENT_CLASS()  
        value_colors, value_no_colors = parse_input(value_markup, ANSICodeMapping.DISABLE_COLORS, keep_tags)
        color_index = build_color_index(value_colors)

        
        color_args = [cls, value_colors] + list(args[1:])
        instance = PARENT_CLASS.__new__(*color_args, **kwargs)

        
        instance.value_colors = value_colors
        instance.value_no_colors = value_no_colors
        instance.has_colors = value_colors != value_no_colors
        instance.color_index = color_index
        return instance

    def __add__(self, other):
        
        return self.__class__(self.value_colors + other, keep_tags=True)

    def __getitem__(self, item):
        
        try:
            color_pos = self.color_index[int(item)]
        except TypeError:  
            return super(ColorStr, self).__getitem__(item)
        return self.__class__(find_char_color(self.value_colors, color_pos), keep_tags=True)

    def __iter__(self):
        
        for color_pos in self.color_index:
            yield self.__class__(find_char_color(self.value_colors, color_pos))

    def __len__(self):
        
        return self.value_no_colors.__len__()

    def __mod__(self, other):
        
        return self.__class__(self.value_colors % other, keep_tags=True)

    def __mul__(self, other):
        
        return self.__class__(self.value_colors * other, keep_tags=True)

    def __repr__(self):
        
        return '{name}({value})'.format(name=self.__class__.__name__, value=repr(self.value_colors))

    def capitalize(self):
        
        return apply_text(self, lambda s: s.capitalize())

    def center(self, width, fillchar=None):
        
        if fillchar is not None:
            result = self.value_no_colors.center(width, fillchar)
        else:
            result = self.value_no_colors.center(width)
        return self.__class__(result.replace(self.value_no_colors, self.value_colors), keep_tags=True)

    def count(self, sub, start=0, end=-1):
        
        return self.value_no_colors.count(sub, start, end)

    def endswith(self, suffix, start=0, end=None):
        
        args = [suffix, start] + ([] if end is None else [end])
        return self.value_no_colors.endswith(*args)

    def encode(self, encoding=None, errors='strict'):
        
        return ColorBytes(super(ColorStr, self).encode(encoding, errors), original_class=self.__class__)

    def decode(self, encoding=None, errors='strict'):
        
        return self.__class__(super(ColorStr, self).decode(encoding, errors), keep_tags=True)

    def find(self, sub, start=None, end=None):
        
        return self.value_no_colors.find(sub, start, end)

    def format(self, *args, **kwargs):
        
        return self.__class__(super(ColorStr, self).format(*args, **kwargs), keep_tags=True)

    def index(self, sub, start=None, end=None):
        
        return self.value_no_colors.index(sub, start, end)

    def isalnum(self):
        
        return self.value_no_colors.isalnum()

    def isalpha(self):
        
        return self.value_no_colors.isalpha()

    def isdecimal(self):
        
        return self.value_no_colors.isdecimal()

    def isdigit(self):
        
        return self.value_no_colors.isdigit()

    def isnumeric(self):
        
        return self.value_no_colors.isnumeric()

    def isspace(self):
        
        return self.value_no_colors.isspace()

    def istitle(self):
        
        return self.value_no_colors.istitle()

    def isupper(self):
        
        return self.value_no_colors.isupper()

    def join(self, iterable):
        
        return self.__class__(super(ColorStr, self).join(iterable), keep_tags=True)

    def ljust(self, width, fillchar=None):
        
        if fillchar is not None:
            result = self.value_no_colors.ljust(width, fillchar)
        else:
            result = self.value_no_colors.ljust(width)
        return self.__class__(result.replace(self.value_no_colors, self.value_colors), keep_tags=True)

    def rfind(self, sub, start=None, end=None):
        
        return self.value_no_colors.rfind(sub, start, end)

    def rindex(self, sub, start=None, end=None):
        
        return self.value_no_colors.rindex(sub, start, end)

    def rjust(self, width, fillchar=None):
        
        if fillchar is not None:
            result = self.value_no_colors.rjust(width, fillchar)
        else:
            result = self.value_no_colors.rjust(width)
        return self.__class__(result.replace(self.value_no_colors, self.value_colors), keep_tags=True)

    def splitlines(self, keepends=False):
        
        return [self.__class__(l) for l in self.value_colors.splitlines(keepends)]

    def startswith(self, prefix, start=0, end=-1):
        
        return self.value_no_colors.startswith(prefix, start, end)

    def swapcase(self):
        
        return apply_text(self, lambda s: s.swapcase())

    def title(self):
        
        return apply_text(self, lambda s: s.title())

    def translate(self, table):
        
        return apply_text(self, lambda s: s.translate(table))

    def upper(self):
        
        return apply_text(self, lambda s: s.upper())

    def zfill(self, width):
        
        if not self.value_no_colors:
            result = self.value_no_colors.zfill(width)
        else:
            result = self.value_colors.replace(self.value_no_colors, self.value_no_colors.zfill(width))
        return self.__class__(result, keep_tags=True)
