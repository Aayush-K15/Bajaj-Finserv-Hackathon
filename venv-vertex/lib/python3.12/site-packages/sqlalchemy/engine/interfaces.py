








from __future__ import annotations

from enum import Enum
from typing import Any
from typing import Awaitable
from typing import Callable
from typing import ClassVar
from typing import Collection
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from .. import util
from ..event import EventTarget
from ..pool import Pool
from ..pool import PoolProxiedConnection as PoolProxiedConnection
from ..sql.compiler import Compiled as Compiled
from ..sql.compiler import Compiled  
from ..sql.compiler import TypeCompiler as TypeCompiler
from ..sql.compiler import TypeCompiler  
from ..util import immutabledict
from ..util.concurrency import await_only
from ..util.typing import Literal
from ..util.typing import NotRequired
from ..util.typing import Protocol
from ..util.typing import TypedDict

if TYPE_CHECKING:
    from .base import Connection
    from .base import Engine
    from .cursor import CursorResult
    from .url import URL
    from ..connectors.asyncio import AsyncIODBAPIConnection
    from ..event import _ListenerFnType
    from ..event import dispatcher
    from ..exc import StatementError
    from ..sql import Executable
    from ..sql.compiler import _InsertManyValuesBatch
    from ..sql.compiler import DDLCompiler
    from ..sql.compiler import IdentifierPreparer
    from ..sql.compiler import InsertmanyvaluesSentinelOpts
    from ..sql.compiler import Linting
    from ..sql.compiler import SQLCompiler
    from ..sql.elements import BindParameter
    from ..sql.elements import ClauseElement
    from ..sql.schema import Column
    from ..sql.schema import DefaultGenerator
    from ..sql.schema import SchemaItem
    from ..sql.schema import Sequence as Sequence_SchemaItem
    from ..sql.sqltypes import Integer
    from ..sql.type_api import _TypeMemoDict
    from ..sql.type_api import TypeEngine
    from ..util.langhelpers import generic_fn_descriptor

ConnectArgsType = Tuple[Sequence[str], MutableMapping[str, Any]]

_T = TypeVar("_T", bound="Any")


class CacheStats(Enum):
    CACHE_HIT = 0
    CACHE_MISS = 1
    CACHING_DISABLED = 2
    NO_CACHE_KEY = 3
    NO_DIALECT_SUPPORT = 4


class ExecuteStyle(Enum):
    

    EXECUTE = 0
    

    EXECUTEMANY = 1
    

    INSERTMANYVALUES = 2
    


class DBAPIModule(Protocol):
    class Error(Exception):
        def __getattr__(self, key: str) -> Any: ...

    class OperationalError(Error):
        pass

    class InterfaceError(Error):
        pass

    class IntegrityError(Error):
        pass

    def __getattr__(self, key: str) -> Any: ...


class DBAPIConnection(Protocol):
      

    def close(self) -> None: ...

    def commit(self) -> None: ...

    def cursor(self, *args: Any, **kwargs: Any) -> DBAPICursor: ...

    def rollback(self) -> None: ...

    def __getattr__(self, key: str) -> Any: ...

    def __setattr__(self, key: str, value: Any) -> None: ...


class DBAPIType(Protocol):
      


class DBAPICursor(Protocol):
      

    @property
    def description(
        self,
    ) -> _DBAPICursorDescription:
          
        ...

    @property
    def rowcount(self) -> int: ...

    arraysize: int

    lastrowid: int

    def close(self) -> None: ...

    def execute(
        self,
        operation: Any,
        parameters: Optional[_DBAPISingleExecuteParams] = None,
    ) -> Any: ...

    def executemany(
        self,
        operation: Any,
        parameters: _DBAPIMultiExecuteParams,
    ) -> Any: ...

    def fetchone(self) -> Optional[Any]: ...

    def fetchmany(self, size: int = ...) -> Sequence[Any]: ...

    def fetchall(self) -> Sequence[Any]: ...

    def setinputsizes(self, sizes: Sequence[Any]) -> None: ...

    def setoutputsize(self, size: Any, column: Any) -> None: ...

    def callproc(
        self, procname: str, parameters: Sequence[Any] = ...
    ) -> Any: ...

    def nextset(self) -> Optional[bool]: ...

    def __getattr__(self, key: str) -> Any: ...


_CoreSingleExecuteParams = Mapping[str, Any]
_MutableCoreSingleExecuteParams = MutableMapping[str, Any]
_CoreMultiExecuteParams = Sequence[_CoreSingleExecuteParams]
_CoreAnyExecuteParams = Union[
    _CoreMultiExecuteParams, _CoreSingleExecuteParams
]

_DBAPISingleExecuteParams = Union[Sequence[Any], _CoreSingleExecuteParams]

_DBAPIMultiExecuteParams = Union[
    Sequence[Sequence[Any]], _CoreMultiExecuteParams
]
_DBAPIAnyExecuteParams = Union[
    _DBAPIMultiExecuteParams, _DBAPISingleExecuteParams
]
_DBAPICursorDescription = Sequence[
    Tuple[
        str,
        "DBAPIType",
        Optional[int],
        Optional[int],
        Optional[int],
        Optional[int],
        Optional[bool],
    ]
]

_AnySingleExecuteParams = _DBAPISingleExecuteParams
_AnyMultiExecuteParams = _DBAPIMultiExecuteParams
_AnyExecuteParams = _DBAPIAnyExecuteParams

CompiledCacheType = MutableMapping[Any, "Compiled"]
SchemaTranslateMapType = Mapping[Optional[str], Optional[str]]

_ImmutableExecuteOptions = immutabledict[str, Any]

_ParamStyle = Literal[
    "qmark", "numeric", "named", "format", "pyformat", "numeric_dollar"
]

_GenericSetInputSizesType = List[Tuple[str, Any, "TypeEngine[Any]"]]

IsolationLevel = Literal[
    "SERIALIZABLE",
    "REPEATABLE READ",
    "READ COMMITTED",
    "READ UNCOMMITTED",
    "AUTOCOMMIT",
]


class _CoreKnownExecutionOptions(TypedDict, total=False):
    compiled_cache: Optional[CompiledCacheType]
    logging_token: str
    isolation_level: IsolationLevel
    no_parameters: bool
    stream_results: bool
    max_row_buffer: int
    yield_per: int
    insertmanyvalues_page_size: int
    schema_translate_map: Optional[SchemaTranslateMapType]
    preserve_rowcount: bool


_ExecuteOptions = immutabledict[str, Any]
CoreExecuteOptionsParameter = Union[
    _CoreKnownExecutionOptions, Mapping[str, Any]
]


class ReflectedIdentity(TypedDict):
    

    always: bool
    

    on_null: bool
    

    start: int
    

    increment: int
    

    minvalue: int
    

    maxvalue: int
    

    nominvalue: bool
    

    nomaxvalue: bool
    

    cycle: bool
    

    cache: Optional[int]
    

    order: bool
    


class ReflectedComputed(TypedDict):
    

    sqltext: str
    

    persisted: NotRequired[bool]
    


class ReflectedColumn(TypedDict):
    

    name: str
    

    type: TypeEngine[Any]
    

    nullable: bool
    

    default: Optional[str]
    

    autoincrement: NotRequired[bool]
    

    comment: NotRequired[Optional[str]]
    

    computed: NotRequired[ReflectedComputed]
    

    identity: NotRequired[ReflectedIdentity]
    

    dialect_options: NotRequired[Dict[str, Any]]
    


class ReflectedConstraint(TypedDict):
    

    name: Optional[str]
    

    comment: NotRequired[Optional[str]]
    


class ReflectedCheckConstraint(ReflectedConstraint):
    

    sqltext: str
    

    dialect_options: NotRequired[Dict[str, Any]]
    


class ReflectedUniqueConstraint(ReflectedConstraint):
    

    column_names: List[str]
    

    duplicates_index: NotRequired[Optional[str]]
    "Indicates if this unique constraint duplicates an index with this name"

    dialect_options: NotRequired[Dict[str, Any]]
    


class ReflectedPrimaryKeyConstraint(ReflectedConstraint):
    

    constrained_columns: List[str]
    

    dialect_options: NotRequired[Dict[str, Any]]
    


class ReflectedForeignKeyConstraint(ReflectedConstraint):
    

    constrained_columns: List[str]
    

    referred_schema: Optional[str]
    

    referred_table: str
    

    referred_columns: List[str]
    

    options: NotRequired[Dict[str, Any]]
    


class ReflectedIndex(TypedDict):
    

    name: Optional[str]
    

    column_names: List[Optional[str]]
    

    expressions: NotRequired[List[str]]
    

    unique: bool
    

    duplicates_constraint: NotRequired[Optional[str]]
    "Indicates if this index mirrors a constraint with this name"

    include_columns: NotRequired[List[str]]
    

    column_sorting: NotRequired[Dict[str, Tuple[str]]]
    

    dialect_options: NotRequired[Dict[str, Any]]
    


class ReflectedTableComment(TypedDict):
    

    text: Optional[str]
    


class BindTyping(Enum):
    

    NONE = 1
    

    SETINPUTSIZES = 2
    

    RENDER_CASTS = 3
    


VersionInfoType = Tuple[Union[int, str], ...]
TableKey = Tuple[Optional[str], str]


class Dialect(EventTarget):
    

    CACHE_HIT = CacheStats.CACHE_HIT
    CACHE_MISS = CacheStats.CACHE_MISS
    CACHING_DISABLED = CacheStats.CACHING_DISABLED
    NO_CACHE_KEY = CacheStats.NO_CACHE_KEY
    NO_DIALECT_SUPPORT = CacheStats.NO_DIALECT_SUPPORT

    dispatch: dispatcher[Dialect]

    name: str
    

    driver: str
    

    dialect_description: str

    dbapi: Optional[DBAPIModule]
    

    @util.non_memoized_property
    def loaded_dbapi(self) -> DBAPIModule:
        
        raise NotImplementedError()

    positional: bool
    

    paramstyle: str
    

    compiler_linting: Linting

    statement_compiler: Type[SQLCompiler]
    

    ddl_compiler: Type[DDLCompiler]
    

    type_compiler_cls: ClassVar[Type[TypeCompiler]]
    

    type_compiler_instance: TypeCompiler
    

    type_compiler: Any
    

    preparer: Type[IdentifierPreparer]
    

    identifier_preparer: IdentifierPreparer
    

    server_version_info: Optional[Tuple[Any, ...]]
    

    default_schema_name: Optional[str]
    

    
    
    default_isolation_level: Optional[IsolationLevel]
    

    
    _on_connect_isolation_level: Optional[IsolationLevel]

    execution_ctx_cls: Type[ExecutionContext]
    

    execute_sequence_format: Union[
        Type[Tuple[Any, ...]], Type[Tuple[List[Any]]]
    ]
    

    supports_alter: bool
    

    max_identifier_length: int
    
    max_index_name_length: Optional[int]
    
    max_constraint_name_length: Optional[int]
    

    supports_server_side_cursors: Union[generic_fn_descriptor[bool], bool]
    

    server_side_cursors: bool
    

    supports_sane_rowcount: bool
    

    supports_sane_multi_rowcount: bool
    

    supports_empty_insert: bool
    

    supports_default_values: bool
    

    supports_default_metavalue: bool
    

    default_metavalue_token: str = "DEFAULT"
    

    supports_multivalues_insert: bool
    

    insert_executemany_returning: bool
    

    insert_executemany_returning_sort_by_parameter_order: bool
    

    update_executemany_returning: bool
    

    delete_executemany_returning: bool
    

    use_insertmanyvalues: bool
    

    use_insertmanyvalues_wo_returning: bool
    

    insertmanyvalues_implicit_sentinel: InsertmanyvaluesSentinelOpts
    

    insertmanyvalues_page_size: int
      

    insertmanyvalues_max_parameters: int
    

    preexecute_autoincrement_sequences: bool
    

    insert_returning: bool
    

    update_returning: bool
    

    update_returning_multifrom: bool
    

    delete_returning: bool
    

    delete_returning_multifrom: bool
    

    favor_returning_over_lastrowid: bool
    

    supports_identity_columns: bool
    

    cte_follows_insert: bool
    

    colspecs: MutableMapping[Type[TypeEngine[Any]], Type[TypeEngine[Any]]]
    

    supports_sequences: bool
    

    sequences_optional: bool
    

    default_sequence_base: int
    

    supports_native_enum: bool
    

    supports_native_boolean: bool
    

    supports_native_decimal: bool
    

    supports_native_uuid: bool
    

    returns_native_bytes: bool
    

    construct_arguments: Optional[
        List[Tuple[Type[Union[SchemaItem, ClauseElement]], Mapping[str, Any]]]
    ] = None
    

    reflection_options: Sequence[str] = ()
    

    dbapi_exception_translation_map: Mapping[str, str] = util.EMPTY_DICT
    

    supports_comments: bool
    

    inline_comments: bool
    

    supports_constraint_comments: bool
    

    _has_events = False

    supports_statement_cache: bool = True
    

    _supports_statement_cache: bool
    

    bind_typing = BindTyping.NONE
    

    is_async: bool
    

    has_terminate: bool
    

    engine_config_types: Mapping[str, Any]
    

    label_length: Optional[int]
    

    include_set_input_sizes: Optional[Set[Any]]
    

    exclude_set_input_sizes: Optional[Set[Any]]
    

    supports_simple_order_by_label: bool
    

    div_is_floordiv: bool
    

    tuple_in_values: bool
    

    _bind_typing_render_casts: bool

    _type_memos: MutableMapping[TypeEngine[Any], _TypeMemoDict]

    def _builtin_onconnect(self) -> Optional[_ListenerFnType]:
        raise NotImplementedError()

    def create_connect_args(self, url: URL) -> ConnectArgsType:
        

        raise NotImplementedError()

    @classmethod
    def import_dbapi(cls) -> DBAPIModule:
        
        raise NotImplementedError()

    def type_descriptor(self, typeobj: TypeEngine[_T]) -> TypeEngine[_T]:
        

        raise NotImplementedError()

    def initialize(self, connection: Connection) -> None:
        

    if TYPE_CHECKING:

        def _overrides_default(self, method_name: str) -> bool: ...

    def get_columns(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> List[ReflectedColumn]:
        

        raise NotImplementedError()

    def get_multi_columns(
        self,
        connection: Connection,
        *,
        schema: Optional[str] = None,
        filter_names: Optional[Collection[str]] = None,
        **kw: Any,
    ) -> Iterable[Tuple[TableKey, List[ReflectedColumn]]]:
        

        raise NotImplementedError()

    def get_pk_constraint(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> ReflectedPrimaryKeyConstraint:
        
        raise NotImplementedError()

    def get_multi_pk_constraint(
        self,
        connection: Connection,
        *,
        schema: Optional[str] = None,
        filter_names: Optional[Collection[str]] = None,
        **kw: Any,
    ) -> Iterable[Tuple[TableKey, ReflectedPrimaryKeyConstraint]]:
        
        raise NotImplementedError()

    def get_foreign_keys(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> List[ReflectedForeignKeyConstraint]:
        

        raise NotImplementedError()

    def get_multi_foreign_keys(
        self,
        connection: Connection,
        *,
        schema: Optional[str] = None,
        filter_names: Optional[Collection[str]] = None,
        **kw: Any,
    ) -> Iterable[Tuple[TableKey, List[ReflectedForeignKeyConstraint]]]:
        

        raise NotImplementedError()

    def get_table_names(
        self, connection: Connection, schema: Optional[str] = None, **kw: Any
    ) -> List[str]:
        

        raise NotImplementedError()

    def get_temp_table_names(
        self, connection: Connection, schema: Optional[str] = None, **kw: Any
    ) -> List[str]:
        

        raise NotImplementedError()

    def get_view_names(
        self, connection: Connection, schema: Optional[str] = None, **kw: Any
    ) -> List[str]:
        

        raise NotImplementedError()

    def get_materialized_view_names(
        self, connection: Connection, schema: Optional[str] = None, **kw: Any
    ) -> List[str]:
        

        raise NotImplementedError()

    def get_sequence_names(
        self, connection: Connection, schema: Optional[str] = None, **kw: Any
    ) -> List[str]:
        

        raise NotImplementedError()

    def get_temp_view_names(
        self, connection: Connection, schema: Optional[str] = None, **kw: Any
    ) -> List[str]:
        

        raise NotImplementedError()

    def get_schema_names(self, connection: Connection, **kw: Any) -> List[str]:
        
        raise NotImplementedError()

    def get_view_definition(
        self,
        connection: Connection,
        view_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> str:
        

        raise NotImplementedError()

    def get_indexes(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> List[ReflectedIndex]:
        

        raise NotImplementedError()

    def get_multi_indexes(
        self,
        connection: Connection,
        *,
        schema: Optional[str] = None,
        filter_names: Optional[Collection[str]] = None,
        **kw: Any,
    ) -> Iterable[Tuple[TableKey, List[ReflectedIndex]]]:
        

        raise NotImplementedError()

    def get_unique_constraints(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> List[ReflectedUniqueConstraint]:
        r

        raise NotImplementedError()

    def get_multi_unique_constraints(
        self,
        connection: Connection,
        *,
        schema: Optional[str] = None,
        filter_names: Optional[Collection[str]] = None,
        **kw: Any,
    ) -> Iterable[Tuple[TableKey, List[ReflectedUniqueConstraint]]]:
        

        raise NotImplementedError()

    def get_check_constraints(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> List[ReflectedCheckConstraint]:
        r

        raise NotImplementedError()

    def get_multi_check_constraints(
        self,
        connection: Connection,
        *,
        schema: Optional[str] = None,
        filter_names: Optional[Collection[str]] = None,
        **kw: Any,
    ) -> Iterable[Tuple[TableKey, List[ReflectedCheckConstraint]]]:
        

        raise NotImplementedError()

    def get_table_options(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> Dict[str, Any]:
        
        raise NotImplementedError()

    def get_multi_table_options(
        self,
        connection: Connection,
        *,
        schema: Optional[str] = None,
        filter_names: Optional[Collection[str]] = None,
        **kw: Any,
    ) -> Iterable[Tuple[TableKey, Dict[str, Any]]]:
        
        raise NotImplementedError()

    def get_table_comment(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> ReflectedTableComment:
        r

        raise NotImplementedError()

    def get_multi_table_comment(
        self,
        connection: Connection,
        *,
        schema: Optional[str] = None,
        filter_names: Optional[Collection[str]] = None,
        **kw: Any,
    ) -> Iterable[Tuple[TableKey, ReflectedTableComment]]:
        

        raise NotImplementedError()

    def normalize_name(self, name: str) -> str:
        
        raise NotImplementedError()

    def denormalize_name(self, name: str) -> str:
        
        raise NotImplementedError()

    def has_table(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> bool:
        

        raise NotImplementedError()

    def has_index(
        self,
        connection: Connection,
        table_name: str,
        index_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> bool:
        

        raise NotImplementedError()

    def has_sequence(
        self,
        connection: Connection,
        sequence_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> bool:
        

        raise NotImplementedError()

    def has_schema(
        self, connection: Connection, schema_name: str, **kw: Any
    ) -> bool:
        

        raise NotImplementedError()

    def _get_server_version_info(self, connection: Connection) -> Any:
        

        raise NotImplementedError()

    def _get_default_schema_name(self, connection: Connection) -> str:
        

        raise NotImplementedError()

    def do_begin(self, dbapi_connection: PoolProxiedConnection) -> None:
        

        raise NotImplementedError()

    def do_rollback(self, dbapi_connection: PoolProxiedConnection) -> None:
        

        raise NotImplementedError()

    def do_commit(self, dbapi_connection: PoolProxiedConnection) -> None:
        

        raise NotImplementedError()

    def do_terminate(self, dbapi_connection: DBAPIConnection) -> None:
        

        raise NotImplementedError()

    def do_close(self, dbapi_connection: DBAPIConnection) -> None:
        

        raise NotImplementedError()

    def _do_ping_w_event(self, dbapi_connection: DBAPIConnection) -> bool:
        raise NotImplementedError()

    def do_ping(self, dbapi_connection: DBAPIConnection) -> bool:
        
        raise NotImplementedError()

    def do_set_input_sizes(
        self,
        cursor: DBAPICursor,
        list_of_tuples: _GenericSetInputSizesType,
        context: ExecutionContext,
    ) -> Any:
        
        raise NotImplementedError()

    def create_xid(self) -> Any:
        

        raise NotImplementedError()

    def do_savepoint(self, connection: Connection, name: str) -> None:
        

        raise NotImplementedError()

    def do_rollback_to_savepoint(
        self, connection: Connection, name: str
    ) -> None:
        

        raise NotImplementedError()

    def do_release_savepoint(self, connection: Connection, name: str) -> None:
        

        raise NotImplementedError()

    def do_begin_twophase(self, connection: Connection, xid: Any) -> None:
        

        raise NotImplementedError()

    def do_prepare_twophase(self, connection: Connection, xid: Any) -> None:
        

        raise NotImplementedError()

    def do_rollback_twophase(
        self,
        connection: Connection,
        xid: Any,
        is_prepared: bool = True,
        recover: bool = False,
    ) -> None:
        

        raise NotImplementedError()

    def do_commit_twophase(
        self,
        connection: Connection,
        xid: Any,
        is_prepared: bool = True,
        recover: bool = False,
    ) -> None:
        

        raise NotImplementedError()

    def do_recover_twophase(self, connection: Connection) -> List[Any]:
        

        raise NotImplementedError()

    def _deliver_insertmanyvalues_batches(
        self,
        connection: Connection,
        cursor: DBAPICursor,
        statement: str,
        parameters: _DBAPIMultiExecuteParams,
        generic_setinputsizes: Optional[_GenericSetInputSizesType],
        context: ExecutionContext,
    ) -> Iterator[_InsertManyValuesBatch]:
        
        raise NotImplementedError()

    def do_executemany(
        self,
        cursor: DBAPICursor,
        statement: str,
        parameters: _DBAPIMultiExecuteParams,
        context: Optional[ExecutionContext] = None,
    ) -> None:
        

        raise NotImplementedError()

    def do_execute(
        self,
        cursor: DBAPICursor,
        statement: str,
        parameters: Optional[_DBAPISingleExecuteParams],
        context: Optional[ExecutionContext] = None,
    ) -> None:
        

        raise NotImplementedError()

    def do_execute_no_params(
        self,
        cursor: DBAPICursor,
        statement: str,
        context: Optional[ExecutionContext] = None,
    ) -> None:
        

        raise NotImplementedError()

    def is_disconnect(
        self,
        e: DBAPIModule.Error,
        connection: Optional[Union[PoolProxiedConnection, DBAPIConnection]],
        cursor: Optional[DBAPICursor],
    ) -> bool:
        

        raise NotImplementedError()

    def connect(self, *cargs: Any, **cparams: Any) -> DBAPIConnection:
        r
        raise NotImplementedError()

    def on_connect_url(self, url: URL) -> Optional[Callable[[Any], Any]]:
        
        return self.on_connect()

    def on_connect(self) -> Optional[Callable[[Any], None]]:
        
        return None

    def reset_isolation_level(self, dbapi_connection: DBAPIConnection) -> None:
        

        raise NotImplementedError()

    def set_isolation_level(
        self, dbapi_connection: DBAPIConnection, level: IsolationLevel
    ) -> None:
        

        raise NotImplementedError()

    def get_isolation_level(
        self, dbapi_connection: DBAPIConnection
    ) -> IsolationLevel:
        

        raise NotImplementedError()

    def get_default_isolation_level(
        self, dbapi_conn: DBAPIConnection
    ) -> IsolationLevel:
        
        raise NotImplementedError()

    def get_isolation_level_values(
        self, dbapi_conn: DBAPIConnection
    ) -> Sequence[IsolationLevel]:
        
        raise NotImplementedError()

    def _assert_and_set_isolation_level(
        self, dbapi_conn: DBAPIConnection, level: IsolationLevel
    ) -> None:
        raise NotImplementedError()

    @classmethod
    def get_dialect_cls(cls, url: URL) -> Type[Dialect]:
        
        return cls

    @classmethod
    def get_async_dialect_cls(cls, url: URL) -> Type[Dialect]:
        
        return cls.get_dialect_cls(url)

    @classmethod
    def load_provisioning(cls) -> None:
        

    @classmethod
    def engine_created(cls, engine: Engine) -> None:
        

    def get_driver_connection(self, connection: DBAPIConnection) -> Any:
        
        raise NotImplementedError()

    def set_engine_execution_options(
        self, engine: Engine, opts: CoreExecuteOptionsParameter
    ) -> None:
        
        raise NotImplementedError()

    def set_connection_execution_options(
        self, connection: Connection, opts: CoreExecuteOptionsParameter
    ) -> None:
        
        raise NotImplementedError()

    def get_dialect_pool_class(self, url: URL) -> Type[Pool]:
        
        raise NotImplementedError()

    def validate_identifier(self, ident: str) -> None:
        


class CreateEnginePlugin:
      

    def __init__(self, url: URL, kwargs: Dict[str, Any]):
        
        self.url = url

    def update_url(self, url: URL) -> URL:
        
        raise NotImplementedError()

    def handle_dialect_kwargs(
        self, dialect_cls: Type[Dialect], dialect_args: Dict[str, Any]
    ) -> None:
        

    def handle_pool_kwargs(
        self, pool_cls: Type[Pool], pool_args: Dict[str, Any]
    ) -> None:
        

    def engine_created(self, engine: Engine) -> None:
        


class ExecutionContext:
    

    engine: Engine
    

    connection: Connection
    

    root_connection: Connection
    

    dialect: Dialect
    

    cursor: DBAPICursor
    

    compiled: Optional[Compiled]
    

    statement: str
    

    invoked_statement: Optional[Executable]
    

    parameters: _AnyMultiExecuteParams
    

    no_parameters: bool
    

    isinsert: bool
    

    isupdate: bool
    

    execute_style: ExecuteStyle
    

    executemany: bool
    

    prefetch_cols: util.generic_fn_descriptor[Optional[Sequence[Column[Any]]]]
    

    postfetch_cols: util.generic_fn_descriptor[Optional[Sequence[Column[Any]]]]
    

    execution_options: _ExecuteOptions
    

    @classmethod
    def _init_ddl(
        cls,
        dialect: Dialect,
        connection: Connection,
        dbapi_connection: PoolProxiedConnection,
        execution_options: _ExecuteOptions,
        compiled_ddl: DDLCompiler,
    ) -> ExecutionContext:
        raise NotImplementedError()

    @classmethod
    def _init_compiled(
        cls,
        dialect: Dialect,
        connection: Connection,
        dbapi_connection: PoolProxiedConnection,
        execution_options: _ExecuteOptions,
        compiled: SQLCompiler,
        parameters: _CoreMultiExecuteParams,
        invoked_statement: Executable,
        extracted_parameters: Optional[Sequence[BindParameter[Any]]],
        cache_hit: CacheStats = CacheStats.CACHING_DISABLED,
    ) -> ExecutionContext:
        raise NotImplementedError()

    @classmethod
    def _init_statement(
        cls,
        dialect: Dialect,
        connection: Connection,
        dbapi_connection: PoolProxiedConnection,
        execution_options: _ExecuteOptions,
        statement: str,
        parameters: _DBAPIMultiExecuteParams,
    ) -> ExecutionContext:
        raise NotImplementedError()

    @classmethod
    def _init_default(
        cls,
        dialect: Dialect,
        connection: Connection,
        dbapi_connection: PoolProxiedConnection,
        execution_options: _ExecuteOptions,
    ) -> ExecutionContext:
        raise NotImplementedError()

    def _exec_default(
        self,
        column: Optional[Column[Any]],
        default: DefaultGenerator,
        type_: Optional[TypeEngine[Any]],
    ) -> Any:
        raise NotImplementedError()

    def _prepare_set_input_sizes(
        self,
    ) -> Optional[List[Tuple[str, Any, TypeEngine[Any]]]]:
        raise NotImplementedError()

    def _get_cache_stats(self) -> str:
        raise NotImplementedError()

    def _setup_result_proxy(self) -> CursorResult[Any]:
        raise NotImplementedError()

    def fire_sequence(self, seq: Sequence_SchemaItem, type_: Integer) -> int:
        
        raise NotImplementedError()

    def create_cursor(self) -> DBAPICursor:
        

        raise NotImplementedError()

    def pre_exec(self) -> None:
        

        raise NotImplementedError()

    def get_out_parameter_values(
        self, out_param_names: Sequence[str]
    ) -> Sequence[Any]:
        
        raise NotImplementedError()

    def post_exec(self) -> None:
        

        raise NotImplementedError()

    def handle_dbapi_exception(self, e: BaseException) -> None:
        

        raise NotImplementedError()

    def lastrow_has_defaults(self) -> bool:
        

        raise NotImplementedError()

    def get_rowcount(self) -> Optional[int]:
        

        raise NotImplementedError()

    def fetchall_for_returning(self, cursor: DBAPICursor) -> Sequence[Any]:
        
        raise NotImplementedError()


class ConnectionEventsTarget(EventTarget):
    

    dispatch: dispatcher[ConnectionEventsTarget]


Connectable = ConnectionEventsTarget


class ExceptionContext:
    

    __slots__ = ()

    dialect: Dialect
    

    connection: Optional[Connection]
    

    engine: Optional[Engine]
    

    cursor: Optional[DBAPICursor]
    

    statement: Optional[str]
    

    parameters: Optional[_DBAPIAnyExecuteParams]
    

    original_exception: BaseException
    

    sqlalchemy_exception: Optional[StatementError]
    

    chained_exception: Optional[BaseException]
    

    execution_context: Optional[ExecutionContext]
    

    is_disconnect: bool
    

    invalidate_pool_on_disconnect: bool
    

    is_pre_ping: bool
    


class AdaptedConnection:
    

    __slots__ = ("_connection",)

    _connection: AsyncIODBAPIConnection

    @property
    def driver_connection(self) -> Any:
        
        return self._connection

    def run_async(self, fn: Callable[[Any], Awaitable[_T]]) -> _T:
        
        return await_only(fn(self._connection))

    def __repr__(self) -> str:
        return "<AdaptedConnection %s>" % self._connection
