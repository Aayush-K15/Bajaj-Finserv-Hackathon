







from __future__ import annotations

import collections.abc as collections_abc
import operator
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from . import attributes
from . import interfaces
from . import loading
from . import util as orm_util
from ._typing import _O
from .base import _assertions
from .context import _column_descriptions
from .context import _determine_last_joined_entity
from .context import _legacy_filter_by_entity_zero
from .context import FromStatement
from .context import ORMCompileState
from .context import QueryContext
from .interfaces import ORMColumnDescription
from .interfaces import ORMColumnsClauseRole
from .util import AliasedClass
from .util import object_mapper
from .util import with_parent
from .. import exc as sa_exc
from .. import inspect
from .. import inspection
from .. import log
from .. import sql
from .. import util
from ..engine import Result
from ..engine import Row
from ..event import dispatcher
from ..event import EventTarget
from ..sql import coercions
from ..sql import expression
from ..sql import roles
from ..sql import Select
from ..sql import util as sql_util
from ..sql import visitors
from ..sql._typing import _FromClauseArgument
from ..sql._typing import _TP
from ..sql.annotation import SupportsCloneAnnotations
from ..sql.base import _entity_namespace_key
from ..sql.base import _generative
from ..sql.base import _NoArg
from ..sql.base import Executable
from ..sql.base import Generative
from ..sql.elements import BooleanClauseList
from ..sql.expression import Exists
from ..sql.selectable import _MemoizedSelectEntities
from ..sql.selectable import _SelectFromElements
from ..sql.selectable import ForUpdateArg
from ..sql.selectable import HasHints
from ..sql.selectable import HasPrefixes
from ..sql.selectable import HasSuffixes
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL
from ..sql.selectable import SelectLabelStyle
from ..util.typing import Literal
from ..util.typing import Self


if TYPE_CHECKING:
    from ._typing import _EntityType
    from ._typing import _ExternalEntityType
    from ._typing import _InternalEntityType
    from ._typing import SynchronizeSessionArgument
    from .mapper import Mapper
    from .path_registry import PathRegistry
    from .session import _PKIdentityArgument
    from .session import Session
    from .state import InstanceState
    from ..engine.cursor import CursorResult
    from ..engine.interfaces import _ImmutableExecuteOptions
    from ..engine.interfaces import CompiledCacheType
    from ..engine.interfaces import IsolationLevel
    from ..engine.interfaces import SchemaTranslateMapType
    from ..engine.result import FrozenResult
    from ..engine.result import ScalarResult
    from ..sql._typing import _ColumnExpressionArgument
    from ..sql._typing import _ColumnExpressionOrStrLabelArgument
    from ..sql._typing import _ColumnsClauseArgument
    from ..sql._typing import _DMLColumnArgument
    from ..sql._typing import _JoinTargetArgument
    from ..sql._typing import _LimitOffsetType
    from ..sql._typing import _MAYBE_ENTITY
    from ..sql._typing import _no_kw
    from ..sql._typing import _NOT_ENTITY
    from ..sql._typing import _OnClauseArgument
    from ..sql._typing import _PropagateAttrsType
    from ..sql._typing import _T0
    from ..sql._typing import _T1
    from ..sql._typing import _T2
    from ..sql._typing import _T3
    from ..sql._typing import _T4
    from ..sql._typing import _T5
    from ..sql._typing import _T6
    from ..sql._typing import _T7
    from ..sql._typing import _TypedColumnClauseArgument as _TCCA
    from ..sql.base import CacheableOptions
    from ..sql.base import ExecutableOption
    from ..sql.dml import UpdateBase
    from ..sql.elements import ColumnElement
    from ..sql.elements import Label
    from ..sql.selectable import _ForUpdateOfArgument
    from ..sql.selectable import _JoinTargetElement
    from ..sql.selectable import _SetupJoinsElement
    from ..sql.selectable import Alias
    from ..sql.selectable import CTE
    from ..sql.selectable import ExecutableReturnsRows
    from ..sql.selectable import FromClause
    from ..sql.selectable import ScalarSelect
    from ..sql.selectable import Subquery


__all__ = ["Query", "QueryContext"]

_T = TypeVar("_T", bound=Any)


@inspection._self_inspects
@log.class_logger
class Query(
    _SelectFromElements,
    SupportsCloneAnnotations,
    HasPrefixes,
    HasSuffixes,
    HasHints,
    EventTarget,
    log.Identified,
    Generative,
    Executable,
    Generic[_T],
):
    

    
    _where_criteria: Tuple[ColumnElement[Any], ...] = ()
    _having_criteria: Tuple[ColumnElement[Any], ...] = ()

    _order_by_clauses: Tuple[ColumnElement[Any], ...] = ()
    _group_by_clauses: Tuple[ColumnElement[Any], ...] = ()
    _limit_clause: Optional[ColumnElement[Any]] = None
    _offset_clause: Optional[ColumnElement[Any]] = None

    _distinct: bool = False
    _distinct_on: Tuple[ColumnElement[Any], ...] = ()

    _for_update_arg: Optional[ForUpdateArg] = None
    _correlate: Tuple[FromClause, ...] = ()
    _auto_correlate: bool = True
    _from_obj: Tuple[FromClause, ...] = ()
    _setup_joins: Tuple[_SetupJoinsElement, ...] = ()

    _label_style: SelectLabelStyle = SelectLabelStyle.LABEL_STYLE_LEGACY_ORM

    _memoized_select_entities = ()

    _compile_options: Union[Type[CacheableOptions], CacheableOptions] = (
        ORMCompileState.default_compile_options
    )

    _with_options: Tuple[ExecutableOption, ...]
    load_options = QueryContext.default_load_options + {
        "_legacy_uniquing": True
    }

    _params: util.immutabledict[str, Any] = util.EMPTY_DICT

    
    
    _enable_assertions = True

    _statement: Optional[ExecutableReturnsRows] = None

    session: Session

    dispatch: dispatcher[Query[_T]]

    
    
    
    @util.memoized_property
    def _propagate_attrs(self) -> _PropagateAttrsType:
        return util.EMPTY_DICT

    def __init__(
        self,
        entities: Union[
            _ColumnsClauseArgument[Any], Sequence[_ColumnsClauseArgument[Any]]
        ],
        session: Optional[Session] = None,
    ):
        

        
        
        
        
        
        self.session = session  
        self._set_entities(entities)

    def _set_propagate_attrs(self, values: Mapping[str, Any]) -> Self:
        self._propagate_attrs = util.immutabledict(values)
        return self

    def _set_entities(
        self,
        entities: Union[
            _ColumnsClauseArgument[Any], Iterable[_ColumnsClauseArgument[Any]]
        ],
    ) -> None:
        self._raw_columns = [
            coercions.expect(
                roles.ColumnsClauseRole,
                ent,
                apply_propagate_attrs=self,
                post_inspect=True,
            )
            for ent in util.to_list(entities)
        ]

    def tuples(self: Query[_O]) -> Query[Tuple[_O]]:
        
        return self.only_return_tuples(True)  

    def _entity_from_pre_ent_zero(self) -> Optional[_InternalEntityType[Any]]:
        if not self._raw_columns:
            return None

        ent = self._raw_columns[0]

        if "parententity" in ent._annotations:
            return ent._annotations["parententity"]  
        elif "bundle" in ent._annotations:
            return ent._annotations["bundle"]  
        else:
            
            for element in visitors.iterate(ent):
                if "parententity" in element._annotations:
                    return element._annotations["parententity"]  
            else:
                return None

    def _only_full_mapper_zero(self, methname: str) -> Mapper[Any]:
        if (
            len(self._raw_columns) != 1
            or "parententity" not in self._raw_columns[0]._annotations
            or not self._raw_columns[0].is_selectable
        ):
            raise sa_exc.InvalidRequestError(
                "%s() can only be used against "
                "a single mapped class." % methname
            )

        return self._raw_columns[0]._annotations["parententity"]  

    def _set_select_from(
        self, obj: Iterable[_FromClauseArgument], set_base_alias: bool
    ) -> None:
        fa = [
            coercions.expect(
                roles.StrictFromClauseRole,
                elem,
                allow_select=True,
                apply_propagate_attrs=self,
            )
            for elem in obj
        ]

        self._compile_options += {"_set_base_alias": set_base_alias}
        self._from_obj = tuple(fa)

    @_generative
    def _set_lazyload_from(self, state: InstanceState[Any]) -> Self:
        self.load_options += {"_lazy_loaded_from": state}
        return self

    def _get_condition(self) -> None:
        
        self._no_criterion_condition("get", order_by=False, distinct=False)

    def _get_existing_condition(self) -> None:
        self._no_criterion_assertion("get", order_by=False, distinct=False)

    def _no_criterion_assertion(
        self, meth: str, order_by: bool = True, distinct: bool = True
    ) -> None:
        if not self._enable_assertions:
            return
        if (
            self._where_criteria
            or self._statement is not None
            or self._from_obj
            or self._setup_joins
            or self._limit_clause is not None
            or self._offset_clause is not None
            or self._group_by_clauses
            or (order_by and self._order_by_clauses)
            or (distinct and self._distinct)
        ):
            raise sa_exc.InvalidRequestError(
                "Query.%s() being called on a "
                "Query with existing criterion. " % meth
            )

    def _no_criterion_condition(
        self, meth: str, order_by: bool = True, distinct: bool = True
    ) -> None:
        self._no_criterion_assertion(meth, order_by, distinct)

        self._from_obj = self._setup_joins = ()
        if self._statement is not None:
            self._compile_options += {"_statement": None}
        self._where_criteria = ()
        self._distinct = False

        self._order_by_clauses = self._group_by_clauses = ()

    def _no_clauseelement_condition(self, meth: str) -> None:
        if not self._enable_assertions:
            return
        if self._order_by_clauses:
            raise sa_exc.InvalidRequestError(
                "Query.%s() being called on a "
                "Query with existing criterion. " % meth
            )
        self._no_criterion_condition(meth)

    def _no_statement_condition(self, meth: str) -> None:
        if not self._enable_assertions:
            return
        if self._statement is not None:
            raise sa_exc.InvalidRequestError(
                (
                    "Query.%s() being called on a Query with an existing full "
                    "statement - can't apply criterion."
                )
                % meth
            )

    def _no_limit_offset(self, meth: str) -> None:
        if not self._enable_assertions:
            return
        if self._limit_clause is not None or self._offset_clause is not None:
            raise sa_exc.InvalidRequestError(
                "Query.%s() being called on a Query which already has LIMIT "
                "or OFFSET applied.  Call %s() before limit() or offset() "
                "are applied." % (meth, meth)
            )

    @property
    def _has_row_limiting_clause(self) -> bool:
        return (
            self._limit_clause is not None or self._offset_clause is not None
        )

    def _get_options(
        self,
        populate_existing: Optional[bool] = None,
        version_check: Optional[bool] = None,
        only_load_props: Optional[Sequence[str]] = None,
        refresh_state: Optional[InstanceState[Any]] = None,
        identity_token: Optional[Any] = None,
    ) -> Self:
        load_options: Dict[str, Any] = {}
        compile_options: Dict[str, Any] = {}

        if version_check:
            load_options["_version_check"] = version_check
        if populate_existing:
            load_options["_populate_existing"] = populate_existing
        if refresh_state:
            load_options["_refresh_state"] = refresh_state
            compile_options["_for_refresh_state"] = True
        if only_load_props:
            compile_options["_only_load_props"] = frozenset(only_load_props)
        if identity_token:
            load_options["_identity_token"] = identity_token

        if load_options:
            self.load_options += load_options
        if compile_options:
            self._compile_options += compile_options

        return self

    def _clone(self, **kw: Any) -> Self:
        return self._generate()

    def _get_select_statement_only(self) -> Select[_T]:
        if self._statement is not None:
            raise sa_exc.InvalidRequestError(
                "Can't call this method on a Query that uses from_statement()"
            )
        return cast("Select[_T]", self.statement)

    @property
    def statement(self) -> Union[Select[_T], FromStatement[_T], UpdateBase]:
        

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        stmt: Union[Select[_T], FromStatement[_T], UpdateBase]

        if not self._compile_options._set_base_alias:
            
            
            stmt = self._statement_20(for_statement=True)
        else:
            stmt = self._compile_state(for_statement=True).statement

        if self._params:
            stmt = stmt.params(self._params)

        return stmt

    def _final_statement(self, legacy_query_style: bool = True) -> Select[Any]:
        

        q = self._clone()

        return q._compile_state(
            use_legacy_query_style=legacy_query_style
        ).statement  

    def _statement_20(
        self, for_statement: bool = False, use_legacy_query_style: bool = True
    ) -> Union[Select[_T], FromStatement[_T]]:
        
        
        
        if self.dispatch.before_compile:
            for fn in self.dispatch.before_compile:
                new_query = fn(self)
                if new_query is not None and new_query is not self:
                    self = new_query
                    if not fn._bake_ok:  
                        self._compile_options += {"_bake_ok": False}

        compile_options = self._compile_options
        compile_options += {
            "_for_statement": for_statement,
            "_use_legacy_query_style": use_legacy_query_style,
        }

        stmt: Union[Select[_T], FromStatement[_T]]

        if self._statement is not None:
            stmt = FromStatement(self._raw_columns, self._statement)
            stmt.__dict__.update(
                _with_options=self._with_options,
                _with_context_options=self._with_context_options,
                _compile_options=compile_options,
                _execution_options=self._execution_options,
                _propagate_attrs=self._propagate_attrs,
            )
        else:
            
            stmt = Select._create_raw_select(**self.__dict__)
            stmt.__dict__.update(
                _label_style=self._label_style,
                _compile_options=compile_options,
                _propagate_attrs=self._propagate_attrs,
            )
            stmt.__dict__.pop("session", None)

        
        
        
        
        if "compile_state_plugin" not in stmt._propagate_attrs:
            stmt._propagate_attrs = stmt._propagate_attrs.union(
                {"compile_state_plugin": "orm", "plugin_subject": None}
            )

        return stmt

    def subquery(
        self,
        name: Optional[str] = None,
        with_labels: bool = False,
        reduce_columns: bool = False,
    ) -> Subquery:
        
        q = self.enable_eagerloads(False)
        if with_labels:
            q = q.set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)

        stmt = q._get_select_statement_only()

        if TYPE_CHECKING:
            assert isinstance(stmt, Select)

        if reduce_columns:
            stmt = stmt.reduce_columns()
        return stmt.subquery(name=name)

    def cte(
        self,
        name: Optional[str] = None,
        recursive: bool = False,
        nesting: bool = False,
    ) -> CTE:
        r  
        return (
            self.enable_eagerloads(False)
            ._get_select_statement_only()
            .cte(name=name, recursive=recursive, nesting=nesting)
        )

    def label(self, name: Optional[str]) -> Label[Any]:
        

        return (
            self.enable_eagerloads(False)
            ._get_select_statement_only()
            .label(name)
        )

    @overload
    def as_scalar(  
        self: Query[Tuple[_MAYBE_ENTITY]],
    ) -> ScalarSelect[_MAYBE_ENTITY]: ...

    @overload
    def as_scalar(
        self: Query[Tuple[_NOT_ENTITY]],
    ) -> ScalarSelect[_NOT_ENTITY]: ...

    @overload
    def as_scalar(self) -> ScalarSelect[Any]: ...

    @util.deprecated(
        "1.4",
        "The :meth:`_query.Query.as_scalar` method is deprecated and will be "
        "removed in a future release.  Please refer to "
        ":meth:`_query.Query.scalar_subquery`.",
    )
    def as_scalar(self) -> ScalarSelect[Any]:
        
        return self.scalar_subquery()

    @overload
    def scalar_subquery(
        self: Query[Tuple[_MAYBE_ENTITY]],
    ) -> ScalarSelect[Any]: ...

    @overload
    def scalar_subquery(
        self: Query[Tuple[_NOT_ENTITY]],
    ) -> ScalarSelect[_NOT_ENTITY]: ...

    @overload
    def scalar_subquery(self) -> ScalarSelect[Any]: ...

    def scalar_subquery(self) -> ScalarSelect[Any]:
        

        return (
            self.enable_eagerloads(False)
            ._get_select_statement_only()
            .scalar_subquery()
        )

    @property
    def selectable(self) -> Union[Select[_T], FromStatement[_T], UpdateBase]:
        
        return self.__clause_element__()

    def __clause_element__(
        self,
    ) -> Union[Select[_T], FromStatement[_T], UpdateBase]:
        return (
            self._with_compile_options(
                _enable_eagerloads=False, _render_for_subquery=True
            )
            .set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
            .statement
        )

    @overload
    def only_return_tuples(
        self: Query[_O], value: Literal[True]
    ) -> RowReturningQuery[Tuple[_O]]: ...

    @overload
    def only_return_tuples(
        self: Query[_O], value: Literal[False]
    ) -> Query[_O]: ...

    @_generative
    def only_return_tuples(self, value: bool) -> Query[Any]:
        
        self.load_options += dict(_only_return_tuples=value)
        return self

    @property
    def is_single_entity(self) -> bool:
        
        return (
            not self.load_options._only_return_tuples
            and len(self._raw_columns) == 1
            and "parententity" in self._raw_columns[0]._annotations
            and isinstance(
                self._raw_columns[0]._annotations["parententity"],
                ORMColumnsClauseRole,
            )
        )

    @_generative
    def enable_eagerloads(self, value: bool) -> Self:
        
        self._compile_options += {"_enable_eagerloads": value}
        return self

    @_generative
    def _with_compile_options(self, **opt: Any) -> Self:
        self._compile_options += opt
        return self

    @util.became_legacy_20(
        ":meth:`_orm.Query.with_labels` and :meth:`_orm.Query.apply_labels`",
        alternative="Use set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL) "
        "instead.",
    )
    def with_labels(self) -> Self:
        return self.set_label_style(
            SelectLabelStyle.LABEL_STYLE_TABLENAME_PLUS_COL
        )

    apply_labels = with_labels

    @property
    def get_label_style(self) -> SelectLabelStyle:
        
        return self._label_style

    def set_label_style(self, style: SelectLabelStyle) -> Self:
          
        if self._label_style is not style:
            self = self._generate()
            self._label_style = style
        return self

    @_generative
    def enable_assertions(self, value: bool) -> Self:
        
        self._enable_assertions = value
        return self

    @property
    def whereclause(self) -> Optional[ColumnElement[bool]]:
        
        return BooleanClauseList._construct_for_whereclause(
            self._where_criteria
        )

    @_generative
    def _with_current_path(self, path: PathRegistry) -> Self:
        
        self._compile_options += {"_current_path": path}
        return self

    @_generative
    def yield_per(self, count: int) -> Self:
        r
        self.load_options += {"_yield_per": count}
        return self

    @util.became_legacy_20(
        ":meth:`_orm.Query.get`",
        alternative="The method is now available as :meth:`_orm.Session.get`",
    )
    def get(self, ident: _PKIdentityArgument) -> Optional[Any]:
          
        self._no_criterion_assertion("get", order_by=False, distinct=False)

        
        
        return self._get_impl(ident, loading.load_on_pk_identity)

    def _get_impl(
        self,
        primary_key_identity: _PKIdentityArgument,
        db_load_fn: Callable[..., Any],
        identity_token: Optional[Any] = None,
    ) -> Optional[Any]:
        mapper = self._only_full_mapper_zero("get")
        return self.session._get_impl(
            mapper,
            primary_key_identity,
            db_load_fn,
            populate_existing=self.load_options._populate_existing,
            with_for_update=self._for_update_arg,
            options=self._with_options,
            identity_token=identity_token,
            execution_options=self._execution_options,
        )

    @property
    def lazy_loaded_from(self) -> Optional[InstanceState[Any]]:
        
        return self.load_options._lazy_loaded_from  

    @property
    def _current_path(self) -> PathRegistry:
        return self._compile_options._current_path  

    @_generative
    def correlate(
        self,
        *fromclauses: Union[Literal[None, False], _FromClauseArgument],
    ) -> Self:
        

        self._auto_correlate = False
        if fromclauses and fromclauses[0] in {None, False}:
            self._correlate = ()
        else:
            self._correlate = self._correlate + tuple(
                coercions.expect(roles.FromClauseRole, f) for f in fromclauses
            )
        return self

    @_generative
    def autoflush(self, setting: bool) -> Self:
        
        self.load_options += {"_autoflush": setting}
        return self

    @_generative
    def populate_existing(self) -> Self:
        
        self.load_options += {"_populate_existing": True}
        return self

    @_generative
    def _with_invoke_all_eagers(self, value: bool) -> Self:
        
        self.load_options += {"_invoke_all_eagers": value}
        return self

    @util.became_legacy_20(
        ":meth:`_orm.Query.with_parent`",
        alternative="Use the :func:`_orm.with_parent` standalone construct.",
    )
    @util.preload_module("sqlalchemy.orm.relationships")
    def with_parent(
        self,
        instance: object,
        property: Optional[  
            attributes.QueryableAttribute[Any]
        ] = None,
        from_entity: Optional[_ExternalEntityType[Any]] = None,
    ) -> Self:
        
        relationships = util.preloaded.orm_relationships

        if from_entity:
            entity_zero = inspect(from_entity)
        else:
            entity_zero = _legacy_filter_by_entity_zero(self)
        if property is None:
            
            mapper = object_mapper(instance)

            for prop in mapper.iterate_properties:
                if (
                    isinstance(prop, relationships.RelationshipProperty)
                    and prop.mapper is entity_zero.mapper  
                ):
                    property = prop  
                    break
            else:
                raise sa_exc.InvalidRequestError(
                    "Could not locate a property which relates instances "
                    "of class '%s' to instances of class '%s'"
                    % (
                        entity_zero.mapper.class_.__name__,  
                        instance.__class__.__name__,
                    )
                )

        return self.filter(
            with_parent(
                instance,
                property,  
                entity_zero.entity,  
            )
        )

    @_generative
    def add_entity(
        self,
        entity: _EntityType[Any],
        alias: Optional[Union[Alias, Subquery]] = None,
    ) -> Query[Any]:
        

        if alias is not None:
            
            entity = AliasedClass(entity, alias)

        self._raw_columns = list(self._raw_columns)

        self._raw_columns.append(
            coercions.expect(
                roles.ColumnsClauseRole, entity, apply_propagate_attrs=self
            )
        )
        return self

    @_generative
    def with_session(self, session: Session) -> Self:
        

        self.session = session
        return self

    def _legacy_from_self(
        self, *entities: _ColumnsClauseArgument[Any]
    ) -> Self:
        
        

        fromclause = (
            self.set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
            .correlate(None)
            .subquery()
            ._anonymous_fromclause()
        )

        q = self._from_selectable(fromclause)

        if entities:
            q._set_entities(entities)
        return q

    @_generative
    def _set_enable_single_crit(self, val: bool) -> Self:
        self._compile_options += {"_enable_single_crit": val}
        return self

    @_generative
    def _from_selectable(
        self, fromclause: FromClause, set_entity_from: bool = True
    ) -> Self:
        for attr in (
            "_where_criteria",
            "_order_by_clauses",
            "_group_by_clauses",
            "_limit_clause",
            "_offset_clause",
            "_last_joined_entity",
            "_setup_joins",
            "_memoized_select_entities",
            "_distinct",
            "_distinct_on",
            "_having_criteria",
            "_prefixes",
            "_suffixes",
        ):
            self.__dict__.pop(attr, None)
        self._set_select_from([fromclause], set_entity_from)
        self._compile_options += {
            "_enable_single_crit": False,
        }

        return self

    @util.deprecated(
        "1.4",
        ":meth:`_query.Query.values` "
        "is deprecated and will be removed in a "
        "future release.  Please use :meth:`_query.Query.with_entities`",
    )
    def values(self, *columns: _ColumnsClauseArgument[Any]) -> Iterable[Any]:
        
        return self._values_no_warn(*columns)

    _values = values

    def _values_no_warn(
        self, *columns: _ColumnsClauseArgument[Any]
    ) -> Iterable[Any]:
        if not columns:
            return iter(())
        q = self._clone().enable_eagerloads(False)
        q._set_entities(columns)
        if not q.load_options._yield_per:
            q.load_options += {"_yield_per": 10}
        return iter(q)

    @util.deprecated(
        "1.4",
        ":meth:`_query.Query.value` "
        "is deprecated and will be removed in a "
        "future release.  Please use :meth:`_query.Query.with_entities` "
        "in combination with :meth:`_query.Query.scalar`",
    )
    def value(self, column: _ColumnExpressionArgument[Any]) -> Any:
        
        try:
            return next(self._values_no_warn(column))[0]  
        except StopIteration:
            return None

    @overload
    def with_entities(self, _entity: _EntityType[_O]) -> Query[_O]: ...

    @overload
    def with_entities(
        self,
        _colexpr: roles.TypedColumnsClauseRole[_T],
    ) -> RowReturningQuery[Tuple[_T]]: ...

    

    
    

    @overload
    def with_entities(
        self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1]
    ) -> RowReturningQuery[Tuple[_T0, _T1]]: ...

    @overload
    def with_entities(
        self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2]
    ) -> RowReturningQuery[Tuple[_T0, _T1, _T2]]: ...

    @overload
    def with_entities(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
    ) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3]]: ...

    @overload
    def with_entities(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        __ent4: _TCCA[_T4],
    ) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4]]: ...

    @overload
    def with_entities(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        __ent4: _TCCA[_T4],
        __ent5: _TCCA[_T5],
    ) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4, _T5]]: ...

    @overload
    def with_entities(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        __ent4: _TCCA[_T4],
        __ent5: _TCCA[_T5],
        __ent6: _TCCA[_T6],
    ) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6]]: ...

    @overload
    def with_entities(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        __ent4: _TCCA[_T4],
        __ent5: _TCCA[_T5],
        __ent6: _TCCA[_T6],
        __ent7: _TCCA[_T7],
    ) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7]]: ...

    

    @overload
    def with_entities(
        self, *entities: _ColumnsClauseArgument[Any]
    ) -> Query[Any]: ...

    @_generative
    def with_entities(
        self, *entities: _ColumnsClauseArgument[Any], **__kw: Any
    ) -> Query[Any]:
        r
        if __kw:
            raise _no_kw()

        
        
        
        _MemoizedSelectEntities._generate_for_statement(self)  
        self._set_entities(entities)
        return self

    @_generative
    def add_columns(
        self, *column: _ColumnExpressionArgument[Any]
    ) -> Query[Any]:
        

        self._raw_columns = list(self._raw_columns)

        self._raw_columns.extend(
            coercions.expect(
                roles.ColumnsClauseRole,
                c,
                apply_propagate_attrs=self,
                post_inspect=True,
            )
            for c in column
        )
        return self

    @util.deprecated(
        "1.4",
        ":meth:`_query.Query.add_column` "
        "is deprecated and will be removed in a "
        "future release.  Please use :meth:`_query.Query.add_columns`",
    )
    def add_column(self, column: _ColumnExpressionArgument[Any]) -> Query[Any]:
        
        return self.add_columns(column)

    @_generative
    def options(self, *args: ExecutableOption) -> Self:
        

        opts = tuple(util.flatten_iterator(args))
        if self._compile_options._current_path:
            
            for opt in opts:
                if not opt._is_core and opt._is_legacy_option:  
                    opt.process_query_conditionally(self)  
        else:
            for opt in opts:
                if not opt._is_core and opt._is_legacy_option:  
                    opt.process_query(self)  

        self._with_options += opts
        return self

    def with_transformation(
        self, fn: Callable[[Query[Any]], Query[Any]]
    ) -> Query[Any]:
        
        return fn(self)

    def get_execution_options(self) -> _ImmutableExecuteOptions:
        
        return self._execution_options

    @overload
    def execution_options(
        self,
        *,
        compiled_cache: Optional[CompiledCacheType] = ...,
        logging_token: str = ...,
        isolation_level: IsolationLevel = ...,
        no_parameters: bool = False,
        stream_results: bool = False,
        max_row_buffer: int = ...,
        yield_per: int = ...,
        insertmanyvalues_page_size: int = ...,
        schema_translate_map: Optional[SchemaTranslateMapType] = ...,
        populate_existing: bool = False,
        autoflush: bool = False,
        preserve_rowcount: bool = False,
        **opt: Any,
    ) -> Self: ...

    @overload
    def execution_options(self, **opt: Any) -> Self: ...

    @_generative
    def execution_options(self, **kwargs: Any) -> Self:
        
        self._execution_options = self._execution_options.union(kwargs)
        return self

    @_generative
    def with_for_update(
        self,
        *,
        nowait: bool = False,
        read: bool = False,
        of: Optional[_ForUpdateOfArgument] = None,
        skip_locked: bool = False,
        key_share: bool = False,
    ) -> Self:
          

        self._for_update_arg = ForUpdateArg(
            read=read,
            nowait=nowait,
            of=of,
            skip_locked=skip_locked,
            key_share=key_share,
        )
        return self

    @_generative
    def params(
        self, __params: Optional[Dict[str, Any]] = None, **kw: Any
    ) -> Self:
        r
        if __params:
            kw.update(__params)
        self._params = self._params.union(kw)
        return self

    def where(self, *criterion: _ColumnExpressionArgument[bool]) -> Self:
        
        return self.filter(*criterion)

    @_generative
    @_assertions(_no_statement_condition, _no_limit_offset)
    def filter(self, *criterion: _ColumnExpressionArgument[bool]) -> Self:
        r  
        for crit in list(criterion):
            crit = coercions.expect(
                roles.WhereHavingRole, crit, apply_propagate_attrs=self
            )

            self._where_criteria += (crit,)
        return self

    @util.memoized_property
    def _last_joined_entity(
        self,
    ) -> Optional[Union[_InternalEntityType[Any], _JoinTargetElement]]:
        if self._setup_joins:
            return _determine_last_joined_entity(
                self._setup_joins,
            )
        else:
            return None

    def _filter_by_zero(self) -> Any:
        

        if self._setup_joins:
            _last_joined_entity = self._last_joined_entity
            if _last_joined_entity is not None:
                return _last_joined_entity

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        if self._from_obj and not self._compile_options._set_base_alias:
            return self._from_obj[0]

        return self._raw_columns[0]

    def filter_by(self, **kwargs: Any) -> Self:
        r
        from_entity = self._filter_by_zero()

        clauses = [
            _entity_namespace_key(from_entity, key) == value
            for key, value in kwargs.items()
        ]
        return self.filter(*clauses)

    @_generative
    def order_by(
        self,
        __first: Union[
            Literal[None, False, _NoArg.NO_ARG],
            _ColumnExpressionOrStrLabelArgument[Any],
        ] = _NoArg.NO_ARG,
        *clauses: _ColumnExpressionOrStrLabelArgument[Any],
    ) -> Self:
        

        for assertion in (self._no_statement_condition, self._no_limit_offset):
            assertion("order_by")

        if not clauses and (__first is None or __first is False):
            self._order_by_clauses = ()
        elif __first is not _NoArg.NO_ARG:
            criterion = tuple(
                coercions.expect(roles.OrderByRole, clause)
                for clause in (__first,) + clauses
            )
            self._order_by_clauses += criterion

        return self

    @_generative
    def group_by(
        self,
        __first: Union[
            Literal[None, False, _NoArg.NO_ARG],
            _ColumnExpressionOrStrLabelArgument[Any],
        ] = _NoArg.NO_ARG,
        *clauses: _ColumnExpressionOrStrLabelArgument[Any],
    ) -> Self:
        

        for assertion in (self._no_statement_condition, self._no_limit_offset):
            assertion("group_by")

        if not clauses and (__first is None or __first is False):
            self._group_by_clauses = ()
        elif __first is not _NoArg.NO_ARG:
            criterion = tuple(
                coercions.expect(roles.GroupByRole, clause)
                for clause in (__first,) + clauses
            )
            self._group_by_clauses += criterion
        return self

    @_generative
    @_assertions(_no_statement_condition, _no_limit_offset)
    def having(self, *having: _ColumnExpressionArgument[bool]) -> Self:
        r

        for criterion in having:
            having_criteria = coercions.expect(
                roles.WhereHavingRole, criterion
            )
            self._having_criteria += (having_criteria,)
        return self

    def _set_op(self, expr_fn: Any, *q: Query[Any]) -> Self:
        list_of_queries = (self,) + q
        return self._from_selectable(expr_fn(*(list_of_queries)).subquery())

    def union(self, *q: Query[Any]) -> Self:
        
        return self._set_op(expression.union, *q)

    def union_all(self, *q: Query[Any]) -> Self:
        
        return self._set_op(expression.union_all, *q)

    def intersect(self, *q: Query[Any]) -> Self:
        
        return self._set_op(expression.intersect, *q)

    def intersect_all(self, *q: Query[Any]) -> Self:
        
        return self._set_op(expression.intersect_all, *q)

    def except_(self, *q: Query[Any]) -> Self:
        
        return self._set_op(expression.except_, *q)

    def except_all(self, *q: Query[Any]) -> Self:
        
        return self._set_op(expression.except_all, *q)

    @_generative
    @_assertions(_no_statement_condition, _no_limit_offset)
    def join(
        self,
        target: _JoinTargetArgument,
        onclause: Optional[_OnClauseArgument] = None,
        *,
        isouter: bool = False,
        full: bool = False,
    ) -> Self:
        r

        join_target = coercions.expect(
            roles.JoinTargetRole,
            target,
            apply_propagate_attrs=self,
            legacy=True,
        )
        if onclause is not None:
            onclause_element = coercions.expect(
                roles.OnClauseRole, onclause, legacy=True
            )
        else:
            onclause_element = None

        self._setup_joins += (
            (
                join_target,
                onclause_element,
                None,
                {
                    "isouter": isouter,
                    "full": full,
                },
            ),
        )

        self.__dict__.pop("_last_joined_entity", None)
        return self

    def outerjoin(
        self,
        target: _JoinTargetArgument,
        onclause: Optional[_OnClauseArgument] = None,
        *,
        full: bool = False,
    ) -> Self:
        
        return self.join(target, onclause=onclause, isouter=True, full=full)

    @_generative
    @_assertions(_no_statement_condition)
    def reset_joinpoint(self) -> Self:
        
        self._last_joined_entity = None

        return self

    @_generative
    @_assertions(_no_clauseelement_condition)
    def select_from(self, *from_obj: _FromClauseArgument) -> Self:
        r

        self._set_select_from(from_obj, False)
        return self

    def __getitem__(self, item: Any) -> Any:
        return orm_util._getitem(
            self,
            item,
        )

    @_generative
    @_assertions(_no_statement_condition)
    def slice(
        self,
        start: int,
        stop: int,
    ) -> Self:
        

        self._limit_clause, self._offset_clause = sql_util._make_slice(
            self._limit_clause, self._offset_clause, start, stop
        )
        return self

    @_generative
    @_assertions(_no_statement_condition)
    def limit(self, limit: _LimitOffsetType) -> Self:
        
        self._limit_clause = sql_util._offset_or_limit_clause(limit)
        return self

    @_generative
    @_assertions(_no_statement_condition)
    def offset(self, offset: _LimitOffsetType) -> Self:
        
        self._offset_clause = sql_util._offset_or_limit_clause(offset)
        return self

    @_generative
    @_assertions(_no_statement_condition)
    def distinct(self, *expr: _ColumnExpressionArgument[Any]) -> Self:
        r
        if expr:
            self._distinct = True
            self._distinct_on = self._distinct_on + tuple(
                coercions.expect(roles.ByOfRole, e) for e in expr
            )
        else:
            self._distinct = True
        return self

    def all(self) -> List[_T]:
        
        return self._iter().all()  

    @_generative
    @_assertions(_no_clauseelement_condition)
    def from_statement(self, statement: ExecutableReturnsRows) -> Self:
        
        statement = coercions.expect(
            roles.SelectStatementRole, statement, apply_propagate_attrs=self
        )
        self._statement = statement
        return self

    def first(self) -> Optional[_T]:
        
        
        if self._statement is not None:
            return self._iter().first()  
        else:
            return self.limit(1)._iter().first()  

    def one_or_none(self) -> Optional[_T]:
        
        return self._iter().one_or_none()  

    def one(self) -> _T:
        
        return self._iter().one()  

    def scalar(self) -> Any:
        
        
        try:
            ret = self.one()
            if not isinstance(ret, collections_abc.Sequence):
                return ret
            return ret[0]
        except sa_exc.NoResultFound:
            return None

    def __iter__(self) -> Iterator[_T]:
        result = self._iter()
        try:
            yield from result  
        except GeneratorExit:
            
            
            result._soft_close()
            raise

    def _iter(self) -> Union[ScalarResult[_T], Result[_T]]:
        
        params = self._params

        statement = self._statement_20()
        result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
            statement,
            params,
            execution_options={"_sa_orm_load_options": self.load_options},
        )

        
        if result._attributes.get("is_single_entity", False):
            result = cast("Result[_T]", result).scalars()

        if (
            result._attributes.get("filtered", False)
            and not self.load_options._yield_per
        ):
            result = result.unique()

        return result

    def __str__(self) -> str:
        statement = self._statement_20()

        try:
            bind = (
                self._get_bind_args(statement, self.session.get_bind)
                if self.session
                else None
            )
        except sa_exc.UnboundExecutionError:
            bind = None

        return str(statement.compile(bind))

    def _get_bind_args(self, statement: Any, fn: Any, **kw: Any) -> Any:
        return fn(clause=statement, **kw)

    @property
    def column_descriptions(self) -> List[ORMColumnDescription]:
        

        return _column_descriptions(self, legacy=True)

    @util.deprecated(
        "2.0",
        "The :meth:`_orm.Query.instances` method is deprecated and will "
        "be removed in a future release. "
        "Use the Select.from_statement() method or aliased() construct in "
        "conjunction with Session.execute() instead.",
    )
    def instances(
        self,
        result_proxy: CursorResult[Any],
        context: Optional[QueryContext] = None,
    ) -> Any:
        
        if context is None:
            util.warn_deprecated(
                "Using the Query.instances() method without a context "
                "is deprecated and will be disallowed in a future release.  "
                "Please make use of :meth:`_query.Query.from_statement` "
                "for linking ORM results to arbitrary select constructs.",
                version="1.4",
            )
            compile_state = self._compile_state(for_statement=False)

            context = QueryContext(
                compile_state,
                compile_state.statement,
                compile_state.statement,
                self._params,
                self.session,
                self.load_options,
            )

        result = loading.instances(result_proxy, context)

        
        if result._attributes.get("is_single_entity", False):
            result = result.scalars()  

        if result._attributes.get("filtered", False):
            result = result.unique()

        
        return result

    @util.became_legacy_20(
        ":meth:`_orm.Query.merge_result`",
        alternative="The method is superseded by the "
        ":func:`_orm.merge_frozen_result` function.",
        enable_warnings=False,  
    )
    def merge_result(
        self,
        iterator: Union[
            FrozenResult[Any], Iterable[Sequence[Any]], Iterable[object]
        ],
        load: bool = True,
    ) -> Union[FrozenResult[Any], Iterable[Any]]:
        

        return loading.merge_result(self, iterator, load)

    def exists(self) -> Exists:
        

        
        
        
        
        

        inner = (
            self.enable_eagerloads(False)
            .add_columns(sql.literal_column("1"))
            .set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
            ._get_select_statement_only()
            .with_only_columns(1)
        )

        ezero = self._entity_from_pre_ent_zero()
        if ezero is not None:
            inner = inner.select_from(ezero)

        return sql.exists(inner)

    def count(self) -> int:
        r
        col = sql.func.count(sql.literal_column("*"))
        return (  
            self._legacy_from_self(col).enable_eagerloads(False).scalar()
        )

    def delete(
        self,
        synchronize_session: SynchronizeSessionArgument = "auto",
        delete_args: Optional[Dict[Any, Any]] = None,
    ) -> int:
        r  

        bulk_del = BulkDelete(self, delete_args)
        if self.dispatch.before_compile_delete:
            for fn in self.dispatch.before_compile_delete:
                new_query = fn(bulk_del.query, bulk_del)
                if new_query is not None:
                    bulk_del.query = new_query

                self = bulk_del.query

        delete_ = sql.delete(*self._raw_columns)  

        if delete_args:
            delete_ = delete_.with_dialect_options(**delete_args)

        delete_._where_criteria = self._where_criteria
        result: CursorResult[Any] = self.session.execute(
            delete_,
            self._params,
            execution_options=self._execution_options.union(
                {"synchronize_session": synchronize_session}
            ),
        )
        bulk_del.result = result  
        self.session.dispatch.after_bulk_delete(bulk_del)
        result.close()

        return result.rowcount

    def update(
        self,
        values: Dict[_DMLColumnArgument, Any],
        synchronize_session: SynchronizeSessionArgument = "auto",
        update_args: Optional[Dict[Any, Any]] = None,
    ) -> int:
        r

        update_args = update_args or {}

        bulk_ud = BulkUpdate(self, values, update_args)

        if self.dispatch.before_compile_update:
            for fn in self.dispatch.before_compile_update:
                new_query = fn(bulk_ud.query, bulk_ud)
                if new_query is not None:
                    bulk_ud.query = new_query
            self = bulk_ud.query

        upd = sql.update(*self._raw_columns)  

        ppo = update_args.pop("preserve_parameter_order", False)
        if ppo:
            upd = upd.ordered_values(*values)  
        else:
            upd = upd.values(values)
        if update_args:
            upd = upd.with_dialect_options(**update_args)

        upd._where_criteria = self._where_criteria
        result: CursorResult[Any] = self.session.execute(
            upd,
            self._params,
            execution_options=self._execution_options.union(
                {"synchronize_session": synchronize_session}
            ),
        )
        bulk_ud.result = result  
        self.session.dispatch.after_bulk_update(bulk_ud)
        result.close()
        return result.rowcount

    def _compile_state(
        self, for_statement: bool = False, **kw: Any
    ) -> ORMCompileState:
        

        stmt = self._statement_20(for_statement=for_statement, **kw)
        assert for_statement == stmt._compile_options._for_statement

        
        
        
        
        compile_state_cls = cast(
            ORMCompileState,
            ORMCompileState._get_plugin_class_for_plugin(stmt, "orm"),
        )

        return compile_state_cls._create_orm_context(
            stmt, toplevel=True, compiler=None
        )

    def _compile_context(self, for_statement: bool = False) -> QueryContext:
        compile_state = self._compile_state(for_statement=for_statement)
        context = QueryContext(
            compile_state,
            compile_state.statement,
            compile_state.statement,
            self._params,
            self.session,
            self.load_options,
        )

        return context


class AliasOption(interfaces.LoaderOption):
    inherit_cache = False

    @util.deprecated(
        "1.4",
        "The :class:`.AliasOption` object is not necessary "
        "for entities to be matched up to a query that is established "
        "via :meth:`.Query.from_statement` and now does nothing.",
    )
    def __init__(self, alias: Union[Alias, Subquery]):
        r

    def process_compile_state(self, compile_state: ORMCompileState) -> None:
        pass


class BulkUD:
    

    def __init__(self, query: Query[Any]):
        self.query = query.enable_eagerloads(False)
        self._validate_query_state()
        self.mapper = self.query._entity_from_pre_ent_zero()

    def _validate_query_state(self) -> None:
        for attr, methname, notset, op in (
            ("_limit_clause", "limit()", None, operator.is_),
            ("_offset_clause", "offset()", None, operator.is_),
            ("_order_by_clauses", "order_by()", (), operator.eq),
            ("_group_by_clauses", "group_by()", (), operator.eq),
            ("_distinct", "distinct()", False, operator.is_),
            (
                "_from_obj",
                "join(), outerjoin(), select_from(), or from_self()",
                (),
                operator.eq,
            ),
            (
                "_setup_joins",
                "join(), outerjoin(), select_from(), or from_self()",
                (),
                operator.eq,
            ),
        ):
            if not op(getattr(self.query, attr), notset):
                raise sa_exc.InvalidRequestError(
                    "Can't call Query.update() or Query.delete() "
                    "when %s has been called" % (methname,)
                )

    @property
    def session(self) -> Session:
        return self.query.session


class BulkUpdate(BulkUD):
    

    def __init__(
        self,
        query: Query[Any],
        values: Dict[_DMLColumnArgument, Any],
        update_kwargs: Optional[Dict[Any, Any]],
    ):
        super().__init__(query)
        self.values = values
        self.update_kwargs = update_kwargs


class BulkDelete(BulkUD):
    

    def __init__(
        self,
        query: Query[Any],
        delete_kwargs: Optional[Dict[Any, Any]],
    ):
        super().__init__(query)
        self.delete_kwargs = delete_kwargs


class RowReturningQuery(Query[Row[_TP]]):
    if TYPE_CHECKING:

        def tuples(self) -> Query[_TP]:  
            ...
