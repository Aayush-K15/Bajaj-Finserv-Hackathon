








from __future__ import annotations

import contextlib
from enum import Enum
import itertools
import sys
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref

from . import attributes
from . import bulk_persistence
from . import context
from . import descriptor_props
from . import exc
from . import identity
from . import loading
from . import query
from . import state as statelib
from ._typing import _O
from ._typing import insp_is_mapper
from ._typing import is_composite_class
from ._typing import is_orm_option
from ._typing import is_user_defined_option
from .base import _class_to_mapper
from .base import _none_set
from .base import _state_mapper
from .base import instance_str
from .base import LoaderCallableStatus
from .base import object_mapper
from .base import object_state
from .base import PassiveFlag
from .base import state_str
from .context import FromStatement
from .context import ORMCompileState
from .identity import IdentityMap
from .query import Query
from .state import InstanceState
from .state_changes import _StateChange
from .state_changes import _StateChangeState
from .state_changes import _StateChangeStates
from .unitofwork import UOWTransaction
from .. import engine
from .. import exc as sa_exc
from .. import sql
from .. import util
from ..engine import Connection
from ..engine import Engine
from ..engine.util import TransactionalContext
from ..event import dispatcher
from ..event import EventTarget
from ..inspection import inspect
from ..inspection import Inspectable
from ..sql import coercions
from ..sql import dml
from ..sql import roles
from ..sql import Select
from ..sql import TableClause
from ..sql import visitors
from ..sql.base import _NoArg
from ..sql.base import CompileState
from ..sql.schema import Table
from ..sql.selectable import ForUpdateArg
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL
from ..util import IdentitySet
from ..util.typing import Literal
from ..util.typing import Protocol

if typing.TYPE_CHECKING:
    from ._typing import _EntityType
    from ._typing import _IdentityKeyType
    from ._typing import _InstanceDict
    from ._typing import OrmExecuteOptionsParameter
    from .interfaces import ORMOption
    from .interfaces import UserDefinedOption
    from .mapper import Mapper
    from .path_registry import PathRegistry
    from .query import RowReturningQuery
    from ..engine import CursorResult
    from ..engine import Result
    from ..engine import Row
    from ..engine import RowMapping
    from ..engine.base import Transaction
    from ..engine.base import TwoPhaseTransaction
    from ..engine.interfaces import _CoreAnyExecuteParams
    from ..engine.interfaces import _CoreSingleExecuteParams
    from ..engine.interfaces import _ExecuteOptions
    from ..engine.interfaces import CoreExecuteOptionsParameter
    from ..engine.result import ScalarResult
    from ..event import _InstanceLevelDispatch
    from ..sql._typing import _ColumnsClauseArgument
    from ..sql._typing import _InfoType
    from ..sql._typing import _T0
    from ..sql._typing import _T1
    from ..sql._typing import _T2
    from ..sql._typing import _T3
    from ..sql._typing import _T4
    from ..sql._typing import _T5
    from ..sql._typing import _T6
    from ..sql._typing import _T7
    from ..sql._typing import _TypedColumnClauseArgument as _TCCA
    from ..sql.base import Executable
    from ..sql.base import ExecutableOption
    from ..sql.dml import UpdateBase
    from ..sql.elements import ClauseElement
    from ..sql.roles import TypedColumnsClauseRole
    from ..sql.selectable import ForUpdateParameter
    from ..sql.selectable import TypedReturnsRows

_T = TypeVar("_T", bound=Any)

__all__ = [
    "Session",
    "SessionTransaction",
    "sessionmaker",
    "ORMExecuteState",
    "close_all_sessions",
    "make_transient",
    "make_transient_to_detached",
    "object_session",
]

_sessions: weakref.WeakValueDictionary[int, Session] = (
    weakref.WeakValueDictionary()
)


statelib._sessions = _sessions

_PKIdentityArgument = Union[Any, Tuple[Any, ...]]

_BindArguments = Dict[str, Any]

_EntityBindKey = Union[Type[_O], "Mapper[_O]"]
_SessionBindKey = Union[Type[Any], "Mapper[Any]", "TableClause", str]
_SessionBind = Union["Engine", "Connection"]

JoinTransactionMode = Literal[
    "conditional_savepoint",
    "rollback_only",
    "control_fully",
    "create_savepoint",
]


class _ConnectionCallableProto(Protocol):
    

    def __call__(
        self,
        mapper: Optional[Mapper[Any]] = None,
        instance: Optional[object] = None,
        **kw: Any,
    ) -> Connection: ...


def _state_session(state: InstanceState[Any]) -> Optional[Session]:
    
    return state.session


class _SessionClassMethods:
    

    @classmethod
    @util.deprecated(
        "1.3",
        "The :meth:`.Session.close_all` method is deprecated and will be "
        "removed in a future release.  Please refer to "
        ":func:`.session.close_all_sessions`.",
    )
    def close_all(cls) -> None:
        

        close_all_sessions()

    @classmethod
    @util.preload_module("sqlalchemy.orm.util")
    def identity_key(
        cls,
        class_: Optional[Type[Any]] = None,
        ident: Union[Any, Tuple[Any, ...]] = None,
        *,
        instance: Optional[Any] = None,
        row: Optional[Union[Row[Any], RowMapping]] = None,
        identity_token: Optional[Any] = None,
    ) -> _IdentityKeyType[Any]:
        
        return util.preloaded.orm_util.identity_key(
            class_,
            ident,
            instance=instance,
            row=row,
            identity_token=identity_token,
        )

    @classmethod
    def object_session(cls, instance: object) -> Optional[Session]:
        

        return object_session(instance)


class SessionTransactionState(_StateChangeState):
    ACTIVE = 1
    PREPARED = 2
    COMMITTED = 3
    DEACTIVE = 4
    CLOSED = 5
    PROVISIONING_CONNECTION = 6



ACTIVE, PREPARED, COMMITTED, DEACTIVE, CLOSED, PROVISIONING_CONNECTION = tuple(
    SessionTransactionState
)


class ORMExecuteState(util.MemoizedSlots):
    

    __slots__ = (
        "session",
        "statement",
        "parameters",
        "execution_options",
        "local_execution_options",
        "bind_arguments",
        "identity_token",
        "_compile_state_cls",
        "_starting_event_idx",
        "_events_todo",
        "_update_execution_options",
    )

    session: Session
    

    statement: Executable
    

    parameters: Optional[_CoreAnyExecuteParams]
    

    execution_options: _ExecuteOptions
    

    local_execution_options: _ExecuteOptions
    

    bind_arguments: _BindArguments
    

    _compile_state_cls: Optional[Type[ORMCompileState]]
    _starting_event_idx: int
    _events_todo: List[Any]
    _update_execution_options: Optional[_ExecuteOptions]

    def __init__(
        self,
        session: Session,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams],
        execution_options: _ExecuteOptions,
        bind_arguments: _BindArguments,
        compile_state_cls: Optional[Type[ORMCompileState]],
        events_todo: List[_InstanceLevelDispatch[Session]],
    ):
        
        self.session = session
        self.statement = statement
        self.parameters = parameters
        self.local_execution_options = execution_options
        self.execution_options = statement._execution_options.union(
            execution_options
        )
        self.bind_arguments = bind_arguments
        self._compile_state_cls = compile_state_cls
        self._events_todo = list(events_todo)

    def _remaining_events(self) -> List[_InstanceLevelDispatch[Session]]:
        return self._events_todo[self._starting_event_idx + 1 :]

    def invoke_statement(
        self,
        statement: Optional[Executable] = None,
        params: Optional[_CoreAnyExecuteParams] = None,
        execution_options: Optional[OrmExecuteOptionsParameter] = None,
        bind_arguments: Optional[_BindArguments] = None,
    ) -> Result[Any]:
        

        if statement is None:
            statement = self.statement

        _bind_arguments = dict(self.bind_arguments)
        if bind_arguments:
            _bind_arguments.update(bind_arguments)
        _bind_arguments["_sa_skip_events"] = True

        _params: Optional[_CoreAnyExecuteParams]
        if params:
            if self.is_executemany:
                _params = []
                exec_many_parameters = cast(
                    "List[Dict[str, Any]]", self.parameters
                )
                for _existing_params, _new_params in itertools.zip_longest(
                    exec_many_parameters,
                    cast("List[Dict[str, Any]]", params),
                ):
                    if _existing_params is None or _new_params is None:
                        raise sa_exc.InvalidRequestError(
                            f"Can't apply executemany parameters to "
                            f"statement; number of parameter sets passed to "
                            f"Session.execute() ({len(exec_many_parameters)}) "
                            f"does not match number of parameter sets given "
                            f"to ORMExecuteState.invoke_statement() "
                            f"({len(params)})"
                        )
                    _existing_params = dict(_existing_params)
                    _existing_params.update(_new_params)
                    _params.append(_existing_params)
            else:
                _params = dict(cast("Dict[str, Any]", self.parameters))
                _params.update(cast("Dict[str, Any]", params))
        else:
            _params = self.parameters

        _execution_options = self.local_execution_options
        if execution_options:
            _execution_options = _execution_options.union(execution_options)

        return self.session._execute_internal(
            statement,
            _params,
            execution_options=_execution_options,
            bind_arguments=_bind_arguments,
            _parent_execute_state=self,
        )

    @property
    def bind_mapper(self) -> Optional[Mapper[Any]]:
        
        mp: Optional[Mapper[Any]] = self.bind_arguments.get("mapper", None)
        return mp

    @property
    def all_mappers(self) -> Sequence[Mapper[Any]]:
        
        if not self.is_orm_statement:
            return []
        elif isinstance(self.statement, (Select, FromStatement)):
            result = []
            seen = set()
            for d in self.statement.column_descriptions:
                ent = d["entity"]
                if ent:
                    insp = inspect(ent, raiseerr=False)
                    if insp and insp.mapper and insp.mapper not in seen:
                        seen.add(insp.mapper)
                        result.append(insp.mapper)
            return result
        elif self.statement.is_dml and self.bind_mapper:
            return [self.bind_mapper]
        else:
            return []

    @property
    def is_orm_statement(self) -> bool:
        
        return self._compile_state_cls is not None

    @property
    def is_executemany(self) -> bool:
        
        return isinstance(self.parameters, list)

    @property
    def is_select(self) -> bool:
        
        return self.statement.is_select

    @property
    def is_from_statement(self) -> bool:
        
        return self.statement.is_from_statement

    @property
    def is_insert(self) -> bool:
        
        return self.statement.is_dml and self.statement.is_insert

    @property
    def is_update(self) -> bool:
        
        return self.statement.is_dml and self.statement.is_update

    @property
    def is_delete(self) -> bool:
        
        return self.statement.is_dml and self.statement.is_delete

    @property
    def _is_crud(self) -> bool:
        return isinstance(self.statement, (dml.Update, dml.Delete))

    def update_execution_options(self, **opts: Any) -> None:
        
        self.local_execution_options = self.local_execution_options.union(opts)

    def _orm_compile_options(
        self,
    ) -> Optional[
        Union[
            context.ORMCompileState.default_compile_options,
            Type[context.ORMCompileState.default_compile_options],
        ]
    ]:
        if not self.is_select:
            return None
        try:
            opts = self.statement._compile_options
        except AttributeError:
            return None

        if opts is not None and opts.isinstance(
            context.ORMCompileState.default_compile_options
        ):
            return opts  
        else:
            return None

    @property
    def lazy_loaded_from(self) -> Optional[InstanceState[Any]]:
        
        return self.load_options._lazy_loaded_from

    @property
    def loader_strategy_path(self) -> Optional[PathRegistry]:
        
        opts = self._orm_compile_options()
        if opts is not None:
            return opts._current_path
        else:
            return None

    @property
    def is_column_load(self) -> bool:
        
        opts = self._orm_compile_options()
        return opts is not None and opts._for_refresh_state

    @property
    def is_relationship_load(self) -> bool:
        
        opts = self._orm_compile_options()
        if opts is None:
            return False
        path = self.loader_strategy_path
        return path is not None and not path.is_root

    @property
    def load_options(
        self,
    ) -> Union[
        context.QueryContext.default_load_options,
        Type[context.QueryContext.default_load_options],
    ]:
        

        if not self.is_select:
            raise sa_exc.InvalidRequestError(
                "This ORM execution is not against a SELECT statement "
                "so there are no load options."
            )

        lo: Union[
            context.QueryContext.default_load_options,
            Type[context.QueryContext.default_load_options],
        ] = self.execution_options.get(
            "_sa_orm_load_options", context.QueryContext.default_load_options
        )
        return lo

    @property
    def update_delete_options(
        self,
    ) -> Union[
        bulk_persistence.BulkUDCompileState.default_update_options,
        Type[bulk_persistence.BulkUDCompileState.default_update_options],
    ]:
        

        if not self._is_crud:
            raise sa_exc.InvalidRequestError(
                "This ORM execution is not against an UPDATE or DELETE "
                "statement so there are no update options."
            )
        uo: Union[
            bulk_persistence.BulkUDCompileState.default_update_options,
            Type[bulk_persistence.BulkUDCompileState.default_update_options],
        ] = self.execution_options.get(
            "_sa_orm_update_options",
            bulk_persistence.BulkUDCompileState.default_update_options,
        )
        return uo

    @property
    def _non_compile_orm_options(self) -> Sequence[ORMOption]:
        return [
            opt
            for opt in self.statement._with_options
            if is_orm_option(opt) and not opt._is_compile_state
        ]

    @property
    def user_defined_options(self) -> Sequence[UserDefinedOption]:
        
        return [
            opt
            for opt in self.statement._with_options
            if is_user_defined_option(opt)
        ]


class SessionTransactionOrigin(Enum):
    

    AUTOBEGIN = 0
    

    BEGIN = 1
    

    BEGIN_NESTED = 2
    

    SUBTRANSACTION = 3
    


class SessionTransaction(_StateChange, TransactionalContext):
    

    _rollback_exception: Optional[BaseException] = None

    _connections: Dict[
        Union[Engine, Connection], Tuple[Connection, Transaction, bool, bool]
    ]
    session: Session
    _parent: Optional[SessionTransaction]

    _state: SessionTransactionState

    _new: weakref.WeakKeyDictionary[InstanceState[Any], object]
    _deleted: weakref.WeakKeyDictionary[InstanceState[Any], object]
    _dirty: weakref.WeakKeyDictionary[InstanceState[Any], object]
    _key_switches: weakref.WeakKeyDictionary[
        InstanceState[Any], Tuple[Any, Any]
    ]

    origin: SessionTransactionOrigin
    

    nested: bool = False
    

    def __init__(
        self,
        session: Session,
        origin: SessionTransactionOrigin,
        parent: Optional[SessionTransaction] = None,
    ):
        TransactionalContext._trans_ctx_check(session)

        self.session = session
        self._connections = {}
        self._parent = parent
        self.nested = nested = origin is SessionTransactionOrigin.BEGIN_NESTED
        self.origin = origin

        if session._close_state is _SessionCloseState.CLOSED:
            raise sa_exc.InvalidRequestError(
                "This Session has been permanently closed and is unable "
                "to handle any more transaction requests."
            )

        if nested:
            if not parent:
                raise sa_exc.InvalidRequestError(
                    "Can't start a SAVEPOINT transaction when no existing "
                    "transaction is in progress"
                )

            self._previous_nested_transaction = session._nested_transaction
        elif origin is SessionTransactionOrigin.SUBTRANSACTION:
            assert parent is not None
        else:
            assert parent is None

        self._state = SessionTransactionState.ACTIVE

        self._take_snapshot()

        
        
        self.session._transaction = self

        self.session.dispatch.after_transaction_create(self.session, self)

    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        if state is SessionTransactionState.DEACTIVE:
            if self._rollback_exception:
                raise sa_exc.PendingRollbackError(
                    "This Session's transaction has been rolled back "
                    "due to a previous exception during flush."
                    " To begin a new transaction with this Session, "
                    "first issue Session.rollback()."
                    f" Original exception was: {self._rollback_exception}",
                    code="7s2a",
                )
            else:
                raise sa_exc.InvalidRequestError(
                    "This session is in 'inactive' state, due to the "
                    "SQL transaction being rolled back; no further SQL "
                    "can be emitted within this transaction."
                )
        elif state is SessionTransactionState.CLOSED:
            raise sa_exc.ResourceClosedError("This transaction is closed")
        elif state is SessionTransactionState.PROVISIONING_CONNECTION:
            raise sa_exc.InvalidRequestError(
                "This session is provisioning a new connection; concurrent "
                "operations are not permitted",
                code="isce",
            )
        else:
            raise sa_exc.InvalidRequestError(
                f"This session is in '{state.name.lower()}' state; no "
                "further SQL can be emitted within this transaction."
            )

    @property
    def parent(self) -> Optional[SessionTransaction]:
        
        return self._parent

    @property
    def is_active(self) -> bool:
        return (
            self.session is not None
            and self._state is SessionTransactionState.ACTIVE
        )

    @property
    def _is_transaction_boundary(self) -> bool:
        return self.nested or not self._parent

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), _StateChangeStates.NO_CHANGE
    )
    def connection(
        self,
        bindkey: Optional[Mapper[Any]],
        execution_options: Optional[_ExecuteOptions] = None,
        **kwargs: Any,
    ) -> Connection:
        bind = self.session.get_bind(bindkey, **kwargs)
        return self._connection_for_bind(bind, execution_options)

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), _StateChangeStates.NO_CHANGE
    )
    def _begin(self, nested: bool = False) -> SessionTransaction:
        return SessionTransaction(
            self.session,
            (
                SessionTransactionOrigin.BEGIN_NESTED
                if nested
                else SessionTransactionOrigin.SUBTRANSACTION
            ),
            self,
        )

    def _iterate_self_and_parents(
        self, upto: Optional[SessionTransaction] = None
    ) -> Iterable[SessionTransaction]:
        current = self
        result: Tuple[SessionTransaction, ...] = ()
        while current:
            result += (current,)
            if current._parent is upto:
                break
            elif current._parent is None:
                raise sa_exc.InvalidRequestError(
                    "Transaction %s is not on the active transaction list"
                    % (upto)
                )
            else:
                current = current._parent

        return result

    def _take_snapshot(self) -> None:
        if not self._is_transaction_boundary:
            parent = self._parent
            assert parent is not None
            self._new = parent._new
            self._deleted = parent._deleted
            self._dirty = parent._dirty
            self._key_switches = parent._key_switches
            return

        is_begin = self.origin in (
            SessionTransactionOrigin.BEGIN,
            SessionTransactionOrigin.AUTOBEGIN,
        )
        if not is_begin and not self.session._flushing:
            self.session.flush()

        self._new = weakref.WeakKeyDictionary()
        self._deleted = weakref.WeakKeyDictionary()
        self._dirty = weakref.WeakKeyDictionary()
        self._key_switches = weakref.WeakKeyDictionary()

    def _restore_snapshot(self, dirty_only: bool = False) -> None:
        
        assert self._is_transaction_boundary

        to_expunge = set(self._new).union(self.session._new)
        self.session._expunge_states(to_expunge, to_transient=True)

        for s, (oldkey, newkey) in self._key_switches.items():
            
            
            self.session.identity_map.safe_discard(s)

            
            s.key = oldkey

            
            if s not in to_expunge:
                self.session.identity_map.replace(s)

        for s in set(self._deleted).union(self.session._deleted):
            self.session._update_impl(s, revert_deletion=True)

        assert not self.session._deleted

        for s in self.session.identity_map.all_states():
            if not dirty_only or s.modified or s in self._dirty:
                s._expire(s.dict, self.session.identity_map._modified)

    def _remove_snapshot(self) -> None:
        
        assert self._is_transaction_boundary

        if not self.nested and self.session.expire_on_commit:
            for s in self.session.identity_map.all_states():
                s._expire(s.dict, self.session.identity_map._modified)

            statelib.InstanceState._detach_states(
                list(self._deleted), self.session
            )
            self._deleted.clear()
        elif self.nested:
            parent = self._parent
            assert parent is not None
            parent._new.update(self._new)
            parent._dirty.update(self._dirty)
            parent._deleted.update(self._deleted)
            parent._key_switches.update(self._key_switches)

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), _StateChangeStates.NO_CHANGE
    )
    def _connection_for_bind(
        self,
        bind: _SessionBind,
        execution_options: Optional[CoreExecuteOptionsParameter],
    ) -> Connection:
        if bind in self._connections:
            if execution_options:
                util.warn(
                    "Connection is already established for the "
                    "given bind; execution_options ignored"
                )
            return self._connections[bind][0]

        self._state = SessionTransactionState.PROVISIONING_CONNECTION

        local_connect = False
        should_commit = True

        try:
            if self._parent:
                conn = self._parent._connection_for_bind(
                    bind, execution_options
                )
                if not self.nested:
                    return conn
            else:
                if isinstance(bind, engine.Connection):
                    conn = bind
                    if conn.engine in self._connections:
                        raise sa_exc.InvalidRequestError(
                            "Session already has a Connection associated "
                            "for the given Connection's Engine"
                        )
                else:
                    conn = bind.connect()
                    local_connect = True

            try:
                if execution_options:
                    conn = conn.execution_options(**execution_options)

                transaction: Transaction
                if self.session.twophase and self._parent is None:
                    
                    
                    
                    
                    transaction = conn.begin_twophase()
                elif self.nested:
                    transaction = conn.begin_nested()
                elif conn.in_transaction():
                    join_transaction_mode = self.session.join_transaction_mode

                    if join_transaction_mode == "conditional_savepoint":
                        if conn.in_nested_transaction():
                            join_transaction_mode = "create_savepoint"
                        else:
                            join_transaction_mode = "rollback_only"

                        if local_connect:
                            util.warn(
                                "The engine provided as bind produced a "
                                "connection that is already in a transaction. "
                                "This is usually caused by a core event, "
                                "such as 'engine_connect', that has left a "
                                "transaction open. The effective join "
                                "transaction mode used by this session is "
                                f"{join_transaction_mode!r}. To silence this "
                                "warning, do not leave transactions open"
                            )
                    if join_transaction_mode in (
                        "control_fully",
                        "rollback_only",
                    ):
                        if conn.in_nested_transaction():
                            transaction = (
                                conn._get_required_nested_transaction()
                            )
                        else:
                            transaction = conn._get_required_transaction()
                        if join_transaction_mode == "rollback_only":
                            should_commit = False
                    elif join_transaction_mode == "create_savepoint":
                        transaction = conn.begin_nested()
                    else:
                        assert False, join_transaction_mode
                else:
                    transaction = conn.begin()
            except:
                
                
                if local_connect:
                    conn.close()
                raise
            else:
                bind_is_connection = isinstance(bind, engine.Connection)

                self._connections[conn] = self._connections[conn.engine] = (
                    conn,
                    transaction,
                    should_commit,
                    not bind_is_connection,
                )
                self.session.dispatch.after_begin(self.session, self, conn)
                return conn
        finally:
            self._state = SessionTransactionState.ACTIVE

    def prepare(self) -> None:
        if self._parent is not None or not self.session.twophase:
            raise sa_exc.InvalidRequestError(
                "'twophase' mode not enabled, or not root transaction; "
                "can't prepare."
            )
        self._prepare_impl()

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)

        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()

        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
                self.session.flush()
            else:
                raise exc.FlushError(
                    "Over 100 subsequent flushes have occurred within "
                    "session.commit() - is an after_flush() hook "
                    "creating new objects?"
                )

        if self._parent is None and self.session.twophase:
            try:
                for t in set(self._connections.values()):
                    cast("TwoPhaseTransaction", t[1]).prepare()
            except:
                with util.safe_reraise():
                    self.rollback()

        self._state = SessionTransactionState.PREPARED

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
                self._prepare_impl()

        if self._parent is None or self.nested:
            for conn, trans, should_commit, autoclose in set(
                self._connections.values()
            ):
                if should_commit:
                    trans.commit()

            self._state = SessionTransactionState.COMMITTED
            self.session.dispatch.after_commit(self.session)

            self._remove_snapshot()

        with self._expect_state(SessionTransactionState.CLOSED):
            self.close()

        if _to_root and self._parent:
            self._parent.commit(_to_root=True)

    @_StateChange.declare_states(
        (
            SessionTransactionState.ACTIVE,
            SessionTransactionState.DEACTIVE,
            SessionTransactionState.PREPARED,
        ),
        SessionTransactionState.CLOSED,
    )
    def rollback(
        self, _capture_exception: bool = False, _to_root: bool = False
    ) -> None:
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.close()

        boundary = self
        rollback_err = None
        if self._state in (
            SessionTransactionState.ACTIVE,
            SessionTransactionState.PREPARED,
        ):
            for transaction in self._iterate_self_and_parents():
                if transaction._parent is None or transaction.nested:
                    try:
                        for t in set(transaction._connections.values()):
                            t[1].rollback()

                        transaction._state = SessionTransactionState.DEACTIVE
                        self.session.dispatch.after_rollback(self.session)
                    except:
                        rollback_err = sys.exc_info()
                    finally:
                        transaction._state = SessionTransactionState.DEACTIVE
                        transaction._restore_snapshot(
                            dirty_only=transaction.nested
                        )
                    boundary = transaction
                    break
                else:
                    transaction._state = SessionTransactionState.DEACTIVE

        sess = self.session

        if not rollback_err and not sess._is_clean():
            
            
            util.warn(
                "Session's state has been changed on "
                "a non-active transaction - this state "
                "will be discarded."
            )
            boundary._restore_snapshot(dirty_only=boundary.nested)

        with self._expect_state(SessionTransactionState.CLOSED):
            self.close()

        if self._parent and _capture_exception:
            self._parent._rollback_exception = sys.exc_info()[1]

        if rollback_err and rollback_err[1]:
            raise rollback_err[1].with_traceback(rollback_err[2])

        sess.dispatch.after_soft_rollback(sess, self)

        if _to_root and self._parent:
            self._parent.rollback(_to_root=True)

    @_StateChange.declare_states(
        _StateChangeStates.ANY, SessionTransactionState.CLOSED
    )
    def close(self, invalidate: bool = False) -> None:
        if self.nested:
            self.session._nested_transaction = (
                self._previous_nested_transaction
            )

        self.session._transaction = self._parent

        for connection, transaction, should_commit, autoclose in set(
            self._connections.values()
        ):
            if invalidate and self._parent is None:
                connection.invalidate()
            if should_commit and transaction.is_active:
                transaction.close()
            if autoclose and self._parent is None:
                connection.close()

        self._state = SessionTransactionState.CLOSED
        sess = self.session

        
        
        
        
        
        
        

        sess.dispatch.after_transaction_end(sess, self)

    def _get_subject(self) -> Session:
        return self.session

    def _transaction_is_active(self) -> bool:
        return self._state is SessionTransactionState.ACTIVE

    def _transaction_is_closed(self) -> bool:
        return self._state is SessionTransactionState.CLOSED

    def _rollback_can_be_called(self) -> bool:
        return self._state not in (COMMITTED, CLOSED)


class _SessionCloseState(Enum):
    ACTIVE = 1
    CLOSED = 2
    CLOSE_IS_RESET = 3


class Session(_SessionClassMethods, EventTarget):
    

    _is_asyncio = False

    dispatch: dispatcher[Session]

    identity_map: IdentityMap
    

    _new: Dict[InstanceState[Any], Any]
    _deleted: Dict[InstanceState[Any], Any]
    bind: Optional[Union[Engine, Connection]]
    __binds: Dict[_SessionBindKey, _SessionBind]
    _flushing: bool
    _warn_on_events: bool
    _transaction: Optional[SessionTransaction]
    _nested_transaction: Optional[SessionTransaction]
    hash_key: int
    autoflush: bool
    expire_on_commit: bool
    enable_baked_queries: bool
    twophase: bool
    join_transaction_mode: JoinTransactionMode
    _query_cls: Type[Query[Any]]
    _close_state: _SessionCloseState

    def __init__(
        self,
        bind: Optional[_SessionBind] = None,
        *,
        autoflush: bool = True,
        future: Literal[True] = True,
        expire_on_commit: bool = True,
        autobegin: bool = True,
        twophase: bool = False,
        binds: Optional[Dict[_SessionBindKey, _SessionBind]] = None,
        enable_baked_queries: bool = True,
        info: Optional[_InfoType] = None,
        query_cls: Optional[Type[Query[Any]]] = None,
        autocommit: Literal[False] = False,
        join_transaction_mode: JoinTransactionMode = "conditional_savepoint",
        close_resets_only: Union[bool, _NoArg] = _NoArg.NO_ARG,
    ):
        r  

        
        
        
        
        if autocommit:
            raise sa_exc.ArgumentError(
                "autocommit=True is no longer supported"
            )
        self.identity_map = identity.WeakInstanceDict()

        if not future:
            raise sa_exc.ArgumentError(
                "The 'future' parameter passed to "
                "Session() may only be set to True."
            )

        self._new = {}  
        self._deleted = {}  
        self.bind = bind
        self.__binds = {}
        self._flushing = False
        self._warn_on_events = False
        self._transaction = None
        self._nested_transaction = None
        self.hash_key = _new_sessionid()
        self.autobegin = autobegin
        self.autoflush = autoflush
        self.expire_on_commit = expire_on_commit
        self.enable_baked_queries = enable_baked_queries

        
        
        if close_resets_only in (True, _NoArg.NO_ARG):
            self._close_state = _SessionCloseState.CLOSE_IS_RESET
        else:
            self._close_state = _SessionCloseState.ACTIVE
        if (
            join_transaction_mode
            and join_transaction_mode
            not in JoinTransactionMode.__args__  
        ):
            raise sa_exc.ArgumentError(
                f"invalid selection for join_transaction_mode: "
                f'"{join_transaction_mode}"'
            )
        self.join_transaction_mode = join_transaction_mode

        self.twophase = twophase
        self._query_cls = query_cls if query_cls else query.Query
        if info:
            self.info.update(info)

        if binds is not None:
            for key, bind in binds.items():
                self._add_bind(key, bind)

        _sessions[self.hash_key] = self

    
    _trans_context_manager: Optional[TransactionalContext] = None

    connection_callable: Optional[_ConnectionCallableProto] = None

    def __enter__(self: _S) -> _S:
        return self

    def __exit__(self, type_: Any, value: Any, traceback: Any) -> None:
        self.close()

    @contextlib.contextmanager
    def _maker_context_manager(self: _S) -> Iterator[_S]:
        with self:
            with self.begin():
                yield self

    def in_transaction(self) -> bool:
        
        return self._transaction is not None

    def in_nested_transaction(self) -> bool:
        
        return self._nested_transaction is not None

    def get_transaction(self) -> Optional[SessionTransaction]:
        
        trans = self._transaction
        while trans is not None and trans._parent is not None:
            trans = trans._parent
        return trans

    def get_nested_transaction(self) -> Optional[SessionTransaction]:
        

        return self._nested_transaction

    @util.memoized_property
    def info(self) -> _InfoType:
        
        return {}

    def _autobegin_t(self, begin: bool = False) -> SessionTransaction:
        if self._transaction is None:
            if not begin and not self.autobegin:
                raise sa_exc.InvalidRequestError(
                    "Autobegin is disabled on this Session; please call "
                    "session.begin() to start a new transaction"
                )
            trans = SessionTransaction(
                self,
                (
                    SessionTransactionOrigin.BEGIN
                    if begin
                    else SessionTransactionOrigin.AUTOBEGIN
                ),
            )
            assert self._transaction is trans
            return trans

        return self._transaction

    def begin(self, nested: bool = False) -> SessionTransaction:
        

        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t(begin=True)

            if not nested:
                return trans

        assert trans is not None

        if nested:
            trans = trans._begin(nested=nested)
            assert self._transaction is trans
            self._nested_transaction = trans
        else:
            raise sa_exc.InvalidRequestError(
                "A transaction is already begun on this Session."
            )

        return trans  

    def begin_nested(self) -> SessionTransaction:
        
        return self.begin(nested=True)

    def rollback(self) -> None:
        
        if self._transaction is None:
            pass
        else:
            self._transaction.rollback(_to_root=True)

    def commit(self) -> None:
        
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()

        trans.commit(_to_root=True)

    def prepare(self) -> None:
        
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()

        trans.prepare()

    def connection(
        self,
        bind_arguments: Optional[_BindArguments] = None,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> Connection:
        r

        if bind_arguments:
            bind = bind_arguments.pop("bind", None)

            if bind is None:
                bind = self.get_bind(**bind_arguments)
        else:
            bind = self.get_bind()

        return self._connection_for_bind(
            bind,
            execution_options=execution_options,
        )

    def _connection_for_bind(
        self,
        engine: _SessionBind,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
        **kw: Any,
    ) -> Connection:
        TransactionalContext._trans_ctx_check(self)

        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
        return trans._connection_for_bind(engine, execution_options)

    @overload
    def _execute_internal(
        self,
        statement: Executable,
        params: Optional[_CoreSingleExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        _parent_execute_state: Optional[Any] = None,
        _add_event: Optional[Any] = None,
        _scalar_result: Literal[True] = ...,
    ) -> Any: ...

    @overload
    def _execute_internal(
        self,
        statement: Executable,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        _parent_execute_state: Optional[Any] = None,
        _add_event: Optional[Any] = None,
        _scalar_result: bool = ...,
    ) -> Result[Any]: ...

    def _execute_internal(
        self,
        statement: Executable,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        _parent_execute_state: Optional[Any] = None,
        _add_event: Optional[Any] = None,
        _scalar_result: bool = False,
    ) -> Any:
        statement = coercions.expect(roles.StatementRole, statement)

        if not bind_arguments:
            bind_arguments = {}
        else:
            bind_arguments = dict(bind_arguments)

        if (
            statement._propagate_attrs.get("compile_state_plugin", None)
            == "orm"
        ):
            compile_state_cls = CompileState._get_plugin_class_for_plugin(
                statement, "orm"
            )
            if TYPE_CHECKING:
                assert isinstance(
                    compile_state_cls, context.AbstractORMCompileState
                )
        else:
            compile_state_cls = None
            bind_arguments.setdefault("clause", statement)

        execution_options = util.coerce_to_immutabledict(execution_options)

        if _parent_execute_state:
            events_todo = _parent_execute_state._remaining_events()
        else:
            events_todo = self.dispatch.do_orm_execute
            if _add_event:
                events_todo = list(events_todo) + [_add_event]

        if events_todo:
            if compile_state_cls is not None:
                
                
                
                
                
                
                (
                    statement,
                    execution_options,
                ) = compile_state_cls.orm_pre_session_exec(
                    self,
                    statement,
                    params,
                    execution_options,
                    bind_arguments,
                    True,
                )

            orm_exec_state = ORMExecuteState(
                self,
                statement,
                params,
                execution_options,
                bind_arguments,
                compile_state_cls,
                events_todo,
            )
            for idx, fn in enumerate(events_todo):
                orm_exec_state._starting_event_idx = idx
                fn_result: Optional[Result[Any]] = fn(orm_exec_state)
                if fn_result:
                    if _scalar_result:
                        return fn_result.scalar()
                    else:
                        return fn_result

            statement = orm_exec_state.statement
            execution_options = orm_exec_state.local_execution_options

        if compile_state_cls is not None:
            
            
            
            
            
            (
                statement,
                execution_options,
            ) = compile_state_cls.orm_pre_session_exec(
                self,
                statement,
                params,
                execution_options,
                bind_arguments,
                False,
            )

        bind = self.get_bind(**bind_arguments)

        conn = self._connection_for_bind(bind)

        if _scalar_result and not compile_state_cls:
            if TYPE_CHECKING:
                params = cast(_CoreSingleExecuteParams, params)
            return conn.scalar(
                statement, params or {}, execution_options=execution_options
            )

        if compile_state_cls:
            result: Result[Any] = compile_state_cls.orm_execute_statement(
                self,
                statement,
                params or {},
                execution_options,
                bind_arguments,
                conn,
            )
        else:
            result = conn.execute(
                statement, params or {}, execution_options=execution_options
            )

        if _scalar_result:
            return result.scalar()
        else:
            return result

    @overload
    def execute(
        self,
        statement: TypedReturnsRows[_T],
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        _parent_execute_state: Optional[Any] = None,
        _add_event: Optional[Any] = None,
    ) -> Result[_T]: ...

    @overload
    def execute(
        self,
        statement: UpdateBase,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        _parent_execute_state: Optional[Any] = None,
        _add_event: Optional[Any] = None,
    ) -> CursorResult[Any]: ...

    @overload
    def execute(
        self,
        statement: Executable,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        _parent_execute_state: Optional[Any] = None,
        _add_event: Optional[Any] = None,
    ) -> Result[Any]: ...

    def execute(
        self,
        statement: Executable,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        _parent_execute_state: Optional[Any] = None,
        _add_event: Optional[Any] = None,
    ) -> Result[Any]:
        r
        return self._execute_internal(
            statement,
            params,
            execution_options=execution_options,
            bind_arguments=bind_arguments,
            _parent_execute_state=_parent_execute_state,
            _add_event=_add_event,
        )

    @overload
    def scalar(
        self,
        statement: TypedReturnsRows[Tuple[_T]],
        params: Optional[_CoreSingleExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        **kw: Any,
    ) -> Optional[_T]: ...

    @overload
    def scalar(
        self,
        statement: Executable,
        params: Optional[_CoreSingleExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        **kw: Any,
    ) -> Any: ...

    def scalar(
        self,
        statement: Executable,
        params: Optional[_CoreSingleExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        **kw: Any,
    ) -> Any:
        

        return self._execute_internal(
            statement,
            params,
            execution_options=execution_options,
            bind_arguments=bind_arguments,
            _scalar_result=True,
            **kw,
        )

    @overload
    def scalars(
        self,
        statement: TypedReturnsRows[Tuple[_T]],
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        **kw: Any,
    ) -> ScalarResult[_T]: ...

    @overload
    def scalars(
        self,
        statement: Executable,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        **kw: Any,
    ) -> ScalarResult[Any]: ...

    def scalars(
        self,
        statement: Executable,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        **kw: Any,
    ) -> ScalarResult[Any]:
        

        return self._execute_internal(
            statement,
            params=params,
            execution_options=execution_options,
            bind_arguments=bind_arguments,
            _scalar_result=False,  
            **kw,
        ).scalars()

    def close(self) -> None:
        
        self._close_impl(invalidate=False)

    def reset(self) -> None:
        
        self._close_impl(invalidate=False, is_reset=True)

    def invalidate(self) -> None:
        
        self._close_impl(invalidate=True)

    def _close_impl(self, invalidate: bool, is_reset: bool = False) -> None:
        if not is_reset and self._close_state is _SessionCloseState.ACTIVE:
            self._close_state = _SessionCloseState.CLOSED
        self.expunge_all()
        if self._transaction is not None:
            for transaction in self._transaction._iterate_self_and_parents():
                transaction.close(invalidate)

    def expunge_all(self) -> None:
        

        all_states = self.identity_map.all_states() + list(self._new)
        self.identity_map._kill()
        self.identity_map = identity.WeakInstanceDict()
        self._new = {}
        self._deleted = {}

        statelib.InstanceState._detach_states(all_states, self)

    def _add_bind(self, key: _SessionBindKey, bind: _SessionBind) -> None:
        try:
            insp = inspect(key)
        except sa_exc.NoInspectionAvailable as err:
            if not isinstance(key, type):
                raise sa_exc.ArgumentError(
                    "Not an acceptable bind target: %s" % key
                ) from err
            else:
                self.__binds[key] = bind
        else:
            if TYPE_CHECKING:
                assert isinstance(insp, Inspectable)

            if isinstance(insp, TableClause):
                self.__binds[insp] = bind
            elif insp_is_mapper(insp):
                self.__binds[insp.class_] = bind
                for _selectable in insp._all_tables:
                    self.__binds[_selectable] = bind
            else:
                raise sa_exc.ArgumentError(
                    "Not an acceptable bind target: %s" % key
                )

    def bind_mapper(
        self, mapper: _EntityBindKey[_O], bind: _SessionBind
    ) -> None:
        
        self._add_bind(mapper, bind)

    def bind_table(self, table: TableClause, bind: _SessionBind) -> None:
        
        self._add_bind(table, bind)

    def get_bind(
        self,
        mapper: Optional[_EntityBindKey[_O]] = None,
        *,
        clause: Optional[ClauseElement] = None,
        bind: Optional[_SessionBind] = None,
        _sa_skip_events: Optional[bool] = None,
        _sa_skip_for_implicit_returning: bool = False,
        **kw: Any,
    ) -> Union[Engine, Connection]:
        

        
        
        if bind:
            return bind
        elif not self.__binds and self.bind:
            
            
            return self.bind

        
        
        
        if mapper is None and clause is None:
            if self.bind:
                return self.bind
            else:
                raise sa_exc.UnboundExecutionError(
                    "This session is not bound to a single Engine or "
                    "Connection, and no context was provided to locate "
                    "a binding."
                )

        
        if mapper is not None:
            try:
                inspected_mapper = inspect(mapper)
            except sa_exc.NoInspectionAvailable as err:
                if isinstance(mapper, type):
                    raise exc.UnmappedClassError(mapper) from err
                else:
                    raise
        else:
            inspected_mapper = None

        
        if self.__binds:
            
            
            if inspected_mapper:
                for cls in inspected_mapper.class_.__mro__:
                    if cls in self.__binds:
                        return self.__binds[cls]
                if clause is None:
                    clause = inspected_mapper.persist_selectable

            if clause is not None:
                plugin_subject = clause._propagate_attrs.get(
                    "plugin_subject", None
                )

                if plugin_subject is not None:
                    for cls in plugin_subject.mapper.class_.__mro__:
                        if cls in self.__binds:
                            return self.__binds[cls]

                for obj in visitors.iterate(clause):
                    if obj in self.__binds:
                        if TYPE_CHECKING:
                            assert isinstance(obj, Table)
                        return self.__binds[obj]

        
        
        if self.bind:
            return self.bind

        context = []
        if inspected_mapper is not None:
            context.append(f"mapper {inspected_mapper}")
        if clause is not None:
            context.append("SQL expression")

        raise sa_exc.UnboundExecutionError(
            f"Could not locate a bind configured on "
            f'{", ".join(context)} or this Session.'
        )

    @overload
    def query(self, _entity: _EntityType[_O]) -> Query[_O]: ...

    @overload
    def query(
        self, _colexpr: TypedColumnsClauseRole[_T]
    ) -> RowReturningQuery[Tuple[_T]]: ...

    

    
    

    @overload
    def query(
        self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1]
    ) -> RowReturningQuery[Tuple[_T0, _T1]]: ...

    @overload
    def query(
        self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2]
    ) -> RowReturningQuery[Tuple[_T0, _T1, _T2]]: ...

    @overload
    def query(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
    ) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3]]: ...

    @overload
    def query(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        __ent4: _TCCA[_T4],
    ) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4]]: ...

    @overload
    def query(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        __ent4: _TCCA[_T4],
        __ent5: _TCCA[_T5],
    ) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4, _T5]]: ...

    @overload
    def query(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        __ent4: _TCCA[_T4],
        __ent5: _TCCA[_T5],
        __ent6: _TCCA[_T6],
    ) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6]]: ...

    @overload
    def query(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        __ent4: _TCCA[_T4],
        __ent5: _TCCA[_T5],
        __ent6: _TCCA[_T6],
        __ent7: _TCCA[_T7],
    ) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7]]: ...

    

    @overload
    def query(
        self, *entities: _ColumnsClauseArgument[Any], **kwargs: Any
    ) -> Query[Any]: ...

    def query(
        self, *entities: _ColumnsClauseArgument[Any], **kwargs: Any
    ) -> Query[Any]:
        

        return self._query_cls(entities, self, **kwargs)

    def _identity_lookup(
        self,
        mapper: Mapper[_O],
        primary_key_identity: Union[Any, Tuple[Any, ...]],
        identity_token: Any = None,
        passive: PassiveFlag = PassiveFlag.PASSIVE_OFF,
        lazy_loaded_from: Optional[InstanceState[Any]] = None,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
    ) -> Union[Optional[_O], LoaderCallableStatus]:
        

        key = mapper.identity_key_from_primary_key(
            primary_key_identity, identity_token=identity_token
        )

        
        return_value = loading.get_from_identity(self, mapper, key, passive)
        return return_value

    @util.non_memoized_property
    @contextlib.contextmanager
    def no_autoflush(self) -> Iterator[Session]:
        
        autoflush = self.autoflush
        self.autoflush = False
        try:
            yield self
        finally:
            self.autoflush = autoflush

    @util.langhelpers.tag_method_for_warnings(
        "This warning originated from the Session 'autoflush' process, "
        "which was invoked automatically in response to a user-initiated "
        "operation. Consider using ``no_autoflush`` context manager if this "
        "warning happened while initializing objects.",
        sa_exc.SAWarning,
    )
    def _autoflush(self) -> None:
        if self.autoflush and not self._flushing:
            try:
                self.flush()
            except sa_exc.StatementError as e:
                
                
                
                
                e.add_detail(
                    "raised as a result of Query-invoked autoflush; "
                    "consider using a session.no_autoflush block if this "
                    "flush is occurring prematurely"
                )
                raise e.with_traceback(sys.exc_info()[2])

    def refresh(
        self,
        instance: object,
        attribute_names: Optional[Iterable[str]] = None,
        with_for_update: ForUpdateParameter = None,
    ) -> None:
        
        try:
            state = attributes.instance_state(instance)
        except exc.NO_STATE as err:
            raise exc.UnmappedInstanceError(instance) from err

        self._expire_state(state, attribute_names)

        
        
        
        
        
        
        self._autoflush()

        if with_for_update == {}:
            raise sa_exc.ArgumentError(
                "with_for_update should be the boolean value "
                "True, or a dictionary with options.  "
                "A blank dictionary is ambiguous."
            )

        with_for_update = ForUpdateArg._from_argument(with_for_update)

        stmt: Select[Any] = sql.select(object_mapper(instance))
        if (
            loading.load_on_ident(
                self,
                stmt,
                state.key,
                refresh_state=state,
                with_for_update=with_for_update,
                only_load_props=attribute_names,
                require_pk_cols=True,
                
                
                
                no_autoflush=True,
                is_user_refresh=True,
            )
            is None
        ):
            raise sa_exc.InvalidRequestError(
                "Could not refresh instance '%s'" % instance_str(instance)
            )

    def expire_all(self) -> None:
        
        for state in self.identity_map.all_states():
            state._expire(state.dict, self.identity_map._modified)

    def expire(
        self, instance: object, attribute_names: Optional[Iterable[str]] = None
    ) -> None:
        
        try:
            state = attributes.instance_state(instance)
        except exc.NO_STATE as err:
            raise exc.UnmappedInstanceError(instance) from err
        self._expire_state(state, attribute_names)

    def _expire_state(
        self,
        state: InstanceState[Any],
        attribute_names: Optional[Iterable[str]],
    ) -> None:
        self._validate_persistent(state)
        if attribute_names:
            state._expire_attributes(state.dict, attribute_names)
        else:
            
            
            cascaded = list(
                state.manager.mapper.cascade_iterator("refresh-expire", state)
            )
            self._conditional_expire(state)
            for o, m, st_, dct_ in cascaded:
                self._conditional_expire(st_)

    def _conditional_expire(
        self, state: InstanceState[Any], autoflush: Optional[bool] = None
    ) -> None:
        

        if state.key:
            state._expire(state.dict, self.identity_map._modified)
        elif state in self._new:
            self._new.pop(state)
            state._detach(self)

    def expunge(self, instance: object) -> None:
        
        try:
            state = attributes.instance_state(instance)
        except exc.NO_STATE as err:
            raise exc.UnmappedInstanceError(instance) from err
        if state.session_id is not self.hash_key:
            raise sa_exc.InvalidRequestError(
                "Instance %s is not present in this Session" % state_str(state)
            )

        cascaded = list(
            state.manager.mapper.cascade_iterator("expunge", state)
        )
        self._expunge_states([state] + [st_ for o, m, st_, dct_ in cascaded])

    def _expunge_states(
        self, states: Iterable[InstanceState[Any]], to_transient: bool = False
    ) -> None:
        for state in states:
            if state in self._new:
                self._new.pop(state)
            elif self.identity_map.contains_state(state):
                self.identity_map.safe_discard(state)
                self._deleted.pop(state, None)
            elif self._transaction:
                
                
                self._transaction._deleted.pop(state, None)
        statelib.InstanceState._detach_states(
            states, self, to_transient=to_transient
        )

    def _register_persistent(self, states: Set[InstanceState[Any]]) -> None:
        

        pending_to_persistent = self.dispatch.pending_to_persistent or None
        for state in states:
            mapper = _state_mapper(state)

            
            obj = state.obj()
            if obj is not None:
                instance_key = mapper._identity_key_from_state(state)

                if (
                    _none_set.intersection(instance_key[1])
                    and not mapper.allow_partial_pks
                    or _none_set.issuperset(instance_key[1])
                ):
                    raise exc.FlushError(
                        "Instance %s has a NULL identity key.  If this is an "
                        "auto-generated value, check that the database table "
                        "allows generation of new primary key values, and "
                        "that the mapped Column object is configured to "
                        "expect these generated values.  Ensure also that "
                        "this flush() is not occurring at an inappropriate "
                        "time, such as within a load() event."
                        % state_str(state)
                    )

                if state.key is None:
                    state.key = instance_key
                elif state.key != instance_key:
                    
                    
                    
                    self.identity_map.safe_discard(state)
                    trans = self._transaction
                    assert trans is not None
                    if state in trans._key_switches:
                        orig_key = trans._key_switches[state][0]
                    else:
                        orig_key = state.key
                    trans._key_switches[state] = (
                        orig_key,
                        instance_key,
                    )
                    state.key = instance_key

                
                
                
                old = self.identity_map.replace(state)
                if (
                    old is not None
                    and mapper._identity_key_from_state(old) == instance_key
                    and old.obj() is not None
                ):
                    util.warn(
                        "Identity map already had an identity for %s, "
                        "replacing it with newly flushed object.   Are there "
                        "load operations occurring inside of an event handler "
                        "within the flush?" % (instance_key,)
                    )
                state._orphaned_outside_of_session = False

        statelib.InstanceState._commit_all_states(
            ((state, state.dict) for state in states), self.identity_map
        )

        self._register_altered(states)

        if pending_to_persistent is not None:
            for state in states.intersection(self._new):
                pending_to_persistent(self, state)

        
        for state in set(states).intersection(self._new):
            self._new.pop(state)

    def _register_altered(self, states: Iterable[InstanceState[Any]]) -> None:
        if self._transaction:
            for state in states:
                if state in self._new:
                    self._transaction._new[state] = True
                else:
                    self._transaction._dirty[state] = True

    def _remove_newly_deleted(
        self, states: Iterable[InstanceState[Any]]
    ) -> None:
        persistent_to_deleted = self.dispatch.persistent_to_deleted or None
        for state in states:
            if self._transaction:
                self._transaction._deleted[state] = True

            if persistent_to_deleted is not None:
                
                
                obj = state.obj()  

            self.identity_map.safe_discard(state)
            self._deleted.pop(state, None)
            state._deleted = True
            
            
            
            if persistent_to_deleted is not None:
                persistent_to_deleted(self, state)

    def add(self, instance: object, _warn: bool = True) -> None:
        
        if _warn and self._warn_on_events:
            self._flush_warning("Session.add()")

        try:
            state = attributes.instance_state(instance)
        except exc.NO_STATE as err:
            raise exc.UnmappedInstanceError(instance) from err

        self._save_or_update_state(state)

    def add_all(self, instances: Iterable[object]) -> None:
        

        if self._warn_on_events:
            self._flush_warning("Session.add_all()")

        for instance in instances:
            self.add(instance, _warn=False)

    def _save_or_update_state(self, state: InstanceState[Any]) -> None:
        state._orphaned_outside_of_session = False
        self._save_or_update_impl(state)

        mapper = _state_mapper(state)
        for o, m, st_, dct_ in mapper.cascade_iterator(
            "save-update", state, halt_on=self._contains_state
        ):
            self._save_or_update_impl(st_)

    def delete(self, instance: object) -> None:
        
        if self._warn_on_events:
            self._flush_warning("Session.delete()")

        try:
            state = attributes.instance_state(instance)
        except exc.NO_STATE as err:
            raise exc.UnmappedInstanceError(instance) from err

        self._delete_impl(state, instance, head=True)

    def _delete_impl(
        self, state: InstanceState[Any], obj: object, head: bool
    ) -> None:
        if state.key is None:
            if head:
                raise sa_exc.InvalidRequestError(
                    "Instance '%s' is not persisted" % state_str(state)
                )
            else:
                return

        to_attach = self._before_attach(state, obj)

        if state in self._deleted:
            return

        self.identity_map.add(state)

        if to_attach:
            self._after_attach(state, obj)

        if head:
            
            
            
            cascade_states = list(
                state.manager.mapper.cascade_iterator("delete", state)
            )
        else:
            cascade_states = None

        self._deleted[state] = obj

        if head:
            if TYPE_CHECKING:
                assert cascade_states is not None
            for o, m, st_, dct_ in cascade_states:
                self._delete_impl(st_, o, False)

    def get(
        self,
        entity: _EntityBindKey[_O],
        ident: _PKIdentityArgument,
        *,
        options: Optional[Sequence[ORMOption]] = None,
        populate_existing: bool = False,
        with_for_update: ForUpdateParameter = None,
        identity_token: Optional[Any] = None,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
    ) -> Optional[_O]:
          
        return self._get_impl(
            entity,
            ident,
            loading.load_on_pk_identity,
            options=options,
            populate_existing=populate_existing,
            with_for_update=with_for_update,
            identity_token=identity_token,
            execution_options=execution_options,
            bind_arguments=bind_arguments,
        )

    def get_one(
        self,
        entity: _EntityBindKey[_O],
        ident: _PKIdentityArgument,
        *,
        options: Optional[Sequence[ORMOption]] = None,
        populate_existing: bool = False,
        with_for_update: ForUpdateParameter = None,
        identity_token: Optional[Any] = None,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
    ) -> _O:
        

        instance = self.get(
            entity,
            ident,
            options=options,
            populate_existing=populate_existing,
            with_for_update=with_for_update,
            identity_token=identity_token,
            execution_options=execution_options,
            bind_arguments=bind_arguments,
        )

        if instance is None:
            raise sa_exc.NoResultFound(
                "No row was found when one was required"
            )

        return instance

    def _get_impl(
        self,
        entity: _EntityBindKey[_O],
        primary_key_identity: _PKIdentityArgument,
        db_load_fn: Callable[..., _O],
        *,
        options: Optional[Sequence[ExecutableOption]] = None,
        populate_existing: bool = False,
        with_for_update: ForUpdateParameter = None,
        identity_token: Optional[Any] = None,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
    ) -> Optional[_O]:
        
        if (
            is_composite_class(primary_key_identity)
            and type(primary_key_identity)
            in descriptor_props._composite_getters
        ):
            getter = descriptor_props._composite_getters[
                type(primary_key_identity)
            ]
            primary_key_identity = getter(primary_key_identity)

        mapper: Optional[Mapper[_O]] = inspect(entity)

        if mapper is None or not mapper.is_mapper:
            raise sa_exc.ArgumentError(
                "Expected mapped class or mapper, got: %r" % entity
            )

        is_dict = isinstance(primary_key_identity, dict)
        if not is_dict:
            primary_key_identity = util.to_list(
                primary_key_identity, default=[None]
            )

        if len(primary_key_identity) != len(mapper.primary_key):
            raise sa_exc.InvalidRequestError(
                "Incorrect number of values in identifier to formulate "
                "primary key for session.get(); primary key columns "
                "are %s" % ",".join("'%s'" % c for c in mapper.primary_key)
            )

        if is_dict:
            pk_synonyms = mapper._pk_synonyms

            if pk_synonyms:
                correct_keys = set(pk_synonyms).intersection(
                    primary_key_identity
                )

                if correct_keys:
                    primary_key_identity = dict(primary_key_identity)
                    for k in correct_keys:
                        primary_key_identity[pk_synonyms[k]] = (
                            primary_key_identity[k]
                        )

            try:
                primary_key_identity = list(
                    primary_key_identity[prop.key]
                    for prop in mapper._identity_key_props
                )

            except KeyError as err:
                raise sa_exc.InvalidRequestError(
                    "Incorrect names of values in identifier to formulate "
                    "primary key for session.get(); primary key attribute "
                    "names are %s (synonym names are also accepted)"
                    % ",".join(
                        "'%s'" % prop.key
                        for prop in mapper._identity_key_props
                    )
                ) from err

        if (
            not populate_existing
            and not mapper.always_refresh
            and with_for_update is None
        ):
            instance = self._identity_lookup(
                mapper,
                primary_key_identity,
                identity_token=identity_token,
                execution_options=execution_options,
                bind_arguments=bind_arguments,
            )

            if instance is not None:
                
                
                if not isinstance(instance, mapper.class_):
                    return None
                return instance

            
            assert instance is not LoaderCallableStatus.PASSIVE_CLASS_MISMATCH

        
        
        

        load_options = context.QueryContext.default_load_options

        if populate_existing:
            load_options += {"_populate_existing": populate_existing}
        statement = sql.select(mapper).set_label_style(
            LABEL_STYLE_TABLENAME_PLUS_COL
        )
        if with_for_update is not None:
            statement._for_update_arg = ForUpdateArg._from_argument(
                with_for_update
            )

        if options:
            statement = statement.options(*options)
        return db_load_fn(
            self,
            statement,
            primary_key_identity,
            load_options=load_options,
            identity_token=identity_token,
            execution_options=execution_options,
            bind_arguments=bind_arguments,
        )

    def merge(
        self,
        instance: _O,
        *,
        load: bool = True,
        options: Optional[Sequence[ORMOption]] = None,
    ) -> _O:
        

        if self._warn_on_events:
            self._flush_warning("Session.merge()")

        _recursive: Dict[InstanceState[Any], object] = {}
        _resolve_conflict_map: Dict[_IdentityKeyType[Any], object] = {}

        if load:
            
            self._autoflush()

        object_mapper(instance)  
        autoflush = self.autoflush
        try:
            self.autoflush = False
            return self._merge(
                attributes.instance_state(instance),
                attributes.instance_dict(instance),
                load=load,
                options=options,
                _recursive=_recursive,
                _resolve_conflict_map=_resolve_conflict_map,
            )
        finally:
            self.autoflush = autoflush

    def _merge(
        self,
        state: InstanceState[_O],
        state_dict: _InstanceDict,
        *,
        options: Optional[Sequence[ORMOption]] = None,
        load: bool,
        _recursive: Dict[Any, object],
        _resolve_conflict_map: Dict[_IdentityKeyType[Any], object],
    ) -> _O:
        mapper: Mapper[_O] = _state_mapper(state)
        if state in _recursive:
            return cast(_O, _recursive[state])

        new_instance = False
        key = state.key

        merged: Optional[_O]

        if key is None:
            if state in self._new:
                util.warn(
                    "Instance %s is already pending in this Session yet is "
                    "being merged again; this is probably not what you want "
                    "to do" % state_str(state)
                )

            if not load:
                raise sa_exc.InvalidRequestError(
                    "merge() with load=False option does not support "
                    "objects transient (i.e. unpersisted) objects.  flush() "
                    "all changes on mapped instances before merging with "
                    "load=False."
                )
            key = mapper._identity_key_from_state(state)
            key_is_persistent = LoaderCallableStatus.NEVER_SET not in key[
                1
            ] and (
                not _none_set.intersection(key[1])
                or (
                    mapper.allow_partial_pks
                    and not _none_set.issuperset(key[1])
                )
            )
        else:
            key_is_persistent = True

        merged = self.identity_map.get(key)

        if merged is None:
            if key_is_persistent and key in _resolve_conflict_map:
                merged = cast(_O, _resolve_conflict_map[key])

            elif not load:
                if state.modified:
                    raise sa_exc.InvalidRequestError(
                        "merge() with load=False option does not support "
                        "objects marked as 'dirty'.  flush() all changes on "
                        "mapped instances before merging with load=False."
                    )
                merged = mapper.class_manager.new_instance()
                merged_state = attributes.instance_state(merged)
                merged_state.key = key
                self._update_impl(merged_state)
                new_instance = True

            elif key_is_persistent:
                merged = self.get(
                    mapper.class_,
                    key[1],
                    identity_token=key[2],
                    options=options,
                )

        if merged is None:
            merged = mapper.class_manager.new_instance()
            merged_state = attributes.instance_state(merged)
            merged_dict = attributes.instance_dict(merged)
            new_instance = True
            self._save_or_update_state(merged_state)
        else:
            merged_state = attributes.instance_state(merged)
            merged_dict = attributes.instance_dict(merged)

        _recursive[state] = merged
        _resolve_conflict_map[key] = merged

        
        
        if state is not merged_state:
            
            if mapper.version_id_col is not None:
                existing_version = mapper._get_state_attr_by_column(
                    state,
                    state_dict,
                    mapper.version_id_col,
                    passive=PassiveFlag.PASSIVE_NO_INITIALIZE,
                )

                merged_version = mapper._get_state_attr_by_column(
                    merged_state,
                    merged_dict,
                    mapper.version_id_col,
                    passive=PassiveFlag.PASSIVE_NO_INITIALIZE,
                )

                if (
                    existing_version
                    is not LoaderCallableStatus.PASSIVE_NO_RESULT
                    and merged_version
                    is not LoaderCallableStatus.PASSIVE_NO_RESULT
                    and existing_version != merged_version
                ):
                    raise exc.StaleDataError(
                        "Version id '%s' on merged state %s "
                        "does not match existing version '%s'. "
                        "Leave the version attribute unset when "
                        "merging to update the most recent version."
                        % (
                            existing_version,
                            state_str(merged_state),
                            merged_version,
                        )
                    )

            merged_state.load_path = state.load_path
            merged_state.load_options = state.load_options

            
            
            
            
            
            merged_state._copy_callables(state)

            for prop in mapper.iterate_properties:
                prop.merge(
                    self,
                    state,
                    state_dict,
                    merged_state,
                    merged_dict,
                    load,
                    _recursive,
                    _resolve_conflict_map,
                )

        if not load:
            
            merged_state._commit_all(merged_dict, self.identity_map)
            merged_state.manager.dispatch._sa_event_merge_wo_load(
                merged_state, None
            )

        if new_instance:
            merged_state.manager.dispatch.load(merged_state, None)

        return merged

    def _validate_persistent(self, state: InstanceState[Any]) -> None:
        if not self.identity_map.contains_state(state):
            raise sa_exc.InvalidRequestError(
                "Instance '%s' is not persistent within this Session"
                % state_str(state)
            )

    def _save_impl(self, state: InstanceState[Any]) -> None:
        if state.key is not None:
            raise sa_exc.InvalidRequestError(
                "Object '%s' already has an identity - "
                "it can't be registered as pending" % state_str(state)
            )

        obj = state.obj()
        to_attach = self._before_attach(state, obj)
        if state not in self._new:
            self._new[state] = obj
            state.insert_order = len(self._new)
        if to_attach:
            self._after_attach(state, obj)

    def _update_impl(
        self, state: InstanceState[Any], revert_deletion: bool = False
    ) -> None:
        if state.key is None:
            raise sa_exc.InvalidRequestError(
                "Instance '%s' is not persisted" % state_str(state)
            )

        if state._deleted:
            if revert_deletion:
                if not state._attached:
                    return
                del state._deleted
            else:
                raise sa_exc.InvalidRequestError(
                    "Instance '%s' has been deleted.  "
                    "Use the make_transient() "
                    "function to send this object back "
                    "to the transient state." % state_str(state)
                )

        obj = state.obj()

        
        if obj is None:
            return

        to_attach = self._before_attach(state, obj)

        self._deleted.pop(state, None)
        if revert_deletion:
            self.identity_map.replace(state)
        else:
            self.identity_map.add(state)

        if to_attach:
            self._after_attach(state, obj)
        elif revert_deletion:
            self.dispatch.deleted_to_persistent(self, state)

    def _save_or_update_impl(self, state: InstanceState[Any]) -> None:
        if state.key is None:
            self._save_impl(state)
        else:
            self._update_impl(state)

    def enable_relationship_loading(self, obj: object) -> None:
        
        try:
            state = attributes.instance_state(obj)
        except exc.NO_STATE as err:
            raise exc.UnmappedInstanceError(obj) from err

        to_attach = self._before_attach(state, obj)
        state._load_pending = True
        if to_attach:
            self._after_attach(state, obj)

    def _before_attach(self, state: InstanceState[Any], obj: object) -> bool:
        self._autobegin_t()

        if state.session_id == self.hash_key:
            return False

        if state.session_id and state.session_id in _sessions:
            raise sa_exc.InvalidRequestError(
                "Object '%s' is already attached to session '%s' "
                "(this is '%s')"
                % (state_str(state), state.session_id, self.hash_key)
            )

        self.dispatch.before_attach(self, state)

        return True

    def _after_attach(self, state: InstanceState[Any], obj: object) -> None:
        state.session_id = self.hash_key
        if state.modified and state._strong_obj is None:
            state._strong_obj = obj
        self.dispatch.after_attach(self, state)

        if state.key:
            self.dispatch.detached_to_persistent(self, state)
        else:
            self.dispatch.transient_to_pending(self, state)

    def __contains__(self, instance: object) -> bool:
        
        try:
            state = attributes.instance_state(instance)
        except exc.NO_STATE as err:
            raise exc.UnmappedInstanceError(instance) from err
        return self._contains_state(state)

    def __iter__(self) -> Iterator[object]:
        
        return iter(
            list(self._new.values()) + list(self.identity_map.values())
        )

    def _contains_state(self, state: InstanceState[Any]) -> bool:
        return state in self._new or self.identity_map.contains_state(state)

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        

        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")

        if self._is_clean():
            return
        try:
            self._flushing = True
            self._flush(objects)
        finally:
            self._flushing = False

    def _flush_warning(self, method: Any) -> None:
        util.warn(
            "Usage of the '%s' operation is not currently supported "
            "within the execution stage of the flush process. "
            "Results may not be consistent.  Consider using alternative "
            "event listeners or connection-level operations instead." % method
        )

    def _is_clean(self) -> bool:
        return (
            not self.identity_map.check_modified()
            and not self._deleted
            and not self._new
        )

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return

        flush_context = UOWTransaction(self)

        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            
            
            dirty = self._dirty_states

        deleted = set(self._deleted)
        new = set(self._new)

        dirty = set(dirty).difference(deleted)

        
        if objects:
            
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)

                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None

        
        processed = set()

        
        
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)

        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)

            is_persistent_orphan = is_orphan and state.has_identity

            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)

        
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"

        if not flush_context.has_work:
            return

        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False

            self.dispatch.after_flush(self, flush_context)

            flush_context.finalize_flush_changes()

            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)

                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )

            
            
            
            
            
            

            self.dispatch.after_flush_postexec(self, flush_context)

            transaction.commit()

        except:
            with util.safe_reraise():
                transaction.rollback(_capture_exception=True)

    def bulk_save_objects(
        self,
        objects: Iterable[object],
        return_defaults: bool = False,
        update_changed_only: bool = True,
        preserve_order: bool = True,
    ) -> None:
        

        obj_states: Iterable[InstanceState[Any]]

        obj_states = (attributes.instance_state(obj) for obj in objects)

        if not preserve_order:
            
            
            
            
            obj_states = sorted(
                obj_states,
                key=lambda state: (id(state.mapper), state.key is not None),
            )

        def grouping_key(
            state: InstanceState[_O],
        ) -> Tuple[Mapper[_O], bool]:
            return (state.mapper, state.key is not None)

        for (mapper, isupdate), states in itertools.groupby(
            obj_states, grouping_key
        ):
            self._bulk_save_mappings(
                mapper,
                states,
                isupdate=isupdate,
                isstates=True,
                return_defaults=return_defaults,
                update_changed_only=update_changed_only,
                render_nulls=False,
            )

    def bulk_insert_mappings(
        self,
        mapper: Mapper[Any],
        mappings: Iterable[Dict[str, Any]],
        return_defaults: bool = False,
        render_nulls: bool = False,
    ) -> None:
        
        self._bulk_save_mappings(
            mapper,
            mappings,
            isupdate=False,
            isstates=False,
            return_defaults=return_defaults,
            update_changed_only=False,
            render_nulls=render_nulls,
        )

    def bulk_update_mappings(
        self, mapper: Mapper[Any], mappings: Iterable[Dict[str, Any]]
    ) -> None:
        
        self._bulk_save_mappings(
            mapper,
            mappings,
            isupdate=True,
            isstates=False,
            return_defaults=False,
            update_changed_only=False,
            render_nulls=False,
        )

    def _bulk_save_mappings(
        self,
        mapper: Mapper[_O],
        mappings: Union[Iterable[InstanceState[_O]], Iterable[Dict[str, Any]]],
        *,
        isupdate: bool,
        isstates: bool,
        return_defaults: bool,
        update_changed_only: bool,
        render_nulls: bool,
    ) -> None:
        mapper = _class_to_mapper(mapper)
        self._flushing = True

        transaction = self._autobegin_t()._begin()
        try:
            if isupdate:
                bulk_persistence._bulk_update(
                    mapper,
                    mappings,
                    transaction,
                    isstates=isstates,
                    update_changed_only=update_changed_only,
                )
            else:
                bulk_persistence._bulk_insert(
                    mapper,
                    mappings,
                    transaction,
                    isstates=isstates,
                    return_defaults=return_defaults,
                    render_nulls=render_nulls,
                )
            transaction.commit()

        except:
            with util.safe_reraise():
                transaction.rollback(_capture_exception=True)
        finally:
            self._flushing = False

    def is_modified(
        self, instance: object, include_collections: bool = True
    ) -> bool:
        r
        state = object_state(instance)

        if not state.modified:
            return False

        dict_ = state.dict

        for attr in state.manager.attributes:
            if (
                not include_collections
                and hasattr(attr.impl, "get_collection")
            ) or not hasattr(attr.impl, "get_history"):
                continue

            (added, unchanged, deleted) = attr.impl.get_history(
                state, dict_, passive=PassiveFlag.NO_CHANGE
            )

            if added or deleted:
                return True
        else:
            return False

    @property
    def is_active(self) -> bool:
        
        return self._transaction is None or self._transaction.is_active

    @property
    def _dirty_states(self) -> Iterable[InstanceState[Any]]:
        
        return self.identity_map._dirty_states()

    @property
    def dirty(self) -> IdentitySet:
        
        return IdentitySet(
            [
                state.obj()
                for state in self._dirty_states
                if state not in self._deleted
            ]
        )

    @property
    def deleted(self) -> IdentitySet:
        "The set of all instances marked as 'deleted' within this ``Session``"

        return util.IdentitySet(list(self._deleted.values()))

    @property
    def new(self) -> IdentitySet:
        "The set of all instances marked as 'new' within this ``Session``."

        return util.IdentitySet(list(self._new.values()))


_S = TypeVar("_S", bound="Session")


class sessionmaker(_SessionClassMethods, Generic[_S]):
    

    class_: Type[_S]

    @overload
    def __init__(
        self,
        bind: Optional[_SessionBind] = ...,
        *,
        class_: Type[_S],
        autoflush: bool = ...,
        expire_on_commit: bool = ...,
        info: Optional[_InfoType] = ...,
        **kw: Any,
    ): ...

    @overload
    def __init__(
        self: "sessionmaker[Session]",
        bind: Optional[_SessionBind] = ...,
        *,
        autoflush: bool = ...,
        expire_on_commit: bool = ...,
        info: Optional[_InfoType] = ...,
        **kw: Any,
    ): ...

    def __init__(
        self,
        bind: Optional[_SessionBind] = None,
        *,
        class_: Type[_S] = Session,  
        autoflush: bool = True,
        expire_on_commit: bool = True,
        info: Optional[_InfoType] = None,
        **kw: Any,
    ):
        r
        kw["bind"] = bind
        kw["autoflush"] = autoflush
        kw["expire_on_commit"] = expire_on_commit
        if info is not None:
            kw["info"] = info
        self.kw = kw
        
        
        self.class_ = type(class_.__name__, (class_,), {})

    def begin(self) -> contextlib.AbstractContextManager[_S]:
        

        session = self()
        return session._maker_context_manager()

    def __call__(self, **local_kw: Any) -> _S:
        
        for k, v in self.kw.items():
            if k == "info" and "info" in local_kw:
                d = v.copy()
                d.update(local_kw["info"])
                local_kw["info"] = d
            else:
                local_kw.setdefault(k, v)
        return self.class_(**local_kw)

    def configure(self, **new_kw: Any) -> None:
        
        self.kw.update(new_kw)

    def __repr__(self) -> str:
        return "%s(class_=%r, %s)" % (
            self.__class__.__name__,
            self.class_.__name__,
            ", ".join("%s=%r" % (k, v) for k, v in self.kw.items()),
        )


def close_all_sessions() -> None:
    

    for sess in _sessions.values():
        sess.close()


def make_transient(instance: object) -> None:
    
    state = attributes.instance_state(instance)
    s = _state_session(state)
    if s:
        s._expunge_states([state])

    
    state.expired_attributes.clear()

    
    if state.callables:
        del state.callables

    if state.key:
        del state.key
    if state._deleted:
        del state._deleted


def make_transient_to_detached(instance: object) -> None:
    
    state = attributes.instance_state(instance)
    if state.session_id or state.key:
        raise sa_exc.InvalidRequestError("Given object must be transient")
    state.key = state.mapper._identity_key_from_state(state)
    if state._deleted:
        del state._deleted
    state._commit_all(state.dict)
    state._expire_attributes(state.dict, state.unloaded)


def object_session(instance: object) -> Optional[Session]:
    

    try:
        state = attributes.instance_state(instance)
    except exc.NO_STATE as err:
        raise exc.UnmappedInstanceError(instance) from err
    else:
        return _state_session(state)


_new_sessionid = util.counter()
