








from __future__ import annotations

from collections import deque
from functools import reduce
from itertools import chain
import sys
import threading
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Deque
from typing import Dict
from typing import FrozenSet
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref

from . import attributes
from . import exc as orm_exc
from . import instrumentation
from . import loading
from . import properties
from . import util as orm_util
from ._typing import _O
from .base import _class_to_mapper
from .base import _parse_mapper_argument
from .base import _state_mapper
from .base import PassiveFlag
from .base import state_str
from .interfaces import _MappedAttribute
from .interfaces import EXT_SKIP
from .interfaces import InspectionAttr
from .interfaces import MapperProperty
from .interfaces import ORMEntityColumnsClauseRole
from .interfaces import ORMFromClauseRole
from .interfaces import StrategizedProperty
from .path_registry import PathRegistry
from .. import event
from .. import exc as sa_exc
from .. import inspection
from .. import log
from .. import schema
from .. import sql
from .. import util
from ..event import dispatcher
from ..event import EventTarget
from ..sql import base as sql_base
from ..sql import coercions
from ..sql import expression
from ..sql import operators
from ..sql import roles
from ..sql import TableClause
from ..sql import util as sql_util
from ..sql import visitors
from ..sql.cache_key import MemoizedHasCacheKey
from ..sql.elements import KeyedColumnElement
from ..sql.schema import Column
from ..sql.schema import Table
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL
from ..util import HasMemoized
from ..util import HasMemoized_ro_memoized_attribute
from ..util.typing import Literal

if TYPE_CHECKING:
    from ._typing import _IdentityKeyType
    from ._typing import _InstanceDict
    from ._typing import _ORMColumnExprArgument
    from ._typing import _RegistryType
    from .decl_api import registry
    from .dependency import DependencyProcessor
    from .descriptor_props import CompositeProperty
    from .descriptor_props import SynonymProperty
    from .events import MapperEvents
    from .instrumentation import ClassManager
    from .path_registry import CachingEntityRegistry
    from .properties import ColumnProperty
    from .relationships import RelationshipProperty
    from .state import InstanceState
    from .util import ORMAdapter
    from ..engine import Row
    from ..engine import RowMapping
    from ..sql._typing import _ColumnExpressionArgument
    from ..sql._typing import _EquivalentColumnMap
    from ..sql.base import ReadOnlyColumnCollection
    from ..sql.elements import ColumnClause
    from ..sql.elements import ColumnElement
    from ..sql.selectable import FromClause
    from ..util import OrderedSet


_T = TypeVar("_T", bound=Any)
_MP = TypeVar("_MP", bound="MapperProperty[Any]")
_Fn = TypeVar("_Fn", bound="Callable[..., Any]")


_WithPolymorphicArg = Union[
    Literal["*"],
    Tuple[
        Union[Literal["*"], Sequence[Union["Mapper[Any]", Type[Any]]]],
        Optional["FromClause"],
    ],
    Sequence[Union["Mapper[Any]", Type[Any]]],
]


_mapper_registries: weakref.WeakKeyDictionary[_RegistryType, bool] = (
    weakref.WeakKeyDictionary()
)


def _all_registries() -> Set[registry]:
    with _CONFIGURE_MUTEX:
        return set(_mapper_registries)


def _unconfigured_mappers() -> Iterator[Mapper[Any]]:
    for reg in _all_registries():
        yield from reg._mappers_to_configure()


_already_compiling = False





NO_ATTRIBUTE = util.symbol("NO_ATTRIBUTE")


_CONFIGURE_MUTEX = threading.RLock()


@inspection._self_inspects
@log.class_logger
class Mapper(
    ORMFromClauseRole,
    ORMEntityColumnsClauseRole[_O],
    MemoizedHasCacheKey,
    InspectionAttr,
    log.Identified,
    inspection.Inspectable["Mapper[_O]"],
    EventTarget,
    Generic[_O],
):
    

    dispatch: dispatcher[Mapper[_O]]

    _dispose_called = False
    _configure_failed: Any = False
    _ready_for_configure = False

    @util.deprecated_params(
        non_primary=(
            "1.3",
            "The :paramref:`.mapper.non_primary` parameter is deprecated, "
            "and will be removed in a future release.  The functionality "
            "of non primary mappers is now better suited using the "
            ":class:`.AliasedClass` construct, which can also be used "
            "as the target of a :func:`_orm.relationship` in 1.3.",
        ),
    )
    def __init__(
        self,
        class_: Type[_O],
        local_table: Optional[FromClause] = None,
        properties: Optional[Mapping[str, MapperProperty[Any]]] = None,
        primary_key: Optional[Iterable[_ORMColumnExprArgument[Any]]] = None,
        non_primary: bool = False,
        inherits: Optional[Union[Mapper[Any], Type[Any]]] = None,
        inherit_condition: Optional[_ColumnExpressionArgument[bool]] = None,
        inherit_foreign_keys: Optional[
            Sequence[_ORMColumnExprArgument[Any]]
        ] = None,
        always_refresh: bool = False,
        version_id_col: Optional[_ORMColumnExprArgument[Any]] = None,
        version_id_generator: Optional[
            Union[Literal[False], Callable[[Any], Any]]
        ] = None,
        polymorphic_on: Optional[
            Union[_ORMColumnExprArgument[Any], str, MapperProperty[Any]]
        ] = None,
        _polymorphic_map: Optional[Dict[Any, Mapper[Any]]] = None,
        polymorphic_identity: Optional[Any] = None,
        concrete: bool = False,
        with_polymorphic: Optional[_WithPolymorphicArg] = None,
        polymorphic_abstract: bool = False,
        polymorphic_load: Optional[Literal["selectin", "inline"]] = None,
        allow_partial_pks: bool = True,
        batch: bool = True,
        column_prefix: Optional[str] = None,
        include_properties: Optional[Sequence[str]] = None,
        exclude_properties: Optional[Sequence[str]] = None,
        passive_updates: bool = True,
        passive_deletes: bool = False,
        confirm_deleted_rows: bool = True,
        eager_defaults: Literal[True, False, "auto"] = "auto",
        legacy_is_orphan: bool = False,
        _compiled_cache_size: int = 100,
    ):
        r
        self.class_ = util.assert_arg_type(class_, type, "class_")
        self._sort_key = "%s.%s" % (
            self.class_.__module__,
            self.class_.__name__,
        )

        self._primary_key_argument = util.to_list(primary_key)
        self.non_primary = non_primary

        self.always_refresh = always_refresh

        if isinstance(version_id_col, MapperProperty):
            self.version_id_prop = version_id_col
            self.version_id_col = None
        else:
            self.version_id_col = (
                coercions.expect(
                    roles.ColumnArgumentOrKeyRole,
                    version_id_col,
                    argname="version_id_col",
                )
                if version_id_col is not None
                else None
            )

        if version_id_generator is False:
            self.version_id_generator = False
        elif version_id_generator is None:
            self.version_id_generator = lambda x: (x or 0) + 1
        else:
            self.version_id_generator = version_id_generator

        self.concrete = concrete
        self.single = False

        if inherits is not None:
            self.inherits = _parse_mapper_argument(inherits)
        else:
            self.inherits = None

        if local_table is not None:
            self.local_table = coercions.expect(
                roles.StrictFromClauseRole,
                local_table,
                disable_inspection=True,
                argname="local_table",
            )
        elif self.inherits:
            
            
            self.local_table = self.inherits.local_table
            self.single = True
        else:
            raise sa_exc.ArgumentError(
                f"Mapper[{self.class_.__name__}(None)] has None for a "
                "primary table argument and does not specify 'inherits'"
            )

        if inherit_condition is not None:
            self.inherit_condition = coercions.expect(
                roles.OnClauseRole, inherit_condition
            )
        else:
            self.inherit_condition = None

        self.inherit_foreign_keys = inherit_foreign_keys
        self._init_properties = dict(properties) if properties else {}
        self._delete_orphans = []
        self.batch = batch
        self.eager_defaults = eager_defaults
        self.column_prefix = column_prefix

        
        
        self.polymorphic_on = (
            coercions.expect(  
                roles.ColumnArgumentOrKeyRole,
                polymorphic_on,
                argname="polymorphic_on",
            )
            if polymorphic_on is not None
            else None
        )
        self.polymorphic_abstract = polymorphic_abstract
        self._dependency_processors = []
        self.validators = util.EMPTY_DICT
        self.passive_updates = passive_updates
        self.passive_deletes = passive_deletes
        self.legacy_is_orphan = legacy_is_orphan
        self._clause_adapter = None
        self._requires_row_aliasing = False
        self._inherits_equated_pairs = None
        self._memoized_values = {}
        self._compiled_cache_size = _compiled_cache_size
        self._reconstructor = None
        self.allow_partial_pks = allow_partial_pks

        if self.inherits and not self.concrete:
            self.confirm_deleted_rows = False
        else:
            self.confirm_deleted_rows = confirm_deleted_rows

        self._set_with_polymorphic(with_polymorphic)
        self.polymorphic_load = polymorphic_load

        
        
        
        self.polymorphic_identity = polymorphic_identity

        
        
        
        if _polymorphic_map is None:
            self.polymorphic_map = {}
        else:
            self.polymorphic_map = _polymorphic_map

        if include_properties is not None:
            self.include_properties = util.to_set(include_properties)
        else:
            self.include_properties = None
        if exclude_properties:
            self.exclude_properties = util.to_set(exclude_properties)
        else:
            self.exclude_properties = None

        
        
        
        with _CONFIGURE_MUTEX:
            cast("MapperEvents", self.dispatch._events)._new_mapper_instance(
                class_, self
            )
            self._configure_inheritance()
            self._configure_class_instrumentation()
            self._configure_properties()
            self._configure_polymorphic_setter()
            self._configure_pks()
            self.registry._flag_new_mapper(self)
            self._log("constructed")
            self._expire_memoizations()

        self.dispatch.after_mapper_constructed(self, self.class_)

    def _prefer_eager_defaults(self, dialect, table):
        if self.eager_defaults == "auto":
            if not table.implicit_returning:
                return False

            return (
                table in self._server_default_col_keys
                and dialect.insert_executemany_returning
            )
        else:
            return self.eager_defaults

    def _gen_cache_key(self, anon_map, bindparams):
        return (self,)

    
    

    is_mapper = True
    

    represents_outer_join = False

    registry: _RegistryType

    @property
    def mapper(self) -> Mapper[_O]:
        
        return self

    @property
    def entity(self):
        r
        return self.class_

    class_: Type[_O]
    

    _identity_class: Type[_O]

    _delete_orphans: List[Tuple[str, Type[Any]]]
    _dependency_processors: List[DependencyProcessor]
    _memoized_values: Dict[Any, Callable[[], Any]]
    _inheriting_mappers: util.WeakSequence[Mapper[Any]]
    _all_tables: Set[TableClause]
    _polymorphic_attr_key: Optional[str]

    _pks_by_table: Dict[FromClause, OrderedSet[ColumnClause[Any]]]
    _cols_by_table: Dict[FromClause, OrderedSet[ColumnElement[Any]]]

    _props: util.OrderedDict[str, MapperProperty[Any]]
    _init_properties: Dict[str, MapperProperty[Any]]

    _columntoproperty: _ColumnMapping

    _set_polymorphic_identity: Optional[Callable[[InstanceState[_O]], None]]
    _validate_polymorphic_identity: Optional[
        Callable[[Mapper[_O], InstanceState[_O], _InstanceDict], None]
    ]

    tables: Sequence[TableClause]
    

    validators: util.immutabledict[str, Tuple[str, Dict[str, Any]]]
    

    always_refresh: bool
    allow_partial_pks: bool
    version_id_col: Optional[ColumnElement[Any]]

    with_polymorphic: Optional[
        Tuple[
            Union[Literal["*"], Sequence[Union[Mapper[Any], Type[Any]]]],
            Optional[FromClause],
        ]
    ]

    version_id_generator: Optional[Union[Literal[False], Callable[[Any], Any]]]

    local_table: FromClause
    

    persist_selectable: FromClause
    

    inherits: Optional[Mapper[Any]]
    

    inherit_condition: Optional[ColumnElement[bool]]

    configured: bool = False
    

    concrete: bool
    

    primary_key: Tuple[ColumnElement[Any], ...]
    

    class_manager: ClassManager[_O]
    

    single: bool
    

    non_primary: bool
    

    polymorphic_on: Optional[KeyedColumnElement[Any]]
    

    polymorphic_map: Dict[Any, Mapper[Any]]
    

    polymorphic_identity: Optional[Any]
    

    base_mapper: Mapper[Any]
    

    columns: ReadOnlyColumnCollection[str, Column[Any]]
    

    c: ReadOnlyColumnCollection[str, Column[Any]]
    

    @util.non_memoized_property
    @util.deprecated("1.3", "Use .persist_selectable")
    def mapped_table(self):
        return self.persist_selectable

    @util.memoized_property
    def _path_registry(self) -> CachingEntityRegistry:
        return PathRegistry.per_mapper(self)

    def _configure_inheritance(self):
        

        
        self._inheriting_mappers = util.WeakSequence()

        if self.inherits:
            if not issubclass(self.class_, self.inherits.class_):
                raise sa_exc.ArgumentError(
                    "Class '%s' does not inherit from '%s'"
                    % (self.class_.__name__, self.inherits.class_.__name__)
                )

            self.dispatch._update(self.inherits.dispatch)

            if self.non_primary != self.inherits.non_primary:
                np = not self.non_primary and "primary" or "non-primary"
                raise sa_exc.ArgumentError(
                    "Inheritance of %s mapper for class '%s' is "
                    "only allowed from a %s mapper"
                    % (np, self.class_.__name__, np)
                )

            if self.single:
                self.persist_selectable = self.inherits.persist_selectable
            elif self.local_table is not self.inherits.local_table:
                if self.concrete:
                    self.persist_selectable = self.local_table
                    for mapper in self.iterate_to_root():
                        if mapper.polymorphic_on is not None:
                            mapper._requires_row_aliasing = True
                else:
                    if self.inherit_condition is None:
                        
                        
                        
                        
                        try:
                            self.inherit_condition = sql_util.join_condition(
                                self.inherits.local_table, self.local_table
                            )
                        except sa_exc.NoForeignKeysError as nfe:
                            assert self.inherits.local_table is not None
                            assert self.local_table is not None
                            raise sa_exc.NoForeignKeysError(
                                "Can't determine the inherit condition "
                                "between inherited table '%s' and "
                                "inheriting "
                                "table '%s'; tables have no "
                                "foreign key relationships established.  "
                                "Please ensure the inheriting table has "
                                "a foreign key relationship to the "
                                "inherited "
                                "table, or provide an "
                                "'on clause' using "
                                "the 'inherit_condition' mapper argument."
                                % (
                                    self.inherits.local_table.description,
                                    self.local_table.description,
                                )
                            ) from nfe
                        except sa_exc.AmbiguousForeignKeysError as afe:
                            assert self.inherits.local_table is not None
                            assert self.local_table is not None
                            raise sa_exc.AmbiguousForeignKeysError(
                                "Can't determine the inherit condition "
                                "between inherited table '%s' and "
                                "inheriting "
                                "table '%s'; tables have more than one "
                                "foreign key relationship established.  "
                                "Please specify the 'on clause' using "
                                "the 'inherit_condition' mapper argument."
                                % (
                                    self.inherits.local_table.description,
                                    self.local_table.description,
                                )
                            ) from afe
                    assert self.inherits.persist_selectable is not None
                    self.persist_selectable = sql.join(
                        self.inherits.persist_selectable,
                        self.local_table,
                        self.inherit_condition,
                    )

                    fks = util.to_set(self.inherit_foreign_keys)
                    self._inherits_equated_pairs = sql_util.criterion_as_pairs(
                        self.persist_selectable.onclause,
                        consider_as_foreign_keys=fks,
                    )
            else:
                self.persist_selectable = self.local_table

            if self.polymorphic_identity is None:
                self._identity_class = self.class_

                if (
                    not self.polymorphic_abstract
                    and self.inherits.base_mapper.polymorphic_on is not None
                ):
                    util.warn(
                        f"{self} does not indicate a 'polymorphic_identity', "
                        "yet is part of an inheritance hierarchy that has a "
                        f"'polymorphic_on' column of "
                        f"'{self.inherits.base_mapper.polymorphic_on}'. "
                        "If this is an intermediary class that should not be "
                        "instantiated, the class may either be left unmapped, "
                        "or may include the 'polymorphic_abstract=True' "
                        "parameter in its Mapper arguments. To leave the "
                        "class unmapped when using Declarative, set the "
                        "'__abstract__ = True' attribute on the class."
                    )
            elif self.concrete:
                self._identity_class = self.class_
            else:
                self._identity_class = self.inherits._identity_class

            if self.version_id_col is None:
                self.version_id_col = self.inherits.version_id_col
                self.version_id_generator = self.inherits.version_id_generator
            elif (
                self.inherits.version_id_col is not None
                and self.version_id_col is not self.inherits.version_id_col
            ):
                util.warn(
                    "Inheriting version_id_col '%s' does not match inherited "
                    "version_id_col '%s' and will not automatically populate "
                    "the inherited versioning column. "
                    "version_id_col should only be specified on "
                    "the base-most mapper that includes versioning."
                    % (
                        self.version_id_col.description,
                        self.inherits.version_id_col.description,
                    )
                )

            self.polymorphic_map = self.inherits.polymorphic_map
            self.batch = self.inherits.batch
            self.inherits._inheriting_mappers.append(self)
            self.base_mapper = self.inherits.base_mapper
            self.passive_updates = self.inherits.passive_updates
            self.passive_deletes = (
                self.inherits.passive_deletes or self.passive_deletes
            )
            self._all_tables = self.inherits._all_tables

            if self.polymorphic_identity is not None:
                if self.polymorphic_identity in self.polymorphic_map:
                    util.warn(
                        "Reassigning polymorphic association for identity %r "
                        "from %r to %r: Check for duplicate use of %r as "
                        "value for polymorphic_identity."
                        % (
                            self.polymorphic_identity,
                            self.polymorphic_map[self.polymorphic_identity],
                            self,
                            self.polymorphic_identity,
                        )
                    )
                self.polymorphic_map[self.polymorphic_identity] = self

            if self.polymorphic_load and self.concrete:
                raise sa_exc.ArgumentError(
                    "polymorphic_load is not currently supported "
                    "with concrete table inheritance"
                )
            if self.polymorphic_load == "inline":
                self.inherits._add_with_polymorphic_subclass(self)
            elif self.polymorphic_load == "selectin":
                pass
            elif self.polymorphic_load is not None:
                raise sa_exc.ArgumentError(
                    "unknown argument for polymorphic_load: %r"
                    % self.polymorphic_load
                )

        else:
            self._all_tables = set()
            self.base_mapper = self
            assert self.local_table is not None
            self.persist_selectable = self.local_table
            if self.polymorphic_identity is not None:
                self.polymorphic_map[self.polymorphic_identity] = self
            self._identity_class = self.class_

        if self.persist_selectable is None:
            raise sa_exc.ArgumentError(
                "Mapper '%s' does not have a persist_selectable specified."
                % self
            )

    def _set_with_polymorphic(
        self, with_polymorphic: Optional[_WithPolymorphicArg]
    ) -> None:
        if with_polymorphic == "*":
            self.with_polymorphic = ("*", None)
        elif isinstance(with_polymorphic, (tuple, list)):
            if isinstance(with_polymorphic[0], (str, tuple, list)):
                self.with_polymorphic = cast(
                    ,
                    with_polymorphic,
                )
            else:
                self.with_polymorphic = (with_polymorphic, None)
        elif with_polymorphic is not None:
            raise sa_exc.ArgumentError(
                f"Invalid setting for with_polymorphic: {with_polymorphic!r}"
            )
        else:
            self.with_polymorphic = None

        if self.with_polymorphic and self.with_polymorphic[1] is not None:
            self.with_polymorphic = (
                self.with_polymorphic[0],
                coercions.expect(
                    roles.StrictFromClauseRole,
                    self.with_polymorphic[1],
                    allow_select=True,
                ),
            )

        if self.configured:
            self._expire_memoizations()

    def _add_with_polymorphic_subclass(self, mapper):
        subcl = mapper.class_
        if self.with_polymorphic is None:
            self._set_with_polymorphic((subcl,))
        elif self.with_polymorphic[0] != "*":
            assert isinstance(self.with_polymorphic[0], tuple)
            self._set_with_polymorphic(
                (self.with_polymorphic[0] + (subcl,), self.with_polymorphic[1])
            )

    def _set_concrete_base(self, mapper):
        

        assert self.concrete
        assert not self.inherits
        assert isinstance(mapper, Mapper)
        self.inherits = mapper
        self.inherits.polymorphic_map.update(self.polymorphic_map)
        self.polymorphic_map = self.inherits.polymorphic_map
        for mapper in self.iterate_to_root():
            if mapper.polymorphic_on is not None:
                mapper._requires_row_aliasing = True
        self.batch = self.inherits.batch
        for mp in self.self_and_descendants:
            mp.base_mapper = self.inherits.base_mapper
        self.inherits._inheriting_mappers.append(self)
        self.passive_updates = self.inherits.passive_updates
        self._all_tables = self.inherits._all_tables

        for key, prop in mapper._props.items():
            if key not in self._props and not self._should_exclude(
                key, key, local=False, column=None
            ):
                self._adapt_inherited_property(key, prop, False)

    def _set_polymorphic_on(self, polymorphic_on):
        self.polymorphic_on = polymorphic_on
        self._configure_polymorphic_setter(True)

    def _configure_class_instrumentation(self):
        

        
        
        
        manager = attributes.opt_manager_of_class(self.class_)

        if self.non_primary:
            if not manager or not manager.is_mapped:
                raise sa_exc.InvalidRequestError(
                    "Class %s has no primary mapper configured.  Configure "
                    "a primary mapper first before setting up a non primary "
                    "Mapper." % self.class_
                )
            self.class_manager = manager

            assert manager.registry is not None
            self.registry = manager.registry
            self._identity_class = manager.mapper._identity_class
            manager.registry._add_non_primary_mapper(self)
            return

        if manager is None or not manager.registry:
            raise sa_exc.InvalidRequestError(
                "The _mapper() function and Mapper() constructor may not be "
                "invoked directly outside of a declarative registry."
                " Please use the sqlalchemy.orm.registry.map_imperatively() "
                "function for a classical mapping."
            )

        self.dispatch.instrument_class(self, self.class_)

        
        
        
        
        

        manager = instrumentation.register_class(
            self.class_,
            mapper=self,
            expired_attribute_loader=util.partial(
                loading.load_scalar_attributes, self
            ),
            
            
            finalize=True,
        )

        self.class_manager = manager

        assert manager.registry is not None
        self.registry = manager.registry

        
        
        if manager.mapper is None:
            return

        event.listen(manager, "init", _event_on_init, raw=True)

        for key, method in util.iterate_attributes(self.class_):
            if key == "__init__" and hasattr(method, "_sa_original_init"):
                method = method._sa_original_init
                if hasattr(method, "__func__"):
                    method = method.__func__
            if callable(method):
                if hasattr(method, "__sa_reconstructor__"):
                    self._reconstructor = method
                    event.listen(manager, "load", _event_on_load, raw=True)
                elif hasattr(method, "__sa_validators__"):
                    validation_opts = method.__sa_validation_opts__
                    for name in method.__sa_validators__:
                        if name in self.validators:
                            raise sa_exc.InvalidRequestError(
                                "A validation function for mapped "
                                "attribute %r on mapper %s already exists."
                                % (name, self)
                            )
                        self.validators = self.validators.union(
                            {name: (method, validation_opts)}
                        )

    def _set_dispose_flags(self) -> None:
        self.configured = True
        self._ready_for_configure = True
        self._dispose_called = True

        self.__dict__.pop("_configure_failed", None)

    def _str_arg_to_mapped_col(self, argname: str, key: str) -> Column[Any]:
        try:
            prop = self._props[key]
        except KeyError as err:
            raise sa_exc.ArgumentError(
                f"Can't determine {argname} column '{key}' - "
                "no attribute is mapped to this name."
            ) from err
        try:
            expr = prop.expression
        except AttributeError as ae:
            raise sa_exc.ArgumentError(
                f"Can't determine {argname} column '{key}'; "
                "property does not refer to a single mapped Column"
            ) from ae
        if not isinstance(expr, Column):
            raise sa_exc.ArgumentError(
                f"Can't determine {argname} column '{key}'; "
                "property does not refer to a single "
                "mapped Column"
            )
        return expr

    def _configure_pks(self) -> None:
        self.tables = sql_util.find_tables(self.persist_selectable)

        self._all_tables.update(t for t in self.tables)

        self._pks_by_table = {}
        self._cols_by_table = {}

        all_cols = util.column_set(
            chain(*[col.proxy_set for col in self._columntoproperty])
        )

        pk_cols = util.column_set(c for c in all_cols if c.primary_key)

        
        for fc in set(self.tables).union([self.persist_selectable]):
            if fc.primary_key and pk_cols.issuperset(fc.primary_key):
                
                
                self._pks_by_table[fc] = util.ordered_column_set(  
                    fc.primary_key
                ).intersection(
                    pk_cols
                )
            self._cols_by_table[fc] = util.ordered_column_set(fc.c).intersection(  
                all_cols
            )

        if self._primary_key_argument:
            coerced_pk_arg = [
                (
                    self._str_arg_to_mapped_col("primary_key", c)
                    if isinstance(c, str)
                    else c
                )
                for c in (
                    coercions.expect(
                        roles.DDLConstraintColumnRole,
                        coerce_pk,
                        argname="primary_key",
                    )
                    for coerce_pk in self._primary_key_argument
                )
            ]
        else:
            coerced_pk_arg = None

        
        
        if coerced_pk_arg:
            for k in coerced_pk_arg:
                if k.table not in self._pks_by_table:
                    self._pks_by_table[k.table] = util.OrderedSet()
                self._pks_by_table[k.table].add(k)

        
        elif (
            self.persist_selectable not in self._pks_by_table
            or len(self._pks_by_table[self.persist_selectable]) == 0
        ):
            raise sa_exc.ArgumentError(
                "Mapper %s could not assemble any primary "
                "key columns for mapped table '%s'"
                % (self, self.persist_selectable.description)
            )
        elif self.local_table not in self._pks_by_table and isinstance(
            self.local_table, schema.Table
        ):
            util.warn(
                "Could not assemble any primary "
                "keys for locally mapped table '%s' - "
                "no rows will be persisted in this Table."
                % self.local_table.description
            )

        if (
            self.inherits
            and not self.concrete
            and not self._primary_key_argument
        ):
            
            
            self.primary_key = self.inherits.primary_key
        else:
            
            primary_key: Collection[ColumnElement[Any]]

            if coerced_pk_arg:
                primary_key = [
                    cc if cc is not None else c
                    for cc, c in (
                        (self.persist_selectable.corresponding_column(c), c)
                        for c in coerced_pk_arg
                    )
                ]
            else:
                
                
                
                
                primary_key = sql_util.reduce_columns(
                    self._pks_by_table[self.persist_selectable],
                    ignore_nonexistent_tables=True,
                )

            if len(primary_key) == 0:
                raise sa_exc.ArgumentError(
                    "Mapper %s could not assemble any primary "
                    "key columns for mapped table '%s'"
                    % (self, self.persist_selectable.description)
                )

            self.primary_key = tuple(primary_key)
            self._log("Identified primary key columns: %s", primary_key)

        
        
        self._readonly_props = {
            self._columntoproperty[col]
            for col in self._columntoproperty
            if self._columntoproperty[col] not in self._identity_key_props
            and (
                not hasattr(col, "table")
                or col.table not in self._cols_by_table
            )
        }

    def _configure_properties(self) -> None:
        self.columns = self.c = sql_base.ColumnCollection()  

        
        self._props = util.OrderedDict()

        
        self._columntoproperty = _ColumnMapping(self)

        explicit_col_props_by_column: Dict[
            KeyedColumnElement[Any], Tuple[str, ColumnProperty[Any]]
        ] = {}
        explicit_col_props_by_key: Dict[str, ColumnProperty[Any]] = {}

        
        
        
        
        if self._init_properties:
            for key, prop_arg in self._init_properties.items():
                if not isinstance(prop_arg, MapperProperty):
                    possible_col_prop = self._make_prop_from_column(
                        key, prop_arg
                    )
                else:
                    possible_col_prop = prop_arg

                
                
                
                

                _map_as_property_now = True
                if isinstance(possible_col_prop, properties.ColumnProperty):
                    for given_col in possible_col_prop.columns:
                        if self.local_table.c.contains_column(given_col):
                            _map_as_property_now = False
                            explicit_col_props_by_key[key] = possible_col_prop
                            explicit_col_props_by_column[given_col] = (
                                key,
                                possible_col_prop,
                            )

                if _map_as_property_now:
                    self._configure_property(
                        key,
                        possible_col_prop,
                        init=False,
                    )

        
        
        
        if self.inherits:
            for key, inherited_prop in self.inherits._props.items():
                if self._should_exclude(key, key, local=False, column=None):
                    continue

                incoming_prop = explicit_col_props_by_key.get(key)
                if incoming_prop:
                    new_prop = self._reconcile_prop_with_incoming_columns(
                        key,
                        inherited_prop,
                        warn_only=False,
                        incoming_prop=incoming_prop,
                    )
                    explicit_col_props_by_key[key] = new_prop

                    for inc_col in incoming_prop.columns:
                        explicit_col_props_by_column[inc_col] = (
                            key,
                            new_prop,
                        )
                elif key not in self._props:
                    self._adapt_inherited_property(key, inherited_prop, False)

        
        
        
        
        

        for column in self.persist_selectable.columns:
            if column in explicit_col_props_by_column:
                
                
                
                key, prop = explicit_col_props_by_column[column]
                self._configure_property(key, prop, init=False)
                continue

            elif column in self._columntoproperty:
                continue

            column_key = (self.column_prefix or "") + column.key
            if self._should_exclude(
                column.key,
                column_key,
                local=self.local_table.c.contains_column(column),
                column=column,
            ):
                continue

            
            
            for mapper in self.iterate_to_root():
                if column in mapper._columntoproperty:
                    column_key = mapper._columntoproperty[column].key

            self._configure_property(
                column_key,
                column,
                init=False,
                setparent=True,
            )

    def _configure_polymorphic_setter(self, init=False):
        
        setter = False
        polymorphic_key: Optional[str] = None

        if self.polymorphic_on is not None:
            setter = True

            if isinstance(self.polymorphic_on, str):
                
                
                try:
                    self.polymorphic_on = self._props[self.polymorphic_on]
                except KeyError as err:
                    raise sa_exc.ArgumentError(
                        "Can't determine polymorphic_on "
                        "value '%s' - no attribute is "
                        "mapped to this name." % self.polymorphic_on
                    ) from err

            if self.polymorphic_on in self._columntoproperty:
                
                
                prop = self._columntoproperty[self.polymorphic_on]
            elif isinstance(self.polymorphic_on, MapperProperty):
                
                
                if not isinstance(
                    self.polymorphic_on, properties.ColumnProperty
                ):
                    raise sa_exc.ArgumentError(
                        "Only direct column-mapped "
                        "property or SQL expression "
                        "can be passed for polymorphic_on"
                    )
                prop = self.polymorphic_on
            else:
                
                
                
                
                
                col = self.persist_selectable.corresponding_column(
                    self.polymorphic_on
                )
                if col is None:
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    setter = False
                    instrument = False
                    col = self.polymorphic_on
                    if isinstance(col, schema.Column) and (
                        self.with_polymorphic is None
                        or self.with_polymorphic[1] is None
                        or self.with_polymorphic[1].corresponding_column(col)
                        is None
                    ):
                        raise sa_exc.InvalidRequestError(
                            "Could not map polymorphic_on column "
                            "'%s' to the mapped table - polymorphic "
                            "loads will not function properly"
                            % col.description
                        )
                else:
                    
                    
                    
                    
                    
                    
                    
                    
                    instrument = True
                key = getattr(col, "key", None)
                if key:
                    if self._should_exclude(key, key, False, col):
                        raise sa_exc.InvalidRequestError(
                            "Cannot exclude or override the "
                            "discriminator column %r" % key
                        )
                else:
                    self.polymorphic_on = col = col.label("_sa_polymorphic_on")
                    key = col.key

                prop = properties.ColumnProperty(col, _instrument=instrument)
                self._configure_property(key, prop, init=init, setparent=True)

            
            
            self.polymorphic_on = prop.columns[0]
            polymorphic_key = prop.key
        else:
            
            
            for mapper in self.iterate_to_root():
                
                
                
                
                
                if mapper.polymorphic_on is not None:
                    if self.persist_selectable is mapper.persist_selectable:
                        self.polymorphic_on = mapper.polymorphic_on
                    else:
                        self.polymorphic_on = (
                            self.persist_selectable
                        ).corresponding_column(mapper.polymorphic_on)
                    
                    
                    
                    if self.polymorphic_on is not None:
                        self._set_polymorphic_identity = (
                            mapper._set_polymorphic_identity
                        )
                        self._polymorphic_attr_key = (
                            mapper._polymorphic_attr_key
                        )
                        self._validate_polymorphic_identity = (
                            mapper._validate_polymorphic_identity
                        )
                    else:
                        self._set_polymorphic_identity = None
                        self._polymorphic_attr_key = None
                    return

        if self.polymorphic_abstract and self.polymorphic_on is None:
            raise sa_exc.InvalidRequestError(
                "The Mapper.polymorphic_abstract parameter may only be used "
                "on a mapper hierarchy which includes the "
                "Mapper.polymorphic_on parameter at the base of the hierarchy."
            )

        if setter:

            def _set_polymorphic_identity(state):
                dict_ = state.dict
                
                

                polymorphic_identity = (
                    state.manager.mapper.polymorphic_identity
                )
                if (
                    polymorphic_identity is None
                    and state.manager.mapper.polymorphic_abstract
                ):
                    raise sa_exc.InvalidRequestError(
                        f"Can't instantiate class for {state.manager.mapper}; "
                        "mapper is marked polymorphic_abstract=True"
                    )

                state.get_impl(polymorphic_key).set(
                    state,
                    dict_,
                    polymorphic_identity,
                    None,
                )

            self._polymorphic_attr_key = polymorphic_key

            def _validate_polymorphic_identity(mapper, state, dict_):
                if (
                    polymorphic_key in dict_
                    and dict_[polymorphic_key]
                    not in mapper._acceptable_polymorphic_identities
                ):
                    util.warn_limited(
                        "Flushing object %s with "
                        "incompatible polymorphic identity %r; the "
                        "object may not refresh and/or load correctly",
                        (state_str(state), dict_[polymorphic_key]),
                    )

            self._set_polymorphic_identity = _set_polymorphic_identity
            self._validate_polymorphic_identity = (
                _validate_polymorphic_identity
            )
        else:
            self._polymorphic_attr_key = None
            self._set_polymorphic_identity = None

    _validate_polymorphic_identity = None

    @HasMemoized.memoized_attribute
    def _version_id_prop(self):
        if self.version_id_col is not None:
            return self._columntoproperty[self.version_id_col]
        else:
            return None

    @HasMemoized.memoized_attribute
    def _acceptable_polymorphic_identities(self):
        identities = set()

        stack = deque([self])
        while stack:
            item = stack.popleft()
            if item.persist_selectable is self.persist_selectable:
                identities.add(item.polymorphic_identity)
                stack.extend(item._inheriting_mappers)

        return identities

    @HasMemoized.memoized_attribute
    def _prop_set(self):
        return frozenset(self._props.values())

    @util.preload_module("sqlalchemy.orm.descriptor_props")
    def _adapt_inherited_property(self, key, prop, init):
        descriptor_props = util.preloaded.orm_descriptor_props

        if not self.concrete:
            self._configure_property(key, prop, init=False, setparent=False)
        elif key not in self._props:
            
            
            
            
            
            
            implementing_attribute = self.class_manager._get_class_attr_mro(
                key, prop
            )
            if implementing_attribute is prop or (
                isinstance(
                    implementing_attribute, attributes.InstrumentedAttribute
                )
                and implementing_attribute._parententity is prop.parent
            ):
                self._configure_property(
                    key,
                    descriptor_props.ConcreteInheritedProperty(),
                    init=init,
                    setparent=True,
                )

    @util.preload_module("sqlalchemy.orm.descriptor_props")
    def _configure_property(
        self,
        key: str,
        prop_arg: Union[KeyedColumnElement[Any], MapperProperty[Any]],
        *,
        init: bool = True,
        setparent: bool = True,
        warn_for_existing: bool = False,
    ) -> MapperProperty[Any]:
        descriptor_props = util.preloaded.orm_descriptor_props
        self._log(
            "_configure_property(%s, %s)", key, prop_arg.__class__.__name__
        )

        if not isinstance(prop_arg, MapperProperty):
            prop: MapperProperty[Any] = self._property_from_column(
                key, prop_arg
            )
        else:
            prop = prop_arg

        if isinstance(prop, properties.ColumnProperty):
            col = self.persist_selectable.corresponding_column(prop.columns[0])

            
            
            
            if col is None and self.inherits:
                path = [self]
                for m in self.inherits.iterate_to_root():
                    col = m.local_table.corresponding_column(prop.columns[0])
                    if col is not None:
                        for m2 in path:
                            m2.persist_selectable._refresh_for_new_column(col)
                        col = self.persist_selectable.corresponding_column(
                            prop.columns[0]
                        )
                        break
                    path.append(m)

            
            
            if col is None:
                col = prop.columns[0]

                
                
                if hasattr(self, "_readonly_props") and (
                    not hasattr(col, "table")
                    or col.table not in self._cols_by_table
                ):
                    self._readonly_props.add(prop)

            else:
                
                
                if (
                    hasattr(self, "_cols_by_table")
                    and col.table in self._cols_by_table
                    and col not in self._cols_by_table[col.table]
                ):
                    self._cols_by_table[col.table].add(col)

            
            
            
            if not hasattr(prop, "_is_polymorphic_discriminator"):
                prop._is_polymorphic_discriminator = (
                    col is self.polymorphic_on
                    or prop.columns[0] is self.polymorphic_on
                )

            if isinstance(col, expression.Label):
                
                
                col.key = col._tq_key_label = key

            self.columns.add(col, key)

            for col in prop.columns:
                for proxy_col in col.proxy_set:
                    self._columntoproperty[proxy_col] = prop

        if getattr(prop, "key", key) != key:
            util.warn(
                f"ORM mapped property {self.class_.__name__}.{prop.key} being "
                "assigned to attribute "
                f"{key!r} is already associated with "
                f"attribute {prop.key!r}. The attribute will be de-associated "
                f"from {prop.key!r}."
            )

        prop.key = key

        if setparent:
            prop.set_parent(self, init)

        if key in self._props and getattr(
            self._props[key], "_mapped_by_synonym", False
        ):
            syn = self._props[key]._mapped_by_synonym
            raise sa_exc.ArgumentError(
                "Can't call map_column=True for synonym %r=%r, "
                "a ColumnProperty already exists keyed to the name "
                "%r for column %r" % (syn, key, key, syn)
            )

        

        
        
        if (
            key in self._props
            and not isinstance(
                self._props[key], descriptor_props.ConcreteInheritedProperty
            )
            and not isinstance(prop, descriptor_props.SynonymProperty)
        ):
            if warn_for_existing:
                util.warn_deprecated(
                    f"User-placed attribute {self.class_.__name__}.{key} on "
                    f"{self} is replacing an existing ORM-mapped attribute.  "
                    "Behavior is not fully defined in this case.  This "
                    "use is deprecated and will raise an error in a future "
                    "release",
                    "2.0",
                )
            oldprop = self._props[key]
            self._path_registry.pop(oldprop, None)

        
        
        
        
        elif (
            warn_for_existing
            and self.class_.__dict__.get(key, None) is not None
            and not isinstance(prop, descriptor_props.SynonymProperty)
            and not isinstance(
                self._props.get(key, None),
                descriptor_props.ConcreteInheritedProperty,
            )
        ):
            util.warn_deprecated(
                f"User-placed attribute {self.class_.__name__}.{key} on "
                f"{self} is replacing an existing class-bound "
                "attribute of the same name.  "
                "Behavior is not fully defined in this case.  This "
                "use is deprecated and will raise an error in a future "
                "release",
                "2.0",
            )

        self._props[key] = prop

        if not self.non_primary:
            prop.instrument_class(self)

        for mapper in self._inheriting_mappers:
            mapper._adapt_inherited_property(key, prop, init)

        if init:
            prop.init()
            prop.post_instrument_class(self)

        if self.configured:
            self._expire_memoizations()

        return prop

    def _make_prop_from_column(
        self,
        key: str,
        column: Union[
            Sequence[KeyedColumnElement[Any]], KeyedColumnElement[Any]
        ],
    ) -> ColumnProperty[Any]:
        columns = util.to_list(column)
        mapped_column = []
        for c in columns:
            mc = self.persist_selectable.corresponding_column(c)
            if mc is None:
                mc = self.local_table.corresponding_column(c)
                if mc is not None:
                    
                    
                    
                    
                    self.persist_selectable._refresh_for_new_column(mc)
                mc = self.persist_selectable.corresponding_column(c)
                if mc is None:
                    raise sa_exc.ArgumentError(
                        "When configuring property '%s' on %s, "
                        "column '%s' is not represented in the mapper's "
                        "table. Use the `column_property()` function to "
                        "force this column to be mapped as a read-only "
                        "attribute." % (key, self, c)
                    )
            mapped_column.append(mc)
        return properties.ColumnProperty(*mapped_column)

    def _reconcile_prop_with_incoming_columns(
        self,
        key: str,
        existing_prop: MapperProperty[Any],
        warn_only: bool,
        incoming_prop: Optional[ColumnProperty[Any]] = None,
        single_column: Optional[KeyedColumnElement[Any]] = None,
    ) -> ColumnProperty[Any]:
        if incoming_prop and (
            self.concrete
            or not isinstance(existing_prop, properties.ColumnProperty)
        ):
            return incoming_prop

        existing_column = existing_prop.columns[0]

        if incoming_prop and existing_column in incoming_prop.columns:
            return incoming_prop

        if incoming_prop is None:
            assert single_column is not None
            incoming_column = single_column
            equated_pair_key = (existing_prop.columns[0], incoming_column)
        else:
            assert single_column is None
            incoming_column = incoming_prop.columns[0]
            equated_pair_key = (incoming_column, existing_prop.columns[0])

        if (
            (
                not self._inherits_equated_pairs
                or (equated_pair_key not in self._inherits_equated_pairs)
            )
            and not existing_column.shares_lineage(incoming_column)
            and existing_column is not self.version_id_col
            and incoming_column is not self.version_id_col
        ):
            msg = (
                "Implicitly combining column %s with column "
                "%s under attribute '%s'.  Please configure one "
                "or more attributes for these same-named columns "
                "explicitly."
                % (
                    existing_prop.columns[-1],
                    incoming_column,
                    key,
                )
            )
            if warn_only:
                util.warn(msg)
            else:
                raise sa_exc.InvalidRequestError(msg)

        
        
        
        new_prop = existing_prop.copy()

        new_prop.columns.insert(0, incoming_column)
        self._log(
            "inserting column to existing list "
            "in properties.ColumnProperty %s",
            key,
        )
        return new_prop  

    @util.preload_module("sqlalchemy.orm.descriptor_props")
    def _property_from_column(
        self,
        key: str,
        column: KeyedColumnElement[Any],
    ) -> ColumnProperty[Any]:
        

        descriptor_props = util.preloaded.orm_descriptor_props

        prop = self._props.get(key)

        if isinstance(prop, properties.ColumnProperty):
            return self._reconcile_prop_with_incoming_columns(
                key,
                prop,
                single_column=column,
                warn_only=prop.parent is not self,
            )
        elif prop is None or isinstance(
            prop, descriptor_props.ConcreteInheritedProperty
        ):
            return self._make_prop_from_column(key, column)
        else:
            raise sa_exc.ArgumentError(
                "WARNING: when configuring property '%s' on %s, "
                "column '%s' conflicts with property '%r'. "
                "To resolve this, map the column to the class under a "
                "different name in the 'properties' dictionary.  Or, "
                "to remove all awareness of the column entirely "
                "(including its availability as a foreign key), "
                "use the 'include_properties' or 'exclude_properties' "
                "mapper arguments to control specifically which table "
                "columns get mapped." % (key, self, column.key, prop)
            )

    @util.langhelpers.tag_method_for_warnings(
        "This warning originated from the `configure_mappers()` process, "
        "which was invoked automatically in response to a user-initiated "
        "operation.",
        sa_exc.SAWarning,
    )
    def _check_configure(self) -> None:
        if self.registry._new_mappers:
            _configure_registries({self.registry}, cascade=True)

    def _post_configure_properties(self) -> None:
        

        self._log("_post_configure_properties() started")
        l = [(key, prop) for key, prop in self._props.items()]
        for key, prop in l:
            self._log("initialize prop %s", key)

            if prop.parent is self and not prop._configure_started:
                prop.init()

            if prop._configure_finished:
                prop.post_instrument_class(self)

        self._log("_post_configure_properties() complete")
        self.configured = True

    def add_properties(self, dict_of_properties):
        
        for key, value in dict_of_properties.items():
            self.add_property(key, value)

    def add_property(
        self, key: str, prop: Union[Column[Any], MapperProperty[Any]]
    ) -> None:
        
        prop = self._configure_property(
            key, prop, init=self.configured, warn_for_existing=True
        )
        assert isinstance(prop, MapperProperty)
        self._init_properties[key] = prop

    def _expire_memoizations(self) -> None:
        for mapper in self.iterate_to_root():
            mapper._reset_memoizations()

    @property
    def _log_desc(self) -> str:
        return (
            "("
            + self.class_.__name__
            + "|"
            + (
                self.local_table is not None
                and self.local_table.description
                or str(self.local_table)
            )
            + (self.non_primary and "|non-primary" or "")
            + ")"
        )

    def _log(self, msg: str, *args: Any) -> None:
        self.logger.info("%s " + msg, *((self._log_desc,) + args))

    def _log_debug(self, msg: str, *args: Any) -> None:
        self.logger.debug("%s " + msg, *((self._log_desc,) + args))

    def __repr__(self) -> str:
        return "<Mapper at 0x%x; %s>" % (id(self), self.class_.__name__)

    def __str__(self) -> str:
        return "Mapper[%s%s(%s)]" % (
            self.class_.__name__,
            self.non_primary and " (non-primary)" or "",
            (
                self.local_table.description
                if self.local_table is not None
                else self.persist_selectable.description
            ),
        )

    def _is_orphan(self, state: InstanceState[_O]) -> bool:
        orphan_possible = False
        for mapper in self.iterate_to_root():
            for key, cls in mapper._delete_orphans:
                orphan_possible = True

                has_parent = attributes.manager_of_class(cls).has_parent(
                    state, key, optimistic=state.has_identity
                )

                if self.legacy_is_orphan and has_parent:
                    return False
                elif not self.legacy_is_orphan and not has_parent:
                    return True

        if self.legacy_is_orphan:
            return orphan_possible
        else:
            return False

    def has_property(self, key: str) -> bool:
        return key in self._props

    def get_property(
        self, key: str, _configure_mappers: bool = False
    ) -> MapperProperty[Any]:
        

        if _configure_mappers:
            self._check_configure()

        try:
            return self._props[key]
        except KeyError as err:
            raise sa_exc.InvalidRequestError(
                f"Mapper '{self}' has no property '{key}'.  If this property "
                "was indicated from other mappers or configure events, ensure "
                "registry.configure() has been called."
            ) from err

    def get_property_by_column(
        self, column: ColumnElement[_T]
    ) -> MapperProperty[_T]:
        

        return self._columntoproperty[column]

    @property
    def iterate_properties(self):
        

        return iter(self._props.values())

    def _mappers_from_spec(
        self, spec: Any, selectable: Optional[FromClause]
    ) -> Sequence[Mapper[Any]]:
        
        if spec == "*":
            mappers = list(self.self_and_descendants)
        elif spec:
            mapper_set: Set[Mapper[Any]] = set()
            for m in util.to_list(spec):
                m = _class_to_mapper(m)
                if not m.isa(self):
                    raise sa_exc.InvalidRequestError(
                        "%r does not inherit from %r" % (m, self)
                    )

                if selectable is None:
                    mapper_set.update(m.iterate_to_root())
                else:
                    mapper_set.add(m)
            mappers = [m for m in self.self_and_descendants if m in mapper_set]
        else:
            mappers = []

        if selectable is not None:
            tables = set(
                sql_util.find_tables(selectable, include_aliases=True)
            )
            mappers = [m for m in mappers if m.local_table in tables]
        return mappers

    def _selectable_from_mappers(
        self, mappers: Iterable[Mapper[Any]], innerjoin: bool
    ) -> FromClause:
        
        from_obj = self.persist_selectable
        for m in mappers:
            if m is self:
                continue
            if m.concrete:
                raise sa_exc.InvalidRequestError(
                    "'with_polymorphic()' requires 'selectable' argument "
                    "when concrete-inheriting mappers are used."
                )
            elif not m.single:
                if innerjoin:
                    from_obj = from_obj.join(
                        m.local_table, m.inherit_condition
                    )
                else:
                    from_obj = from_obj.outerjoin(
                        m.local_table, m.inherit_condition
                    )

        return from_obj

    @HasMemoized.memoized_attribute
    def _version_id_has_server_side_value(self) -> bool:
        vid_col = self.version_id_col

        if vid_col is None:
            return False

        elif not isinstance(vid_col, Column):
            return True
        else:
            return vid_col.server_default is not None or (
                vid_col.default is not None
                and (
                    not vid_col.default.is_scalar
                    and not vid_col.default.is_callable
                )
            )

    @HasMemoized.memoized_attribute
    def _single_table_criterion(self):
        if self.single and self.inherits and self.polymorphic_on is not None:
            return self.polymorphic_on._annotate(
                {"parententity": self, "parentmapper": self}
            ).in_(
                [
                    m.polymorphic_identity
                    for m in self.self_and_descendants
                    if not m.polymorphic_abstract
                ]
            )
        else:
            return None

    @HasMemoized.memoized_attribute
    def _has_aliased_polymorphic_fromclause(self):
        
        return self.with_polymorphic and isinstance(
            self.with_polymorphic[1],
            expression.AliasedReturnsRows,
        )

    @HasMemoized.memoized_attribute
    def _should_select_with_poly_adapter(self):
        

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        return (
            self._has_aliased_polymorphic_fromclause
            or self._requires_row_aliasing
            or (self.base_mapper._has_aliased_polymorphic_fromclause)
            or self.base_mapper._requires_row_aliasing
        )

    @HasMemoized.memoized_attribute
    def _with_polymorphic_mappers(self) -> Sequence[Mapper[Any]]:
        self._check_configure()

        if not self.with_polymorphic:
            return []
        return self._mappers_from_spec(*self.with_polymorphic)

    @HasMemoized.memoized_attribute
    def _post_inspect(self):
        
        self._check_configure()

    @HasMemoized_ro_memoized_attribute
    def _with_polymorphic_selectable(self) -> FromClause:
        if not self.with_polymorphic:
            return self.persist_selectable

        spec, selectable = self.with_polymorphic
        if selectable is not None:
            return selectable
        else:
            return self._selectable_from_mappers(
                self._mappers_from_spec(spec, selectable), False
            )

    with_polymorphic_mappers = _with_polymorphic_mappers
    

    @HasMemoized_ro_memoized_attribute
    def _insert_cols_evaluating_none(self):
        return {
            table: frozenset(
                col for col in columns if col.type.should_evaluate_none
            )
            for table, columns in self._cols_by_table.items()
        }

    @HasMemoized.memoized_attribute
    def _insert_cols_as_none(self):
        return {
            table: frozenset(
                col.key
                for col in columns
                if not col.primary_key
                and not col.server_default
                and not col.default
                and not col.type.should_evaluate_none
            )
            for table, columns in self._cols_by_table.items()
        }

    @HasMemoized.memoized_attribute
    def _propkey_to_col(self):
        return {
            table: {self._columntoproperty[col].key: col for col in columns}
            for table, columns in self._cols_by_table.items()
        }

    @HasMemoized.memoized_attribute
    def _pk_keys_by_table(self):
        return {
            table: frozenset([col.key for col in pks])
            for table, pks in self._pks_by_table.items()
        }

    @HasMemoized.memoized_attribute
    def _pk_attr_keys_by_table(self):
        return {
            table: frozenset([self._columntoproperty[col].key for col in pks])
            for table, pks in self._pks_by_table.items()
        }

    @HasMemoized.memoized_attribute
    def _server_default_cols(
        self,
    ) -> Mapping[FromClause, FrozenSet[Column[Any]]]:
        return {
            table: frozenset(
                [
                    col
                    for col in cast("Iterable[Column[Any]]", columns)
                    if col.server_default is not None
                    or (
                        col.default is not None
                        and col.default.is_clause_element
                    )
                ]
            )
            for table, columns in self._cols_by_table.items()
        }

    @HasMemoized.memoized_attribute
    def _server_onupdate_default_cols(
        self,
    ) -> Mapping[FromClause, FrozenSet[Column[Any]]]:
        return {
            table: frozenset(
                [
                    col
                    for col in cast("Iterable[Column[Any]]", columns)
                    if col.server_onupdate is not None
                    or (
                        col.onupdate is not None
                        and col.onupdate.is_clause_element
                    )
                ]
            )
            for table, columns in self._cols_by_table.items()
        }

    @HasMemoized.memoized_attribute
    def _server_default_col_keys(self) -> Mapping[FromClause, FrozenSet[str]]:
        return {
            table: frozenset(col.key for col in cols if col.key is not None)
            for table, cols in self._server_default_cols.items()
        }

    @HasMemoized.memoized_attribute
    def _server_onupdate_default_col_keys(
        self,
    ) -> Mapping[FromClause, FrozenSet[str]]:
        return {
            table: frozenset(col.key for col in cols if col.key is not None)
            for table, cols in self._server_onupdate_default_cols.items()
        }

    @HasMemoized.memoized_attribute
    def _server_default_plus_onupdate_propkeys(self) -> Set[str]:
        result: Set[str] = set()

        col_to_property = self._columntoproperty
        for table, columns in self._server_default_cols.items():
            result.update(
                col_to_property[col].key
                for col in columns.intersection(col_to_property)
            )
        for table, columns in self._server_onupdate_default_cols.items():
            result.update(
                col_to_property[col].key
                for col in columns.intersection(col_to_property)
            )
        return result

    @HasMemoized.memoized_instancemethod
    def __clause_element__(self):
        annotations: Dict[str, Any] = {
            "entity_namespace": self,
            "parententity": self,
            "parentmapper": self,
        }
        if self.persist_selectable is not self.local_table:
            
            
            annotations["dml_table"] = self.local_table._annotate(
                {
                    "entity_namespace": self,
                    "parententity": self,
                    "parentmapper": self,
                }
            )._set_propagate_attrs(
                {"compile_state_plugin": "orm", "plugin_subject": self}
            )

        return self.selectable._annotate(annotations)._set_propagate_attrs(
            {"compile_state_plugin": "orm", "plugin_subject": self}
        )

    @util.memoized_property
    def select_identity_token(self):
        return (
            expression.null()
            ._annotate(
                {
                    "entity_namespace": self,
                    "parententity": self,
                    "parentmapper": self,
                    "identity_token": True,
                }
            )
            ._set_propagate_attrs(
                {"compile_state_plugin": "orm", "plugin_subject": self}
            )
        )

    @property
    def selectable(self) -> FromClause:
        
        return self._with_polymorphic_selectable

    def _with_polymorphic_args(
        self,
        spec: Any = None,
        selectable: Union[Literal[False, None], FromClause] = False,
        innerjoin: bool = False,
    ) -> Tuple[Sequence[Mapper[Any]], FromClause]:
        if selectable not in (None, False):
            selectable = coercions.expect(
                roles.StrictFromClauseRole, selectable, allow_select=True
            )

        if self.with_polymorphic:
            if not spec:
                spec = self.with_polymorphic[0]
            if selectable is False:
                selectable = self.with_polymorphic[1]
        elif selectable is False:
            selectable = None
        mappers = self._mappers_from_spec(spec, selectable)
        if selectable is not None:
            return mappers, selectable
        else:
            return mappers, self._selectable_from_mappers(mappers, innerjoin)

    @HasMemoized.memoized_attribute
    def _polymorphic_properties(self):
        return list(
            self._iterate_polymorphic_properties(
                self._with_polymorphic_mappers
            )
        )

    @property
    def _all_column_expressions(self):
        poly_properties = self._polymorphic_properties
        adapter = self._polymorphic_adapter

        return [
            adapter.columns[c] if adapter else c
            for prop in poly_properties
            if isinstance(prop, properties.ColumnProperty)
            and prop._renders_in_subqueries
            for c in prop.columns
        ]

    def _columns_plus_keys(self, polymorphic_mappers=()):
        if polymorphic_mappers:
            poly_properties = self._iterate_polymorphic_properties(
                polymorphic_mappers
            )
        else:
            poly_properties = self._polymorphic_properties

        return [
            (prop.key, prop.columns[0])
            for prop in poly_properties
            if isinstance(prop, properties.ColumnProperty)
        ]

    @HasMemoized.memoized_attribute
    def _polymorphic_adapter(self) -> Optional[orm_util.ORMAdapter]:
        if self._has_aliased_polymorphic_fromclause:
            return orm_util.ORMAdapter(
                orm_util._TraceAdaptRole.MAPPER_POLYMORPHIC_ADAPTER,
                self,
                selectable=self.selectable,
                equivalents=self._equivalent_columns,
                limit_on_entity=False,
            )
        else:
            return None

    def _iterate_polymorphic_properties(self, mappers=None):
        
        if mappers is None:
            mappers = self._with_polymorphic_mappers

        if not mappers:
            for c in self.iterate_properties:
                yield c
        else:
            
            
            
            for c in util.unique_list(
                chain(
                    *[
                        list(mapper.iterate_properties)
                        for mapper in [self] + mappers
                    ]
                )
            ):
                if getattr(c, "_is_polymorphic_discriminator", False) and (
                    self.polymorphic_on is None
                    or c.columns[0] is not self.polymorphic_on
                ):
                    continue
                yield c

    @HasMemoized.memoized_attribute
    def attrs(self) -> util.ReadOnlyProperties[MapperProperty[Any]]:
        

        self._check_configure()
        return util.ReadOnlyProperties(self._props)

    @HasMemoized.memoized_attribute
    def all_orm_descriptors(self) -> util.ReadOnlyProperties[InspectionAttr]:
        
        return util.ReadOnlyProperties(
            dict(self.class_manager._all_sqla_attributes())
        )

    @HasMemoized.memoized_attribute
    @util.preload_module("sqlalchemy.orm.descriptor_props")
    def _pk_synonyms(self) -> Dict[str, str]:
        
        descriptor_props = util.preloaded.orm_descriptor_props

        pk_keys = {prop.key for prop in self._identity_key_props}

        return {
            syn.key: syn.name
            for k, syn in self._props.items()
            if isinstance(syn, descriptor_props.SynonymProperty)
            and syn.name in pk_keys
        }

    @HasMemoized.memoized_attribute
    @util.preload_module("sqlalchemy.orm.descriptor_props")
    def synonyms(self) -> util.ReadOnlyProperties[SynonymProperty[Any]]:
        
        descriptor_props = util.preloaded.orm_descriptor_props

        return self._filter_properties(descriptor_props.SynonymProperty)

    @property
    def entity_namespace(self):
        return self.class_

    @HasMemoized.memoized_attribute
    def column_attrs(self) -> util.ReadOnlyProperties[ColumnProperty[Any]]:
        
        return self._filter_properties(properties.ColumnProperty)

    @HasMemoized.memoized_attribute
    @util.preload_module("sqlalchemy.orm.relationships")
    def relationships(
        self,
    ) -> util.ReadOnlyProperties[RelationshipProperty[Any]]:
        
        return self._filter_properties(
            util.preloaded.orm_relationships.RelationshipProperty
        )

    @HasMemoized.memoized_attribute
    @util.preload_module("sqlalchemy.orm.descriptor_props")
    def composites(self) -> util.ReadOnlyProperties[CompositeProperty[Any]]:
        
        return self._filter_properties(
            util.preloaded.orm_descriptor_props.CompositeProperty
        )

    def _filter_properties(
        self, type_: Type[_MP]
    ) -> util.ReadOnlyProperties[_MP]:
        self._check_configure()
        return util.ReadOnlyProperties(
            util.OrderedDict(
                (k, v) for k, v in self._props.items() if isinstance(v, type_)
            )
        )

    @HasMemoized.memoized_attribute
    def _get_clause(self):
        
        params = [
            (
                primary_key,
                sql.bindparam("pk_%d" % idx, type_=primary_key.type),
            )
            for idx, primary_key in enumerate(self.primary_key, 1)
        ]
        return (
            sql.and_(*[k == v for (k, v) in params]),
            util.column_dict(params),
        )

    @HasMemoized.memoized_attribute
    def _equivalent_columns(self) -> _EquivalentColumnMap:
          
        result: _EquivalentColumnMap = {}

        def visit_binary(binary):
            if binary.operator == operators.eq:
                if binary.left in result:
                    result[binary.left].add(binary.right)
                else:
                    result[binary.left] = {binary.right}
                if binary.right in result:
                    result[binary.right].add(binary.left)
                else:
                    result[binary.right] = {binary.left}

        for mapper in self.base_mapper.self_and_descendants:
            if mapper.inherit_condition is not None:
                visitors.traverse(
                    mapper.inherit_condition, {}, {"binary": visit_binary}
                )

        return result

    def _is_userland_descriptor(self, assigned_name: str, obj: Any) -> bool:
        if isinstance(
            obj,
            (
                _MappedAttribute,
                instrumentation.ClassManager,
                expression.ColumnElement,
            ),
        ):
            return False
        else:
            return assigned_name not in self._dataclass_fields

    @HasMemoized.memoized_attribute
    def _dataclass_fields(self):
        return [f.name for f in util.dataclass_fields(self.class_)]

    def _should_exclude(self, name, assigned_name, local, column):
        

        if column is not None and sql_base._never_select_column(column):
            return True

        
        
        
        if local:
            if self.class_.__dict__.get(
                assigned_name, None
            ) is not None and self._is_userland_descriptor(
                assigned_name, self.class_.__dict__[assigned_name]
            ):
                return True
        else:
            attr = self.class_manager._get_class_attr_mro(assigned_name, None)
            if attr is not None and self._is_userland_descriptor(
                assigned_name, attr
            ):
                return True

        if (
            self.include_properties is not None
            and name not in self.include_properties
            and (column is None or column not in self.include_properties)
        ):
            self._log("not including property %s" % (name))
            return True

        if self.exclude_properties is not None and (
            name in self.exclude_properties
            or (column is not None and column in self.exclude_properties)
        ):
            self._log("excluding property %s" % (name))
            return True

        return False

    def common_parent(self, other: Mapper[Any]) -> bool:
        

        return self.base_mapper is other.base_mapper

    def is_sibling(self, other: Mapper[Any]) -> bool:
        
        return (
            self.base_mapper is other.base_mapper
            and not self.isa(other)
            and not other.isa(self)
        )

    def _canload(
        self, state: InstanceState[Any], allow_subtypes: bool
    ) -> bool:
        s = self.primary_mapper()
        if self.polymorphic_on is not None or allow_subtypes:
            return _state_mapper(state).isa(s)
        else:
            return _state_mapper(state) is s

    def isa(self, other: Mapper[Any]) -> bool:
        

        m: Optional[Mapper[Any]] = self
        while m and m is not other:
            m = m.inherits
        return bool(m)

    def iterate_to_root(self) -> Iterator[Mapper[Any]]:
        m: Optional[Mapper[Any]] = self
        while m:
            yield m
            m = m.inherits

    @HasMemoized.memoized_attribute
    def self_and_descendants(self) -> Sequence[Mapper[Any]]:
        
        descendants = []
        stack = deque([self])
        while stack:
            item = stack.popleft()
            descendants.append(item)
            stack.extend(item._inheriting_mappers)
        return util.WeakSequence(descendants)

    def polymorphic_iterator(self) -> Iterator[Mapper[Any]]:
        
        return iter(self.self_and_descendants)

    def primary_mapper(self) -> Mapper[Any]:
        

        return self.class_manager.mapper

    @property
    def primary_base_mapper(self) -> Mapper[Any]:
        return self.class_manager.mapper.base_mapper

    def _result_has_identity_key(self, result, adapter=None):
        pk_cols: Sequence[ColumnElement[Any]]
        if adapter is not None:
            pk_cols = [adapter.columns[c] for c in self.primary_key]
        else:
            pk_cols = self.primary_key
        rk = result.keys()
        for col in pk_cols:
            if col not in rk:
                return False
        else:
            return True

    def identity_key_from_row(
        self,
        row: Union[Row[Any], RowMapping],
        identity_token: Optional[Any] = None,
        adapter: Optional[ORMAdapter] = None,
    ) -> _IdentityKeyType[_O]:
        
        pk_cols: Sequence[ColumnElement[Any]]
        if adapter is not None:
            pk_cols = [adapter.columns[c] for c in self.primary_key]
        else:
            pk_cols = self.primary_key

        mapping: RowMapping
        if hasattr(row, "_mapping"):
            mapping = row._mapping
        else:
            mapping = row  

        return (
            self._identity_class,
            tuple(mapping[column] for column in pk_cols),
            identity_token,
        )

    def identity_key_from_primary_key(
        self,
        primary_key: Tuple[Any, ...],
        identity_token: Optional[Any] = None,
    ) -> _IdentityKeyType[_O]:
        
        return (
            self._identity_class,
            tuple(primary_key),
            identity_token,
        )

    def identity_key_from_instance(self, instance: _O) -> _IdentityKeyType[_O]:
        
        state = attributes.instance_state(instance)
        return self._identity_key_from_state(state, PassiveFlag.PASSIVE_OFF)

    def _identity_key_from_state(
        self,
        state: InstanceState[_O],
        passive: PassiveFlag = PassiveFlag.PASSIVE_RETURN_NO_VALUE,
    ) -> _IdentityKeyType[_O]:
        dict_ = state.dict
        manager = state.manager
        return (
            self._identity_class,
            tuple(
                [
                    manager[prop.key].impl.get(state, dict_, passive)
                    for prop in self._identity_key_props
                ]
            ),
            state.identity_token,
        )

    def primary_key_from_instance(self, instance: _O) -> Tuple[Any, ...]:
        
        state = attributes.instance_state(instance)
        identity_key = self._identity_key_from_state(
            state, PassiveFlag.PASSIVE_OFF
        )
        return identity_key[1]

    @HasMemoized.memoized_attribute
    def _persistent_sortkey_fn(self):
        key_fns = [col.type.sort_key_function for col in self.primary_key]

        if set(key_fns).difference([None]):

            def key(state):
                return tuple(
                    key_fn(val) if key_fn is not None else val
                    for key_fn, val in zip(key_fns, state.key[1])
                )

        else:

            def key(state):
                return state.key[1]

        return key

    @HasMemoized.memoized_attribute
    def _identity_key_props(self):
        return [self._columntoproperty[col] for col in self.primary_key]

    @HasMemoized.memoized_attribute
    def _all_pk_cols(self):
        collection: Set[ColumnClause[Any]] = set()
        for table in self.tables:
            collection.update(self._pks_by_table[table])
        return collection

    @HasMemoized.memoized_attribute
    def _should_undefer_in_wildcard(self):
        cols: Set[ColumnElement[Any]] = set(self.primary_key)
        if self.polymorphic_on is not None:
            cols.add(self.polymorphic_on)
        return cols

    @HasMemoized.memoized_attribute
    def _primary_key_propkeys(self):
        return {self._columntoproperty[col].key for col in self._all_pk_cols}

    def _get_state_attr_by_column(
        self,
        state: InstanceState[_O],
        dict_: _InstanceDict,
        column: ColumnElement[Any],
        passive: PassiveFlag = PassiveFlag.PASSIVE_RETURN_NO_VALUE,
    ) -> Any:
        prop = self._columntoproperty[column]
        return state.manager[prop.key].impl.get(state, dict_, passive=passive)

    def _set_committed_state_attr_by_column(self, state, dict_, column, value):
        prop = self._columntoproperty[column]
        state.manager[prop.key].impl.set_committed_value(state, dict_, value)

    def _set_state_attr_by_column(self, state, dict_, column, value):
        prop = self._columntoproperty[column]
        state.manager[prop.key].impl.set(state, dict_, value, None)

    def _get_committed_attr_by_column(self, obj, column):
        state = attributes.instance_state(obj)
        dict_ = attributes.instance_dict(obj)
        return self._get_committed_state_attr_by_column(
            state, dict_, column, passive=PassiveFlag.PASSIVE_OFF
        )

    def _get_committed_state_attr_by_column(
        self, state, dict_, column, passive=PassiveFlag.PASSIVE_RETURN_NO_VALUE
    ):
        prop = self._columntoproperty[column]
        return state.manager[prop.key].impl.get_committed_value(
            state, dict_, passive=passive
        )

    def _optimized_get_statement(self, state, attribute_names):
        
        props = self._props

        col_attribute_names = set(attribute_names).intersection(
            state.mapper.column_attrs.keys()
        )
        tables: Set[FromClause] = set(
            chain(
                *[
                    sql_util.find_tables(c, check_columns=True)
                    for key in col_attribute_names
                    for c in props[key].columns
                ]
            )
        )

        if self.base_mapper.local_table in tables:
            return None

        def visit_binary(binary):
            leftcol = binary.left
            rightcol = binary.right
            if leftcol is None or rightcol is None:
                return

            if leftcol.table not in tables:
                leftval = self._get_committed_state_attr_by_column(
                    state,
                    state.dict,
                    leftcol,
                    passive=PassiveFlag.PASSIVE_NO_INITIALIZE,
                )
                if leftval in orm_util._none_set:
                    raise _OptGetColumnsNotAvailable()
                binary.left = sql.bindparam(
                    None, leftval, type_=binary.right.type
                )
            elif rightcol.table not in tables:
                rightval = self._get_committed_state_attr_by_column(
                    state,
                    state.dict,
                    rightcol,
                    passive=PassiveFlag.PASSIVE_NO_INITIALIZE,
                )
                if rightval in orm_util._none_set:
                    raise _OptGetColumnsNotAvailable()
                binary.right = sql.bindparam(
                    None, rightval, type_=binary.right.type
                )

        allconds: List[ColumnElement[bool]] = []

        start = False

        
        

        for mapper in reversed(list(self.iterate_to_root())):
            if mapper.local_table in tables:
                start = True
            elif not isinstance(mapper.local_table, expression.TableClause):
                return None
            if start and not mapper.single:
                assert mapper.inherits
                assert not mapper.concrete
                assert mapper.inherit_condition is not None
                allconds.append(mapper.inherit_condition)
                tables.add(mapper.local_table)

        
        
        
        
        try:
            _traversed = visitors.cloned_traverse(
                allconds[0], {}, {"binary": visit_binary}
            )
        except _OptGetColumnsNotAvailable:
            return None
        else:
            allconds[0] = _traversed

        cond = sql.and_(*allconds)

        cols = []
        for key in col_attribute_names:
            cols.extend(props[key].columns)
        return (
            sql.select(*cols)
            .where(cond)
            .set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
        )

    def _iterate_to_target_viawpoly(self, mapper):
        if self.isa(mapper):
            prev = self
            for m in self.iterate_to_root():
                yield m

                if m is not prev and prev not in m._with_polymorphic_mappers:
                    break

                prev = m
                if m is mapper:
                    break

    @HasMemoized.memoized_attribute
    def _would_selectinload_combinations_cache(self):
        return {}

    def _would_selectin_load_only_from_given_mapper(self, super_mapper):
        
        cache = self._would_selectinload_combinations_cache

        try:
            return cache[super_mapper]
        except KeyError:
            pass

        
        
        
        
        assert self.isa(super_mapper)

        mapper = super_mapper
        for m in self._iterate_to_target_viawpoly(mapper):
            if m.polymorphic_load == "selectin":
                retval = m is super_mapper
                break
        else:
            retval = False

        cache[super_mapper] = retval
        return retval

    def _should_selectin_load(self, enabled_via_opt, polymorphic_from):
        if not enabled_via_opt:
            
            mapper = polymorphic_from
            for m in self._iterate_to_target_viawpoly(mapper):
                if m.polymorphic_load == "selectin":
                    return m
        else:
            
            enabled_via_opt = set(enabled_via_opt)
            enabled_via_opt_mappers = {e.mapper: e for e in enabled_via_opt}
            for entity in enabled_via_opt.union([polymorphic_from]):
                mapper = entity.mapper
                for m in self._iterate_to_target_viawpoly(mapper):
                    if (
                        m.polymorphic_load == "selectin"
                        or m in enabled_via_opt_mappers
                    ):
                        return enabled_via_opt_mappers.get(m, m)

        return None

    @util.preload_module("sqlalchemy.orm.strategy_options")
    def _subclass_load_via_in(self, entity, polymorphic_from):
        

        strategy_options = util.preloaded.orm_strategy_options

        assert self.inherits

        if self.polymorphic_on is not None:
            polymorphic_prop = self._columntoproperty[self.polymorphic_on]
            keep_props = set([polymorphic_prop] + self._identity_key_props)
        else:
            keep_props = set(self._identity_key_props)

        disable_opt = strategy_options.Load(entity)
        enable_opt = strategy_options.Load(entity)

        classes_to_include = {self}
        m: Optional[Mapper[Any]] = self.inherits
        while (
            m is not None
            and m is not polymorphic_from
            and m.polymorphic_load == "selectin"
        ):
            classes_to_include.add(m)
            m = m.inherits

        for prop in self.column_attrs + self.relationships:
            
            
            
            if prop.key not in self.class_manager:
                continue

            if prop.parent in classes_to_include or prop in keep_props:
                
                
                if not isinstance(prop, StrategizedProperty):
                    continue

                enable_opt = enable_opt._set_generic_strategy(
                    
                    
                    
                    (getattr(entity.entity_namespace, prop.key),),
                    dict(prop.strategy_key),
                    _reconcile_to_other=True,
                )
            else:
                
                
                
                disable_opt = disable_opt._set_generic_strategy(
                    
                    
                    
                    (getattr(entity.entity_namespace, prop.key),),
                    {"do_nothing": True},
                    _reconcile_to_other=False,
                )

        primary_key = [
            sql_util._deep_annotate(pk, {"_orm_adapt": True})
            for pk in self.primary_key
        ]

        in_expr: ColumnElement[Any]

        if len(primary_key) > 1:
            in_expr = sql.tuple_(*primary_key)
        else:
            in_expr = primary_key[0]

        if entity.is_aliased_class:
            assert entity.mapper is self

            q = sql.select(entity).set_label_style(
                LABEL_STYLE_TABLENAME_PLUS_COL
            )

            in_expr = entity._adapter.traverse(in_expr)
            primary_key = [entity._adapter.traverse(k) for k in primary_key]
            q = q.where(
                in_expr.in_(sql.bindparam("primary_keys", expanding=True))
            ).order_by(*primary_key)
        else:
            q = sql.select(self).set_label_style(
                LABEL_STYLE_TABLENAME_PLUS_COL
            )
            q = q.where(
                in_expr.in_(sql.bindparam("primary_keys", expanding=True))
            ).order_by(*primary_key)

        return q, enable_opt, disable_opt

    @HasMemoized.memoized_attribute
    def _subclass_load_via_in_mapper(self):
        
        return self._subclass_load_via_in(self, self.base_mapper)

    def cascade_iterator(
        self,
        type_: str,
        state: InstanceState[_O],
        halt_on: Optional[Callable[[InstanceState[Any]], bool]] = None,
    ) -> Iterator[
        Tuple[object, Mapper[Any], InstanceState[Any], _InstanceDict]
    ]:
        r
        visited_states: Set[InstanceState[Any]] = set()
        prp, mpp = object(), object()

        assert state.mapper.isa(self)

        
        
        visitables: Deque[
            Tuple[
                Deque[Any],
                object,
                Optional[InstanceState[Any]],
                Optional[_InstanceDict],
            ]
        ]

        visitables = deque(
            [(deque(state.mapper._props.values()), prp, state, state.dict)]
        )

        while visitables:
            iterator, item_type, parent_state, parent_dict = visitables[-1]
            if not iterator:
                visitables.pop()
                continue

            if item_type is prp:
                prop = iterator.popleft()
                if not prop.cascade or type_ not in prop.cascade:
                    continue
                assert parent_state is not None
                assert parent_dict is not None
                queue = deque(
                    prop.cascade_iterator(
                        type_,
                        parent_state,
                        parent_dict,
                        visited_states,
                        halt_on,
                    )
                )
                if queue:
                    visitables.append((queue, mpp, None, None))
            elif item_type is mpp:
                (
                    instance,
                    instance_mapper,
                    corresponding_state,
                    corresponding_dict,
                ) = iterator.popleft()
                yield (
                    instance,
                    instance_mapper,
                    corresponding_state,
                    corresponding_dict,
                )
                visitables.append(
                    (
                        deque(instance_mapper._props.values()),
                        prp,
                        corresponding_state,
                        corresponding_dict,
                    )
                )

    @HasMemoized.memoized_attribute
    def _compiled_cache(self):
        return util.LRUCache(self._compiled_cache_size)

    @HasMemoized.memoized_attribute
    def _multiple_persistence_tables(self):
        return len(self.tables) > 1

    @HasMemoized.memoized_attribute
    def _sorted_tables(self):
        table_to_mapper: Dict[TableClause, Mapper[Any]] = {}

        for mapper in self.base_mapper.self_and_descendants:
            for t in mapper.tables:
                table_to_mapper.setdefault(t, mapper)

        extra_dependencies = []
        for table, mapper in table_to_mapper.items():
            super_ = mapper.inherits
            if super_:
                extra_dependencies.extend(
                    [(super_table, table) for super_table in super_.tables]
                )

        def skip(fk):
            
            
            
            
            
            parent = table_to_mapper.get(fk.parent.table)
            dep = table_to_mapper.get(fk.column.table)
            if (
                parent is not None
                and dep is not None
                and dep is not parent
                and dep.inherit_condition is not None
            ):
                cols = set(sql_util._find_columns(dep.inherit_condition))
                if parent.inherit_condition is not None:
                    cols = cols.union(
                        sql_util._find_columns(parent.inherit_condition)
                    )
                    return fk.parent not in cols and fk.column not in cols
                else:
                    return fk.parent not in cols
            return False

        sorted_ = sql_util.sort_tables(
            table_to_mapper,
            skip_fn=skip,
            extra_dependencies=extra_dependencies,
        )

        ret = util.OrderedDict()
        for t in sorted_:
            ret[t] = table_to_mapper[t]
        return ret

    def _memo(self, key: Any, callable_: Callable[[], _T]) -> _T:
        if key in self._memoized_values:
            return cast(_T, self._memoized_values[key])
        else:
            self._memoized_values[key] = value = callable_()
            return value

    @util.memoized_property
    def _table_to_equated(self):
        

        result: util.defaultdict[
            Table,
            List[
                Tuple[
                    Mapper[Any],
                    List[Tuple[ColumnElement[Any], ColumnElement[Any]]],
                ]
            ],
        ] = util.defaultdict(list)

        def set_union(x, y):
            return x.union(y)

        for table in self._sorted_tables:
            cols = set(table.c)

            for m in self.iterate_to_root():
                if m._inherits_equated_pairs and cols.intersection(
                    reduce(
                        set_union,
                        [l.proxy_set for l, r in m._inherits_equated_pairs],
                    )
                ):
                    result[table].append((m, m._inherits_equated_pairs))

        return result


class _OptGetColumnsNotAvailable(Exception):
    pass


def configure_mappers() -> None:
    

    _configure_registries(_all_registries(), cascade=True)


def _configure_registries(
    registries: Set[_RegistryType], cascade: bool
) -> None:
    for reg in registries:
        if reg._new_mappers:
            break
    else:
        return

    with _CONFIGURE_MUTEX:
        global _already_compiling
        if _already_compiling:
            return
        _already_compiling = True
        try:
            
            for reg in registries:
                if reg._new_mappers:
                    break
            else:
                return

            Mapper.dispatch._for_class(Mapper).before_configured()  
            
            
            
            

            _do_configure_registries(registries, cascade)
        finally:
            _already_compiling = False
    Mapper.dispatch._for_class(Mapper).after_configured()  


@util.preload_module("sqlalchemy.orm.decl_api")
def _do_configure_registries(
    registries: Set[_RegistryType], cascade: bool
) -> None:
    registry = util.preloaded.orm_decl_api.registry

    orig = set(registries)

    for reg in registry._recurse_with_dependencies(registries):
        has_skip = False

        for mapper in reg._mappers_to_configure():
            run_configure = None

            for fn in mapper.dispatch.before_mapper_configured:
                run_configure = fn(mapper, mapper.class_)
                if run_configure is EXT_SKIP:
                    has_skip = True
                    break
            if run_configure is EXT_SKIP:
                continue

            if getattr(mapper, "_configure_failed", False):
                e = sa_exc.InvalidRequestError(
                    "One or more mappers failed to initialize - "
                    "can't proceed with initialization of other "
                    "mappers. Triggering mapper: '%s'. "
                    "Original exception was: %s"
                    % (mapper, mapper._configure_failed)
                )
                e._configure_failed = mapper._configure_failed  
                raise e

            if not mapper.configured:
                try:
                    mapper._post_configure_properties()
                    mapper._expire_memoizations()
                    mapper.dispatch.mapper_configured(mapper, mapper.class_)
                except Exception:
                    exc = sys.exc_info()[1]
                    if not hasattr(exc, "_configure_failed"):
                        mapper._configure_failed = exc
                    raise
        if not has_skip:
            reg._new_mappers = False

        if not cascade and reg._dependencies.difference(orig):
            raise sa_exc.InvalidRequestError(
                "configure was called with cascade=False but "
                "additional registries remain"
            )


@util.preload_module("sqlalchemy.orm.decl_api")
def _dispose_registries(registries: Set[_RegistryType], cascade: bool) -> None:
    registry = util.preloaded.orm_decl_api.registry

    orig = set(registries)

    for reg in registry._recurse_with_dependents(registries):
        if not cascade and reg._dependents.difference(orig):
            raise sa_exc.InvalidRequestError(
                "Registry has dependent registries that are not disposed; "
                "pass cascade=True to clear these also"
            )

        while reg._managers:
            try:
                manager, _ = reg._managers.popitem()
            except KeyError:
                
                pass
            else:
                reg._dispose_manager_and_mapper(manager)

        reg._non_primary_mappers.clear()
        reg._dependents.clear()
        for dep in reg._dependencies:
            dep._dependents.discard(reg)
        reg._dependencies.clear()
        
        
        
        
        reg._new_mappers = False


def reconstructor(fn: _Fn) -> _Fn:
    
    fn.__sa_reconstructor__ = True  
    return fn


def validates(
    *names: str, include_removes: bool = False, include_backrefs: bool = True
) -> Callable[[_Fn], _Fn]:
    r

    def wrap(fn: _Fn) -> _Fn:
        fn.__sa_validators__ = names  
        fn.__sa_validation_opts__ = {  
            "include_removes": include_removes,
            "include_backrefs": include_backrefs,
        }
        return fn

    return wrap


def _event_on_load(state, ctx):
    instrumenting_mapper = state.manager.mapper

    if instrumenting_mapper._reconstructor:
        instrumenting_mapper._reconstructor(state.obj())


def _event_on_init(state, args, kwargs):
    

    instrumenting_mapper = state.manager.mapper
    if instrumenting_mapper:
        instrumenting_mapper._check_configure()
        if instrumenting_mapper._set_polymorphic_identity:
            instrumenting_mapper._set_polymorphic_identity(state)


class _ColumnMapping(Dict["ColumnElement[Any]", "MapperProperty[Any]"]):
    

    __slots__ = ("mapper",)

    def __init__(self, mapper):
        
        self.mapper = mapper

    def __missing__(self, column):
        prop = self.mapper._props.get(column)
        if prop:
            raise orm_exc.UnmappedColumnError(
                "Column '%s.%s' is not available, due to "
                "conflicting property '%s':%r"
                % (column.table.name, column.name, column.key, prop)
            )
        raise orm_exc.UnmappedColumnError(
            "No column %s is configured on mapper %s..."
            % (column, self.mapper)
        )
