







from __future__ import annotations

from typing import Any
from typing import Callable
from typing import Collection
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref

from . import instrumentation
from . import interfaces
from . import mapperlib
from .attributes import QueryableAttribute
from .base import _mapper_or_none
from .base import NO_KEY
from .instrumentation import ClassManager
from .instrumentation import InstrumentationFactory
from .query import BulkDelete
from .query import BulkUpdate
from .query import Query
from .scoping import scoped_session
from .session import Session
from .session import sessionmaker
from .. import event
from .. import exc
from .. import util
from ..event import EventTarget
from ..event.registry import _ET
from ..util.compat import inspect_getfullargspec

if TYPE_CHECKING:
    from weakref import ReferenceType

    from ._typing import _InstanceDict
    from ._typing import _InternalEntityType
    from ._typing import _O
    from ._typing import _T
    from .attributes import Event
    from .base import EventConstants
    from .session import ORMExecuteState
    from .session import SessionTransaction
    from .unitofwork import UOWTransaction
    from ..engine import Connection
    from ..event.base import _Dispatch
    from ..event.base import _HasEventsDispatch
    from ..event.registry import _EventKey
    from ..orm.collections import CollectionAdapter
    from ..orm.context import QueryContext
    from ..orm.decl_api import DeclarativeAttributeIntercept
    from ..orm.decl_api import DeclarativeMeta
    from ..orm.mapper import Mapper
    from ..orm.state import InstanceState

_KT = TypeVar("_KT", bound=Any)
_ET2 = TypeVar("_ET2", bound=EventTarget)


class InstrumentationEvents(event.Events[InstrumentationFactory]):
    

    _target_class_doc = "SomeBaseClass"
    _dispatch_target = InstrumentationFactory

    @classmethod
    def _accept_with(
        cls,
        target: Union[
            InstrumentationFactory,
            Type[InstrumentationFactory],
        ],
        identifier: str,
    ) -> Optional[
        Union[
            InstrumentationFactory,
            Type[InstrumentationFactory],
        ]
    ]:
        if isinstance(target, type):
            return _InstrumentationEventsHold(target)  
        else:
            return None

    @classmethod
    def _listen(
        cls, event_key: _EventKey[_T], propagate: bool = True, **kw: Any
    ) -> None:
        target, identifier, fn = (
            event_key.dispatch_target,
            event_key.identifier,
            event_key._listen_fn,
        )

        def listen(target_cls: type, *arg: Any) -> Optional[Any]:
            listen_cls = target()

            
            
            
            
            if listen_cls is None:
                return None

            if propagate and issubclass(target_cls, listen_cls):
                return fn(target_cls, *arg)
            elif not propagate and target_cls is listen_cls:
                return fn(target_cls, *arg)
            else:
                return None

        def remove(ref: ReferenceType[_T]) -> None:
            key = event.registry._EventKey(  
                None,
                identifier,
                listen,
                instrumentation._instrumentation_factory,
            )
            getattr(
                instrumentation._instrumentation_factory.dispatch, identifier
            ).remove(key)

        target = weakref.ref(target.class_, remove)

        event_key.with_dispatch_target(
            instrumentation._instrumentation_factory
        ).with_wrapper(listen).base_listen(**kw)

    @classmethod
    def _clear(cls) -> None:
        super()._clear()
        instrumentation._instrumentation_factory.dispatch._clear()

    def class_instrument(self, cls: ClassManager[_O]) -> None:
        

    def class_uninstrument(self, cls: ClassManager[_O]) -> None:
        

    def attribute_instrument(
        self, cls: ClassManager[_O], key: _KT, inst: _O
    ) -> None:
        


class _InstrumentationEventsHold:
    

    def __init__(self, class_: type) -> None:
        self.class_ = class_

    dispatch = event.dispatcher(InstrumentationEvents)


class InstanceEvents(event.Events[ClassManager[Any]]):
    

    _target_class_doc = "SomeClass"

    _dispatch_target = ClassManager

    @classmethod
    def _new_classmanager_instance(
        cls,
        class_: Union[DeclarativeAttributeIntercept, DeclarativeMeta, type],
        classmanager: ClassManager[_O],
    ) -> None:
        _InstanceEventsHold.populate(class_, classmanager)

    @classmethod
    @util.preload_module("sqlalchemy.orm")
    def _accept_with(
        cls,
        target: Union[
            ClassManager[Any],
            Type[ClassManager[Any]],
        ],
        identifier: str,
    ) -> Optional[Union[ClassManager[Any], Type[ClassManager[Any]]]]:
        orm = util.preloaded.orm

        if isinstance(target, ClassManager):
            return target
        elif isinstance(target, mapperlib.Mapper):
            return target.class_manager
        elif target is orm.mapper:  
            util.warn_deprecated(
                "The `sqlalchemy.orm.mapper()` symbol is deprecated and "
                "will be removed in a future release. For the mapper-wide "
                "event target, use the 'sqlalchemy.orm.Mapper' class.",
                "2.0",
            )
            return ClassManager
        elif isinstance(target, type):
            if issubclass(target, mapperlib.Mapper):
                return ClassManager
            else:
                manager = instrumentation.opt_manager_of_class(target)
                if manager:
                    return manager
                else:
                    return _InstanceEventsHold(target)  
        return None

    @classmethod
    def _listen(
        cls,
        event_key: _EventKey[ClassManager[Any]],
        raw: bool = False,
        propagate: bool = False,
        restore_load_context: bool = False,
        **kw: Any,
    ) -> None:
        target, fn = (event_key.dispatch_target, event_key._listen_fn)

        if not raw or restore_load_context:

            def wrap(
                state: InstanceState[_O], *arg: Any, **kw: Any
            ) -> Optional[Any]:
                if not raw:
                    target: Any = state.obj()
                else:
                    target = state
                if restore_load_context:
                    runid = state.runid
                try:
                    return fn(target, *arg, **kw)
                finally:
                    if restore_load_context:
                        state.runid = runid

            event_key = event_key.with_wrapper(wrap)

        event_key.base_listen(propagate=propagate, **kw)

        if propagate:
            for mgr in target.subclass_managers(True):
                event_key.with_dispatch_target(mgr).base_listen(propagate=True)

    @classmethod
    def _clear(cls) -> None:
        super()._clear()
        _InstanceEventsHold._clear()

    def first_init(self, manager: ClassManager[_O], cls: Type[_O]) -> None:
        

    def init(self, target: _O, args: Any, kwargs: Any) -> None:
        

    def init_failure(self, target: _O, args: Any, kwargs: Any) -> None:
        

    def _sa_event_merge_wo_load(
        self, target: _O, context: QueryContext
    ) -> None:
        

    def load(self, target: _O, context: QueryContext) -> None:
          

    def refresh(
        self, target: _O, context: QueryContext, attrs: Optional[Iterable[str]]
    ) -> None:
        

    def refresh_flush(
        self,
        target: _O,
        flush_context: UOWTransaction,
        attrs: Optional[Iterable[str]],
    ) -> None:
        

    def expire(self, target: _O, attrs: Optional[Iterable[str]]) -> None:
        

    def pickle(self, target: _O, state_dict: _InstanceDict) -> None:
        

    def unpickle(self, target: _O, state_dict: _InstanceDict) -> None:
        


class _EventsHold(event.RefCollection[_ET]):
    

    all_holds: weakref.WeakKeyDictionary[Any, Any]

    def __init__(
        self,
        class_: Union[DeclarativeAttributeIntercept, DeclarativeMeta, type],
    ) -> None:
        self.class_ = class_

    @classmethod
    def _clear(cls) -> None:
        cls.all_holds.clear()

    class HoldEvents(Generic[_ET2]):
        _dispatch_target: Optional[Type[_ET2]] = None

        @classmethod
        def _listen(
            cls,
            event_key: _EventKey[_ET2],
            raw: bool = False,
            propagate: bool = False,
            retval: bool = False,
            **kw: Any,
        ) -> None:
            target = event_key.dispatch_target

            if target.class_ in target.all_holds:
                collection = target.all_holds[target.class_]
            else:
                collection = target.all_holds[target.class_] = {}

            event.registry._stored_in_collection(event_key, target)
            collection[event_key._key] = (
                event_key,
                raw,
                propagate,
                retval,
                kw,
            )

            if propagate:
                stack = list(target.class_.__subclasses__())
                while stack:
                    subclass = stack.pop(0)
                    stack.extend(subclass.__subclasses__())
                    subject = target.resolve(subclass)
                    if subject is not None:
                        
                        
                        event_key.with_dispatch_target(subject).listen(
                            raw=raw, propagate=False, retval=retval, **kw
                        )

    def remove(self, event_key: _EventKey[_ET]) -> None:
        target = event_key.dispatch_target

        if isinstance(target, _EventsHold):
            collection = target.all_holds[target.class_]
            del collection[event_key._key]

    @classmethod
    def populate(
        cls,
        class_: Union[DeclarativeAttributeIntercept, DeclarativeMeta, type],
        subject: Union[ClassManager[_O], Mapper[_O]],
    ) -> None:
        for subclass in class_.__mro__:
            if subclass in cls.all_holds:
                collection = cls.all_holds[subclass]
                for (
                    event_key,
                    raw,
                    propagate,
                    retval,
                    kw,
                ) in collection.values():
                    if propagate or subclass is class_:
                        
                        
                        
                        
                        
                        event_key.with_dispatch_target(subject).listen(
                            raw=raw, propagate=False, retval=retval, **kw
                        )


class _InstanceEventsHold(_EventsHold[_ET]):
    all_holds: weakref.WeakKeyDictionary[Any, Any] = (
        weakref.WeakKeyDictionary()
    )

    def resolve(self, class_: Type[_O]) -> Optional[ClassManager[_O]]:
        return instrumentation.opt_manager_of_class(class_)

    class HoldInstanceEvents(_EventsHold.HoldEvents[_ET], InstanceEvents):  
        pass

    dispatch = event.dispatcher(HoldInstanceEvents)


class MapperEvents(event.Events[mapperlib.Mapper[Any]]):
    

    _target_class_doc = "SomeClass"
    _dispatch_target = mapperlib.Mapper

    @classmethod
    def _new_mapper_instance(
        cls,
        class_: Union[DeclarativeAttributeIntercept, DeclarativeMeta, type],
        mapper: Mapper[_O],
    ) -> None:
        _MapperEventsHold.populate(class_, mapper)

    @classmethod
    @util.preload_module("sqlalchemy.orm")
    def _accept_with(
        cls,
        target: Union[mapperlib.Mapper[Any], Type[mapperlib.Mapper[Any]]],
        identifier: str,
    ) -> Optional[Union[mapperlib.Mapper[Any], Type[mapperlib.Mapper[Any]]]]:
        orm = util.preloaded.orm

        if target is orm.mapper:  
            util.warn_deprecated(
                "The `sqlalchemy.orm.mapper()` symbol is deprecated and "
                "will be removed in a future release. For the mapper-wide "
                "event target, use the 'sqlalchemy.orm.Mapper' class.",
                "2.0",
            )
            return mapperlib.Mapper
        elif isinstance(target, type):
            if issubclass(target, mapperlib.Mapper):
                return target
            else:
                mapper = _mapper_or_none(target)
                if mapper is not None:
                    return mapper
                else:
                    return _MapperEventsHold(target)
        else:
            return target

    @classmethod
    def _listen(
        cls,
        event_key: _EventKey[_ET],
        raw: bool = False,
        retval: bool = False,
        propagate: bool = False,
        **kw: Any,
    ) -> None:
        target, identifier, fn = (
            event_key.dispatch_target,
            event_key.identifier,
            event_key._listen_fn,
        )

        if (
            identifier in ("before_configured", "after_configured")
            and target is not mapperlib.Mapper
        ):
            util.warn(
                "'before_configured' and 'after_configured' ORM events "
                "only invoke with the Mapper class "
                "as the target."
            )

        if not raw or not retval:
            if not raw:
                meth = getattr(cls, identifier)
                try:
                    target_index = (
                        inspect_getfullargspec(meth)[0].index("target") - 1
                    )
                except ValueError:
                    target_index = None

            def wrap(*arg: Any, **kw: Any) -> Any:
                if not raw and target_index is not None:
                    arg = list(arg)  
                    arg[target_index] = arg[target_index].obj()  
                if not retval:
                    fn(*arg, **kw)
                    return interfaces.EXT_CONTINUE
                else:
                    return fn(*arg, **kw)

            event_key = event_key.with_wrapper(wrap)

        if propagate:
            for mapper in target.self_and_descendants:
                event_key.with_dispatch_target(mapper).base_listen(
                    propagate=True, **kw
                )
        else:
            event_key.base_listen(**kw)

    @classmethod
    def _clear(cls) -> None:
        super()._clear()
        _MapperEventsHold._clear()

    def instrument_class(self, mapper: Mapper[_O], class_: Type[_O]) -> None:
        r

    def after_mapper_constructed(
        self, mapper: Mapper[_O], class_: Type[_O]
    ) -> None:
        

    def before_mapper_configured(
        self, mapper: Mapper[_O], class_: Type[_O]
    ) -> None:
        

    def mapper_configured(self, mapper: Mapper[_O], class_: Type[_O]) -> None:
        r
        

    def before_configured(self) -> None:
        

    def after_configured(self) -> None:
        

    def before_insert(
        self, mapper: Mapper[_O], connection: Connection, target: _O
    ) -> None:
        

    def after_insert(
        self, mapper: Mapper[_O], connection: Connection, target: _O
    ) -> None:
        

    def before_update(
        self, mapper: Mapper[_O], connection: Connection, target: _O
    ) -> None:
        

    def after_update(
        self, mapper: Mapper[_O], connection: Connection, target: _O
    ) -> None:
        

    def before_delete(
        self, mapper: Mapper[_O], connection: Connection, target: _O
    ) -> None:
        

    def after_delete(
        self, mapper: Mapper[_O], connection: Connection, target: _O
    ) -> None:
        


class _MapperEventsHold(_EventsHold[_ET]):
    all_holds = weakref.WeakKeyDictionary()

    def resolve(
        self, class_: Union[Type[_T], _InternalEntityType[_T]]
    ) -> Optional[Mapper[_T]]:
        return _mapper_or_none(class_)

    class HoldMapperEvents(_EventsHold.HoldEvents[_ET], MapperEvents):  
        pass

    dispatch = event.dispatcher(HoldMapperEvents)


_sessionevents_lifecycle_event_names: Set[str] = set()


class SessionEvents(event.Events[Session]):
    

    _target_class_doc = "SomeSessionClassOrObject"

    _dispatch_target = Session

    def _lifecycle_event(  
        fn: Callable[[SessionEvents, Session, Any], None],
    ) -> Callable[[SessionEvents, Session, Any], None]:
        _sessionevents_lifecycle_event_names.add(fn.__name__)
        return fn

    @classmethod
    def _accept_with(  
        cls, target: Any, identifier: str
    ) -> Union[Session, type]:
        if isinstance(target, scoped_session):
            target = target.session_factory
            if not isinstance(target, sessionmaker) and (
                not isinstance(target, type) or not issubclass(target, Session)
            ):
                raise exc.ArgumentError(
                    "Session event listen on a scoped_session "
                    "requires that its creation callable "
                    "is associated with the Session class."
                )

        if isinstance(target, sessionmaker):
            return target.class_
        elif isinstance(target, type):
            if issubclass(target, scoped_session):
                return Session
            elif issubclass(target, Session):
                return target
        elif isinstance(target, Session):
            return target
        elif hasattr(target, "_no_async_engine_events"):
            target._no_async_engine_events()
        else:
            
            return event.Events._accept_with(target, identifier)  

    @classmethod
    def _listen(
        cls,
        event_key: Any,
        *,
        raw: bool = False,
        restore_load_context: bool = False,
        **kw: Any,
    ) -> None:
        is_instance_event = (
            event_key.identifier in _sessionevents_lifecycle_event_names
        )

        if is_instance_event:
            if not raw or restore_load_context:
                fn = event_key._listen_fn

                def wrap(
                    session: Session,
                    state: InstanceState[_O],
                    *arg: Any,
                    **kw: Any,
                ) -> Optional[Any]:
                    if not raw:
                        target = state.obj()
                        if target is None:
                            
                            
                            return None
                    else:
                        target = state  
                    if restore_load_context:
                        runid = state.runid
                    try:
                        return fn(session, target, *arg, **kw)
                    finally:
                        if restore_load_context:
                            state.runid = runid

                event_key = event_key.with_wrapper(wrap)

        event_key.base_listen(**kw)

    def do_orm_execute(self, orm_execute_state: ORMExecuteState) -> None:
        

    def after_transaction_create(
        self, session: Session, transaction: SessionTransaction
    ) -> None:
        

    def after_transaction_end(
        self, session: Session, transaction: SessionTransaction
    ) -> None:
        

    def before_commit(self, session: Session) -> None:
        

    def after_commit(self, session: Session) -> None:
        

    def after_rollback(self, session: Session) -> None:
        

    def after_soft_rollback(
        self, session: Session, previous_transaction: SessionTransaction
    ) -> None:
        

    def before_flush(
        self,
        session: Session,
        flush_context: UOWTransaction,
        instances: Optional[Sequence[_O]],
    ) -> None:
        

    def after_flush(
        self, session: Session, flush_context: UOWTransaction
    ) -> None:
        

    def after_flush_postexec(
        self, session: Session, flush_context: UOWTransaction
    ) -> None:
        

    def after_begin(
        self,
        session: Session,
        transaction: SessionTransaction,
        connection: Connection,
    ) -> None:
        

    @_lifecycle_event
    def before_attach(self, session: Session, instance: _O) -> None:
        

    @_lifecycle_event
    def after_attach(self, session: Session, instance: _O) -> None:
        

    @event._legacy_signature(
        "0.9",
        ["session", "query", "query_context", "result"],
        lambda update_context: (
            update_context.session,
            update_context.query,
            None,
            update_context.result,
        ),
    )
    def after_bulk_update(self, update_context: _O) -> None:
        

    @event._legacy_signature(
        "0.9",
        ["session", "query", "query_context", "result"],
        lambda delete_context: (
            delete_context.session,
            delete_context.query,
            None,
            delete_context.result,
        ),
    )
    def after_bulk_delete(self, delete_context: _O) -> None:
        

    @_lifecycle_event
    def transient_to_pending(self, session: Session, instance: _O) -> None:
        

    @_lifecycle_event
    def pending_to_transient(self, session: Session, instance: _O) -> None:
        

    @_lifecycle_event
    def persistent_to_transient(self, session: Session, instance: _O) -> None:
        

    @_lifecycle_event
    def pending_to_persistent(self, session: Session, instance: _O) -> None:
        

    @_lifecycle_event
    def detached_to_persistent(self, session: Session, instance: _O) -> None:
        

    @_lifecycle_event
    def loaded_as_persistent(self, session: Session, instance: _O) -> None:
        

    @_lifecycle_event
    def persistent_to_deleted(self, session: Session, instance: _O) -> None:
        

    @_lifecycle_event
    def deleted_to_persistent(self, session: Session, instance: _O) -> None:
        

    @_lifecycle_event
    def deleted_to_detached(self, session: Session, instance: _O) -> None:
        

    @_lifecycle_event
    def persistent_to_detached(self, session: Session, instance: _O) -> None:
        


class AttributeEvents(event.Events[QueryableAttribute[Any]]):
    r

    _target_class_doc = "SomeClass.some_attribute"
    _dispatch_target = QueryableAttribute

    @staticmethod
    def _set_dispatch(
        cls: Type[_HasEventsDispatch[Any]], dispatch_cls: Type[_Dispatch[Any]]
    ) -> _Dispatch[Any]:
        dispatch = event.Events._set_dispatch(cls, dispatch_cls)
        dispatch_cls._active_history = False
        return dispatch

    @classmethod
    def _accept_with(
        cls,
        target: Union[QueryableAttribute[Any], Type[QueryableAttribute[Any]]],
        identifier: str,
    ) -> Union[QueryableAttribute[Any], Type[QueryableAttribute[Any]]]:
        
        if isinstance(target, interfaces.MapperProperty):
            return getattr(target.parent.class_, target.key)
        else:
            return target

    @classmethod
    def _listen(  
        cls,
        event_key: _EventKey[QueryableAttribute[Any]],
        active_history: bool = False,
        raw: bool = False,
        retval: bool = False,
        propagate: bool = False,
        include_key: bool = False,
    ) -> None:
        target, fn = event_key.dispatch_target, event_key._listen_fn

        if active_history:
            target.dispatch._active_history = True

        if not raw or not retval or not include_key:

            def wrap(target: InstanceState[_O], *arg: Any, **kw: Any) -> Any:
                if not raw:
                    target = target.obj()  
                if not retval:
                    if arg:
                        value = arg[0]
                    else:
                        value = None
                    if include_key:
                        fn(target, *arg, **kw)
                    else:
                        fn(target, *arg)
                    return value
                else:
                    if include_key:
                        return fn(target, *arg, **kw)
                    else:
                        return fn(target, *arg)

            event_key = event_key.with_wrapper(wrap)

        event_key.base_listen(propagate=propagate)

        if propagate:
            manager = instrumentation.manager_of_class(target.class_)

            for mgr in manager.subclass_managers(True):  
                event_key.with_dispatch_target(mgr[target.key]).base_listen(
                    propagate=True
                )
                if active_history:
                    mgr[target.key].dispatch._active_history = True

    def append(
        self,
        target: _O,
        value: _T,
        initiator: Event,
        *,
        key: EventConstants = NO_KEY,
    ) -> Optional[_T]:
        

    def append_wo_mutation(
        self,
        target: _O,
        value: _T,
        initiator: Event,
        *,
        key: EventConstants = NO_KEY,
    ) -> None:
        

    def bulk_replace(
        self,
        target: _O,
        values: Iterable[_T],
        initiator: Event,
        *,
        keys: Optional[Iterable[EventConstants]] = None,
    ) -> None:
        

    def remove(
        self,
        target: _O,
        value: _T,
        initiator: Event,
        *,
        key: EventConstants = NO_KEY,
    ) -> None:
        

    def set(
        self, target: _O, value: _T, oldvalue: _T, initiator: Event
    ) -> None:
        

    def init_scalar(
        self, target: _O, value: _T, dict_: Dict[Any, Any]
    ) -> None:
        r  

    def init_collection(
        self,
        target: _O,
        collection: Type[Collection[Any]],
        collection_adapter: CollectionAdapter,
    ) -> None:
        

    def dispose_collection(
        self,
        target: _O,
        collection: Collection[Any],
        collection_adapter: CollectionAdapter,
    ) -> None:
        

    def modified(self, target: _O, initiator: Event) -> None:
        


class QueryEvents(event.Events[Query[Any]]):
    

    _target_class_doc = "SomeQuery"
    _dispatch_target = Query

    def before_compile(self, query: Query[Any]) -> None:
          

    def before_compile_update(
        self, query: Query[Any], update_context: BulkUpdate
    ) -> None:
          

    def before_compile_delete(
        self, query: Query[Any], delete_context: BulkDelete
    ) -> None:
        

    @classmethod
    def _listen(
        cls,
        event_key: _EventKey[_ET],
        retval: bool = False,
        bake_ok: bool = False,
        **kw: Any,
    ) -> None:
        fn = event_key._listen_fn

        if not retval:

            def wrap(*arg: Any, **kw: Any) -> Any:
                if not retval:
                    query = arg[0]
                    fn(*arg, **kw)
                    return query
                else:
                    return fn(*arg, **kw)

            event_key = event_key.with_wrapper(wrap)
        else:
            
            def wrap(*arg: Any, **kw: Any) -> Any:
                return fn(*arg, **kw)

            event_key = event_key.with_wrapper(wrap)

        wrap._bake_ok = bake_ok  

        event_key.base_listen(**kw)
