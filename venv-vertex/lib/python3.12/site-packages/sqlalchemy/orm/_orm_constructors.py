






from __future__ import annotations

import typing
from typing import Any
from typing import Callable
from typing import Collection
from typing import Iterable
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Type
from typing import TYPE_CHECKING
from typing import Union

from . import mapperlib as mapperlib
from ._typing import _O
from .descriptor_props import Composite
from .descriptor_props import Synonym
from .interfaces import _AttributeOptions
from .properties import MappedColumn
from .properties import MappedSQLExpression
from .query import AliasOption
from .relationships import _RelationshipArgumentType
from .relationships import _RelationshipDeclared
from .relationships import _RelationshipSecondaryArgument
from .relationships import RelationshipProperty
from .session import Session
from .util import _ORMJoin
from .util import AliasedClass
from .util import AliasedInsp
from .util import LoaderCriteriaOption
from .. import sql
from .. import util
from ..exc import InvalidRequestError
from ..sql._typing import _no_kw
from ..sql.base import _NoArg
from ..sql.base import SchemaEventTarget
from ..sql.schema import _InsertSentinelColumnDefault
from ..sql.schema import SchemaConst
from ..sql.selectable import FromClause
from ..util.typing import Annotated
from ..util.typing import Literal

if TYPE_CHECKING:
    from ._typing import _EntityType
    from ._typing import _ORMColumnExprArgument
    from .descriptor_props import _CC
    from .descriptor_props import _CompositeAttrType
    from .interfaces import PropComparator
    from .mapper import Mapper
    from .query import Query
    from .relationships import _LazyLoadArgumentType
    from .relationships import _ORMColCollectionArgument
    from .relationships import _ORMOrderByArgument
    from .relationships import _RelationshipJoinConditionArgument
    from .relationships import ORMBackrefArgument
    from .session import _SessionBind
    from ..sql._typing import _AutoIncrementType
    from ..sql._typing import _ColumnExpressionArgument
    from ..sql._typing import _FromClauseArgument
    from ..sql._typing import _InfoType
    from ..sql._typing import _OnClauseArgument
    from ..sql._typing import _TypeEngineArgument
    from ..sql.elements import ColumnElement
    from ..sql.schema import _ServerDefaultArgument
    from ..sql.schema import _ServerOnUpdateArgument
    from ..sql.selectable import Alias
    from ..sql.selectable import Subquery


_T = typing.TypeVar("_T")


@util.deprecated(
    "1.4",
    "The :class:`.AliasOption` object is not necessary "
    "for entities to be matched up to a query that is established "
    "via :meth:`.Query.from_statement` and now does nothing.",
    enable_warnings=False,  
)
def contains_alias(alias: Union[Alias, Subquery]) -> AliasOption:
    r
    return AliasOption(alias)


def mapped_column(
    __name_pos: Optional[
        Union[str, _TypeEngineArgument[Any], SchemaEventTarget]
    ] = None,
    __type_pos: Optional[
        Union[_TypeEngineArgument[Any], SchemaEventTarget]
    ] = None,
    *args: SchemaEventTarget,
    init: Union[_NoArg, bool] = _NoArg.NO_ARG,
    repr: Union[_NoArg, bool] = _NoArg.NO_ARG,  
    default: Optional[Any] = _NoArg.NO_ARG,
    default_factory: Union[_NoArg, Callable[[], _T]] = _NoArg.NO_ARG,
    compare: Union[_NoArg, bool] = _NoArg.NO_ARG,
    kw_only: Union[_NoArg, bool] = _NoArg.NO_ARG,
    hash: Union[_NoArg, bool, None] = _NoArg.NO_ARG,  
    nullable: Optional[
        Union[bool, Literal[SchemaConst.NULL_UNSPECIFIED]]
    ] = SchemaConst.NULL_UNSPECIFIED,
    primary_key: Optional[bool] = False,
    deferred: Union[_NoArg, bool] = _NoArg.NO_ARG,
    deferred_group: Optional[str] = None,
    deferred_raiseload: Optional[bool] = None,
    use_existing_column: bool = False,
    name: Optional[str] = None,
    type_: Optional[_TypeEngineArgument[Any]] = None,
    autoincrement: _AutoIncrementType = "auto",
    doc: Optional[str] = None,
    key: Optional[str] = None,
    index: Optional[bool] = None,
    unique: Optional[bool] = None,
    info: Optional[_InfoType] = None,
    onupdate: Optional[Any] = None,
    insert_default: Optional[Any] = _NoArg.NO_ARG,
    server_default: Optional[_ServerDefaultArgument] = None,
    server_onupdate: Optional[_ServerOnUpdateArgument] = None,
    active_history: bool = False,
    quote: Optional[bool] = None,
    system: bool = False,
    comment: Optional[str] = None,
    sort_order: Union[_NoArg, int] = _NoArg.NO_ARG,
    dataclass_metadata: Union[_NoArg, Mapping[Any, Any], None] = _NoArg.NO_ARG,
    **kw: Any,
) -> MappedColumn[Any]:
    r

    return MappedColumn(
        __name_pos,
        __type_pos,
        *args,
        name=name,
        type_=type_,
        autoincrement=autoincrement,
        insert_default=insert_default,
        attribute_options=_AttributeOptions(
            init,
            repr,
            default,
            default_factory,
            compare,
            kw_only,
            hash,
            dataclass_metadata,
        ),
        doc=doc,
        key=key,
        index=index,
        unique=unique,
        info=info,
        active_history=active_history,
        nullable=nullable,
        onupdate=onupdate,
        primary_key=primary_key,
        server_default=server_default,
        server_onupdate=server_onupdate,
        use_existing_column=use_existing_column,
        quote=quote,
        comment=comment,
        system=system,
        deferred=deferred,
        deferred_group=deferred_group,
        deferred_raiseload=deferred_raiseload,
        sort_order=sort_order,
        **kw,
    )


def orm_insert_sentinel(
    name: Optional[str] = None,
    type_: Optional[_TypeEngineArgument[Any]] = None,
    *,
    default: Optional[Any] = None,
    omit_from_statements: bool = True,
) -> MappedColumn[Any]:
    

    return mapped_column(
        name=name,
        default=(
            default if default is not None else _InsertSentinelColumnDefault()
        ),
        _omit_from_statements=omit_from_statements,
        insert_sentinel=True,
        use_existing_column=True,
        nullable=True,
    )


@util.deprecated_params(
    **{
        arg: (
            "2.0",
            f"The :paramref:`_orm.column_property.{arg}` parameter is "
            "deprecated for :func:`_orm.column_property`.  This parameter "
            "applies to a writeable-attribute in a Declarative Dataclasses "
            "configuration only, and :func:`_orm.column_property` is treated "
            "as a read-only attribute in this context.",
        )
        for arg in ("init", "kw_only", "default", "default_factory")
    }
)
def column_property(
    column: _ORMColumnExprArgument[_T],
    *additional_columns: _ORMColumnExprArgument[Any],
    group: Optional[str] = None,
    deferred: bool = False,
    raiseload: bool = False,
    comparator_factory: Optional[Type[PropComparator[_T]]] = None,
    init: Union[_NoArg, bool] = _NoArg.NO_ARG,
    repr: Union[_NoArg, bool] = _NoArg.NO_ARG,  
    default: Optional[Any] = _NoArg.NO_ARG,
    default_factory: Union[_NoArg, Callable[[], _T]] = _NoArg.NO_ARG,
    compare: Union[_NoArg, bool] = _NoArg.NO_ARG,
    kw_only: Union[_NoArg, bool] = _NoArg.NO_ARG,
    hash: Union[_NoArg, bool, None] = _NoArg.NO_ARG,  
    active_history: bool = False,
    expire_on_flush: bool = True,
    info: Optional[_InfoType] = None,
    doc: Optional[str] = None,
    dataclass_metadata: Union[_NoArg, Mapping[Any, Any], None] = _NoArg.NO_ARG,
) -> MappedSQLExpression[_T]:
    r
    return MappedSQLExpression(
        column,
        *additional_columns,
        attribute_options=_AttributeOptions(
            False if init is _NoArg.NO_ARG else init,
            repr,
            default,
            default_factory,
            compare,
            kw_only,
            hash,
            dataclass_metadata,
        ),
        group=group,
        deferred=deferred,
        raiseload=raiseload,
        comparator_factory=comparator_factory,
        active_history=active_history,
        expire_on_flush=expire_on_flush,
        info=info,
        doc=doc,
        _assume_readonly_dc_attributes=True,
    )


@overload
def composite(
    _class_or_attr: _CompositeAttrType[Any],
    *attrs: _CompositeAttrType[Any],
    group: Optional[str] = None,
    deferred: bool = False,
    raiseload: bool = False,
    comparator_factory: Optional[Type[Composite.Comparator[_T]]] = None,
    active_history: bool = False,
    init: Union[_NoArg, bool] = _NoArg.NO_ARG,
    repr: Union[_NoArg, bool] = _NoArg.NO_ARG,  
    default: Optional[Any] = _NoArg.NO_ARG,
    default_factory: Union[_NoArg, Callable[[], _T]] = _NoArg.NO_ARG,
    compare: Union[_NoArg, bool] = _NoArg.NO_ARG,
    kw_only: Union[_NoArg, bool] = _NoArg.NO_ARG,
    hash: Union[_NoArg, bool, None] = _NoArg.NO_ARG,  
    info: Optional[_InfoType] = None,
    doc: Optional[str] = None,
    dataclass_metadata: Union[_NoArg, Mapping[Any, Any], None] = _NoArg.NO_ARG,
    **__kw: Any,
) -> Composite[Any]: ...


@overload
def composite(
    _class_or_attr: Type[_CC],
    *attrs: _CompositeAttrType[Any],
    group: Optional[str] = None,
    deferred: bool = False,
    raiseload: bool = False,
    comparator_factory: Optional[Type[Composite.Comparator[_T]]] = None,
    active_history: bool = False,
    init: Union[_NoArg, bool] = _NoArg.NO_ARG,
    repr: Union[_NoArg, bool] = _NoArg.NO_ARG,  
    default: Optional[Any] = _NoArg.NO_ARG,
    default_factory: Union[_NoArg, Callable[[], _T]] = _NoArg.NO_ARG,
    compare: Union[_NoArg, bool] = _NoArg.NO_ARG,
    kw_only: Union[_NoArg, bool] = _NoArg.NO_ARG,
    hash: Union[_NoArg, bool, None] = _NoArg.NO_ARG,  
    info: Optional[_InfoType] = None,
    doc: Optional[str] = None,
    **__kw: Any,
) -> Composite[_CC]: ...


@overload
def composite(
    _class_or_attr: Callable[..., _CC],
    *attrs: _CompositeAttrType[Any],
    group: Optional[str] = None,
    deferred: bool = False,
    raiseload: bool = False,
    comparator_factory: Optional[Type[Composite.Comparator[_T]]] = None,
    active_history: bool = False,
    init: Union[_NoArg, bool] = _NoArg.NO_ARG,
    repr: Union[_NoArg, bool] = _NoArg.NO_ARG,  
    default: Optional[Any] = _NoArg.NO_ARG,
    default_factory: Union[_NoArg, Callable[[], _T]] = _NoArg.NO_ARG,
    compare: Union[_NoArg, bool] = _NoArg.NO_ARG,
    kw_only: Union[_NoArg, bool] = _NoArg.NO_ARG,
    hash: Union[_NoArg, bool, None] = _NoArg.NO_ARG,  
    info: Optional[_InfoType] = None,
    doc: Optional[str] = None,
    **__kw: Any,
) -> Composite[_CC]: ...


def composite(
    _class_or_attr: Union[
        None, Type[_CC], Callable[..., _CC], _CompositeAttrType[Any]
    ] = None,
    *attrs: _CompositeAttrType[Any],
    group: Optional[str] = None,
    deferred: bool = False,
    raiseload: bool = False,
    comparator_factory: Optional[Type[Composite.Comparator[_T]]] = None,
    active_history: bool = False,
    init: Union[_NoArg, bool] = _NoArg.NO_ARG,
    repr: Union[_NoArg, bool] = _NoArg.NO_ARG,  
    default: Optional[Any] = _NoArg.NO_ARG,
    default_factory: Union[_NoArg, Callable[[], _T]] = _NoArg.NO_ARG,
    compare: Union[_NoArg, bool] = _NoArg.NO_ARG,
    kw_only: Union[_NoArg, bool] = _NoArg.NO_ARG,
    hash: Union[_NoArg, bool, None] = _NoArg.NO_ARG,  
    info: Optional[_InfoType] = None,
    doc: Optional[str] = None,
    dataclass_metadata: Union[_NoArg, Mapping[Any, Any], None] = _NoArg.NO_ARG,
    **__kw: Any,
) -> Composite[Any]:
    r
    if __kw:
        raise _no_kw()

    return Composite(
        _class_or_attr,
        *attrs,
        attribute_options=_AttributeOptions(
            init,
            repr,
            default,
            default_factory,
            compare,
            kw_only,
            hash,
            dataclass_metadata,
        ),
        group=group,
        deferred=deferred,
        raiseload=raiseload,
        comparator_factory=comparator_factory,
        active_history=active_history,
        info=info,
        doc=doc,
    )


def with_loader_criteria(
    entity_or_base: _EntityType[Any],
    where_criteria: Union[
        _ColumnExpressionArgument[bool],
        Callable[[Any], _ColumnExpressionArgument[bool]],
    ],
    loader_only: bool = False,
    include_aliases: bool = False,
    propagate_to_loaders: bool = True,
    track_closure_variables: bool = True,
) -> LoaderCriteriaOption:
      
    return LoaderCriteriaOption(
        entity_or_base,
        where_criteria,
        loader_only,
        include_aliases,
        propagate_to_loaders,
        track_closure_variables,
    )


def relationship(
    argument: Optional[_RelationshipArgumentType[Any]] = None,
    secondary: Optional[_RelationshipSecondaryArgument] = None,
    *,
    uselist: Optional[bool] = None,
    collection_class: Optional[
        Union[Type[Collection[Any]], Callable[[], Collection[Any]]]
    ] = None,
    primaryjoin: Optional[_RelationshipJoinConditionArgument] = None,
    secondaryjoin: Optional[_RelationshipJoinConditionArgument] = None,
    back_populates: Optional[str] = None,
    order_by: _ORMOrderByArgument = False,
    backref: Optional[ORMBackrefArgument] = None,
    overlaps: Optional[str] = None,
    post_update: bool = False,
    cascade: str = "save-update, merge",
    viewonly: bool = False,
    init: Union[_NoArg, bool] = _NoArg.NO_ARG,
    repr: Union[_NoArg, bool] = _NoArg.NO_ARG,  
    default: Union[_NoArg, _T] = _NoArg.NO_ARG,
    default_factory: Union[_NoArg, Callable[[], _T]] = _NoArg.NO_ARG,
    compare: Union[_NoArg, bool] = _NoArg.NO_ARG,
    kw_only: Union[_NoArg, bool] = _NoArg.NO_ARG,
    hash: Union[_NoArg, bool, None] = _NoArg.NO_ARG,  
    lazy: _LazyLoadArgumentType = "select",
    passive_deletes: Union[Literal["all"], bool] = False,
    passive_updates: bool = True,
    active_history: bool = False,
    enable_typechecks: bool = True,
    foreign_keys: Optional[_ORMColCollectionArgument] = None,
    remote_side: Optional[_ORMColCollectionArgument] = None,
    join_depth: Optional[int] = None,
    comparator_factory: Optional[
        Type[RelationshipProperty.Comparator[Any]]
    ] = None,
    single_parent: bool = False,
    innerjoin: bool = False,
    distinct_target_key: Optional[bool] = None,
    load_on_pending: bool = False,
    query_class: Optional[Type[Query[Any]]] = None,
    info: Optional[_InfoType] = None,
    omit_join: Literal[None, False] = None,
    sync_backref: Optional[bool] = None,
    dataclass_metadata: Union[_NoArg, Mapping[Any, Any], None] = _NoArg.NO_ARG,
    **kw: Any,
) -> _RelationshipDeclared[Any]:
    

    return _RelationshipDeclared(
        argument,
        secondary=secondary,
        uselist=uselist,
        collection_class=collection_class,
        primaryjoin=primaryjoin,
        secondaryjoin=secondaryjoin,
        back_populates=back_populates,
        order_by=order_by,
        backref=backref,
        overlaps=overlaps,
        post_update=post_update,
        cascade=cascade,
        viewonly=viewonly,
        attribute_options=_AttributeOptions(
            init,
            repr,
            default,
            default_factory,
            compare,
            kw_only,
            hash,
            dataclass_metadata,
        ),
        lazy=lazy,
        passive_deletes=passive_deletes,
        passive_updates=passive_updates,
        active_history=active_history,
        enable_typechecks=enable_typechecks,
        foreign_keys=foreign_keys,
        remote_side=remote_side,
        join_depth=join_depth,
        comparator_factory=comparator_factory,
        single_parent=single_parent,
        innerjoin=innerjoin,
        distinct_target_key=distinct_target_key,
        load_on_pending=load_on_pending,
        query_class=query_class,
        info=info,
        omit_join=omit_join,
        sync_backref=sync_backref,
        **kw,
    )


def synonym(
    name: str,
    *,
    map_column: Optional[bool] = None,
    descriptor: Optional[Any] = None,
    comparator_factory: Optional[Type[PropComparator[_T]]] = None,
    init: Union[_NoArg, bool] = _NoArg.NO_ARG,
    repr: Union[_NoArg, bool] = _NoArg.NO_ARG,  
    default: Union[_NoArg, _T] = _NoArg.NO_ARG,
    default_factory: Union[_NoArg, Callable[[], _T]] = _NoArg.NO_ARG,
    compare: Union[_NoArg, bool] = _NoArg.NO_ARG,
    kw_only: Union[_NoArg, bool] = _NoArg.NO_ARG,
    hash: Union[_NoArg, bool, None] = _NoArg.NO_ARG,  
    info: Optional[_InfoType] = None,
    doc: Optional[str] = None,
    dataclass_metadata: Union[_NoArg, Mapping[Any, Any], None] = _NoArg.NO_ARG,
) -> Synonym[Any]:
    
    return Synonym(
        name,
        map_column=map_column,
        descriptor=descriptor,
        comparator_factory=comparator_factory,
        attribute_options=_AttributeOptions(
            init,
            repr,
            default,
            default_factory,
            compare,
            kw_only,
            hash,
            dataclass_metadata,
        ),
        doc=doc,
        info=info,
    )


def create_session(
    bind: Optional[_SessionBind] = None, **kwargs: Any
) -> Session:
    r

    kwargs.setdefault("autoflush", False)
    kwargs.setdefault("expire_on_commit", False)
    return Session(bind=bind, **kwargs)


def _mapper_fn(*arg: Any, **kw: Any) -> NoReturn:
    
    raise InvalidRequestError(
        "The 'sqlalchemy.orm.mapper()' function is removed as of "
        "SQLAlchemy 2.0.  Use the "
        "'sqlalchemy.orm.registry.map_imperatively()` "
        "method of the ``sqlalchemy.orm.registry`` class to perform "
        "classical mapping."
    )


def dynamic_loader(
    argument: Optional[_RelationshipArgumentType[Any]] = None, **kw: Any
) -> RelationshipProperty[Any]:
    
    kw["lazy"] = "dynamic"
    return relationship(argument, **kw)


def backref(name: str, **kwargs: Any) -> ORMBackrefArgument:
      

    return (name, kwargs)


def deferred(
    column: _ORMColumnExprArgument[_T],
    *additional_columns: _ORMColumnExprArgument[Any],
    group: Optional[str] = None,
    raiseload: bool = False,
    comparator_factory: Optional[Type[PropComparator[_T]]] = None,
    init: Union[_NoArg, bool] = _NoArg.NO_ARG,
    repr: Union[_NoArg, bool] = _NoArg.NO_ARG,  
    default: Optional[Any] = _NoArg.NO_ARG,
    default_factory: Union[_NoArg, Callable[[], _T]] = _NoArg.NO_ARG,
    compare: Union[_NoArg, bool] = _NoArg.NO_ARG,
    kw_only: Union[_NoArg, bool] = _NoArg.NO_ARG,
    hash: Union[_NoArg, bool, None] = _NoArg.NO_ARG,  
    active_history: bool = False,
    expire_on_flush: bool = True,
    info: Optional[_InfoType] = None,
    doc: Optional[str] = None,
    dataclass_metadata: Union[_NoArg, Mapping[Any, Any], None] = _NoArg.NO_ARG,
) -> MappedSQLExpression[_T]:
    r
    return MappedSQLExpression(
        column,
        *additional_columns,
        attribute_options=_AttributeOptions(
            init,
            repr,
            default,
            default_factory,
            compare,
            kw_only,
            hash,
            dataclass_metadata,
        ),
        group=group,
        deferred=True,
        raiseload=raiseload,
        comparator_factory=comparator_factory,
        active_history=active_history,
        expire_on_flush=expire_on_flush,
        info=info,
        doc=doc,
    )


def query_expression(
    default_expr: _ORMColumnExprArgument[_T] = sql.null(),
    *,
    repr: Union[_NoArg, bool] = _NoArg.NO_ARG,  
    compare: Union[_NoArg, bool] = _NoArg.NO_ARG,  
    expire_on_flush: bool = True,
    info: Optional[_InfoType] = None,
    doc: Optional[str] = None,
) -> MappedSQLExpression[_T]:
    
    prop = MappedSQLExpression(
        default_expr,
        attribute_options=_AttributeOptions(
            False,
            repr,
            _NoArg.NO_ARG,
            _NoArg.NO_ARG,
            compare,
            _NoArg.NO_ARG,
            _NoArg.NO_ARG,
            _NoArg.NO_ARG,
        ),
        expire_on_flush=expire_on_flush,
        info=info,
        doc=doc,
        _assume_readonly_dc_attributes=True,
    )

    prop.strategy_key = (("query_expression", True),)
    return prop


def clear_mappers() -> None:
    

    mapperlib._dispose_registries(mapperlib._all_registries(), False)






AliasedType = Annotated[Type[_O], "aliased"]


@overload
def aliased(
    element: Type[_O],
    alias: Optional[FromClause] = None,
    name: Optional[str] = None,
    flat: bool = False,
    adapt_on_names: bool = False,
) -> AliasedType[_O]: ...


@overload
def aliased(
    element: Union[AliasedClass[_O], Mapper[_O], AliasedInsp[_O]],
    alias: Optional[FromClause] = None,
    name: Optional[str] = None,
    flat: bool = False,
    adapt_on_names: bool = False,
) -> AliasedClass[_O]: ...


@overload
def aliased(
    element: FromClause,
    alias: None = None,
    name: Optional[str] = None,
    flat: bool = False,
    adapt_on_names: bool = False,
) -> FromClause: ...


def aliased(
    element: Union[_EntityType[_O], FromClause],
    alias: Optional[FromClause] = None,
    name: Optional[str] = None,
    flat: bool = False,
    adapt_on_names: bool = False,
) -> Union[AliasedClass[_O], FromClause, AliasedType[_O]]:
    
    return AliasedInsp._alias_factory(
        element,
        alias=alias,
        name=name,
        flat=flat,
        adapt_on_names=adapt_on_names,
    )


def with_polymorphic(
    base: Union[Type[_O], Mapper[_O]],
    classes: Union[Literal["*"], Iterable[Type[Any]]],
    selectable: Union[Literal[False, None], FromClause] = False,
    flat: bool = False,
    polymorphic_on: Optional[ColumnElement[Any]] = None,
    aliased: bool = False,
    innerjoin: bool = False,
    adapt_on_names: bool = False,
    name: Optional[str] = None,
    _use_mapper_path: bool = False,
) -> AliasedClass[_O]:
    
    return AliasedInsp._with_polymorphic_factory(
        base,
        classes,
        selectable=selectable,
        flat=flat,
        polymorphic_on=polymorphic_on,
        adapt_on_names=adapt_on_names,
        aliased=aliased,
        innerjoin=innerjoin,
        name=name,
        _use_mapper_path=_use_mapper_path,
    )


def join(
    left: _FromClauseArgument,
    right: _FromClauseArgument,
    onclause: Optional[_OnClauseArgument] = None,
    isouter: bool = False,
    full: bool = False,
) -> _ORMJoin:
    r
    return _ORMJoin(left, right, onclause, isouter, full)


def outerjoin(
    left: _FromClauseArgument,
    right: _FromClauseArgument,
    onclause: Optional[_OnClauseArgument] = None,
    full: bool = False,
) -> _ORMJoin:
    
    return _ORMJoin(left, right, onclause, True, full)
