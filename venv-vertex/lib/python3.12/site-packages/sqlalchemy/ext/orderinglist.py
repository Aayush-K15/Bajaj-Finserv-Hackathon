







from __future__ import annotations

from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterable
from typing import List
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Type
from typing import TypeVar
from typing import Union

from ..orm.collections import collection
from ..orm.collections import collection_adapter
from ..util.typing import SupportsIndex

_T = TypeVar("_T")
OrderingFunc = Callable[[int, Sequence[_T]], object]


__all__ = ["ordering_list"]


def ordering_list(
    attr: str,
    count_from: Optional[int] = None,
    ordering_func: Optional[OrderingFunc[_T]] = None,
    reorder_on_append: bool = False,
) -> Callable[[], OrderingList[_T]]:
    

    kw = _unsugar_count_from(
        count_from=count_from,
        ordering_func=ordering_func,
        reorder_on_append=reorder_on_append,
    )
    return lambda: OrderingList(attr, **kw)





def count_from_0(index: int, collection: object) -> int:
    

    return index


def count_from_1(index: int, collection: object) -> int:
    

    return index + 1


def count_from_n_factory(start: int) -> OrderingFunc[Any]:
    

    def f(index: int, collection: object) -> int:
        return index + start

    try:
        f.__name__ = "count_from_%i" % start
    except TypeError:
        pass
    return f


def _unsugar_count_from(**kw: Any) -> Dict[str, Any]:
    

    count_from = kw.pop("count_from", None)
    if kw.get("ordering_func", None) is None and count_from is not None:
        if count_from == 0:
            kw["ordering_func"] = count_from_0
        elif count_from == 1:
            kw["ordering_func"] = count_from_1
        else:
            kw["ordering_func"] = count_from_n_factory(count_from)
    return kw


class OrderingList(List[_T]):
    

    ordering_attr: str
    ordering_func: OrderingFunc[_T]
    reorder_on_append: bool

    def __init__(
        self,
        ordering_attr: str,
        ordering_func: Optional[OrderingFunc[_T]] = None,
        reorder_on_append: bool = False,
    ):
        
        self.ordering_attr = ordering_attr
        if ordering_func is None:
            ordering_func = count_from_0
        self.ordering_func = ordering_func
        self.reorder_on_append = reorder_on_append

    
    
    def _get_order_value(self, entity: _T) -> Any:
        return getattr(entity, self.ordering_attr)

    def _set_order_value(self, entity: _T, value: Any) -> None:
        setattr(entity, self.ordering_attr, value)

    def reorder(self) -> None:
        
        for index, entity in enumerate(self):
            self._order_entity(index, entity, True)

    
    _reorder = reorder

    def _order_entity(
        self, index: int, entity: _T, reorder: bool = True
    ) -> None:
        have = self._get_order_value(entity)

        
        if have is not None and not reorder:
            return

        should_be = self.ordering_func(index, self)
        if have != should_be:
            self._set_order_value(entity, should_be)

    def append(self, entity: _T) -> None:
        super().append(entity)
        self._order_entity(len(self) - 1, entity, self.reorder_on_append)

    def _raw_append(self, entity: _T) -> None:
        

        super().append(entity)

    _raw_append = collection.adds(1)(_raw_append)

    def insert(self, index: SupportsIndex, entity: _T) -> None:
        super().insert(index, entity)
        self._reorder()

    def remove(self, entity: _T) -> None:
        super().remove(entity)

        adapter = collection_adapter(self)
        if adapter and adapter._referenced_by_owner:
            self._reorder()

    def pop(self, index: SupportsIndex = -1) -> _T:
        entity = super().pop(index)
        self._reorder()
        return entity

    @overload
    def __setitem__(self, index: SupportsIndex, entity: _T) -> None: ...

    @overload
    def __setitem__(self, index: slice, entity: Iterable[_T]) -> None: ...

    def __setitem__(
        self,
        index: Union[SupportsIndex, slice],
        entity: Union[_T, Iterable[_T]],
    ) -> None:
        if isinstance(index, slice):
            step = index.step or 1
            start = index.start or 0
            if start < 0:
                start += len(self)
            stop = index.stop or len(self)
            if stop < 0:
                stop += len(self)
            entities = list(entity)  
            for i in range(start, stop, step):
                self.__setitem__(i, entities[i])
        else:
            self._order_entity(int(index), entity, True)  
            super().__setitem__(index, entity)  

    def __delitem__(self, index: Union[SupportsIndex, slice]) -> None:
        super().__delitem__(index)
        self._reorder()

    def __reduce__(self) -> Any:
        return _reconstitute, (self.__class__, self.__dict__, list(self))

    for func_name, func in list(locals().items()):
        if (
            callable(func)
            and func.__name__ == func_name
            and not func.__doc__
            and hasattr(list, func_name)
        ):
            func.__doc__ = getattr(list, func_name).__doc__
    del func_name, func


def _reconstitute(
    cls: Type[OrderingList[_T]], dict_: Dict[str, Any], items: List[_T]
) -> OrderingList[_T]:
    
    obj = cls.__new__(cls)
    obj.__dict__.update(dict_)
    list.extend(obj, items)
    return obj
