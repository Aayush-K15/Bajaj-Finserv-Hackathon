






r  
from __future__ import annotations

import dataclasses
from typing import Any
from typing import Callable
from typing import cast
from typing import ClassVar
from typing import Dict
from typing import List
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from .. import util
from ..orm import backref
from ..orm import declarative_base as _declarative_base
from ..orm import exc as orm_exc
from ..orm import interfaces
from ..orm import relationship
from ..orm.decl_base import _DeferredMapperConfig
from ..orm.mapper import _CONFIGURE_MUTEX
from ..schema import ForeignKeyConstraint
from ..sql import and_
from ..util import Properties
from ..util.typing import Protocol

if TYPE_CHECKING:
    from ..engine.base import Engine
    from ..orm.base import RelationshipDirection
    from ..orm.relationships import ORMBackrefArgument
    from ..orm.relationships import Relationship
    from ..sql.schema import Column
    from ..sql.schema import MetaData
    from ..sql.schema import Table
    from ..util import immutabledict


_KT = TypeVar("_KT", bound=Any)
_VT = TypeVar("_VT", bound=Any)


class PythonNameForTableType(Protocol):
    def __call__(
        self, base: Type[Any], tablename: str, table: Table
    ) -> str: ...


def classname_for_table(
    base: Type[Any],
    tablename: str,
    table: Table,
) -> str:
    
    return str(tablename)


class NameForScalarRelationshipType(Protocol):
    def __call__(
        self,
        base: Type[Any],
        local_cls: Type[Any],
        referred_cls: Type[Any],
        constraint: ForeignKeyConstraint,
    ) -> str: ...


def name_for_scalar_relationship(
    base: Type[Any],
    local_cls: Type[Any],
    referred_cls: Type[Any],
    constraint: ForeignKeyConstraint,
) -> str:
    
    return referred_cls.__name__.lower()


class NameForCollectionRelationshipType(Protocol):
    def __call__(
        self,
        base: Type[Any],
        local_cls: Type[Any],
        referred_cls: Type[Any],
        constraint: ForeignKeyConstraint,
    ) -> str: ...


def name_for_collection_relationship(
    base: Type[Any],
    local_cls: Type[Any],
    referred_cls: Type[Any],
    constraint: ForeignKeyConstraint,
) -> str:
    
    return referred_cls.__name__.lower() + "_collection"


class GenerateRelationshipType(Protocol):
    @overload
    def __call__(
        self,
        base: Type[Any],
        direction: RelationshipDirection,
        return_fn: Callable[..., Relationship[Any]],
        attrname: str,
        local_cls: Type[Any],
        referred_cls: Type[Any],
        **kw: Any,
    ) -> Relationship[Any]: ...

    @overload
    def __call__(
        self,
        base: Type[Any],
        direction: RelationshipDirection,
        return_fn: Callable[..., ORMBackrefArgument],
        attrname: str,
        local_cls: Type[Any],
        referred_cls: Type[Any],
        **kw: Any,
    ) -> ORMBackrefArgument: ...

    def __call__(
        self,
        base: Type[Any],
        direction: RelationshipDirection,
        return_fn: Union[
            Callable[..., Relationship[Any]], Callable[..., ORMBackrefArgument]
        ],
        attrname: str,
        local_cls: Type[Any],
        referred_cls: Type[Any],
        **kw: Any,
    ) -> Union[ORMBackrefArgument, Relationship[Any]]: ...


@overload
def generate_relationship(
    base: Type[Any],
    direction: RelationshipDirection,
    return_fn: Callable[..., Relationship[Any]],
    attrname: str,
    local_cls: Type[Any],
    referred_cls: Type[Any],
    **kw: Any,
) -> Relationship[Any]: ...


@overload
def generate_relationship(
    base: Type[Any],
    direction: RelationshipDirection,
    return_fn: Callable[..., ORMBackrefArgument],
    attrname: str,
    local_cls: Type[Any],
    referred_cls: Type[Any],
    **kw: Any,
) -> ORMBackrefArgument: ...


def generate_relationship(
    base: Type[Any],
    direction: RelationshipDirection,
    return_fn: Union[
        Callable[..., Relationship[Any]], Callable[..., ORMBackrefArgument]
    ],
    attrname: str,
    local_cls: Type[Any],
    referred_cls: Type[Any],
    **kw: Any,
) -> Union[Relationship[Any], ORMBackrefArgument]:
    r

    if return_fn is backref:
        return return_fn(attrname, **kw)
    elif return_fn is relationship:
        return return_fn(referred_cls, **kw)
    else:
        raise TypeError("Unknown relationship function: %s" % return_fn)


ByModuleProperties = Properties[Union["ByModuleProperties", Type[Any]]]


class AutomapBase:
    

    __abstract__ = True

    classes: ClassVar[Properties[Type[Any]]]
    

    by_module: ClassVar[ByModuleProperties]
    

    metadata: ClassVar[MetaData]
    

    _sa_automapbase_bookkeeping: ClassVar[_Bookkeeping]

    @classmethod
    @util.deprecated_params(
        engine=(
            "2.0",
            "The :paramref:`_automap.AutomapBase.prepare.engine` parameter "
            "is deprecated and will be removed in a future release.  "
            "Please use the "
            ":paramref:`_automap.AutomapBase.prepare.autoload_with` "
            "parameter.",
        ),
        reflect=(
            "2.0",
            "The :paramref:`_automap.AutomapBase.prepare.reflect` "
            "parameter is deprecated and will be removed in a future "
            "release.  Reflection is enabled when "
            ":paramref:`_automap.AutomapBase.prepare.autoload_with` "
            "is passed.",
        ),
    )
    def prepare(
        cls: Type[AutomapBase],
        autoload_with: Optional[Engine] = None,
        engine: Optional[Any] = None,
        reflect: bool = False,
        schema: Optional[str] = None,
        classname_for_table: Optional[PythonNameForTableType] = None,
        modulename_for_table: Optional[PythonNameForTableType] = None,
        collection_class: Optional[Any] = None,
        name_for_scalar_relationship: Optional[
            NameForScalarRelationshipType
        ] = None,
        name_for_collection_relationship: Optional[
            NameForCollectionRelationshipType
        ] = None,
        generate_relationship: Optional[GenerateRelationshipType] = None,
        reflection_options: Union[
            Dict[_KT, _VT], immutabledict[_KT, _VT]
        ] = util.EMPTY_DICT,
    ) -> None:
        

        for mr in cls.__mro__:
            if "_sa_automapbase_bookkeeping" in mr.__dict__:
                automap_base = cast("Type[AutomapBase]", mr)
                break
        else:
            assert False, "Can't locate automap base in class hierarchy"

        glbls = globals()
        if classname_for_table is None:
            classname_for_table = glbls["classname_for_table"]
        if name_for_scalar_relationship is None:
            name_for_scalar_relationship = glbls[
                "name_for_scalar_relationship"
            ]
        if name_for_collection_relationship is None:
            name_for_collection_relationship = glbls[
                "name_for_collection_relationship"
            ]
        if generate_relationship is None:
            generate_relationship = glbls["generate_relationship"]
        if collection_class is None:
            collection_class = list

        if autoload_with:
            reflect = True

        if engine:
            autoload_with = engine

        if reflect:
            assert autoload_with
            opts = dict(
                schema=schema,
                extend_existing=True,
                autoload_replace=False,
            )
            if reflection_options:
                opts.update(reflection_options)
            cls.metadata.reflect(autoload_with, **opts)  

        with _CONFIGURE_MUTEX:
            table_to_map_config: Union[
                Dict[Optional[Table], _DeferredMapperConfig],
                Dict[Table, _DeferredMapperConfig],
            ] = {
                cast("Table", m.local_table): m
                for m in _DeferredMapperConfig.classes_for_base(
                    cls, sort=False
                )
            }

            many_to_many: List[
                Tuple[Table, Table, List[ForeignKeyConstraint], Table]
            ]
            many_to_many = []

            bookkeeping = automap_base._sa_automapbase_bookkeeping
            metadata_tables = cls.metadata.tables

            for table_key in set(metadata_tables).difference(
                bookkeeping.table_keys
            ):
                table = metadata_tables[table_key]
                bookkeeping.table_keys.add(table_key)

                lcl_m2m, rem_m2m, m2m_const = _is_many_to_many(cls, table)
                if lcl_m2m is not None:
                    assert rem_m2m is not None
                    assert m2m_const is not None
                    many_to_many.append((lcl_m2m, rem_m2m, m2m_const, table))
                elif not table.primary_key:
                    continue
                elif table not in table_to_map_config:
                    clsdict: Dict[str, Any] = {"__table__": table}
                    if modulename_for_table is not None:
                        new_module = modulename_for_table(
                            cls, table.name, table
                        )
                        if new_module is not None:
                            clsdict["__module__"] = new_module
                    else:
                        new_module = None

                    newname = classname_for_table(cls, table.name, table)
                    if new_module is None and newname in cls.classes:
                        util.warn(
                            "Ignoring duplicate class name "
                            f"'{newname}' "
                            "received in automap base for table "
                            f"{table.key} without "
                            "``__module__`` being set; consider using the "
                            "``modulename_for_table`` hook"
                        )
                        continue

                    mapped_cls = type(
                        newname,
                        (automap_base,),
                        clsdict,
                    )
                    map_config = _DeferredMapperConfig.config_for_cls(
                        mapped_cls
                    )
                    assert map_config.cls.__name__ == newname
                    if new_module is None:
                        cls.classes[newname] = mapped_cls

                    by_module_properties: ByModuleProperties = cls.by_module
                    for token in map_config.cls.__module__.split("."):
                        if token not in by_module_properties:
                            by_module_properties[token] = util.Properties({})

                        props = by_module_properties[token]

                        
                        
                        
                        
                        assert isinstance(props, Properties)
                        by_module_properties = props

                    by_module_properties[map_config.cls.__name__] = mapped_cls

                    table_to_map_config[table] = map_config

            for map_config in table_to_map_config.values():
                _relationships_for_fks(
                    automap_base,
                    map_config,
                    table_to_map_config,
                    collection_class,
                    name_for_scalar_relationship,
                    name_for_collection_relationship,
                    generate_relationship,
                )

            for lcl_m2m, rem_m2m, m2m_const, table in many_to_many:
                _m2m_relationship(
                    automap_base,
                    lcl_m2m,
                    rem_m2m,
                    m2m_const,
                    table,
                    table_to_map_config,
                    collection_class,
                    name_for_scalar_relationship,
                    name_for_collection_relationship,
                    generate_relationship,
                )

            for map_config in _DeferredMapperConfig.classes_for_base(
                automap_base
            ):
                map_config.map()

    _sa_decl_prepare = True
    

    @classmethod
    def _sa_raise_deferred_config(cls) -> NoReturn:
        raise orm_exc.UnmappedClassError(
            cls,
            msg="Class %s is a subclass of AutomapBase.  "
            "Mappings are not produced until the .prepare() "
            "method is called on the class hierarchy."
            % orm_exc._safe_cls_name(cls),
        )


@dataclasses.dataclass
class _Bookkeeping:
    __slots__ = ("table_keys",)

    table_keys: Set[str]


def automap_base(
    declarative_base: Optional[Type[Any]] = None, **kw: Any
) -> Any:
    r
    if declarative_base is None:
        Base = _declarative_base(**kw)
    else:
        Base = declarative_base

    return type(
        Base.__name__,
        (AutomapBase, Base),
        {
            "__abstract__": True,
            "classes": util.Properties({}),
            "by_module": util.Properties({}),
            "_sa_automapbase_bookkeeping": _Bookkeeping(set()),
        },
    )


def _is_many_to_many(
    automap_base: Type[Any], table: Table
) -> Tuple[
    Optional[Table], Optional[Table], Optional[list[ForeignKeyConstraint]]
]:
    fk_constraints = [
        const
        for const in table.constraints
        if isinstance(const, ForeignKeyConstraint)
    ]
    if len(fk_constraints) != 2:
        return None, None, None

    cols: List[Column[Any]] = sum(
        [
            [fk.parent for fk in fk_constraint.elements]
            for fk_constraint in fk_constraints
        ],
        [],
    )

    if set(cols) != set(table.c):
        return None, None, None

    return (
        fk_constraints[0].elements[0].column.table,
        fk_constraints[1].elements[0].column.table,
        fk_constraints,
    )


def _relationships_for_fks(
    automap_base: Type[Any],
    map_config: _DeferredMapperConfig,
    table_to_map_config: Union[
        Dict[Optional[Table], _DeferredMapperConfig],
        Dict[Table, _DeferredMapperConfig],
    ],
    collection_class: type,
    name_for_scalar_relationship: NameForScalarRelationshipType,
    name_for_collection_relationship: NameForCollectionRelationshipType,
    generate_relationship: GenerateRelationshipType,
) -> None:
    local_table = cast("Optional[Table]", map_config.local_table)
    local_cls = cast(
        "Optional[Type[Any]]", map_config.cls
    )  

    if local_table is None or local_cls is None:
        return
    for constraint in local_table.constraints:
        if isinstance(constraint, ForeignKeyConstraint):
            fks = constraint.elements
            referred_table = fks[0].column.table
            referred_cfg = table_to_map_config.get(referred_table, None)
            if referred_cfg is None:
                continue
            referred_cls = referred_cfg.cls

            if local_cls is not referred_cls and issubclass(
                local_cls, referred_cls
            ):
                continue

            relationship_name = name_for_scalar_relationship(
                automap_base, local_cls, referred_cls, constraint
            )
            backref_name = name_for_collection_relationship(
                automap_base, referred_cls, local_cls, constraint
            )

            o2m_kws: Dict[str, Union[str, bool]] = {}
            nullable = False not in {fk.parent.nullable for fk in fks}
            if not nullable:
                o2m_kws["cascade"] = "all, delete-orphan"

                if (
                    constraint.ondelete
                    and constraint.ondelete.lower() == "cascade"
                ):
                    o2m_kws["passive_deletes"] = True
            else:
                if (
                    constraint.ondelete
                    and constraint.ondelete.lower() == "set null"
                ):
                    o2m_kws["passive_deletes"] = True

            create_backref = backref_name not in referred_cfg.properties

            if relationship_name not in map_config.properties:
                if create_backref:
                    backref_obj = generate_relationship(
                        automap_base,
                        interfaces.ONETOMANY,
                        backref,
                        backref_name,
                        referred_cls,
                        local_cls,
                        collection_class=collection_class,
                        **o2m_kws,
                    )
                else:
                    backref_obj = None
                rel = generate_relationship(
                    automap_base,
                    interfaces.MANYTOONE,
                    relationship,
                    relationship_name,
                    local_cls,
                    referred_cls,
                    foreign_keys=[fk.parent for fk in constraint.elements],
                    backref=backref_obj,
                    remote_side=[fk.column for fk in constraint.elements],
                )
                if rel is not None:
                    map_config.properties[relationship_name] = rel
                    if not create_backref:
                        referred_cfg.properties[
                            backref_name
                        ].back_populates = relationship_name  
            elif create_backref:
                rel = generate_relationship(
                    automap_base,
                    interfaces.ONETOMANY,
                    relationship,
                    backref_name,
                    referred_cls,
                    local_cls,
                    foreign_keys=[fk.parent for fk in constraint.elements],
                    back_populates=relationship_name,
                    collection_class=collection_class,
                    **o2m_kws,
                )
                if rel is not None:
                    referred_cfg.properties[backref_name] = rel
                    map_config.properties[
                        relationship_name
                    ].back_populates = backref_name  


def _m2m_relationship(
    automap_base: Type[Any],
    lcl_m2m: Table,
    rem_m2m: Table,
    m2m_const: List[ForeignKeyConstraint],
    table: Table,
    table_to_map_config: Union[
        Dict[Optional[Table], _DeferredMapperConfig],
        Dict[Table, _DeferredMapperConfig],
    ],
    collection_class: type,
    name_for_scalar_relationship: NameForCollectionRelationshipType,
    name_for_collection_relationship: NameForCollectionRelationshipType,
    generate_relationship: GenerateRelationshipType,
) -> None:
    map_config = table_to_map_config.get(lcl_m2m, None)
    referred_cfg = table_to_map_config.get(rem_m2m, None)
    if map_config is None or referred_cfg is None:
        return

    local_cls = map_config.cls
    referred_cls = referred_cfg.cls

    relationship_name = name_for_collection_relationship(
        automap_base, local_cls, referred_cls, m2m_const[0]
    )
    backref_name = name_for_collection_relationship(
        automap_base, referred_cls, local_cls, m2m_const[1]
    )

    create_backref = backref_name not in referred_cfg.properties

    if table in table_to_map_config:
        overlaps = "__*"
    else:
        overlaps = None

    if relationship_name not in map_config.properties:
        if create_backref:
            backref_obj = generate_relationship(
                automap_base,
                interfaces.MANYTOMANY,
                backref,
                backref_name,
                referred_cls,
                local_cls,
                collection_class=collection_class,
                overlaps=overlaps,
            )
        else:
            backref_obj = None

        rel = generate_relationship(
            automap_base,
            interfaces.MANYTOMANY,
            relationship,
            relationship_name,
            local_cls,
            referred_cls,
            overlaps=overlaps,
            secondary=table,
            primaryjoin=and_(
                fk.column == fk.parent for fk in m2m_const[0].elements
            ),  
            secondaryjoin=and_(
                fk.column == fk.parent for fk in m2m_const[1].elements
            ),  
            backref=backref_obj,
            collection_class=collection_class,
        )
        if rel is not None:
            map_config.properties[relationship_name] = rel

            if not create_backref:
                referred_cfg.properties[
                    backref_name
                ].back_populates = relationship_name  
    elif create_backref:
        rel = generate_relationship(
            automap_base,
            interfaces.MANYTOMANY,
            relationship,
            backref_name,
            referred_cls,
            local_cls,
            overlaps=overlaps,
            secondary=table,
            primaryjoin=and_(
                fk.column == fk.parent for fk in m2m_const[1].elements
            ),  
            secondaryjoin=and_(
                fk.column == fk.parent for fk in m2m_const[0].elements
            ),  
            back_populates=relationship_name,
            collection_class=collection_class,
        )
        if rel is not None:
            referred_cfg.properties[backref_name] = rel
            map_config.properties[
                relationship_name
            ].back_populates = backref_name  
