








from __future__ import annotations

import array
from dataclasses import dataclass
from enum import Enum
from typing import Optional

import sqlalchemy.types as types
from sqlalchemy.types import Float


class VectorIndexType(Enum):
    

    HNSW = "HNSW"
    
    IVF = "IVF"
    


class VectorDistanceType(Enum):
    

    EUCLIDEAN = "EUCLIDEAN"
    
    DOT = "DOT"
    
    COSINE = "COSINE"
    
    MANHATTAN = "MANHATTAN"
    


class VectorStorageFormat(Enum):
    

    INT8 = "INT8"
    
    BINARY = "BINARY"
    
    FLOAT32 = "FLOAT32"
    
    FLOAT64 = "FLOAT64"
    


@dataclass
class VectorIndexConfig:
    

    index_type: VectorIndexType = VectorIndexType.HNSW
    distance: Optional[VectorDistanceType] = None
    accuracy: Optional[int] = None
    hnsw_neighbors: Optional[int] = None
    hnsw_efconstruction: Optional[int] = None
    ivf_neighbor_partitions: Optional[int] = None
    ivf_sample_per_partition: Optional[int] = None
    ivf_min_vectors_per_partition: Optional[int] = None
    parallel: Optional[int] = None

    def __post_init__(self):
        self.index_type = VectorIndexType(self.index_type)
        for field in [
            "hnsw_neighbors",
            "hnsw_efconstruction",
            "ivf_neighbor_partitions",
            "ivf_sample_per_partition",
            "ivf_min_vectors_per_partition",
            "parallel",
            "accuracy",
        ]:
            value = getattr(self, field)
            if value is not None and not isinstance(value, int):
                raise TypeError(
                    f"{field} must be an integer if"
                    f"provided, got {type(value).__name__}"
                )


class VECTOR(types.TypeEngine):
    

    cache_ok = True
    __visit_name__ = "VECTOR"

    _typecode_map = {
        VectorStorageFormat.INT8: "b",  
        VectorStorageFormat.BINARY: "B",  
        VectorStorageFormat.FLOAT32: "f",  
        VectorStorageFormat.FLOAT64: "d",  
    }

    def __init__(self, dim=None, storage_format=None):
        
        if dim is not None and not isinstance(dim, int):
            raise TypeError("dim must be an interger")
        if storage_format is not None and not isinstance(
            storage_format, VectorStorageFormat
        ):
            raise TypeError(
                "storage_format must be an enum of type VectorStorageFormat"
            )
        self.dim = dim
        self.storage_format = storage_format

    def _cached_bind_processor(self, dialect):
        

        def process(value):
            if value is None or isinstance(value, array.array):
                return value

            
            elif isinstance(value, list):
                typecode = self._array_typecode(self.storage_format)
                value = array.array(typecode, value)
                return value

            else:
                raise TypeError("VECTOR accepts list or array.array()")

        return process

    def _cached_result_processor(self, dialect, coltype):
        

        def process(value):
            if isinstance(value, array.array):
                return list(value)

        return process

    def _array_typecode(self, typecode):
        
        return self._typecode_map.get(typecode, "d")

    class comparator_factory(types.TypeEngine.Comparator):
        def l2_distance(self, other):
            return self.op("<->", return_type=Float)(other)

        def inner_product(self, other):
            return self.op("<

        def cosine_distance(self, other):
            return self.op("<=>", return_type=Float)(other)
