







r  
from __future__ import annotations

import datetime
import re
from typing import Any
from typing import Callable
from typing import Optional
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

from .base import MySQLDialect
from .base import MySQLExecutionContext
from .types import TIME
from ... import exc
from ... import util
from ...connectors.pyodbc import PyODBCConnector
from ...sql.sqltypes import Time

if TYPE_CHECKING:
    from ...engine import Connection
    from ...engine.interfaces import DBAPIConnection
    from ...engine.interfaces import Dialect
    from ...sql.type_api import _ResultProcessorType


class _pyodbcTIME(TIME):
    def result_processor(
        self, dialect: Dialect, coltype: object
    ) -> _ResultProcessorType[datetime.time]:
        def process(value: Any) -> Union[datetime.time, None]:
            
            return value  

        return process


class MySQLExecutionContext_pyodbc(MySQLExecutionContext):
    def get_lastrowid(self) -> int:
        cursor = self.create_cursor()
        cursor.execute("SELECT LAST_INSERT_ID()")
        lastrowid = cursor.fetchone()[0]  
        cursor.close()
        return lastrowid  


class MySQLDialect_pyodbc(PyODBCConnector, MySQLDialect):
    supports_statement_cache = True
    colspecs = util.update_copy(MySQLDialect.colspecs, {Time: _pyodbcTIME})
    supports_unicode_statements = True
    execution_ctx_cls = MySQLExecutionContext_pyodbc

    pyodbc_driver_name = "MySQL"

    def _detect_charset(self, connection: Connection) -> str:
        

        
        
        
        
        
        

        
        self._connection_charset = None
        try:
            value = self._fetch_setting(connection, "character_set_client")
            if value:
                return value
        except exc.DBAPIError:
            pass

        util.warn(
            "Could not detect the connection character set.  "
            "Assuming latin1."
        )
        return "latin1"

    def _get_server_version_info(
        self, connection: Connection
    ) -> Tuple[int, ...]:
        return MySQLDialect._get_server_version_info(self, connection)

    def _extract_error_code(self, exception: BaseException) -> Optional[int]:
        m = re.compile(r"\((\d+)\)").search(str(exception.args))
        if m is None:
            return None
        c: Optional[str] = m.group(1)
        if c:
            return int(c)
        else:
            return None

    def on_connect(self) -> Callable[[DBAPIConnection], None]:
        super_ = super().on_connect()

        def on_connect(conn: DBAPIConnection) -> None:
            if super_ is not None:
                super_(conn)

            
            
            pyodbc_SQL_CHAR = 1  
            pyodbc_SQL_WCHAR = -8  
            conn.setdecoding(pyodbc_SQL_CHAR, encoding="utf-8")
            conn.setdecoding(pyodbc_SQL_WCHAR, encoding="utf-8")
            conn.setencoding(encoding="utf-8")

        return on_connect


dialect = MySQLDialect_pyodbc
