






from __future__ import annotations

import enum
import re
from typing import Any
from typing import Dict
from typing import Optional
from typing import Set
from typing import Type
from typing import TYPE_CHECKING
from typing import Union

from .types import _StringType
from ... import exc
from ... import sql
from ... import util
from ...sql import sqltypes
from ...sql import type_api

if TYPE_CHECKING:
    from ...engine.interfaces import Dialect
    from ...sql.elements import ColumnElement
    from ...sql.type_api import _BindProcessorType
    from ...sql.type_api import _ResultProcessorType
    from ...sql.type_api import TypeEngine
    from ...sql.type_api import TypeEngineMixin


class ENUM(type_api.NativeForEmulated, sqltypes.Enum, _StringType):
    

    __visit_name__ = "ENUM"

    native_enum = True

    def __init__(self, *enums: Union[str, Type[enum.Enum]], **kw: Any) -> None:
        
        kw.pop("strict", None)
        self._enum_init(enums, kw)  
        _StringType.__init__(self, length=self.length, **kw)

    @classmethod
    def adapt_emulated_to_native(
        cls,
        impl: Union[TypeEngine[Any], TypeEngineMixin],
        **kw: Any,
    ) -> ENUM:
        
        if TYPE_CHECKING:
            assert isinstance(impl, ENUM)
        kw.setdefault("validate_strings", impl.validate_strings)
        kw.setdefault("values_callable", impl.values_callable)
        kw.setdefault("omit_aliases", impl._omit_aliases)
        return cls(**kw)

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        
        
        
        
        if elem == "":
            return elem
        else:
            return super()._object_value_for_elem(elem)

    def __repr__(self) -> str:
        return util.generic_repr(
            self, to_inspect=[ENUM, _StringType, sqltypes.Enum]
        )






class SET(_StringType):
    

    __visit_name__ = "SET"

    def __init__(self, *values: str, **kw: Any):
        
        self.retrieve_as_bitwise = kw.pop("retrieve_as_bitwise", False)
        self.values = tuple(values)
        if not self.retrieve_as_bitwise and "" in values:
            raise exc.ArgumentError(
                "Can't use the blank value '' in a SET without "
                "setting retrieve_as_bitwise=True"
            )
        if self.retrieve_as_bitwise:
            self._inversed_bitmap: Dict[str, int] = {
                value: 2**idx for idx, value in enumerate(self.values)
            }
            self._bitmap: Dict[int, str] = {
                2**idx: value for idx, value in enumerate(self.values)
            }
        length = max([len(v) for v in values] + [0])
        kw.setdefault("length", length)
        super().__init__(**kw)

    def column_expression(
        self, colexpr: ColumnElement[Any]
    ) -> ColumnElement[Any]:
        if self.retrieve_as_bitwise:
            return sql.type_coerce(
                sql.type_coerce(colexpr, sqltypes.Integer) + 0, self
            )
        else:
            return colexpr

    def result_processor(
        self, dialect: Dialect, coltype: Any
    ) -> Optional[_ResultProcessorType[Any]]:
        if self.retrieve_as_bitwise:

            def process(value: Union[str, int, None]) -> Optional[Set[str]]:
                if value is not None:
                    value = int(value)

                    return set(util.map_bits(self._bitmap.__getitem__, value))
                else:
                    return None

        else:
            super_convert = super().result_processor(dialect, coltype)

            def process(value: Union[str, Set[str], None]) -> Optional[Set[str]]:  
                if isinstance(value, str):
                    
                    if super_convert:
                        value = super_convert(value)
                        assert value is not None
                    if TYPE_CHECKING:
                        assert isinstance(value, str)
                    return set(re.findall(r"[^,]+", value))
                else:
                    
                    
                    if value is not None:
                        value.discard("")
                    return value

        return process

    def bind_processor(
        self, dialect: Dialect
    ) -> _BindProcessorType[Union[str, int]]:
        super_convert = super().bind_processor(dialect)
        if self.retrieve_as_bitwise:

            def process(
                value: Union[str, int, set[str], None],
            ) -> Union[str, int, None]:
                if value is None:
                    return None
                elif isinstance(value, (int, str)):
                    if super_convert:
                        return super_convert(value)  
                    else:
                        return value
                else:
                    int_value = 0
                    for v in value:
                        int_value |= self._inversed_bitmap[v]
                    return int_value

        else:

            def process(
                value: Union[str, int, set[str], None],
            ) -> Union[str, int, None]:
                
                if value is not None and not isinstance(value, (int, str)):
                    value = ",".join(value)
                if super_convert:
                    return super_convert(value)  
                else:
                    return value

        return process

    def adapt(self, cls: type, **kw: Any) -> Any:
        kw["retrieve_as_bitwise"] = self.retrieve_as_bitwise
        return util.constructor_copy(self, cls, *self.values, **kw)

    def __repr__(self) -> str:
        return util.generic_repr(
            self,
            to_inspect=[SET, _StringType],
            additional_kw=[
                ("retrieve_as_bitwise", False),
            ],
        )
