





from __future__ import annotations

import datetime
import decimal
from typing import Any
from typing import Iterable
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union

from ... import exc
from ... import util
from ...sql import sqltypes

if TYPE_CHECKING:
    from .base import MySQLDialect
    from ...engine.interfaces import Dialect
    from ...sql.type_api import _BindProcessorType
    from ...sql.type_api import _ResultProcessorType
    from ...sql.type_api import TypeEngine


class _NumericType:
    

    def __init__(
        self, unsigned: bool = False, zerofill: bool = False, **kw: Any
    ):
        self.unsigned = unsigned
        self.zerofill = zerofill
        super().__init__(**kw)

    def __repr__(self) -> str:
        return util.generic_repr(
            self, to_inspect=[_NumericType, sqltypes.Numeric]
        )


class _FloatType(_NumericType, sqltypes.Float[Union[decimal.Decimal, float]]):
    def __init__(
        self,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
        asdecimal: bool = True,
        **kw: Any,
    ):
        if isinstance(self, (REAL, DOUBLE)) and (
            (precision is None and scale is not None)
            or (precision is not None and scale is None)
        ):
            raise exc.ArgumentError(
                "You must specify both precision and scale or omit "
                "both altogether."
            )
        super().__init__(precision=precision, asdecimal=asdecimal, **kw)
        self.scale = scale

    def __repr__(self) -> str:
        return util.generic_repr(
            self, to_inspect=[_FloatType, _NumericType, sqltypes.Float]
        )


class _IntegerType(_NumericType, sqltypes.Integer):
    def __init__(self, display_width: Optional[int] = None, **kw: Any):
        self.display_width = display_width
        super().__init__(**kw)

    def __repr__(self) -> str:
        return util.generic_repr(
            self, to_inspect=[_IntegerType, _NumericType, sqltypes.Integer]
        )


class _StringType(sqltypes.String):
    

    def __init__(
        self,
        charset: Optional[str] = None,
        collation: Optional[str] = None,
        ascii: bool = False,  
        binary: bool = False,
        unicode: bool = False,
        national: bool = False,
        **kw: Any,
    ):
        self.charset = charset

        
        kw.setdefault("collation", kw.pop("collate", collation))

        self.ascii = ascii
        self.unicode = unicode
        self.binary = binary
        self.national = national
        super().__init__(**kw)

    def __repr__(self) -> str:
        return util.generic_repr(
            self, to_inspect=[_StringType, sqltypes.String]
        )


class _MatchType(
    sqltypes.Float[Union[decimal.Decimal, float]], sqltypes.MatchType
):
    def __init__(self, **kw: Any):
        
        sqltypes.Float.__init__(self)  
        sqltypes.MatchType.__init__(self)


class NUMERIC(_NumericType, sqltypes.NUMERIC[Union[decimal.Decimal, float]]):
    

    __visit_name__ = "NUMERIC"

    def __init__(
        self,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
        asdecimal: bool = True,
        **kw: Any,
    ):
        
        super().__init__(
            precision=precision, scale=scale, asdecimal=asdecimal, **kw
        )


class DECIMAL(_NumericType, sqltypes.DECIMAL[Union[decimal.Decimal, float]]):
    

    __visit_name__ = "DECIMAL"

    def __init__(
        self,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
        asdecimal: bool = True,
        **kw: Any,
    ):
        
        super().__init__(
            precision=precision, scale=scale, asdecimal=asdecimal, **kw
        )


class DOUBLE(_FloatType, sqltypes.DOUBLE[Union[decimal.Decimal, float]]):
    

    __visit_name__ = "DOUBLE"

    def __init__(
        self,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
        asdecimal: bool = True,
        **kw: Any,
    ):
        
        super().__init__(
            precision=precision, scale=scale, asdecimal=asdecimal, **kw
        )


class REAL(_FloatType, sqltypes.REAL[Union[decimal.Decimal, float]]):
    

    __visit_name__ = "REAL"

    def __init__(
        self,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
        asdecimal: bool = True,
        **kw: Any,
    ):
        
        super().__init__(
            precision=precision, scale=scale, asdecimal=asdecimal, **kw
        )


class FLOAT(_FloatType, sqltypes.FLOAT[Union[decimal.Decimal, float]]):
    

    __visit_name__ = "FLOAT"

    def __init__(
        self,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
        asdecimal: bool = False,
        **kw: Any,
    ):
        
        super().__init__(
            precision=precision, scale=scale, asdecimal=asdecimal, **kw
        )

    def bind_processor(
        self, dialect: Dialect
    ) -> Optional[_BindProcessorType[Union[decimal.Decimal, float]]]:
        return None


class INTEGER(_IntegerType, sqltypes.INTEGER):
    

    __visit_name__ = "INTEGER"

    def __init__(self, display_width: Optional[int] = None, **kw: Any):
        
        super().__init__(display_width=display_width, **kw)


class BIGINT(_IntegerType, sqltypes.BIGINT):
    

    __visit_name__ = "BIGINT"

    def __init__(self, display_width: Optional[int] = None, **kw: Any):
        
        super().__init__(display_width=display_width, **kw)


class MEDIUMINT(_IntegerType):
    

    __visit_name__ = "MEDIUMINT"

    def __init__(self, display_width: Optional[int] = None, **kw: Any):
        
        super().__init__(display_width=display_width, **kw)


class TINYINT(_IntegerType):
    

    __visit_name__ = "TINYINT"

    def __init__(self, display_width: Optional[int] = None, **kw: Any):
        
        super().__init__(display_width=display_width, **kw)

    def _compare_type_affinity(self, other: TypeEngine[Any]) -> bool:
        return (
            self._type_affinity is other._type_affinity
            or other._type_affinity is sqltypes.Boolean
        )


class SMALLINT(_IntegerType, sqltypes.SMALLINT):
    

    __visit_name__ = "SMALLINT"

    def __init__(self, display_width: Optional[int] = None, **kw: Any):
        
        super().__init__(display_width=display_width, **kw)


class BIT(sqltypes.TypeEngine[Any]):
    

    __visit_name__ = "BIT"

    def __init__(self, length: Optional[int] = None):
        
        self.length = length

    def result_processor(
        self, dialect: MySQLDialect, coltype: object  
    ) -> Optional[_ResultProcessorType[Any]]:
        

        if dialect.supports_native_bit:
            return None

        def process(value: Optional[Iterable[int]]) -> Optional[int]:
            if value is not None:
                v = 0
                for i in value:
                    v = v << 8 | i
                return v
            return value

        return process


class TIME(sqltypes.TIME):
    

    __visit_name__ = "TIME"

    def __init__(self, timezone: bool = False, fsp: Optional[int] = None):
        
        super().__init__(timezone=timezone)
        self.fsp = fsp

    def result_processor(
        self, dialect: Dialect, coltype: object
    ) -> _ResultProcessorType[datetime.time]:
        time = datetime.time

        def process(value: Any) -> Optional[datetime.time]:
            
            if value is not None:
                microseconds = value.microseconds
                seconds = value.seconds
                minutes = seconds // 60
                return time(
                    minutes // 60,
                    minutes % 60,
                    seconds - minutes * 60,
                    microsecond=microseconds,
                )
            else:
                return None

        return process


class TIMESTAMP(sqltypes.TIMESTAMP):
    

    __visit_name__ = "TIMESTAMP"

    def __init__(self, timezone: bool = False, fsp: Optional[int] = None):
        
        super().__init__(timezone=timezone)
        self.fsp = fsp


class DATETIME(sqltypes.DATETIME):
    

    __visit_name__ = "DATETIME"

    def __init__(self, timezone: bool = False, fsp: Optional[int] = None):
        
        super().__init__(timezone=timezone)
        self.fsp = fsp


class YEAR(sqltypes.TypeEngine[Any]):
    

    __visit_name__ = "YEAR"

    def __init__(self, display_width: Optional[int] = None):
        self.display_width = display_width


class TEXT(_StringType, sqltypes.TEXT):
    

    __visit_name__ = "TEXT"

    def __init__(self, length: Optional[int] = None, **kw: Any):
        
        super().__init__(length=length, **kw)


class TINYTEXT(_StringType):
    

    __visit_name__ = "TINYTEXT"

    def __init__(self, **kwargs: Any):
        
        super().__init__(**kwargs)


class MEDIUMTEXT(_StringType):
    

    __visit_name__ = "MEDIUMTEXT"

    def __init__(self, **kwargs: Any):
        
        super().__init__(**kwargs)


class LONGTEXT(_StringType):
    

    __visit_name__ = "LONGTEXT"

    def __init__(self, **kwargs: Any):
        
        super().__init__(**kwargs)


class VARCHAR(_StringType, sqltypes.VARCHAR):
    

    __visit_name__ = "VARCHAR"

    def __init__(self, length: Optional[int] = None, **kwargs: Any) -> None:
        
        super().__init__(length=length, **kwargs)


class CHAR(_StringType, sqltypes.CHAR):
    

    __visit_name__ = "CHAR"

    def __init__(self, length: Optional[int] = None, **kwargs: Any):
        
        super().__init__(length=length, **kwargs)

    @classmethod
    def _adapt_string_for_cast(cls, type_: sqltypes.String) -> sqltypes.CHAR:
        
        
        type_ = sqltypes.to_instance(type_)
        if isinstance(type_, sqltypes.CHAR):
            return type_
        elif isinstance(type_, _StringType):
            return CHAR(
                length=type_.length,
                charset=type_.charset,
                collation=type_.collation,
                ascii=type_.ascii,
                binary=type_.binary,
                unicode=type_.unicode,
                national=False,  
            )
        else:
            return CHAR(length=type_.length)


class NVARCHAR(_StringType, sqltypes.NVARCHAR):
    

    __visit_name__ = "NVARCHAR"

    def __init__(self, length: Optional[int] = None, **kwargs: Any):
        
        kwargs["national"] = True
        super().__init__(length=length, **kwargs)


class NCHAR(_StringType, sqltypes.NCHAR):
    

    __visit_name__ = "NCHAR"

    def __init__(self, length: Optional[int] = None, **kwargs: Any):
        
        kwargs["national"] = True
        super().__init__(length=length, **kwargs)


class TINYBLOB(sqltypes._Binary):
    

    __visit_name__ = "TINYBLOB"


class MEDIUMBLOB(sqltypes._Binary):
    

    __visit_name__ = "MEDIUMBLOB"


class LONGBLOB(sqltypes._Binary):
    

    __visit_name__ = "LONGBLOB"
