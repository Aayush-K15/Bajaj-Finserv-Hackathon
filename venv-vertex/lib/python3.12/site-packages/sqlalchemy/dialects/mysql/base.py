







r  
from __future__ import annotations

from collections import defaultdict
from itertools import compress
import re
from typing import Any
from typing import Callable
from typing import cast
from typing import DefaultDict
from typing import Dict
from typing import List
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

from . import reflection as _reflection
from .enumerated import ENUM
from .enumerated import SET
from .json import JSON
from .json import JSONIndexType
from .json import JSONPathType
from .reserved_words import RESERVED_WORDS_MARIADB
from .reserved_words import RESERVED_WORDS_MYSQL
from .types import _FloatType
from .types import _IntegerType
from .types import _MatchType
from .types import _NumericType
from .types import _StringType
from .types import BIGINT
from .types import BIT
from .types import CHAR
from .types import DATETIME
from .types import DECIMAL
from .types import DOUBLE
from .types import FLOAT
from .types import INTEGER
from .types import LONGBLOB
from .types import LONGTEXT
from .types import MEDIUMBLOB
from .types import MEDIUMINT
from .types import MEDIUMTEXT
from .types import NCHAR
from .types import NUMERIC
from .types import NVARCHAR
from .types import REAL
from .types import SMALLINT
from .types import TEXT
from .types import TIME
from .types import TIMESTAMP
from .types import TINYBLOB
from .types import TINYINT
from .types import TINYTEXT
from .types import VARCHAR
from .types import YEAR
from ... import exc
from ... import literal_column
from ... import schema as sa_schema
from ... import sql
from ... import util
from ...engine import cursor as _cursor
from ...engine import default
from ...engine import reflection
from ...engine.reflection import ReflectionDefaults
from ...sql import coercions
from ...sql import compiler
from ...sql import elements
from ...sql import functions
from ...sql import operators
from ...sql import roles
from ...sql import sqltypes
from ...sql import util as sql_util
from ...sql import visitors
from ...sql.compiler import InsertmanyvaluesSentinelOpts
from ...sql.compiler import SQLCompiler
from ...sql.schema import SchemaConst
from ...types import BINARY
from ...types import BLOB
from ...types import BOOLEAN
from ...types import DATE
from ...types import LargeBinary
from ...types import UUID
from ...types import VARBINARY
from ...util import topological

if TYPE_CHECKING:

    from ...dialects.mysql import expression
    from ...dialects.mysql.dml import OnDuplicateClause
    from ...engine.base import Connection
    from ...engine.cursor import CursorResult
    from ...engine.interfaces import DBAPIConnection
    from ...engine.interfaces import DBAPICursor
    from ...engine.interfaces import DBAPIModule
    from ...engine.interfaces import IsolationLevel
    from ...engine.interfaces import PoolProxiedConnection
    from ...engine.interfaces import ReflectedCheckConstraint
    from ...engine.interfaces import ReflectedColumn
    from ...engine.interfaces import ReflectedForeignKeyConstraint
    from ...engine.interfaces import ReflectedIndex
    from ...engine.interfaces import ReflectedPrimaryKeyConstraint
    from ...engine.interfaces import ReflectedTableComment
    from ...engine.interfaces import ReflectedUniqueConstraint
    from ...engine.row import Row
    from ...engine.url import URL
    from ...schema import Table
    from ...sql import ddl
    from ...sql import selectable
    from ...sql.dml import _DMLTableElement
    from ...sql.dml import Delete
    from ...sql.dml import Update
    from ...sql.dml import ValuesBase
    from ...sql.functions import aggregate_strings
    from ...sql.functions import random
    from ...sql.functions import rollup
    from ...sql.functions import sysdate
    from ...sql.schema import Sequence as Sequence_SchemaItem
    from ...sql.type_api import TypeEngine
    from ...sql.visitors import ExternallyTraversible


SET_RE = re.compile(
    r"\s*SET\s+(?:(?:GLOBAL|SESSION)\s+)?\w", re.I | re.UNICODE
)


MSTime = TIME
MSSet = SET
MSEnum = ENUM
MSLongBlob = LONGBLOB
MSMediumBlob = MEDIUMBLOB
MSTinyBlob = TINYBLOB
MSBlob = BLOB
MSBinary = BINARY
MSVarBinary = VARBINARY
MSNChar = NCHAR
MSNVarChar = NVARCHAR
MSChar = CHAR
MSString = VARCHAR
MSLongText = LONGTEXT
MSMediumText = MEDIUMTEXT
MSTinyText = TINYTEXT
MSText = TEXT
MSYear = YEAR
MSTimeStamp = TIMESTAMP
MSBit = BIT
MSSmallInteger = SMALLINT
MSTinyInteger = TINYINT
MSMediumInteger = MEDIUMINT
MSBigInteger = BIGINT
MSNumeric = NUMERIC
MSDecimal = DECIMAL
MSDouble = DOUBLE
MSReal = REAL
MSFloat = FLOAT
MSInteger = INTEGER

colspecs = {
    _IntegerType: _IntegerType,
    _NumericType: _NumericType,
    _FloatType: _FloatType,
    sqltypes.Numeric: NUMERIC,
    sqltypes.Float: FLOAT,
    sqltypes.Double: DOUBLE,
    sqltypes.Time: TIME,
    sqltypes.Enum: ENUM,
    sqltypes.MatchType: _MatchType,
    sqltypes.JSON: JSON,
    sqltypes.JSON.JSONIndexType: JSONIndexType,
    sqltypes.JSON.JSONPathType: JSONPathType,
}


ischema_names = {
    "bigint": BIGINT,
    "binary": BINARY,
    "bit": BIT,
    "blob": BLOB,
    "boolean": BOOLEAN,
    "char": CHAR,
    "date": DATE,
    "datetime": DATETIME,
    "decimal": DECIMAL,
    "double": DOUBLE,
    "enum": ENUM,
    "fixed": DECIMAL,
    "float": FLOAT,
    "int": INTEGER,
    "integer": INTEGER,
    "json": JSON,
    "longblob": LONGBLOB,
    "longtext": LONGTEXT,
    "mediumblob": MEDIUMBLOB,
    "mediumint": MEDIUMINT,
    "mediumtext": MEDIUMTEXT,
    "nchar": NCHAR,
    "nvarchar": NVARCHAR,
    "numeric": NUMERIC,
    "set": SET,
    "smallint": SMALLINT,
    "text": TEXT,
    "time": TIME,
    "timestamp": TIMESTAMP,
    "tinyblob": TINYBLOB,
    "tinyint": TINYINT,
    "tinytext": TINYTEXT,
    "uuid": UUID,
    "varbinary": VARBINARY,
    "varchar": VARCHAR,
    "year": YEAR,
}


class MySQLExecutionContext(default.DefaultExecutionContext):
    def post_exec(self) -> None:
        if (
            self.isdelete
            and cast(SQLCompiler, self.compiled).effective_returning
            and not self.cursor.description
        ):
            
            
            
            
            
            
            
            self.cursor_fetch_strategy = (
                _cursor.FullyBufferedCursorFetchStrategy(
                    self.cursor,
                    [
                        (entry.keyname, None)  
                        for entry in cast(
                            SQLCompiler, self.compiled
                        )._result_columns
                    ],
                    [],
                )
            )

    def create_server_side_cursor(self) -> DBAPICursor:
        if self.dialect.supports_server_side_cursors:
            return self._dbapi_connection.cursor(
                self.dialect._sscursor  
            )
        else:
            raise NotImplementedError()

    def fire_sequence(
        self, seq: Sequence_SchemaItem, type_: sqltypes.Integer
    ) -> int:
        return self._execute_scalar(  
            (
                "select nextval(%s)"
                % self.identifier_preparer.format_sequence(seq)
            ),
            type_,
        )


class MySQLCompiler(compiler.SQLCompiler):
    dialect: MySQLDialect
    render_table_with_column_in_update_from = True
    

    extract_map = compiler.SQLCompiler.extract_map.copy()
    extract_map.update({"milliseconds": "millisecond"})

    def default_from(self) -> str:
        
        if self.stack:
            stmt = self.stack[-1]["selectable"]
            if stmt._where_criteria:  
                return " FROM DUAL"

        return ""

    def visit_random_func(self, fn: random, **kw: Any) -> str:
        return "rand%s" % self.function_argspec(fn)

    def visit_rollup_func(self, fn: rollup[Any], **kw: Any) -> str:
        clause = ", ".join(
            elem._compiler_dispatch(self, **kw) for elem in fn.clauses
        )
        return f"{clause} WITH ROLLUP"

    def visit_aggregate_strings_func(
        self, fn: aggregate_strings, **kw: Any
    ) -> str:
        expr, delimeter = (
            elem._compiler_dispatch(self, **kw) for elem in fn.clauses
        )
        return f"group_concat({expr} SEPARATOR {delimeter})"

    def visit_sequence(self, sequence: sa_schema.Sequence, **kw: Any) -> str:
        return "nextval(%s)" % self.preparer.format_sequence(sequence)

    def visit_sysdate_func(self, fn: sysdate, **kw: Any) -> str:
        return "SYSDATE()"

    def _render_json_extract_from_binary(
        self, binary: elements.BinaryExpression[Any], operator: Any, **kw: Any
    ) -> str:
        
        
        

        if binary.type._type_affinity is sqltypes.JSON:
            return "JSON_EXTRACT(%s, %s)" % (
                self.process(binary.left, **kw),
                self.process(binary.right, **kw),
            )

        
        
        case_expression = "CASE JSON_EXTRACT(%s, %s) WHEN 'null' THEN NULL" % (
            self.process(binary.left, **kw),
            self.process(binary.right, **kw),
        )

        if binary.type._type_affinity is sqltypes.Integer:
            type_expression = (
                "ELSE CAST(JSON_EXTRACT(%s, %s) AS SIGNED INTEGER)"
                % (
                    self.process(binary.left, **kw),
                    self.process(binary.right, **kw),
                )
            )
        elif binary.type._type_affinity is sqltypes.Numeric:
            binary_type = cast(sqltypes.Numeric[Any], binary.type)
            if (
                binary_type.scale is not None
                and binary_type.precision is not None
            ):
                
                type_expression = (
                    "ELSE CAST(JSON_EXTRACT(%s, %s) AS DECIMAL(%s, %s))"
                    % (
                        self.process(binary.left, **kw),
                        self.process(binary.right, **kw),
                        binary_type.precision,
                        binary_type.scale,
                    )
                )
            else:
                
                type_expression = (
                    "ELSE JSON_EXTRACT(%s, %s)+0.0000000000000000000000"
                    % (
                        self.process(binary.left, **kw),
                        self.process(binary.right, **kw),
                    )
                )
        elif binary.type._type_affinity is sqltypes.Boolean:
            
            
            type_expression = "WHEN true THEN true ELSE false"
        elif binary.type._type_affinity is sqltypes.String:
            
            
            
            
            type_expression = "ELSE JSON_UNQUOTE(JSON_EXTRACT(%s, %s))" % (
                self.process(binary.left, **kw),
                self.process(binary.right, **kw),
            )
        else:
            
            type_expression = "ELSE JSON_EXTRACT(%s, %s)" % (
                self.process(binary.left, **kw),
                self.process(binary.right, **kw),
            )

        return case_expression + " " + type_expression + " END"

    def visit_json_getitem_op_binary(
        self, binary: elements.BinaryExpression[Any], operator: Any, **kw: Any
    ) -> str:
        return self._render_json_extract_from_binary(binary, operator, **kw)

    def visit_json_path_getitem_op_binary(
        self, binary: elements.BinaryExpression[Any], operator: Any, **kw: Any
    ) -> str:
        return self._render_json_extract_from_binary(binary, operator, **kw)

    def visit_on_duplicate_key_update(
        self, on_duplicate: OnDuplicateClause, **kw: Any
    ) -> str:
        statement: ValuesBase = self.current_executable

        cols: List[elements.KeyedColumnElement[Any]]
        if on_duplicate._parameter_ordering:
            parameter_ordering = [
                coercions.expect(roles.DMLColumnRole, key)
                for key in on_duplicate._parameter_ordering
            ]
            ordered_keys = set(parameter_ordering)
            cols = [
                statement.table.c[key]
                for key in parameter_ordering
                if key in statement.table.c
            ] + [c for c in statement.table.c if c.key not in ordered_keys]
        else:
            cols = list(statement.table.c)

        clauses = []

        requires_mysql8_alias = statement.select is None and (
            self.dialect._requires_alias_for_on_duplicate_key
        )

        if requires_mysql8_alias:
            if statement.table.name.lower() == "new":  
                _on_dup_alias_name = "new_1"
            else:
                _on_dup_alias_name = "new"

        on_duplicate_update = {
            coercions.expect_as_key(roles.DMLColumnRole, key): value
            for key, value in on_duplicate.update.items()
        }

        
        for column in (col for col in cols if col.key in on_duplicate_update):
            val = on_duplicate_update[column.key]

            
            
            if coercions._is_literal(val):
                val = elements.BindParameter(None, val, type_=column.type)
                value_text = self.process(val.self_group(), use_schema=False)
            else:

                def replace(
                    element: ExternallyTraversible, **kw: Any
                ) -> Optional[ExternallyTraversible]:
                    if (
                        isinstance(element, elements.BindParameter)
                        and element.type._isnull
                    ):
                        return element._with_binary_element_type(column.type)
                    elif (
                        isinstance(element, elements.ColumnClause)
                        and element.table is on_duplicate.inserted_alias
                    ):
                        if requires_mysql8_alias:
                            column_literal_clause = (
                                f"{_on_dup_alias_name}."
                                f"{self.preparer.quote(element.name)}"
                            )
                        else:
                            column_literal_clause = (
                                f"VALUES({self.preparer.quote(element.name)})"
                            )
                        return literal_column(column_literal_clause)
                    else:
                        
                        return None

                val = visitors.replacement_traverse(val, {}, replace)
                value_text = self.process(val.self_group(), use_schema=False)

            name_text = self.preparer.quote(column.name)
            clauses.append("%s = %s" % (name_text, value_text))

        non_matching = set(on_duplicate_update) - {c.key for c in cols}
        if non_matching:
            util.warn(
                "Additional column names not matching "
                "any column keys in table '%s': %s"
                % (
                    self.statement.table.name,  
                    (", ".join("'%s'" % c for c in non_matching)),
                )
            )

        if requires_mysql8_alias:
            return (
                f"AS {_on_dup_alias_name} "
                f"ON DUPLICATE KEY UPDATE {', '.join(clauses)}"
            )
        else:
            return f"ON DUPLICATE KEY UPDATE {', '.join(clauses)}"

    def visit_concat_op_expression_clauselist(
        self, clauselist: elements.ClauseList, operator: Any, **kw: Any
    ) -> str:
        return "concat(%s)" % (
            ", ".join(self.process(elem, **kw) for elem in clauselist.clauses)
        )

    def visit_concat_op_binary(
        self, binary: elements.BinaryExpression[Any], operator: Any, **kw: Any
    ) -> str:
        return "concat(%s, %s)" % (
            self.process(binary.left, **kw),
            self.process(binary.right, **kw),
        )

    _match_valid_flag_combinations = frozenset(
        (
            
            (False, False, False),
            (True, False, False),
            (False, True, False),
            (False, False, True),
            (False, True, True),
        )
    )

    _match_flag_expressions = (
        "IN BOOLEAN MODE",
        "IN NATURAL LANGUAGE MODE",
        "WITH QUERY EXPANSION",
    )

    def visit_mysql_match(self, element: expression.match, **kw: Any) -> str:
        return self.visit_match_op_binary(element, element.operator, **kw)

    def visit_match_op_binary(
        self, binary: expression.match, operator: Any, **kw: Any
    ) -> str:
        

        modifiers = binary.modifiers

        boolean_mode = modifiers.get("mysql_boolean_mode", True)
        natural_language = modifiers.get("mysql_natural_language", False)
        query_expansion = modifiers.get("mysql_query_expansion", False)

        flag_combination = (boolean_mode, natural_language, query_expansion)

        if flag_combination not in self._match_valid_flag_combinations:
            flags = (
                "in_boolean_mode=%s" % boolean_mode,
                "in_natural_language_mode=%s" % natural_language,
                "with_query_expansion=%s" % query_expansion,
            )

            flags_str = ", ".join(flags)

            raise exc.CompileError("Invalid MySQL match flags: %s" % flags_str)

        match_clause = self.process(binary.left, **kw)
        against_clause = self.process(binary.right, **kw)

        if any(flag_combination):
            flag_expressions = compress(
                self._match_flag_expressions,
                flag_combination,
            )

            against_clause = " ".join([against_clause, *flag_expressions])

        return "MATCH (%s) AGAINST (%s)" % (match_clause, against_clause)

    def get_from_hint_text(
        self, table: selectable.FromClause, text: Optional[str]
    ) -> Optional[str]:
        return text

    def visit_typeclause(
        self,
        typeclause: elements.TypeClause,
        type_: Optional[TypeEngine[Any]] = None,
        **kw: Any,
    ) -> Optional[str]:
        if type_ is None:
            type_ = typeclause.type.dialect_impl(self.dialect)
        if isinstance(type_, sqltypes.TypeDecorator):
            return self.visit_typeclause(typeclause, type_.impl, **kw)  
        elif isinstance(type_, sqltypes.Integer):
            if getattr(type_, "unsigned", False):
                return "UNSIGNED INTEGER"
            else:
                return "SIGNED INTEGER"
        elif isinstance(type_, sqltypes.TIMESTAMP):
            return "DATETIME"
        elif isinstance(
            type_,
            (
                sqltypes.DECIMAL,
                sqltypes.DateTime,
                sqltypes.Date,
                sqltypes.Time,
            ),
        ):
            return self.dialect.type_compiler_instance.process(type_)
        elif isinstance(type_, sqltypes.String) and not isinstance(
            type_, (ENUM, SET)
        ):
            adapted = CHAR._adapt_string_for_cast(type_)
            return self.dialect.type_compiler_instance.process(adapted)
        elif isinstance(type_, sqltypes._Binary):
            return "BINARY"
        elif isinstance(type_, sqltypes.JSON):
            return "JSON"
        elif isinstance(type_, sqltypes.NUMERIC):
            return self.dialect.type_compiler_instance.process(type_).replace(
                "NUMERIC", "DECIMAL"
            )
        elif (
            isinstance(type_, sqltypes.Float)
            and self.dialect._support_float_cast
        ):
            return self.dialect.type_compiler_instance.process(type_)
        else:
            return None

    def visit_cast(self, cast: elements.Cast[Any], **kw: Any) -> str:
        type_ = self.process(cast.typeclause)
        if type_ is None:
            util.warn(
                "Datatype %s does not support CAST on MySQL/MariaDb; "
                "the CAST will be skipped."
                % self.dialect.type_compiler_instance.process(
                    cast.typeclause.type
                )
            )
            return self.process(cast.clause.self_group(), **kw)

        return "CAST(%s AS %s)" % (self.process(cast.clause, **kw), type_)

    def render_literal_value(
        self, value: Optional[str], type_: TypeEngine[Any]
    ) -> str:
        value = super().render_literal_value(value, type_)
        if self.dialect._backslash_escapes:
            value = value.replace("\\", "\\\\")
        return value

    
    
    def visit_true(self, expr: elements.True_, **kw: Any) -> str:
        return "true"

    def visit_false(self, expr: elements.False_, **kw: Any) -> str:
        return "false"

    def get_select_precolumns(
        self, select: selectable.Select[Any], **kw: Any
    ) -> str:
        
        if isinstance(select._distinct, str):
            util.warn_deprecated(
                "Sending string values for 'distinct' is deprecated in the "
                "MySQL dialect and will be removed in a future release.  "
                "Please use :meth:`.Select.prefix_with` for special keywords "
                "at the start of a SELECT statement",
                version="1.4",
            )
            return select._distinct.upper() + " "

        return super().get_select_precolumns(select, **kw)

    def visit_join(
        self,
        join: selectable.Join,
        asfrom: bool = False,
        from_linter: Optional[compiler.FromLinter] = None,
        **kwargs: Any,
    ) -> str:
        if from_linter:
            from_linter.edges.add((join.left, join.right))

        if join.full:
            join_type = " FULL OUTER JOIN "
        elif join.isouter:
            join_type = " LEFT OUTER JOIN "
        else:
            join_type = " INNER JOIN "

        return "".join(
            (
                self.process(
                    join.left, asfrom=True, from_linter=from_linter, **kwargs
                ),
                join_type,
                self.process(
                    join.right, asfrom=True, from_linter=from_linter, **kwargs
                ),
                " ON ",
                self.process(join.onclause, from_linter=from_linter, **kwargs),  
            )
        )

    def for_update_clause(
        self, select: selectable.GenerativeSelect, **kw: Any
    ) -> str:
        assert select._for_update_arg is not None
        if select._for_update_arg.read:
            tmp = " LOCK IN SHARE MODE"
        else:
            tmp = " FOR UPDATE"

        if select._for_update_arg.of and self.dialect.supports_for_update_of:
            tables: util.OrderedSet[elements.ClauseElement] = util.OrderedSet()
            for c in select._for_update_arg.of:
                tables.update(sql_util.surface_selectables_only(c))

            tmp += " OF " + ", ".join(
                self.process(table, ashint=True, use_schema=False, **kw)
                for table in tables
            )

        if select._for_update_arg.nowait:
            tmp += " NOWAIT"

        if select._for_update_arg.skip_locked:
            tmp += " SKIP LOCKED"

        return tmp

    def limit_clause(
        self, select: selectable.GenerativeSelect, **kw: Any
    ) -> str:
        
        
        
        
        
        
        

        limit_clause, offset_clause = (
            select._limit_clause,
            select._offset_clause,
        )

        if limit_clause is None and offset_clause is None:
            return ""
        elif offset_clause is not None:
            
            
            
            if limit_clause is None:
                
                
                
                
                
                return " \n LIMIT %s, %s" % (
                    self.process(offset_clause, **kw),
                    "18446744073709551615",
                )
            else:
                return " \n LIMIT %s, %s" % (
                    self.process(offset_clause, **kw),
                    self.process(limit_clause, **kw),
                )
        else:
            assert limit_clause is not None
            
            return " \n LIMIT %s" % (self.process(limit_clause, **kw),)

    def update_limit_clause(self, update_stmt: Update) -> Optional[str]:
        limit = update_stmt.kwargs.get("%s_limit" % self.dialect.name, None)
        if limit is not None:
            return f"LIMIT {int(limit)}"
        else:
            return None

    def delete_limit_clause(self, delete_stmt: Delete) -> Optional[str]:
        limit = delete_stmt.kwargs.get("%s_limit" % self.dialect.name, None)
        if limit is not None:
            return f"LIMIT {int(limit)}"
        else:
            return None

    def update_tables_clause(
        self,
        update_stmt: Update,
        from_table: _DMLTableElement,
        extra_froms: List[selectable.FromClause],
        **kw: Any,
    ) -> str:
        kw["asfrom"] = True
        return ", ".join(
            t._compiler_dispatch(self, **kw)
            for t in [from_table] + list(extra_froms)
        )

    def update_from_clause(
        self,
        update_stmt: Update,
        from_table: _DMLTableElement,
        extra_froms: List[selectable.FromClause],
        from_hints: Any,
        **kw: Any,
    ) -> None:
        return None

    def delete_table_clause(
        self,
        delete_stmt: Delete,
        from_table: _DMLTableElement,
        extra_froms: List[selectable.FromClause],
        **kw: Any,
    ) -> str:
        
        ashint = False
        if extra_froms:
            ashint = True
        return from_table._compiler_dispatch(
            self, asfrom=True, iscrud=True, ashint=ashint, **kw
        )

    def delete_extra_from_clause(
        self,
        delete_stmt: Delete,
        from_table: _DMLTableElement,
        extra_froms: List[selectable.FromClause],
        from_hints: Any,
        **kw: Any,
    ) -> str:
        
        kw["asfrom"] = True
        return "USING " + ", ".join(
            t._compiler_dispatch(self, fromhints=from_hints, **kw)
            for t in [from_table] + extra_froms
        )

    def visit_empty_set_expr(
        self, element_types: List[TypeEngine[Any]], **kw: Any
    ) -> str:
        return (
            "SELECT %(outer)s FROM (SELECT %(inner)s) "
            "as _empty_set WHERE 1!=1"
            % {
                "inner": ", ".join(
                    "1 AS _in_%s" % idx
                    for idx, type_ in enumerate(element_types)
                ),
                "outer": ", ".join(
                    "_in_%s" % idx for idx, type_ in enumerate(element_types)
                ),
            }
        )

    def visit_is_distinct_from_binary(
        self, binary: elements.BinaryExpression[Any], operator: Any, **kw: Any
    ) -> str:
        return "NOT (%s <=> %s)" % (
            self.process(binary.left),
            self.process(binary.right),
        )

    def visit_is_not_distinct_from_binary(
        self, binary: elements.BinaryExpression[Any], operator: Any, **kw: Any
    ) -> str:
        return "%s <=> %s" % (
            self.process(binary.left),
            self.process(binary.right),
        )

    def _mariadb_regexp_flags(
        self, flags: str, pattern: elements.ColumnElement[Any], **kw: Any
    ) -> str:
        return "CONCAT('(?', %s, ')', %s)" % (
            self.render_literal_value(flags, sqltypes.STRINGTYPE),
            self.process(pattern, **kw),
        )

    def _regexp_match(
        self,
        op_string: str,
        binary: elements.BinaryExpression[Any],
        operator: Any,
        **kw: Any,
    ) -> str:
        assert binary.modifiers is not None
        flags = binary.modifiers["flags"]
        if flags is None:
            return self._generate_generic_binary(binary, op_string, **kw)
        elif self.dialect.is_mariadb:
            return "%s%s%s" % (
                self.process(binary.left, **kw),
                op_string,
                self._mariadb_regexp_flags(flags, binary.right),
            )
        else:
            text = "REGEXP_LIKE(%s, %s, %s)" % (
                self.process(binary.left, **kw),
                self.process(binary.right, **kw),
                self.render_literal_value(flags, sqltypes.STRINGTYPE),
            )
            if op_string == " NOT REGEXP ":
                return "NOT %s" % text
            else:
                return text

    def visit_regexp_match_op_binary(
        self, binary: elements.BinaryExpression[Any], operator: Any, **kw: Any
    ) -> str:
        return self._regexp_match(" REGEXP ", binary, operator, **kw)

    def visit_not_regexp_match_op_binary(
        self, binary: elements.BinaryExpression[Any], operator: Any, **kw: Any
    ) -> str:
        return self._regexp_match(" NOT REGEXP ", binary, operator, **kw)

    def visit_regexp_replace_op_binary(
        self, binary: elements.BinaryExpression[Any], operator: Any, **kw: Any
    ) -> str:
        assert binary.modifiers is not None
        flags = binary.modifiers["flags"]
        if flags is None:
            return "REGEXP_REPLACE(%s, %s)" % (
                self.process(binary.left, **kw),
                self.process(binary.right, **kw),
            )
        elif self.dialect.is_mariadb:
            return "REGEXP_REPLACE(%s, %s, %s)" % (
                self.process(binary.left, **kw),
                self._mariadb_regexp_flags(flags, binary.right.clauses[0]),
                self.process(binary.right.clauses[1], **kw),
            )
        else:
            return "REGEXP_REPLACE(%s, %s, %s)" % (
                self.process(binary.left, **kw),
                self.process(binary.right, **kw),
                self.render_literal_value(flags, sqltypes.STRINGTYPE),
            )


class MySQLDDLCompiler(compiler.DDLCompiler):
    dialect: MySQLDialect

    def get_column_specification(
        self, column: sa_schema.Column[Any], **kw: Any
    ) -> str:
        
        if (
            self.dialect.is_mariadb is True
            and column.computed is not None
            and column._user_defined_nullable is SchemaConst.NULL_UNSPECIFIED
        ):
            column.nullable = True
        colspec = [
            self.preparer.format_column(column),
            self.dialect.type_compiler_instance.process(
                column.type, type_expression=column
            ),
        ]

        if column.computed is not None:
            colspec.append(self.process(column.computed))

        is_timestamp = isinstance(
            column.type._unwrapped_dialect_impl(self.dialect),
            sqltypes.TIMESTAMP,
        )

        if not column.nullable:
            colspec.append("NOT NULL")

        
        elif column.nullable and is_timestamp:
            colspec.append("NULL")

        comment = column.comment
        if comment is not None:
            literal = self.sql_compiler.render_literal_value(
                comment, sqltypes.String()
            )
            colspec.append("COMMENT " + literal)

        if (
            column.table is not None
            and column is column.table._autoincrement_column
            and (
                column.server_default is None
                or isinstance(column.server_default, sa_schema.Identity)
            )
            and not (
                self.dialect.supports_sequences
                and isinstance(column.default, sa_schema.Sequence)
                and not column.default.optional
            )
        ):
            colspec.append("AUTO_INCREMENT")
        else:
            default = self.get_column_default_string(column)

            if default is not None:
                if (
                    self.dialect._support_default_function
                    and not re.match(r"^\s*[\'\"\(]", default)
                    and not re.search(r"ON +UPDATE", default, re.I)
                    and not re.match(
                        r"\bnow\(\d+\)|\bcurrent_timestamp\(\d+\)",
                        default,
                        re.I,
                    )
                    and re.match(r".*\W.*", default)
                ):
                    colspec.append(f"DEFAULT ({default})")
                else:
                    colspec.append("DEFAULT " + default)
        return " ".join(colspec)

    def post_create_table(self, table: sa_schema.Table) -> str:
        

        table_opts = []

        opts = {
            k[len(self.dialect.name) + 1 :].upper(): v
            for k, v in table.kwargs.items()
            if k.startswith("%s_" % self.dialect.name)
        }

        if table.comment is not None:
            opts["COMMENT"] = table.comment

        partition_options = [
            "PARTITION_BY",
            "PARTITIONS",
            "SUBPARTITIONS",
            "SUBPARTITION_BY",
        ]

        nonpart_options = set(opts).difference(partition_options)
        part_options = set(opts).intersection(partition_options)

        for opt in topological.sort(
            [
                ("DEFAULT_CHARSET", "COLLATE"),
                ("DEFAULT_CHARACTER_SET", "COLLATE"),
                ("CHARSET", "COLLATE"),
                ("CHARACTER_SET", "COLLATE"),
            ],
            nonpart_options,
        ):
            arg = opts[opt]
            if opt in _reflection._options_of_type_string:
                arg = self.sql_compiler.render_literal_value(
                    arg, sqltypes.String()
                )

            if opt in (
                "DATA_DIRECTORY",
                "INDEX_DIRECTORY",
                "DEFAULT_CHARACTER_SET",
                "CHARACTER_SET",
                "DEFAULT_CHARSET",
                "DEFAULT_COLLATE",
            ):
                opt = opt.replace("_", " ")

            joiner = "="
            if opt in (
                "TABLESPACE",
                "DEFAULT CHARACTER SET",
                "CHARACTER SET",
                "COLLATE",
            ):
                joiner = " "

            table_opts.append(joiner.join((opt, arg)))

        for opt in topological.sort(
            [
                ("PARTITION_BY", "PARTITIONS"),
                ("PARTITION_BY", "SUBPARTITION_BY"),
                ("PARTITION_BY", "SUBPARTITIONS"),
                ("PARTITIONS", "SUBPARTITIONS"),
                ("PARTITIONS", "SUBPARTITION_BY"),
                ("SUBPARTITION_BY", "SUBPARTITIONS"),
            ],
            part_options,
        ):
            arg = opts[opt]
            if opt in _reflection._options_of_type_string:
                arg = self.sql_compiler.render_literal_value(
                    arg, sqltypes.String()
                )

            opt = opt.replace("_", " ")
            joiner = " "

            table_opts.append(joiner.join((opt, arg)))

        return " ".join(table_opts)

    def visit_create_index(self, create: ddl.CreateIndex, **kw: Any) -> str:  
        index = create.element
        self._verify_index_table(index)
        preparer = self.preparer
        table = preparer.format_table(index.table)  

        columns = [
            self.sql_compiler.process(
                (
                    elements.Grouping(expr)  
                    if (
                        isinstance(expr, elements.BinaryExpression)
                        or (
                            isinstance(expr, elements.UnaryExpression)
                            and expr.modifier
                            not in (operators.desc_op, operators.asc_op)
                        )
                        or isinstance(expr, functions.FunctionElement)
                    )
                    else expr
                ),
                include_table=False,
                literal_binds=True,
            )
            for expr in index.expressions
        ]

        name = self._prepared_index_name(index)

        text = "CREATE "
        if index.unique:
            text += "UNIQUE "

        index_prefix = index.kwargs.get("%s_prefix" % self.dialect.name, None)
        if index_prefix:
            text += index_prefix + " "

        text += "INDEX "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
        text += "%s ON %s " % (name, table)

        length = index.dialect_options[self.dialect.name]["length"]
        if length is not None:
            if isinstance(length, dict):
                
                
                
                columns_str = ", ".join(
                    (
                        "%s(%d)" % (expr, length[col.name])  
                        if col.name in length  
                        else (
                            "%s(%d)" % (expr, length[expr])
                            if expr in length
                            else "%s" % expr
                        )
                    )
                    for col, expr in zip(index.expressions, columns)
                )
            else:
                
                
                columns_str = ", ".join(
                    "%s(%d)" % (col, length) for col in columns
                )
        else:
            columns_str = ", ".join(columns)
        text += "(%s)" % columns_str

        parser = index.dialect_options["mysql"]["with_parser"]
        if parser is not None:
            text += " WITH PARSER %s" % (parser,)

        using = index.dialect_options["mysql"]["using"]
        if using is not None:
            text += " USING %s" % (preparer.quote(using))

        return text

    def visit_primary_key_constraint(
        self, constraint: sa_schema.PrimaryKeyConstraint, **kw: Any
    ) -> str:
        text = super().visit_primary_key_constraint(constraint)
        using = constraint.dialect_options["mysql"]["using"]
        if using:
            text += " USING %s" % (self.preparer.quote(using))
        return text

    def visit_drop_index(self, drop: ddl.DropIndex, **kw: Any) -> str:
        index = drop.element
        text = "\nDROP INDEX "
        if drop.if_exists:
            text += "IF EXISTS "

        return text + "%s ON %s" % (
            self._prepared_index_name(index, include_schema=False),
            self.preparer.format_table(index.table),  
        )

    def visit_drop_constraint(
        self, drop: ddl.DropConstraint, **kw: Any
    ) -> str:
        constraint = drop.element
        if isinstance(constraint, sa_schema.ForeignKeyConstraint):
            qual = "FOREIGN KEY "
            const = self.preparer.format_constraint(constraint)
        elif isinstance(constraint, sa_schema.PrimaryKeyConstraint):
            qual = "PRIMARY KEY "
            const = ""
        elif isinstance(constraint, sa_schema.UniqueConstraint):
            qual = "INDEX "
            const = self.preparer.format_constraint(constraint)
        elif isinstance(constraint, sa_schema.CheckConstraint):
            if self.dialect.is_mariadb:
                qual = "CONSTRAINT "
            else:
                qual = "CHECK "
            const = self.preparer.format_constraint(constraint)
        else:
            qual = ""
            const = self.preparer.format_constraint(constraint)
        return "ALTER TABLE %s DROP %s%s" % (
            self.preparer.format_table(constraint.table),
            qual,
            const,
        )

    def define_constraint_match(
        self, constraint: sa_schema.ForeignKeyConstraint
    ) -> str:
        if constraint.match is not None:
            raise exc.CompileError(
                "MySQL ignores the 'MATCH' keyword while at the same time "
                "causes ON UPDATE/ON DELETE clauses to be ignored."
            )
        return ""

    def visit_set_table_comment(
        self, create: ddl.SetTableComment, **kw: Any
    ) -> str:
        return "ALTER TABLE %s COMMENT %s" % (
            self.preparer.format_table(create.element),
            self.sql_compiler.render_literal_value(
                create.element.comment, sqltypes.String()
            ),
        )

    def visit_drop_table_comment(
        self, drop: ddl.DropTableComment, **kw: Any
    ) -> str:
        return "ALTER TABLE %s COMMENT ''" % (
            self.preparer.format_table(drop.element)
        )

    def visit_set_column_comment(
        self, create: ddl.SetColumnComment, **kw: Any
    ) -> str:
        return "ALTER TABLE %s CHANGE %s %s" % (
            self.preparer.format_table(create.element.table),
            self.preparer.format_column(create.element),
            self.get_column_specification(create.element),
        )


class MySQLTypeCompiler(compiler.GenericTypeCompiler):
    def _extend_numeric(self, type_: _NumericType, spec: str) -> str:
        "Extend a numeric-type declaration with MySQL specific extensions."

        if not self._mysql_type(type_):
            return spec

        if type_.unsigned:
            spec += " UNSIGNED"
        if type_.zerofill:
            spec += " ZEROFILL"
        return spec

    def _extend_string(
        self, type_: _StringType, defaults: Dict[str, Any], spec: str
    ) -> str:
        

        def attr(name: str) -> Any:
            return getattr(type_, name, defaults.get(name))

        if attr("charset"):
            charset = "CHARACTER SET %s" % attr("charset")
        elif attr("ascii"):
            charset = "ASCII"
        elif attr("unicode"):
            charset = "UNICODE"
        else:

            charset = None

        if attr("collation"):
            collation = "COLLATE %s" % type_.collation
        elif attr("binary"):
            collation = "BINARY"
        else:
            collation = None

        if attr("national"):
            
            return " ".join(
                [c for c in ("NATIONAL", spec, collation) if c is not None]
            )
        return " ".join(
            [c for c in (spec, charset, collation) if c is not None]
        )

    def _mysql_type(self, type_: Any) -> bool:
        return isinstance(type_, (_StringType, _NumericType))

    def visit_NUMERIC(self, type_: NUMERIC, **kw: Any) -> str:  
        if type_.precision is None:
            return self._extend_numeric(type_, "NUMERIC")
        elif type_.scale is None:
            return self._extend_numeric(
                type_,
                "NUMERIC(%(precision)s)" % {"precision": type_.precision},
            )
        else:
            return self._extend_numeric(
                type_,
                "NUMERIC(%(precision)s, %(scale)s)"
                % {"precision": type_.precision, "scale": type_.scale},
            )

    def visit_DECIMAL(self, type_: DECIMAL, **kw: Any) -> str:  
        if type_.precision is None:
            return self._extend_numeric(type_, "DECIMAL")
        elif type_.scale is None:
            return self._extend_numeric(
                type_,
                "DECIMAL(%(precision)s)" % {"precision": type_.precision},
            )
        else:
            return self._extend_numeric(
                type_,
                "DECIMAL(%(precision)s, %(scale)s)"
                % {"precision": type_.precision, "scale": type_.scale},
            )

    def visit_DOUBLE(self, type_: DOUBLE, **kw: Any) -> str:  
        if type_.precision is not None and type_.scale is not None:
            return self._extend_numeric(
                type_,
                "DOUBLE(%(precision)s, %(scale)s)"
                % {"precision": type_.precision, "scale": type_.scale},
            )
        else:
            return self._extend_numeric(type_, "DOUBLE")

    def visit_REAL(self, type_: REAL, **kw: Any) -> str:  
        if type_.precision is not None and type_.scale is not None:
            return self._extend_numeric(
                type_,
                "REAL(%(precision)s, %(scale)s)"
                % {"precision": type_.precision, "scale": type_.scale},
            )
        else:
            return self._extend_numeric(type_, "REAL")

    def visit_FLOAT(self, type_: FLOAT, **kw: Any) -> str:  
        if (
            self._mysql_type(type_)
            and type_.scale is not None
            and type_.precision is not None
        ):
            return self._extend_numeric(
                type_, "FLOAT(%s, %s)" % (type_.precision, type_.scale)
            )
        elif type_.precision is not None:
            return self._extend_numeric(
                type_, "FLOAT(%s)" % (type_.precision,)
            )
        else:
            return self._extend_numeric(type_, "FLOAT")

    def visit_INTEGER(self, type_: INTEGER, **kw: Any) -> str:  
        if self._mysql_type(type_) and type_.display_width is not None:
            return self._extend_numeric(
                type_,
                "INTEGER(%(display_width)s)"
                % {"display_width": type_.display_width},
            )
        else:
            return self._extend_numeric(type_, "INTEGER")

    def visit_BIGINT(self, type_: BIGINT, **kw: Any) -> str:  
        if self._mysql_type(type_) and type_.display_width is not None:
            return self._extend_numeric(
                type_,
                "BIGINT(%(display_width)s)"
                % {"display_width": type_.display_width},
            )
        else:
            return self._extend_numeric(type_, "BIGINT")

    def visit_MEDIUMINT(self, type_: MEDIUMINT, **kw: Any) -> str:
        if self._mysql_type(type_) and type_.display_width is not None:
            return self._extend_numeric(
                type_,
                "MEDIUMINT(%(display_width)s)"
                % {"display_width": type_.display_width},
            )
        else:
            return self._extend_numeric(type_, "MEDIUMINT")

    def visit_TINYINT(self, type_: TINYINT, **kw: Any) -> str:
        if self._mysql_type(type_) and type_.display_width is not None:
            return self._extend_numeric(
                type_, "TINYINT(%s)" % type_.display_width
            )
        else:
            return self._extend_numeric(type_, "TINYINT")

    def visit_SMALLINT(self, type_: SMALLINT, **kw: Any) -> str:  
        if self._mysql_type(type_) and type_.display_width is not None:
            return self._extend_numeric(
                type_,
                "SMALLINT(%(display_width)s)"
                % {"display_width": type_.display_width},
            )
        else:
            return self._extend_numeric(type_, "SMALLINT")

    def visit_BIT(self, type_: BIT, **kw: Any) -> str:
        if type_.length is not None:
            return "BIT(%s)" % type_.length
        else:
            return "BIT"

    def visit_DATETIME(self, type_: DATETIME, **kw: Any) -> str:  
        if getattr(type_, "fsp", None):
            return "DATETIME(%d)" % type_.fsp  
        else:
            return "DATETIME"

    def visit_DATE(self, type_: DATE, **kw: Any) -> str:  
        return "DATE"

    def visit_TIME(self, type_: TIME, **kw: Any) -> str:  
        if getattr(type_, "fsp", None):
            return "TIME(%d)" % type_.fsp  
        else:
            return "TIME"

    def visit_TIMESTAMP(self, type_: TIMESTAMP, **kw: Any) -> str:  
        if getattr(type_, "fsp", None):
            return "TIMESTAMP(%d)" % type_.fsp  
        else:
            return "TIMESTAMP"

    def visit_YEAR(self, type_: YEAR, **kw: Any) -> str:
        if type_.display_width is None:
            return "YEAR"
        else:
            return "YEAR(%s)" % type_.display_width

    def visit_TEXT(self, type_: TEXT, **kw: Any) -> str:  
        if type_.length is not None:
            return self._extend_string(type_, {}, "TEXT(%d)" % type_.length)
        else:
            return self._extend_string(type_, {}, "TEXT")

    def visit_TINYTEXT(self, type_: TINYTEXT, **kw: Any) -> str:
        return self._extend_string(type_, {}, "TINYTEXT")

    def visit_MEDIUMTEXT(self, type_: MEDIUMTEXT, **kw: Any) -> str:
        return self._extend_string(type_, {}, "MEDIUMTEXT")

    def visit_LONGTEXT(self, type_: LONGTEXT, **kw: Any) -> str:
        return self._extend_string(type_, {}, "LONGTEXT")

    def visit_VARCHAR(self, type_: VARCHAR, **kw: Any) -> str:  
        if type_.length is not None:
            return self._extend_string(type_, {}, "VARCHAR(%d)" % type_.length)
        else:
            raise exc.CompileError(
                "VARCHAR requires a length on dialect %s" % self.dialect.name
            )

    def visit_CHAR(self, type_: CHAR, **kw: Any) -> str:  
        if type_.length is not None:
            return self._extend_string(
                type_, {}, "CHAR(%(length)s)" % {"length": type_.length}
            )
        else:
            return self._extend_string(type_, {}, "CHAR")

    def visit_NVARCHAR(self, type_: NVARCHAR, **kw: Any) -> str:  
        
        
        if type_.length is not None:
            return self._extend_string(
                type_,
                {"national": True},
                "VARCHAR(%(length)s)" % {"length": type_.length},
            )
        else:
            raise exc.CompileError(
                "NVARCHAR requires a length on dialect %s" % self.dialect.name
            )

    def visit_NCHAR(self, type_: NCHAR, **kw: Any) -> str:  
        
        
        if type_.length is not None:
            return self._extend_string(
                type_,
                {"national": True},
                "CHAR(%(length)s)" % {"length": type_.length},
            )
        else:
            return self._extend_string(type_, {"national": True}, "CHAR")

    def visit_UUID(self, type_: UUID[Any], **kw: Any) -> str:  
        return "UUID"

    def visit_VARBINARY(self, type_: VARBINARY, **kw: Any) -> str:
        return "VARBINARY(%d)" % type_.length  

    def visit_JSON(self, type_: JSON, **kw: Any) -> str:
        return "JSON"

    def visit_large_binary(self, type_: LargeBinary, **kw: Any) -> str:
        return self.visit_BLOB(type_)

    def visit_enum(self, type_: ENUM, **kw: Any) -> str:  
        if not type_.native_enum:
            return super().visit_enum(type_)
        else:
            return self._visit_enumerated_values("ENUM", type_, type_.enums)

    def visit_BLOB(self, type_: LargeBinary, **kw: Any) -> str:
        if type_.length is not None:
            return "BLOB(%d)" % type_.length
        else:
            return "BLOB"

    def visit_TINYBLOB(self, type_: TINYBLOB, **kw: Any) -> str:
        return "TINYBLOB"

    def visit_MEDIUMBLOB(self, type_: MEDIUMBLOB, **kw: Any) -> str:
        return "MEDIUMBLOB"

    def visit_LONGBLOB(self, type_: LONGBLOB, **kw: Any) -> str:
        return "LONGBLOB"

    def _visit_enumerated_values(
        self, name: str, type_: _StringType, enumerated_values: Sequence[str]
    ) -> str:
        quoted_enums = []
        for e in enumerated_values:
            if self.dialect.identifier_preparer._double_percents:
                e = e.replace("%", "%%")
            quoted_enums.append("'%s'" % e.replace("'", "''"))
        return self._extend_string(
            type_, {}, "%s(%s)" % (name, ",".join(quoted_enums))
        )

    def visit_ENUM(self, type_: ENUM, **kw: Any) -> str:
        return self._visit_enumerated_values("ENUM", type_, type_.enums)

    def visit_SET(self, type_: SET, **kw: Any) -> str:
        return self._visit_enumerated_values("SET", type_, type_.values)

    def visit_BOOLEAN(self, type_: sqltypes.Boolean, **kw: Any) -> str:
        return "BOOL"


class MySQLIdentifierPreparer(compiler.IdentifierPreparer):
    reserved_words = RESERVED_WORDS_MYSQL

    def __init__(
        self,
        dialect: default.DefaultDialect,
        server_ansiquotes: bool = False,
        **kw: Any,
    ):
        if not server_ansiquotes:
            quote = "`"
        else:
            quote = '"'

        super().__init__(dialect, initial_quote=quote, escape_quote=quote)

    def _quote_free_identifiers(self, *ids: Optional[str]) -> Tuple[str, ...]:
        

        return tuple([self.quote_identifier(i) for i in ids if i is not None])


class MariaDBIdentifierPreparer(MySQLIdentifierPreparer):
    reserved_words = RESERVED_WORDS_MARIADB


class MySQLDialect(default.DefaultDialect):
    

    name = "mysql"
    supports_statement_cache = True

    supports_alter = True

    
    
    supports_native_boolean = False

    
    
    supports_native_bit = False

    
    max_identifier_length = 255
    max_index_name_length = 64
    max_constraint_name_length = 64

    div_is_floordiv = False

    supports_native_enum = True

    returns_native_bytes = True

    supports_sequences = False  
    

    sequences_optional = False

    supports_for_update_of = False  
    

    _requires_alias_for_on_duplicate_key = False  
    

    
    
    supports_default_values = False
    supports_default_metavalue = True

    use_insertmanyvalues: bool = True
    insertmanyvalues_implicit_sentinel = (
        InsertmanyvaluesSentinelOpts.ANY_AUTOINCREMENT
    )

    supports_sane_rowcount = True
    supports_sane_multi_rowcount = False
    supports_multivalues_insert = True
    insert_null_pk_still_autoincrements = True

    supports_comments = True
    inline_comments = True
    default_paramstyle = "format"
    colspecs = colspecs

    cte_follows_insert = True

    statement_compiler = MySQLCompiler
    ddl_compiler = MySQLDDLCompiler
    type_compiler_cls = MySQLTypeCompiler
    ischema_names = ischema_names
    preparer: type[MySQLIdentifierPreparer] = MySQLIdentifierPreparer

    is_mariadb: bool = False
    _mariadb_normalized_version_info = None

    
    
    
    _backslash_escapes = True
    _server_ansiquotes = False

    server_version_info: Tuple[int, ...]
    identifier_preparer: MySQLIdentifierPreparer

    construct_arguments = [
        (sa_schema.Table, {"*": None}),
        (sql.Update, {"limit": None}),
        (sql.Delete, {"limit": None}),
        (sa_schema.PrimaryKeyConstraint, {"using": None}),
        (
            sa_schema.Index,
            {
                "using": None,
                "length": None,
                "prefix": None,
                "with_parser": None,
            },
        ),
    ]

    def __init__(
        self,
        json_serializer: Optional[Callable[..., Any]] = None,
        json_deserializer: Optional[Callable[..., Any]] = None,
        is_mariadb: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        kwargs.pop("use_ansiquotes", None)  
        default.DefaultDialect.__init__(self, **kwargs)
        self._json_serializer = json_serializer
        self._json_deserializer = json_deserializer
        self._set_mariadb(is_mariadb, ())

    def get_isolation_level_values(
        self, dbapi_conn: DBAPIConnection
    ) -> Sequence[IsolationLevel]:
        return (
            "SERIALIZABLE",
            "READ UNCOMMITTED",
            "READ COMMITTED",
            "REPEATABLE READ",
        )

    def set_isolation_level(
        self, dbapi_connection: DBAPIConnection, level: IsolationLevel
    ) -> None:
        cursor = dbapi_connection.cursor()
        cursor.execute(f"SET SESSION TRANSACTION ISOLATION LEVEL {level}")
        cursor.execute("COMMIT")
        cursor.close()

    def get_isolation_level(
        self, dbapi_connection: DBAPIConnection
    ) -> IsolationLevel:
        cursor = dbapi_connection.cursor()
        if self._is_mysql and self.server_version_info >= (5, 7, 20):
            cursor.execute("SELECT @@transaction_isolation")
        else:
            cursor.execute("SELECT @@tx_isolation")
        row = cursor.fetchone()
        if row is None:
            util.warn(
                "Could not retrieve transaction isolation level for MySQL "
                "connection."
            )
            raise NotImplementedError()
        val = row[0]
        cursor.close()
        if isinstance(val, bytes):
            val = val.decode()
        return val.upper().replace("-", " ")  

    @classmethod
    def _is_mariadb_from_url(cls, url: URL) -> bool:
        dbapi = cls.import_dbapi()
        dialect = cls(dbapi=dbapi)

        cargs, cparams = dialect.create_connect_args(url)
        conn = dialect.connect(*cargs, **cparams)
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT VERSION() LIKE '%MariaDB%'")
            val = cursor.fetchone()[0]  
        except:
            raise
        else:
            return bool(val)
        finally:
            conn.close()

    def _get_server_version_info(
        self, connection: Connection
    ) -> Tuple[int, ...]:
        
        
        
        dbapi_con = connection.connection
        cursor = dbapi_con.cursor()
        cursor.execute("SELECT VERSION()")

        val = cursor.fetchone()[0]  
        cursor.close()
        if isinstance(val, bytes):
            val = val.decode()

        return self._parse_server_version(val)

    def _parse_server_version(self, val: str) -> Tuple[int, ...]:
        version: List[int] = []
        is_mariadb = False

        r = re.compile(r"[.\-+]")
        tokens = r.split(val)
        for token in tokens:
            parsed_token = re.match(
                r"^(?:(\d+)(?:a|b|c)?|(MariaDB\w*))$", token
            )
            if not parsed_token:
                continue
            elif parsed_token.group(2):
                self._mariadb_normalized_version_info = tuple(version[-3:])
                is_mariadb = True
            else:
                digit = int(parsed_token.group(1))
                version.append(digit)

        server_version_info = tuple(version)

        self._set_mariadb(
            bool(server_version_info and is_mariadb), server_version_info
        )

        if not is_mariadb:
            self._mariadb_normalized_version_info = server_version_info

        if server_version_info < (5, 0, 2):
            raise NotImplementedError(
                "the MySQL/MariaDB dialect supports server "
                "version info 5.0.2 and above."
            )

        
        self.server_version_info = server_version_info
        return server_version_info

    def _set_mariadb(
        self, is_mariadb: Optional[bool], server_version_info: Tuple[int, ...]
    ) -> None:
        if is_mariadb is None:
            return

        if not is_mariadb and self.is_mariadb:
            raise exc.InvalidRequestError(
                "MySQL version %s is not a MariaDB variant."
                % (".".join(map(str, server_version_info)),)
            )
        if is_mariadb:

            if not issubclass(self.preparer, MariaDBIdentifierPreparer):
                self.preparer = MariaDBIdentifierPreparer
                
                
                self.identifier_preparer = self.preparer(self)

            
            
            self.delete_returning = True
            self.insert_returning = True

        self.is_mariadb = is_mariadb

    def do_begin_twophase(self, connection: Connection, xid: Any) -> None:
        connection.execute(sql.text("XA BEGIN :xid"), dict(xid=xid))

    def do_prepare_twophase(self, connection: Connection, xid: Any) -> None:
        connection.execute(sql.text("XA END :xid"), dict(xid=xid))
        connection.execute(sql.text("XA PREPARE :xid"), dict(xid=xid))

    def do_rollback_twophase(
        self,
        connection: Connection,
        xid: Any,
        is_prepared: bool = True,
        recover: bool = False,
    ) -> None:
        if not is_prepared:
            connection.execute(sql.text("XA END :xid"), dict(xid=xid))
        connection.execute(sql.text("XA ROLLBACK :xid"), dict(xid=xid))

    def do_commit_twophase(
        self,
        connection: Connection,
        xid: Any,
        is_prepared: bool = True,
        recover: bool = False,
    ) -> None:
        if not is_prepared:
            self.do_prepare_twophase(connection, xid)
        connection.execute(sql.text("XA COMMIT :xid"), dict(xid=xid))

    def do_recover_twophase(self, connection: Connection) -> List[Any]:
        resultset = connection.exec_driver_sql("XA RECOVER")
        return [
            row["data"][0 : row["gtrid_length"]]
            for row in resultset.mappings()
        ]

    def is_disconnect(
        self,
        e: DBAPIModule.Error,
        connection: Optional[Union[PoolProxiedConnection, DBAPIConnection]],
        cursor: Optional[DBAPICursor],
    ) -> bool:
        if isinstance(
            e,
            (
                self.dbapi.OperationalError,  
                self.dbapi.ProgrammingError,  
                self.dbapi.InterfaceError,  
            ),
        ) and self._extract_error_code(e) in (
            1927,
            2006,
            2013,
            2014,
            2045,
            2055,
            4031,
        ):
            return True
        elif isinstance(
            e, (self.dbapi.InterfaceError, self.dbapi.InternalError)  
        ):
            
            
            return "(0, '')" in str(e)
        else:
            return False

    def _compat_fetchall(
        self, rp: CursorResult[Any], charset: Optional[str] = None
    ) -> Union[Sequence[Row[Any]], Sequence[_DecodingRow]]:
        

        return [_DecodingRow(row, charset) for row in rp.fetchall()]

    def _compat_fetchone(
        self, rp: CursorResult[Any], charset: Optional[str] = None
    ) -> Union[Row[Any], None, _DecodingRow]:
        

        row = rp.fetchone()
        if row:
            return _DecodingRow(row, charset)
        else:
            return None

    def _compat_first(
        self, rp: CursorResult[Any], charset: Optional[str] = None
    ) -> Optional[_DecodingRow]:
        

        row = rp.first()
        if row:
            return _DecodingRow(row, charset)
        else:
            return None

    def _extract_error_code(
        self, exception: DBAPIModule.Error
    ) -> Optional[int]:
        raise NotImplementedError()

    def _get_default_schema_name(self, connection: Connection) -> str:
        return connection.exec_driver_sql("SELECT DATABASE()").scalar()  

    @reflection.cache
    def has_table(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> bool:
        self._ensure_has_table_connection(connection)

        if schema is None:
            schema = self.default_schema_name

        assert schema is not None

        full_name = ".".join(
            self.identifier_preparer._quote_free_identifiers(
                schema, table_name
            )
        )

        
        
        
        
        

        try:
            with connection.exec_driver_sql(
                f"DESCRIBE {full_name}",
                execution_options={"skip_user_error_events": True},
            ) as rs:
                return rs.fetchone() is not None
        except exc.DBAPIError as e:
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            if self._extract_error_code(e.orig) in (1146, 1049, 1051):  
                return False
            raise

    @reflection.cache
    def has_sequence(
        self,
        connection: Connection,
        sequence_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> bool:
        if not self.supports_sequences:
            self._sequences_not_supported()
        if not schema:
            schema = self.default_schema_name
        
        
        cursor = connection.execute(
            sql.text(
                "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES "
                "WHERE TABLE_TYPE='SEQUENCE' and TABLE_NAME=:name AND "
                "TABLE_SCHEMA=:schema_name"
            ),
            dict(
                name=str(sequence_name),
                schema_name=str(schema),
            ),
        )
        return cursor.first() is not None

    def _sequences_not_supported(self) -> NoReturn:
        raise NotImplementedError(
            "Sequences are supported only by the "
            "MariaDB series 10.3 or greater"
        )

    @reflection.cache
    def get_sequence_names(
        self, connection: Connection, schema: Optional[str] = None, **kw: Any
    ) -> List[str]:
        if not self.supports_sequences:
            self._sequences_not_supported()
        if not schema:
            schema = self.default_schema_name
        
        cursor = connection.execute(
            sql.text(
                "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES "
                "WHERE TABLE_TYPE='SEQUENCE' and TABLE_SCHEMA=:schema_name"
            ),
            dict(schema_name=schema),
        )
        return [
            row[0]
            for row in self._compat_fetchall(
                cursor, charset=self._connection_charset
            )
        ]

    def initialize(self, connection: Connection) -> None:
        
        
        self._connection_charset: Optional[str] = self._detect_charset(
            connection
        )

        
        
        
        
        default.DefaultDialect.initialize(self, connection)

        self._detect_sql_mode(connection)
        self._detect_ansiquotes(connection)  
        self._detect_casing(connection)
        if self._server_ansiquotes:
            
            
            self.identifier_preparer = self.preparer(
                self, server_ansiquotes=self._server_ansiquotes
            )

        self.supports_sequences = (
            self.is_mariadb and self.server_version_info >= (10, 3)
        )

        self.supports_for_update_of = (
            self._is_mysql and self.server_version_info >= (8,)
        )

        self._needs_correct_for_88718_96365 = (
            not self.is_mariadb and self.server_version_info >= (8,)
        )

        self.delete_returning = (
            self.is_mariadb and self.server_version_info >= (10, 0, 5)
        )

        self.insert_returning = (
            self.is_mariadb and self.server_version_info >= (10, 5)
        )

        self._requires_alias_for_on_duplicate_key = (
            self._is_mysql and self.server_version_info >= (8, 0, 20)
        )

        self._warn_for_known_db_issues()

    def _warn_for_known_db_issues(self) -> None:
        if self.is_mariadb:
            mdb_version = self._mariadb_normalized_version_info
            assert mdb_version is not None
            if mdb_version > (10, 2) and mdb_version < (10, 2, 9):
                util.warn(
                    "MariaDB %r before 10.2.9 has known issues regarding "
                    "CHECK constraints, which impact handling of NULL values "
                    "with SQLAlchemy's boolean datatype (MDEV-13596). An "
                    "additional issue prevents proper migrations of columns "
                    "with CHECK constraints (MDEV-11114).  Please upgrade to "
                    "MariaDB 10.2.9 or greater, or use the MariaDB 10.1 "
                    "series, to avoid these issues." % (mdb_version,)
                )

    @property
    def _support_float_cast(self) -> bool:
        if not self.server_version_info:
            return False
        elif self.is_mariadb:
            
            return self.server_version_info >= (10, 4, 5)
        else:
            
            return self.server_version_info >= (8, 0, 17)

    @property
    def _support_default_function(self) -> bool:
        if not self.server_version_info:
            return False
        elif self.is_mariadb:
            
            return self.server_version_info >= (10, 2, 1)
        else:
            
            return self.server_version_info >= (8, 0, 13)

    @property
    def _is_mariadb(self) -> bool:
        return self.is_mariadb

    @property
    def _is_mysql(self) -> bool:
        return not self.is_mariadb

    @property
    def _is_mariadb_102(self) -> bool:
        return (
            self.is_mariadb
            and self._mariadb_normalized_version_info  
            > (
                10,
                2,
            )
        )

    @reflection.cache
    def get_schema_names(self, connection: Connection, **kw: Any) -> List[str]:
        rp = connection.exec_driver_sql("SHOW schemas")
        return [r[0] for r in rp]

    @reflection.cache
    def get_table_names(
        self, connection: Connection, schema: Optional[str] = None, **kw: Any
    ) -> List[str]:
        
        if schema is not None:
            current_schema: str = schema
        else:
            current_schema = self.default_schema_name  

        charset = self._connection_charset

        rp = connection.exec_driver_sql(
            "SHOW FULL TABLES FROM %s"
            % self.identifier_preparer.quote_identifier(current_schema)
        )

        return [
            row[0]
            for row in self._compat_fetchall(rp, charset=charset)
            if row[1] == "BASE TABLE"
        ]

    @reflection.cache
    def get_view_names(
        self, connection: Connection, schema: Optional[str] = None, **kw: Any
    ) -> List[str]:
        if schema is None:
            schema = self.default_schema_name
        assert schema is not None
        charset = self._connection_charset
        rp = connection.exec_driver_sql(
            "SHOW FULL TABLES FROM %s"
            % self.identifier_preparer.quote_identifier(schema)
        )
        return [
            row[0]
            for row in self._compat_fetchall(rp, charset=charset)
            if row[1] in ("VIEW", "SYSTEM VIEW")
        ]

    @reflection.cache
    def get_table_options(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> Dict[str, Any]:
        parsed_state = self._parsed_state_or_create(
            connection, table_name, schema, **kw
        )
        if parsed_state.table_options:
            return parsed_state.table_options
        else:
            return ReflectionDefaults.table_options()

    @reflection.cache
    def get_columns(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> List[ReflectedColumn]:
        parsed_state = self._parsed_state_or_create(
            connection, table_name, schema, **kw
        )
        if parsed_state.columns:
            return parsed_state.columns
        else:
            return ReflectionDefaults.columns()

    @reflection.cache
    def get_pk_constraint(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> ReflectedPrimaryKeyConstraint:
        parsed_state = self._parsed_state_or_create(
            connection, table_name, schema, **kw
        )
        for key in parsed_state.keys:
            if key["type"] == "PRIMARY":
                
                cols = [s[0] for s in key["columns"]]
                return {"constrained_columns": cols, "name": None}
        return ReflectionDefaults.pk_constraint()

    @reflection.cache
    def get_foreign_keys(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> List[ReflectedForeignKeyConstraint]:
        parsed_state = self._parsed_state_or_create(
            connection, table_name, schema, **kw
        )
        default_schema = None

        fkeys: List[ReflectedForeignKeyConstraint] = []

        for spec in parsed_state.fk_constraints:
            ref_name = spec["table"][-1]
            ref_schema = len(spec["table"]) > 1 and spec["table"][-2] or schema

            if not ref_schema:
                if default_schema is None:
                    default_schema = connection.dialect.default_schema_name
                if schema == default_schema:
                    ref_schema = schema

            loc_names = spec["local"]
            ref_names = spec["foreign"]

            con_kw = {}
            for opt in ("onupdate", "ondelete"):
                if spec.get(opt, False) not in ("NO ACTION", None):
                    con_kw[opt] = spec[opt]

            fkey_d: ReflectedForeignKeyConstraint = {
                "name": spec["name"],
                "constrained_columns": loc_names,
                "referred_schema": ref_schema,
                "referred_table": ref_name,
                "referred_columns": ref_names,
                "options": con_kw,
            }
            fkeys.append(fkey_d)

        if self._needs_correct_for_88718_96365:
            self._correct_for_mysql_bugs_88718_96365(fkeys, connection)

        return fkeys if fkeys else ReflectionDefaults.foreign_keys()

    def _correct_for_mysql_bugs_88718_96365(
        self,
        fkeys: List[ReflectedForeignKeyConstraint],
        connection: Connection,
    ) -> None:
        
        
        

        
        
        

        
        
        
        

        if self._casing in (1, 2):

            def lower(s: str) -> str:
                return s.lower()

        else:
            
            
            
            def lower(s: str) -> str:
                return s

        default_schema_name: str = connection.dialect.default_schema_name  

        
        
        
        schema_by_table_by_column: DefaultDict[
            str, DefaultDict[str, List[str]]
        ] = DefaultDict(lambda: DefaultDict(list))
        for rec in fkeys:
            sch = lower(rec["referred_schema"] or default_schema_name)
            tbl = lower(rec["referred_table"])
            for col_name in rec["referred_columns"]:
                schema_by_table_by_column[sch][tbl].append(col_name)

        if schema_by_table_by_column:

            condition = sql.or_(
                *(
                    sql.and_(
                        _info_columns.c.table_schema == schema,
                        sql.or_(
                            *(
                                sql.and_(
                                    _info_columns.c.table_name == table,
                                    sql.func.lower(
                                        _info_columns.c.column_name
                                    ).in_(columns),
                                )
                                for table, columns in tables.items()
                            )
                        ),
                    )
                    for schema, tables in schema_by_table_by_column.items()
                )
            )

            select = sql.select(
                _info_columns.c.table_schema,
                _info_columns.c.table_name,
                _info_columns.c.column_name,
            ).where(condition)

            correct_for_wrong_fk_case: CursorResult[Tuple[str, str, str]] = (
                connection.execute(select)
            )

            
            
            
            
            
            
            
            
            
            
            d: DefaultDict[Tuple[str, str], Dict[str, str]] = defaultdict(dict)
            for schema, tname, cname in correct_for_wrong_fk_case:
                d[(lower(schema), lower(tname))]["SCHEMANAME"] = schema
                d[(lower(schema), lower(tname))]["TABLENAME"] = tname
                d[(lower(schema), lower(tname))][cname.lower()] = cname

            for fkey in fkeys:
                rec_b = d[
                    (
                        lower(fkey["referred_schema"] or default_schema_name),
                        lower(fkey["referred_table"]),
                    )
                ]

                fkey["referred_table"] = rec_b["TABLENAME"]
                if fkey["referred_schema"] is not None:
                    fkey["referred_schema"] = rec_b["SCHEMANAME"]

                fkey["referred_columns"] = [
                    rec_b[col.lower()] for col in fkey["referred_columns"]
                ]

    @reflection.cache
    def get_check_constraints(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> List[ReflectedCheckConstraint]:
        parsed_state = self._parsed_state_or_create(
            connection, table_name, schema, **kw
        )

        cks: List[ReflectedCheckConstraint] = [
            {"name": spec["name"], "sqltext": spec["sqltext"]}
            for spec in parsed_state.ck_constraints
        ]
        cks.sort(key=lambda d: d["name"] or "~")  
        return cks if cks else ReflectionDefaults.check_constraints()

    @reflection.cache
    def get_table_comment(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> ReflectedTableComment:
        parsed_state = self._parsed_state_or_create(
            connection, table_name, schema, **kw
        )
        comment = parsed_state.table_options.get(f"{self.name}_comment", None)
        if comment is not None:
            return {"text": comment}
        else:
            return ReflectionDefaults.table_comment()

    @reflection.cache
    def get_indexes(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> List[ReflectedIndex]:
        parsed_state = self._parsed_state_or_create(
            connection, table_name, schema, **kw
        )

        indexes: List[ReflectedIndex] = []

        for spec in parsed_state.keys:
            dialect_options = {}
            unique = False
            flavor = spec["type"]
            if flavor == "PRIMARY":
                continue
            if flavor == "UNIQUE":
                unique = True
            elif flavor in ("FULLTEXT", "SPATIAL"):
                dialect_options["%s_prefix" % self.name] = flavor
            elif flavor is not None:
                util.warn(
                    "Converting unknown KEY type %s to a plain KEY", flavor
                )

            if spec["parser"]:
                dialect_options["%s_with_parser" % (self.name)] = spec[
                    "parser"
                ]

            index_d: ReflectedIndex = {
                "name": spec["name"],
                "column_names": [s[0] for s in spec["columns"]],
                "unique": unique,
            }

            mysql_length = {
                s[0]: s[1] for s in spec["columns"] if s[1] is not None
            }
            if mysql_length:
                dialect_options["%s_length" % self.name] = mysql_length

            if flavor:
                index_d["type"] = flavor  

            if dialect_options:
                index_d["dialect_options"] = dialect_options

            indexes.append(index_d)
        indexes.sort(key=lambda d: d["name"] or "~")  
        return indexes if indexes else ReflectionDefaults.indexes()

    @reflection.cache
    def get_unique_constraints(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> List[ReflectedUniqueConstraint]:
        parsed_state = self._parsed_state_or_create(
            connection, table_name, schema, **kw
        )

        ucs: List[ReflectedUniqueConstraint] = [
            {
                "name": key["name"],
                "column_names": [col[0] for col in key["columns"]],
                "duplicates_index": key["name"],
            }
            for key in parsed_state.keys
            if key["type"] == "UNIQUE"
        ]
        ucs.sort(key=lambda d: d["name"] or "~")  
        if ucs:
            return ucs
        else:
            return ReflectionDefaults.unique_constraints()

    @reflection.cache
    def get_view_definition(
        self,
        connection: Connection,
        view_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> str:
        charset = self._connection_charset
        full_name = ".".join(
            self.identifier_preparer._quote_free_identifiers(schema, view_name)
        )
        sql = self._show_create_table(
            connection, None, charset, full_name=full_name
        )
        if sql.upper().startswith("CREATE TABLE"):
            
            raise exc.NoSuchTableError(full_name)
        return sql

    def _parsed_state_or_create(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> _reflection.ReflectedState:
        return self._setup_parser(
            connection,
            table_name,
            schema,
            info_cache=kw.get("info_cache", None),
        )

    @util.memoized_property
    def _tabledef_parser(self) -> _reflection.MySQLTableDefinitionParser:
        
        preparer = self.identifier_preparer
        return _reflection.MySQLTableDefinitionParser(self, preparer)

    @reflection.cache
    def _setup_parser(
        self,
        connection: Connection,
        table_name: str,
        schema: Optional[str] = None,
        **kw: Any,
    ) -> _reflection.ReflectedState:
        charset = self._connection_charset
        parser = self._tabledef_parser
        full_name = ".".join(
            self.identifier_preparer._quote_free_identifiers(
                schema, table_name
            )
        )
        sql = self._show_create_table(
            connection, None, charset, full_name=full_name
        )
        if parser._check_view(sql):
            
            columns = self._describe_table(
                connection, None, charset, full_name=full_name
            )
            sql = parser._describe_to_create(
                table_name, columns  
            )
        return parser.parse(sql, charset)

    def _fetch_setting(
        self, connection: Connection, setting_name: str
    ) -> Optional[str]:
        charset = self._connection_charset

        if self.server_version_info and self.server_version_info < (5, 6):
            sql = "SHOW VARIABLES LIKE '%s'" % setting_name
            fetch_col = 1
        else:
            sql = "SELECT @@%s" % setting_name
            fetch_col = 0

        show_var = connection.exec_driver_sql(sql)
        row = self._compat_first(show_var, charset=charset)
        if not row:
            return None
        else:
            return cast(Optional[str], row[fetch_col])

    def _detect_charset(self, connection: Connection) -> str:
        raise NotImplementedError()

    def _detect_casing(self, connection: Connection) -> int:
        
        

        setting = self._fetch_setting(connection, "lower_case_table_names")
        if setting is None:
            cs = 0
        else:
            
            
            if setting == "OFF":
                cs = 0
            elif setting == "ON":
                cs = 1
            else:
                cs = int(setting)
        self._casing = cs
        return cs

    def _detect_collations(self, connection: Connection) -> Dict[str, str]:
        

        collations = {}
        charset = self._connection_charset
        rs = connection.exec_driver_sql("SHOW COLLATION")
        for row in self._compat_fetchall(rs, charset):
            collations[row[0]] = row[1]
        return collations

    def _detect_sql_mode(self, connection: Connection) -> None:
        setting = self._fetch_setting(connection, "sql_mode")

        if setting is None:
            util.warn(
                "Could not retrieve SQL_MODE; please ensure the "
                "MySQL user has permissions to SHOW VARIABLES"
            )
            self._sql_mode = ""
        else:
            self._sql_mode = setting or ""

    def _detect_ansiquotes(self, connection: Connection) -> None:
        

        mode = self._sql_mode
        if not mode:
            mode = ""
        elif mode.isdigit():
            mode_no = int(mode)
            mode = (mode_no | 4 == mode_no) and "ANSI_QUOTES" or ""

        self._server_ansiquotes = "ANSI_QUOTES" in mode

        
        self._backslash_escapes = "NO_BACKSLASH_ESCAPES" not in mode

    @overload
    def _show_create_table(
        self,
        connection: Connection,
        table: Optional[Table],
        charset: Optional[str],
        full_name: str,
    ) -> str: ...

    @overload
    def _show_create_table(
        self,
        connection: Connection,
        table: Table,
        charset: Optional[str] = None,
        full_name: None = None,
    ) -> str: ...

    def _show_create_table(
        self,
        connection: Connection,
        table: Optional[Table],
        charset: Optional[str] = None,
        full_name: Optional[str] = None,
    ) -> str:
        

        if full_name is None:
            assert table is not None
            full_name = self.identifier_preparer.format_table(table)
        st = "SHOW CREATE TABLE %s" % full_name

        try:
            rp = connection.execution_options(
                skip_user_error_events=True
            ).exec_driver_sql(st)
        except exc.DBAPIError as e:
            if self._extract_error_code(e.orig) == 1146:  
                raise exc.NoSuchTableError(full_name) from e
            else:
                raise
        row = self._compat_first(rp, charset=charset)
        if not row:
            raise exc.NoSuchTableError(full_name)
        return cast(str, row[1]).strip()

    @overload
    def _describe_table(
        self,
        connection: Connection,
        table: Optional[Table],
        charset: Optional[str],
        full_name: str,
    ) -> Union[Sequence[Row[Any]], Sequence[_DecodingRow]]: ...

    @overload
    def _describe_table(
        self,
        connection: Connection,
        table: Table,
        charset: Optional[str] = None,
        full_name: None = None,
    ) -> Union[Sequence[Row[Any]], Sequence[_DecodingRow]]: ...

    def _describe_table(
        self,
        connection: Connection,
        table: Optional[Table],
        charset: Optional[str] = None,
        full_name: Optional[str] = None,
    ) -> Union[Sequence[Row[Any]], Sequence[_DecodingRow]]:
        

        if full_name is None:
            assert table is not None
            full_name = self.identifier_preparer.format_table(table)
        st = "DESCRIBE %s" % full_name

        rp, rows = None, None
        try:
            try:
                rp = connection.execution_options(
                    skip_user_error_events=True
                ).exec_driver_sql(st)
            except exc.DBAPIError as e:
                code = self._extract_error_code(e.orig)  
                if code == 1146:
                    raise exc.NoSuchTableError(full_name) from e

                elif code == 1356:
                    raise exc.UnreflectableTableError(
                        "Table or view named %s could not be "
                        "reflected: %s" % (full_name, e)
                    ) from e

                else:
                    raise
            rows = self._compat_fetchall(rp, charset=charset)
        finally:
            if rp:
                rp.close()
        return rows


class _DecodingRow:
    

    
    
    

    _encoding_compat: Dict[str, str] = {
        "koi8r": "koi8_r",
        "koi8u": "koi8_u",
        "utf16": "utf-16-be",  
        "utf8mb4": "utf8",  
        "utf8mb3": "utf8",  
        
        "eucjpms": "ujis",
    }

    def __init__(self, rowproxy: Row[Any], charset: Optional[str]):
        self.rowproxy = rowproxy
        self.charset = (
            self._encoding_compat.get(charset, charset)
            if charset is not None
            else None
        )

    def __getitem__(self, index: int) -> Any:
        item = self.rowproxy[index]
        if self.charset and isinstance(item, bytes):
            return item.decode(self.charset)
        else:
            return item

    def __getattr__(self, attr: str) -> Any:
        item = getattr(self.rowproxy, attr)
        if self.charset and isinstance(item, bytes):
            return item.decode(self.charset)
        else:
            return item


_info_columns = sql.table(
    "columns",
    sql.column("table_schema", VARCHAR(64)),
    sql.column("table_name", VARCHAR(64)),
    sql.column("column_name", VARCHAR(64)),
    schema="information_schema",
)
