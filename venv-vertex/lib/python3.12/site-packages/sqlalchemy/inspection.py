







from __future__ import annotations

from typing import Any
from typing import Callable
from typing import Dict
from typing import Generic
from typing import Optional
from typing import overload
from typing import Type
from typing import TypeVar
from typing import Union

from . import exc
from .util.typing import Literal
from .util.typing import Protocol

_T = TypeVar("_T", bound=Any)
_TCov = TypeVar("_TCov", bound=Any, covariant=True)
_F = TypeVar("_F", bound=Callable[..., Any])

_IN = TypeVar("_IN", bound=Any)

_registrars: Dict[type, Union[Literal[True], Callable[[Any], Any]]] = {}


class Inspectable(Generic[_T]):
    

    __slots__ = ()


class _InspectableTypeProtocol(Protocol[_TCov]):
    

    def _sa_inspect_type(self) -> _TCov: ...


class _InspectableProtocol(Protocol[_TCov]):
    

    def _sa_inspect_instance(self) -> _TCov: ...


@overload
def inspect(
    subject: Type[_InspectableTypeProtocol[_IN]], raiseerr: bool = True
) -> _IN: ...


@overload
def inspect(
    subject: _InspectableProtocol[_IN], raiseerr: bool = True
) -> _IN: ...


@overload
def inspect(subject: Inspectable[_IN], raiseerr: bool = True) -> _IN: ...


@overload
def inspect(subject: Any, raiseerr: Literal[False] = ...) -> Optional[Any]: ...


@overload
def inspect(subject: Any, raiseerr: bool = True) -> Any: ...


def inspect(subject: Any, raiseerr: bool = True) -> Any:
    
    type_ = type(subject)
    for cls in type_.__mro__:
        if cls in _registrars:
            reg = _registrars.get(cls, None)
            if reg is None:
                continue
            elif reg is True:
                return subject
            ret = reg(subject)
            if ret is not None:
                return ret
    else:
        reg = ret = None

    if raiseerr and (reg is None or ret is None):
        raise exc.NoInspectionAvailable(
            "No inspection system is "
            "available for object of type %s" % type_
        )
    return ret


def _inspects(
    *types: Type[Any],
) -> Callable[[_F], _F]:
    def decorate(fn_or_cls: _F) -> _F:
        for type_ in types:
            if type_ in _registrars:
                raise AssertionError("Type %s is already registered" % type_)
            _registrars[type_] = fn_or_cls
        return fn_or_cls

    return decorate


_TT = TypeVar("_TT", bound="Type[Any]")


def _self_inspects(cls: _TT) -> _TT:
    if cls in _registrars:
        raise AssertionError("Type %s is already registered" % cls)
    _registrars[cls] = True
    return cls
