










from __future__ import annotations

import collections
from enum import Enum
import itertools
from itertools import zip_longest
import operator
import re
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import FrozenSet
from typing import Generator
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import NamedTuple
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from . import roles
from . import visitors
from .cache_key import HasCacheKey  
from .cache_key import MemoizedHasCacheKey  
from .traversals import HasCopyInternals  
from .visitors import ClauseVisitor
from .visitors import ExtendedInternalTraversal
from .visitors import ExternallyTraversible
from .visitors import InternalTraversal
from .. import event
from .. import exc
from .. import util
from ..util import HasMemoized as HasMemoized
from ..util import hybridmethod
from ..util import typing as compat_typing
from ..util.typing import Final
from ..util.typing import Protocol
from ..util.typing import Self
from ..util.typing import TypeGuard

if TYPE_CHECKING:
    from . import coercions
    from . import elements
    from . import type_api
    from ._orm_types import DMLStrategyArgument
    from ._orm_types import SynchronizeSessionArgument
    from ._typing import _CLE
    from .cache_key import CacheKey
    from .compiler import SQLCompiler
    from .elements import BindParameter
    from .elements import ClauseList
    from .elements import ColumnClause  
    from .elements import ColumnElement
    from .elements import NamedColumn
    from .elements import SQLCoreOperations
    from .elements import TextClause
    from .schema import Column
    from .schema import DefaultGenerator
    from .selectable import _JoinTargetElement
    from .selectable import _SelectIterable
    from .selectable import FromClause
    from .visitors import anon_map
    from ..engine import Connection
    from ..engine import CursorResult
    from ..engine.interfaces import _CoreMultiExecuteParams
    from ..engine.interfaces import _ExecuteOptions
    from ..engine.interfaces import _ImmutableExecuteOptions
    from ..engine.interfaces import CacheStats
    from ..engine.interfaces import Compiled
    from ..engine.interfaces import CompiledCacheType
    from ..engine.interfaces import CoreExecuteOptionsParameter
    from ..engine.interfaces import Dialect
    from ..engine.interfaces import IsolationLevel
    from ..engine.interfaces import SchemaTranslateMapType
    from ..event import dispatcher

if not TYPE_CHECKING:
    coercions = None  
    elements = None  
    type_api = None  


class _NoArg(Enum):
    NO_ARG = 0

    def __repr__(self):
        return f"_NoArg.{self.name}"


NO_ARG: Final = _NoArg.NO_ARG


class _NoneName(Enum):
    NONE_NAME = 0
    


_NONE_NAME: Final = _NoneName.NONE_NAME

_T = TypeVar("_T", bound=Any)

_Fn = TypeVar("_Fn", bound=Callable[..., Any])

_AmbiguousTableNameMap = MutableMapping[str, str]


class _DefaultDescriptionTuple(NamedTuple):
    arg: Any
    is_scalar: Optional[bool]
    is_callable: Optional[bool]
    is_sentinel: Optional[bool]

    @classmethod
    def _from_column_default(
        cls, default: Optional[DefaultGenerator]
    ) -> _DefaultDescriptionTuple:
        return (
            _DefaultDescriptionTuple(
                default.arg,  
                default.is_scalar,
                default.is_callable,
                default.is_sentinel,
            )
            if default
            and (
                default.has_arg
                or (not default.for_update and default.is_sentinel)
            )
            else _DefaultDescriptionTuple(None, None, None, None)
        )


_never_select_column: operator.attrgetter[Any] = operator.attrgetter(
    "_omit_from_statements"
)


class _EntityNamespace(Protocol):
    def __getattr__(self, key: str) -> SQLCoreOperations[Any]: ...


class _HasEntityNamespace(Protocol):
    @util.ro_non_memoized_property
    def entity_namespace(self) -> _EntityNamespace: ...


def _is_has_entity_namespace(element: Any) -> TypeGuard[_HasEntityNamespace]:
    return hasattr(element, "entity_namespace")



_Self = TypeVar("_Self", bound=Any)


class Immutable:
    

    __slots__ = ()

    _is_immutable: bool = True

    def unique_params(self, *optionaldict: Any, **kwargs: Any) -> NoReturn:
        raise NotImplementedError("Immutable objects do not support copying")

    def params(self, *optionaldict: Any, **kwargs: Any) -> NoReturn:
        raise NotImplementedError("Immutable objects do not support copying")

    def _clone(self: _Self, **kw: Any) -> _Self:
        return self

    def _copy_internals(
        self, *, omit_attrs: Iterable[str] = (), **kw: Any
    ) -> None:
        pass


class SingletonConstant(Immutable):
    

    _is_singleton_constant: bool = True

    _singleton: SingletonConstant

    def __new__(cls: _T, *arg: Any, **kw: Any) -> _T:
        return cast(_T, cls._singleton)

    @util.non_memoized_property
    def proxy_set(self) -> FrozenSet[ColumnElement[Any]]:
        raise NotImplementedError()

    @classmethod
    def _create_singleton(cls) -> None:
        obj = object.__new__(cls)
        obj.__init__()  

        
        
        
        
        
        
        
        obj.proxy_set = frozenset([obj])
        cls._singleton = obj


def _from_objects(
    *elements: Union[
        ColumnElement[Any], FromClause, TextClause, _JoinTargetElement
    ]
) -> Iterator[FromClause]:
    return itertools.chain.from_iterable(
        [element._from_objects for element in elements]
    )


def _select_iterables(
    elements: Iterable[roles.ColumnsClauseRole],
) -> _SelectIterable:
    
    return itertools.chain.from_iterable(
        [c._select_iterable for c in elements]
    )


_SelfGenerativeType = TypeVar("_SelfGenerativeType", bound="_GenerativeType")


class _GenerativeType(compat_typing.Protocol):
    def _generate(self) -> Self: ...


def _generative(fn: _Fn) -> _Fn:
    

    @util.decorator
    def _generative(
        fn: _Fn, self: _SelfGenerativeType, *args: Any, **kw: Any
    ) -> _SelfGenerativeType:
        

        self = self._generate()
        x = fn(self, *args, **kw)
        assert x is self, "generative methods must return self"
        return self

    decorated = _generative(fn)
    decorated.non_generative = fn  
    return decorated


def _exclusive_against(*names: str, **kw: Any) -> Callable[[_Fn], _Fn]:
    msgs: Dict[str, str] = kw.pop("msgs", {})

    defaults: Dict[str, str] = kw.pop("defaults", {})

    getters: List[Tuple[str, operator.attrgetter[Any], Optional[str]]] = [
        (name, operator.attrgetter(name), defaults.get(name, None))
        for name in names
    ]

    @util.decorator
    def check(fn: _Fn, *args: Any, **kw: Any) -> Any:
        
        
        self = args[0]
        args = args[1:]
        for name, getter, default_ in getters:
            if getter(self) is not default_:
                msg = msgs.get(
                    name,
                    "Method %s() has already been invoked on this %s construct"
                    % (fn.__name__, self.__class__),
                )
                raise exc.InvalidRequestError(msg)
        return fn(self, *args, **kw)

    return check


def _clone(element, **kw):
    return element._clone(**kw)


def _expand_cloned(
    elements: Iterable[_CLE],
) -> Iterable[_CLE]:
    
    
    return itertools.chain(*[x._cloned_set for x in elements])


def _de_clone(
    elements: Iterable[_CLE],
) -> Iterable[_CLE]:
    for x in elements:
        while x._is_clone_of is not None:
            x = x._is_clone_of
        yield x


def _cloned_intersection(a: Iterable[_CLE], b: Iterable[_CLE]) -> Set[_CLE]:
    
    all_overlap: Set[_CLE] = set(_expand_cloned(a)).intersection(
        _expand_cloned(b)
    )
    return {elem for elem in a if all_overlap.intersection(elem._cloned_set)}


def _cloned_difference(a: Iterable[_CLE], b: Iterable[_CLE]) -> Set[_CLE]:
    all_overlap: Set[_CLE] = set(_expand_cloned(a)).intersection(
        _expand_cloned(b)
    )
    return {
        elem for elem in a if not all_overlap.intersection(elem._cloned_set)
    }


class _DialectArgView(MutableMapping[str, Any]):
    

    __slots__ = ("obj",)

    def __init__(self, obj: DialectKWArgs) -> None:
        self.obj = obj

    def _key(self, key: str) -> Tuple[str, str]:
        try:
            dialect, value_key = key.split("_", 1)
        except ValueError as err:
            raise KeyError(key) from err
        else:
            return dialect, value_key

    def __getitem__(self, key: str) -> Any:
        dialect, value_key = self._key(key)

        try:
            opt = self.obj.dialect_options[dialect]
        except exc.NoSuchModuleError as err:
            raise KeyError(key) from err
        else:
            return opt[value_key]

    def __setitem__(self, key: str, value: Any) -> None:
        try:
            dialect, value_key = self._key(key)
        except KeyError as err:
            raise exc.ArgumentError(
                "Keys must be of the form <dialectname>_<argname>"
            ) from err
        else:
            self.obj.dialect_options[dialect][value_key] = value

    def __delitem__(self, key: str) -> None:
        dialect, value_key = self._key(key)
        del self.obj.dialect_options[dialect][value_key]

    def __len__(self) -> int:
        return sum(
            len(args._non_defaults)
            for args in self.obj.dialect_options.values()
        )

    def __iter__(self) -> Generator[str, None, None]:
        return (
            "%s_%s" % (dialect_name, value_name)
            for dialect_name in self.obj.dialect_options
            for value_name in self.obj.dialect_options[
                dialect_name
            ]._non_defaults
        )


class _DialectArgDict(MutableMapping[str, Any]):
    

    def __init__(self) -> None:
        self._non_defaults: Dict[str, Any] = {}
        self._defaults: Dict[str, Any] = {}

    def __len__(self) -> int:
        return len(set(self._non_defaults).union(self._defaults))

    def __iter__(self) -> Iterator[str]:
        return iter(set(self._non_defaults).union(self._defaults))

    def __getitem__(self, key: str) -> Any:
        if key in self._non_defaults:
            return self._non_defaults[key]
        else:
            return self._defaults[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self._non_defaults[key] = value

    def __delitem__(self, key: str) -> None:
        del self._non_defaults[key]


@util.preload_module("sqlalchemy.dialects")
def _kw_reg_for_dialect(dialect_name: str) -> Optional[Dict[Any, Any]]:
    dialect_cls = util.preloaded.dialects.registry.load(dialect_name)
    if dialect_cls.construct_arguments is None:
        return None
    return dict(dialect_cls.construct_arguments)


class DialectKWArgs:
    

    __slots__ = ()

    _dialect_kwargs_traverse_internals: List[Tuple[str, Any]] = [
        ("dialect_options", InternalTraversal.dp_dialect_options)
    ]

    @classmethod
    def argument_for(
        cls, dialect_name: str, argument_name: str, default: Any
    ) -> None:
        

        construct_arg_dictionary: Optional[Dict[Any, Any]] = (
            DialectKWArgs._kw_registry[dialect_name]
        )
        if construct_arg_dictionary is None:
            raise exc.ArgumentError(
                "Dialect '%s' does have keyword-argument "
                "validation and defaults enabled configured" % dialect_name
            )
        if cls not in construct_arg_dictionary:
            construct_arg_dictionary[cls] = {}
        construct_arg_dictionary[cls][argument_name] = default

    @property
    def dialect_kwargs(self) -> _DialectArgView:
        
        return _DialectArgView(self)

    @property
    def kwargs(self) -> _DialectArgView:
        
        return self.dialect_kwargs

    _kw_registry: util.PopulateDict[str, Optional[Dict[Any, Any]]] = (
        util.PopulateDict(_kw_reg_for_dialect)
    )

    @classmethod
    def _kw_reg_for_dialect_cls(cls, dialect_name: str) -> _DialectArgDict:
        construct_arg_dictionary = DialectKWArgs._kw_registry[dialect_name]
        d = _DialectArgDict()

        if construct_arg_dictionary is None:
            d._defaults.update({"*": None})
        else:
            for cls in reversed(cls.__mro__):
                if cls in construct_arg_dictionary:
                    d._defaults.update(construct_arg_dictionary[cls])
        return d

    @util.memoized_property
    def dialect_options(self) -> util.PopulateDict[str, _DialectArgDict]:
        

        return util.PopulateDict(self._kw_reg_for_dialect_cls)

    def _validate_dialect_kwargs(self, kwargs: Dict[str, Any]) -> None:
        

        if not kwargs:
            return

        for k in kwargs:
            m = re.match("^(.+?)_(.+)$", k)
            if not m:
                raise TypeError(
                    "Additional arguments should be "
                    "named <dialectname>_<argument>, got '%s'" % k
                )
            dialect_name, arg_name = m.group(1, 2)

            try:
                construct_arg_dictionary = self.dialect_options[dialect_name]
            except exc.NoSuchModuleError:
                util.warn(
                    "Can't validate argument %r; can't "
                    "locate any SQLAlchemy dialect named %r"
                    % (k, dialect_name)
                )
                self.dialect_options[dialect_name] = d = _DialectArgDict()
                d._defaults.update({"*": None})
                d._non_defaults[arg_name] = kwargs[k]
            else:
                if (
                    "*" not in construct_arg_dictionary
                    and arg_name not in construct_arg_dictionary
                ):
                    raise exc.ArgumentError(
                        "Argument %r is not accepted by "
                        "dialect %r on behalf of %r"
                        % (k, dialect_name, self.__class__)
                    )
                else:
                    construct_arg_dictionary[arg_name] = kwargs[k]


class CompileState:
    

    __slots__ = ("statement", "_ambiguous_table_name_map")

    plugins: Dict[Tuple[str, str], Type[CompileState]] = {}

    _ambiguous_table_name_map: Optional[_AmbiguousTableNameMap]

    @classmethod
    def create_for_statement(
        cls, statement: Executable, compiler: SQLCompiler, **kw: Any
    ) -> CompileState:
        

        if statement._propagate_attrs:
            plugin_name = statement._propagate_attrs.get(
                "compile_state_plugin", "default"
            )
            klass = cls.plugins.get(
                (plugin_name, statement._effective_plugin_target), None
            )
            if klass is None:
                klass = cls.plugins[
                    ("default", statement._effective_plugin_target)
                ]

        else:
            klass = cls.plugins[
                ("default", statement._effective_plugin_target)
            ]

        if klass is cls:
            return cls(statement, compiler, **kw)
        else:
            return klass.create_for_statement(statement, compiler, **kw)

    def __init__(self, statement, compiler, **kw):
        self.statement = statement

    @classmethod
    def get_plugin_class(
        cls, statement: Executable
    ) -> Optional[Type[CompileState]]:
        plugin_name = statement._propagate_attrs.get(
            "compile_state_plugin", None
        )

        if plugin_name:
            key = (plugin_name, statement._effective_plugin_target)
            if key in cls.plugins:
                return cls.plugins[key]

        
        
        
        
        try:
            return cls.plugins[("default", statement._effective_plugin_target)]
        except KeyError:
            return None

    @classmethod
    def _get_plugin_class_for_plugin(
        cls, statement: Executable, plugin_name: str
    ) -> Optional[Type[CompileState]]:
        try:
            return cls.plugins[
                (plugin_name, statement._effective_plugin_target)
            ]
        except KeyError:
            return None

    @classmethod
    def plugin_for(
        cls, plugin_name: str, visit_name: str
    ) -> Callable[[_Fn], _Fn]:
        def decorate(cls_to_decorate):
            cls.plugins[(plugin_name, visit_name)] = cls_to_decorate
            return cls_to_decorate

        return decorate


class Generative(HasMemoized):
    

    def _generate(self) -> Self:
        skip = self._memoized_keys
        cls = self.__class__
        s = cls.__new__(cls)
        if skip:
            
            s.__dict__ = {
                k: v for k, v in self.__dict__.copy().items() if k not in skip
            }
        else:
            s.__dict__ = self.__dict__.copy()
        return s


class InPlaceGenerative(HasMemoized):
    

    __slots__ = ()

    def _generate(self):
        skip = self._memoized_keys
        
        for k in skip:
            self.__dict__.pop(k, None)
        return self


class HasCompileState(Generative):
    

    _compile_state_plugin: Optional[Type[CompileState]] = None

    _attributes: util.immutabledict[str, Any] = util.EMPTY_DICT

    _compile_state_factory = CompileState.create_for_statement


class _MetaOptions(type):
    

    _cache_attrs: Tuple[str, ...]

    def __add__(self, other):
        o1 = self()

        if set(other).difference(self._cache_attrs):
            raise TypeError(
                "dictionary contains attributes not covered by "
                "Options class %s: %r"
                % (self, set(other).difference(self._cache_attrs))
            )

        o1.__dict__.update(other)
        return o1

    if TYPE_CHECKING:

        def __getattr__(self, key: str) -> Any: ...

        def __setattr__(self, key: str, value: Any) -> None: ...

        def __delattr__(self, key: str) -> None: ...


class Options(metaclass=_MetaOptions):
    

    __slots__ = ()

    _cache_attrs: Tuple[str, ...]

    def __init_subclass__(cls) -> None:
        dict_ = cls.__dict__
        cls._cache_attrs = tuple(
            sorted(
                d
                for d in dict_
                if not d.startswith("__")
                and d not in ("_cache_key_traversal",)
            )
        )
        super().__init_subclass__()

    def __init__(self, **kw: Any) -> None:
        self.__dict__.update(kw)

    def __add__(self, other):
        o1 = self.__class__.__new__(self.__class__)
        o1.__dict__.update(self.__dict__)

        if set(other).difference(self._cache_attrs):
            raise TypeError(
                "dictionary contains attributes not covered by "
                "Options class %s: %r"
                % (self, set(other).difference(self._cache_attrs))
            )

        o1.__dict__.update(other)
        return o1

    def __eq__(self, other):
        
        
        for a, b in zip_longest(self._cache_attrs, other._cache_attrs):
            if getattr(self, a) != getattr(other, b):
                return False
        return True

    def __repr__(self) -> str:
        

        return "%s(%s)" % (
            self.__class__.__name__,
            ", ".join(
                "%s=%r" % (k, self.__dict__[k])
                for k in self._cache_attrs
                if k in self.__dict__
            ),
        )

    @classmethod
    def isinstance(cls, klass: Type[Any]) -> bool:
        return issubclass(cls, klass)

    @hybridmethod
    def add_to_element(self, name: str, value: str) -> Any:
        return self + {name: getattr(self, name) + value}

    @hybridmethod
    def _state_dict_inst(self) -> Mapping[str, Any]:
        return self.__dict__

    _state_dict_const: util.immutabledict[str, Any] = util.EMPTY_DICT

    @_state_dict_inst.classlevel
    def _state_dict(cls) -> Mapping[str, Any]:
        return cls._state_dict_const

    @classmethod
    def safe_merge(cls, other: "Options") -> Any:
        d = other._state_dict()

        
        
        
        

        if (
            cls is not other.__class__
            and other._cache_attrs
            and set(other._cache_attrs).difference(cls._cache_attrs)
        ):
            raise TypeError(
                "other element %r is not empty, is not of type %s, "
                "and contains attributes not covered here %r"
                % (
                    other,
                    cls,
                    set(other._cache_attrs).difference(cls._cache_attrs),
                )
            )
        return cls + d

    @classmethod
    def from_execution_options(
        cls,
        key: str,
        attrs: set[str],
        exec_options: Mapping[str, Any],
        statement_exec_options: Mapping[str, Any],
    ) -> Tuple["Options", Mapping[str, Any]]:
        

        
        
        check_argnames = attrs.intersection(
            set(exec_options).union(statement_exec_options)
        )

        existing_options = exec_options.get(key, cls)

        if check_argnames:
            result = {}
            for argname in check_argnames:
                local = "_" + argname
                if argname in exec_options:
                    result[local] = exec_options[argname]
                elif argname in statement_exec_options:
                    result[local] = statement_exec_options[argname]

            new_options = existing_options + result
            exec_options = util.immutabledict(exec_options).merge_with(
                {key: new_options}
            )
            return new_options, exec_options

        else:
            return existing_options, exec_options

    if TYPE_CHECKING:

        def __getattr__(self, key: str) -> Any: ...

        def __setattr__(self, key: str, value: Any) -> None: ...

        def __delattr__(self, key: str) -> None: ...


class CacheableOptions(Options, HasCacheKey):
    __slots__ = ()

    @hybridmethod
    def _gen_cache_key_inst(
        self, anon_map: Any, bindparams: List[BindParameter[Any]]
    ) -> Optional[Tuple[Any]]:
        return HasCacheKey._gen_cache_key(self, anon_map, bindparams)

    @_gen_cache_key_inst.classlevel
    def _gen_cache_key(
        cls, anon_map: "anon_map", bindparams: List[BindParameter[Any]]
    ) -> Tuple[CacheableOptions, Any]:
        return (cls, ())

    @hybridmethod
    def _generate_cache_key(self) -> Optional[CacheKey]:
        return HasCacheKey._generate_cache_key_for_object(self)


class ExecutableOption(HasCopyInternals):
    __slots__ = ()

    _annotations: _ImmutableExecuteOptions = util.EMPTY_DICT

    __visit_name__: str = "executable_option"

    _is_has_cache_key: bool = False

    _is_core: bool = True

    def _clone(self, **kw):
        
        c = self.__class__.__new__(self.__class__)
        c.__dict__ = dict(self.__dict__)  
        return c


class Executable(roles.StatementRole):
    

    supports_execution: bool = True
    _execution_options: _ImmutableExecuteOptions = util.EMPTY_DICT
    _is_default_generator: bool = False
    _with_options: Tuple[ExecutableOption, ...] = ()
    _with_context_options: Tuple[
        Tuple[Callable[[CompileState], None], Any], ...
    ] = ()
    _compile_options: Optional[Union[Type[CacheableOptions], CacheableOptions]]

    _executable_traverse_internals = [
        ("_with_options", InternalTraversal.dp_executable_options),
        (
            "_with_context_options",
            ExtendedInternalTraversal.dp_with_context_options,
        ),
        ("_propagate_attrs", ExtendedInternalTraversal.dp_propagate_attrs),
    ]

    is_select: bool = False
    is_from_statement: bool = False
    is_update: bool = False
    is_insert: bool = False
    is_text: bool = False
    is_delete: bool = False
    is_dml: bool = False

    if TYPE_CHECKING:
        __visit_name__: str

        def _compile_w_cache(
            self,
            dialect: Dialect,
            *,
            compiled_cache: Optional[CompiledCacheType],
            column_keys: List[str],
            for_executemany: bool = False,
            schema_translate_map: Optional[SchemaTranslateMapType] = None,
            **kw: Any,
        ) -> Tuple[
            Compiled, Optional[Sequence[BindParameter[Any]]], CacheStats
        ]: ...

        def _execute_on_connection(
            self,
            connection: Connection,
            distilled_params: _CoreMultiExecuteParams,
            execution_options: CoreExecuteOptionsParameter,
        ) -> CursorResult[Any]: ...

        def _execute_on_scalar(
            self,
            connection: Connection,
            distilled_params: _CoreMultiExecuteParams,
            execution_options: CoreExecuteOptionsParameter,
        ) -> Any: ...

    @util.ro_non_memoized_property
    def _all_selected_columns(self) -> _SelectIterable:
        raise NotImplementedError()

    @property
    def _effective_plugin_target(self) -> str:
        return self.__visit_name__

    @_generative
    def options(self, *options: ExecutableOption) -> Self:
        
        self._with_options += tuple(
            coercions.expect(roles.ExecutableOptionRole, opt)
            for opt in options
        )
        return self

    @_generative
    def _set_compile_options(self, compile_options: CacheableOptions) -> Self:
        

        self._compile_options = compile_options
        return self

    @_generative
    def _update_compile_options(self, options: CacheableOptions) -> Self:
        

        assert self._compile_options is not None
        self._compile_options += options
        return self

    @_generative
    def _add_context_option(
        self,
        callable_: Callable[[CompileState], None],
        cache_args: Any,
    ) -> Self:
        
        self._with_context_options += ((callable_, cache_args),)
        return self

    @overload
    def execution_options(
        self,
        *,
        compiled_cache: Optional[CompiledCacheType] = ...,
        logging_token: str = ...,
        isolation_level: IsolationLevel = ...,
        no_parameters: bool = False,
        stream_results: bool = False,
        max_row_buffer: int = ...,
        yield_per: int = ...,
        insertmanyvalues_page_size: int = ...,
        schema_translate_map: Optional[SchemaTranslateMapType] = ...,
        populate_existing: bool = False,
        autoflush: bool = False,
        synchronize_session: SynchronizeSessionArgument = ...,
        dml_strategy: DMLStrategyArgument = ...,
        render_nulls: bool = ...,
        is_delete_using: bool = ...,
        is_update_from: bool = ...,
        preserve_rowcount: bool = False,
        **opt: Any,
    ) -> Self: ...

    @overload
    def execution_options(self, **opt: Any) -> Self: ...

    @_generative
    def execution_options(self, **kw: Any) -> Self:
          
        if "isolation_level" in kw:
            raise exc.ArgumentError(
                "'isolation_level' execution option may only be specified "
                "on Connection.execution_options(), or "
                "per-engine using the isolation_level "
                "argument to create_engine()."
            )
        if "compiled_cache" in kw:
            raise exc.ArgumentError(
                "'compiled_cache' execution option may only be specified "
                "on Connection.execution_options(), not per statement."
            )
        self._execution_options = self._execution_options.union(kw)
        return self

    def get_execution_options(self) -> _ExecuteOptions:
        
        return self._execution_options


class SchemaEventTarget(event.EventTarget):
    

    dispatch: dispatcher[SchemaEventTarget]

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        

    def _set_parent_with_dispatch(
        self, parent: SchemaEventTarget, **kw: Any
    ) -> None:
        self.dispatch.before_parent_attach(self, parent)
        self._set_parent(parent, **kw)
        self.dispatch.after_parent_attach(self, parent)


class SchemaVisitable(SchemaEventTarget, visitors.Visitable):
    


class SchemaVisitor(ClauseVisitor):
    

    __traverse_options__: Dict[str, Any] = {"schema_visitor": True}


class _SentinelDefaultCharacterization(Enum):
    NONE = "none"
    UNKNOWN = "unknown"
    CLIENTSIDE = "clientside"
    SENTINEL_DEFAULT = "sentinel_default"
    SERVERSIDE = "serverside"
    IDENTITY = "identity"
    SEQUENCE = "sequence"


class _SentinelColumnCharacterization(NamedTuple):
    columns: Optional[Sequence[Column[Any]]] = None
    is_explicit: bool = False
    is_autoinc: bool = False
    default_characterization: _SentinelDefaultCharacterization = (
        _SentinelDefaultCharacterization.NONE
    )


_COLKEY = TypeVar("_COLKEY", Union[None, str], str)

_COL_co = TypeVar("_COL_co", bound="ColumnElement[Any]", covariant=True)
_COL = TypeVar("_COL", bound="ColumnElement[Any]")


class _ColumnMetrics(Generic[_COL_co]):
    __slots__ = ("column",)

    column: _COL_co

    def __init__(
        self, collection: ColumnCollection[Any, _COL_co], col: _COL_co
    ) -> None:
        self.column = col

        
        
        pi = collection._proxy_index
        if pi:
            for eps_col in col._expanded_proxy_set:
                pi[eps_col].add(self)

    def get_expanded_proxy_set(self) -> FrozenSet[ColumnElement[Any]]:
        return self.column._expanded_proxy_set

    def dispose(self, collection: ColumnCollection[_COLKEY, _COL_co]) -> None:
        pi = collection._proxy_index
        if not pi:
            return
        for col in self.column._expanded_proxy_set:
            colset = pi.get(col, None)
            if colset:
                colset.discard(self)
            if colset is not None and not colset:
                del pi[col]

    def embedded(
        self,
        target_set: Union[
            Set[ColumnElement[Any]], FrozenSet[ColumnElement[Any]]
        ],
    ) -> bool:
        expanded_proxy_set = self.column._expanded_proxy_set
        for t in target_set.difference(expanded_proxy_set):
            if not expanded_proxy_set.intersection(_expand_cloned([t])):
                return False
        return True


class ColumnCollection(Generic[_COLKEY, _COL_co]):
    

    __slots__ = ("_collection", "_index", "_colset", "_proxy_index")

    _collection: List[Tuple[_COLKEY, _COL_co, _ColumnMetrics[_COL_co]]]
    _index: Dict[Union[None, str, int], Tuple[_COLKEY, _COL_co]]
    _proxy_index: Dict[ColumnElement[Any], Set[_ColumnMetrics[_COL_co]]]
    _colset: Set[_COL_co]

    def __init__(
        self, columns: Optional[Iterable[Tuple[_COLKEY, _COL_co]]] = None
    ):
        object.__setattr__(self, "_colset", set())
        object.__setattr__(self, "_index", {})
        object.__setattr__(
            self, "_proxy_index", collections.defaultdict(util.OrderedSet)
        )
        object.__setattr__(self, "_collection", [])
        if columns:
            self._initial_populate(columns)

    @util.preload_module("sqlalchemy.sql.elements")
    def __clause_element__(self) -> ClauseList:
        elements = util.preloaded.sql_elements

        return elements.ClauseList(
            _literal_as_text_role=roles.ColumnsClauseRole,
            group=False,
            *self._all_columns,
        )

    def _initial_populate(
        self, iter_: Iterable[Tuple[_COLKEY, _COL_co]]
    ) -> None:
        self._populate_separate_keys(iter_)

    @property
    def _all_columns(self) -> List[_COL_co]:
        return [col for (_, col, _) in self._collection]

    def keys(self) -> List[_COLKEY]:
        
        return [k for (k, _, _) in self._collection]

    def values(self) -> List[_COL_co]:
        
        return [col for (_, col, _) in self._collection]

    def items(self) -> List[Tuple[_COLKEY, _COL_co]]:
        

        return [(k, col) for (k, col, _) in self._collection]

    def __bool__(self) -> bool:
        return bool(self._collection)

    def __len__(self) -> int:
        return len(self._collection)

    def __iter__(self) -> Iterator[_COL_co]:
        
        return iter([col for _, col, _ in self._collection])

    @overload
    def __getitem__(self, key: Union[str, int]) -> _COL_co: ...

    @overload
    def __getitem__(
        self, key: Tuple[Union[str, int], ...]
    ) -> ReadOnlyColumnCollection[_COLKEY, _COL_co]: ...

    @overload
    def __getitem__(
        self, key: slice
    ) -> ReadOnlyColumnCollection[_COLKEY, _COL_co]: ...

    def __getitem__(
        self, key: Union[str, int, slice, Tuple[Union[str, int], ...]]
    ) -> Union[ReadOnlyColumnCollection[_COLKEY, _COL_co], _COL_co]:
        try:
            if isinstance(key, (tuple, slice)):
                if isinstance(key, slice):
                    cols = (
                        (sub_key, col)
                        for (sub_key, col, _) in self._collection[key]
                    )
                else:
                    cols = (self._index[sub_key] for sub_key in key)

                return ColumnCollection(cols).as_readonly()
            else:
                return self._index[key][1]
        except KeyError as err:
            if isinstance(err.args[0], int):
                raise IndexError(err.args[0]) from err
            else:
                raise

    def __getattr__(self, key: str) -> _COL_co:
        try:
            return self._index[key][1]
        except KeyError as err:
            raise AttributeError(key) from err

    def __contains__(self, key: str) -> bool:
        if key not in self._index:
            if not isinstance(key, str):
                raise exc.ArgumentError(
                    "__contains__ requires a string argument"
                )
            return False
        else:
            return True

    def compare(self, other: ColumnCollection[_COLKEY, _COL_co]) -> bool:
        

        for l, r in zip_longest(self, other):
            if l is not r:
                return False
        else:
            return True

    def __eq__(self, other: Any) -> bool:
        return self.compare(other)

    @overload
    def get(self, key: str, default: None = None) -> Optional[_COL_co]: ...

    @overload
    def get(self, key: str, default: _COL) -> Union[_COL_co, _COL]: ...

    def get(
        self, key: str, default: Optional[_COL] = None
    ) -> Optional[Union[_COL_co, _COL]]:
        

        if key in self._index:
            return self._index[key][1]
        else:
            return default

    def __str__(self) -> str:
        return "%s(%s)" % (
            self.__class__.__name__,
            ", ".join(str(c) for c in self),
        )

    def __setitem__(self, key: str, value: Any) -> NoReturn:
        raise NotImplementedError()

    def __delitem__(self, key: str) -> NoReturn:
        raise NotImplementedError()

    def __setattr__(self, key: str, obj: Any) -> NoReturn:
        raise NotImplementedError()

    def clear(self) -> NoReturn:
        
        raise NotImplementedError()

    def remove(self, column: Any) -> NoReturn:
        raise NotImplementedError()

    def update(self, iter_: Any) -> NoReturn:
        
        raise NotImplementedError()

    
    __hash__: Optional[int] = None  

    def _populate_separate_keys(
        self, iter_: Iterable[Tuple[_COLKEY, _COL_co]]
    ) -> None:
        

        self._collection[:] = collection = [
            (k, c, _ColumnMetrics(self, c)) for k, c in iter_
        ]
        self._colset.update(c._deannotate() for _, c, _ in collection)
        self._index.update(
            {idx: (k, c) for idx, (k, c, _) in enumerate(collection)}
        )
        self._index.update({k: (k, col) for k, col, _ in reversed(collection)})

    def add(
        self, column: ColumnElement[Any], key: Optional[_COLKEY] = None
    ) -> None:
        
        colkey: _COLKEY

        if key is None:
            colkey = column.key  
        else:
            colkey = key

        l = len(self._collection)

        
        

        _column = cast(_COL_co, column)

        self._collection.append(
            (colkey, _column, _ColumnMetrics(self, _column))
        )
        self._colset.add(_column._deannotate())
        self._index[l] = (colkey, _column)
        if colkey not in self._index:
            self._index[colkey] = (colkey, _column)

    def __getstate__(self) -> Dict[str, Any]:
        return {
            "_collection": [(k, c) for k, c, _ in self._collection],
            "_index": self._index,
        }

    def __setstate__(self, state: Dict[str, Any]) -> None:
        object.__setattr__(self, "_index", state["_index"])
        object.__setattr__(
            self, "_proxy_index", collections.defaultdict(util.OrderedSet)
        )
        object.__setattr__(
            self,
            "_collection",
            [
                (k, c, _ColumnMetrics(self, c))
                for (k, c) in state["_collection"]
            ],
        )
        object.__setattr__(
            self, "_colset", {col for k, col, _ in self._collection}
        )

    def contains_column(self, col: ColumnElement[Any]) -> bool:
        
        if col not in self._colset:
            if isinstance(col, str):
                raise exc.ArgumentError(
                    "contains_column cannot be used with string arguments. "
                    "Use ``col_name in table.c`` instead."
                )
            return False
        else:
            return True

    def as_readonly(self) -> ReadOnlyColumnCollection[_COLKEY, _COL_co]:
        

        return ReadOnlyColumnCollection(self)

    def _init_proxy_index(self) -> None:
        
        pi = self._proxy_index
        if pi:
            return

        for _, _, metrics in self._collection:
            eps = metrics.column._expanded_proxy_set

            for eps_col in eps:
                pi[eps_col].add(metrics)

    def corresponding_column(
        self, column: _COL, require_embedded: bool = False
    ) -> Optional[Union[_COL, _COL_co]]:
        
        

        
        if column in self._colset:
            return column

        selected_intersection, selected_metrics = None, None
        target_set = column.proxy_set

        pi = self._proxy_index
        if not pi:
            self._init_proxy_index()

        for current_metrics in (
            mm for ts in target_set if ts in pi for mm in pi[ts]
        ):
            if not require_embedded or current_metrics.embedded(target_set):
                if selected_metrics is None:
                    
                    selected_metrics = current_metrics
                    continue

                current_intersection = target_set.intersection(
                    current_metrics.column._expanded_proxy_set
                )
                if selected_intersection is None:
                    selected_intersection = target_set.intersection(
                        selected_metrics.column._expanded_proxy_set
                    )

                if len(current_intersection) > len(selected_intersection):
                    
                    
                    
                    

                    selected_metrics = current_metrics
                    selected_intersection = current_intersection
                elif current_intersection == selected_intersection:
                    
                    
                    
                    
                    
                    
                    
                    
                    

                    selected_col_distance = sum(
                        [
                            sc._annotations.get("weight", 1)
                            for sc in (
                                selected_metrics.column._uncached_proxy_list()
                            )
                            if sc.shares_lineage(column)
                        ],
                    )
                    current_col_distance = sum(
                        [
                            sc._annotations.get("weight", 1)
                            for sc in (
                                current_metrics.column._uncached_proxy_list()
                            )
                            if sc.shares_lineage(column)
                        ],
                    )
                    if current_col_distance < selected_col_distance:
                        selected_metrics = current_metrics
                        selected_intersection = current_intersection

        return selected_metrics.column if selected_metrics else None


_NAMEDCOL = TypeVar("_NAMEDCOL", bound="NamedColumn[Any]")


class DedupeColumnCollection(ColumnCollection[str, _NAMEDCOL]):
    

    def add(  
        self, column: _NAMEDCOL, key: Optional[str] = None
    ) -> None:
        if key is not None and column.key != key:
            raise exc.ArgumentError(
                "DedupeColumnCollection requires columns be under "
                "the same key as their .key"
            )
        key = column.key

        if key is None:
            raise exc.ArgumentError(
                "Can't add unnamed column to column collection"
            )

        if key in self._index:
            existing = self._index[key][1]

            if existing is column:
                return

            self.replace(column)

            
            
            
            util.memoized_property.reset(column, "proxy_set")
        else:
            self._append_new_column(key, column)

    def _append_new_column(self, key: str, named_column: _NAMEDCOL) -> None:
        l = len(self._collection)
        self._collection.append(
            (key, named_column, _ColumnMetrics(self, named_column))
        )
        self._colset.add(named_column._deannotate())
        self._index[l] = (key, named_column)
        self._index[key] = (key, named_column)

    def _populate_separate_keys(
        self, iter_: Iterable[Tuple[str, _NAMEDCOL]]
    ) -> None:
        
        cols = list(iter_)

        replace_col = []
        for k, col in cols:
            if col.key != k:
                raise exc.ArgumentError(
                    "DedupeColumnCollection requires columns be under "
                    "the same key as their .key"
                )
            if col.name in self._index and col.key != col.name:
                replace_col.append(col)
            elif col.key in self._index:
                replace_col.append(col)
            else:
                self._index[k] = (k, col)
                self._collection.append((k, col, _ColumnMetrics(self, col)))
        self._colset.update(c._deannotate() for (k, c, _) in self._collection)

        self._index.update(
            (idx, (k, c)) for idx, (k, c, _) in enumerate(self._collection)
        )
        for col in replace_col:
            self.replace(col)

    def extend(self, iter_: Iterable[_NAMEDCOL]) -> None:
        self._populate_separate_keys((col.key, col) for col in iter_)

    def remove(self, column: _NAMEDCOL) -> None:  
        if column not in self._colset:
            raise ValueError(
                "Can't remove column %r; column is not in this collection"
                % column
            )
        del self._index[column.key]
        self._colset.remove(column)
        self._collection[:] = [
            (k, c, metrics)
            for (k, c, metrics) in self._collection
            if c is not column
        ]
        for metrics in self._proxy_index.get(column, ()):
            metrics.dispose(self)

        self._index.update(
            {idx: (k, col) for idx, (k, col, _) in enumerate(self._collection)}
        )
        
        del self._index[len(self._collection)]

    def replace(
        self,
        column: _NAMEDCOL,
        extra_remove: Optional[Iterable[_NAMEDCOL]] = None,
    ) -> None:
        

        if extra_remove:
            remove_col = set(extra_remove)
        else:
            remove_col = set()
        
        if column.name in self._index and column.key != column.name:
            other = self._index[column.name][1]
            if other.name == other.key:
                remove_col.add(other)

        if column.key in self._index:
            remove_col.add(self._index[column.key][1])

        if not remove_col:
            self._append_new_column(column.key, column)
            return
        new_cols: List[Tuple[str, _NAMEDCOL, _ColumnMetrics[_NAMEDCOL]]] = []
        replaced = False
        for k, col, metrics in self._collection:
            if col in remove_col:
                if not replaced:
                    replaced = True
                    new_cols.append(
                        (column.key, column, _ColumnMetrics(self, column))
                    )
            else:
                new_cols.append((k, col, metrics))

        if remove_col:
            self._colset.difference_update(remove_col)

            for rc in remove_col:
                for metrics in self._proxy_index.get(rc, ()):
                    metrics.dispose(self)

        if not replaced:
            new_cols.append((column.key, column, _ColumnMetrics(self, column)))

        self._colset.add(column._deannotate())
        self._collection[:] = new_cols

        self._index.clear()

        self._index.update(
            {idx: (k, col) for idx, (k, col, _) in enumerate(self._collection)}
        )
        self._index.update({k: (k, col) for (k, col, _) in self._collection})


class ReadOnlyColumnCollection(
    util.ReadOnlyContainer, ColumnCollection[_COLKEY, _COL_co]
):
    __slots__ = ("_parent",)

    def __init__(self, collection: ColumnCollection[_COLKEY, _COL_co]):
        object.__setattr__(self, "_parent", collection)
        object.__setattr__(self, "_colset", collection._colset)
        object.__setattr__(self, "_index", collection._index)
        object.__setattr__(self, "_collection", collection._collection)
        object.__setattr__(self, "_proxy_index", collection._proxy_index)

    def __getstate__(self) -> Dict[str, _COL_co]:
        return {"_parent": self._parent}

    def __setstate__(self, state: Dict[str, Any]) -> None:
        parent = state["_parent"]
        self.__init__(parent)  

    def add(self, column: Any, key: Any = ...) -> Any:
        self._readonly()

    def extend(self, elements: Any) -> NoReturn:
        self._readonly()

    def remove(self, item: Any) -> NoReturn:
        self._readonly()


class ColumnSet(util.OrderedSet["ColumnClause[Any]"]):
    def contains_column(self, col: ColumnClause[Any]) -> bool:
        return col in self

    def extend(self, cols: Iterable[Any]) -> None:
        for col in cols:
            self.add(col)

    def __eq__(self, other):
        l = []
        for c in other:
            for local in self:
                if c.shares_lineage(local):
                    l.append(c == local)
        return elements.and_(*l)

    def __hash__(self) -> int:  
        return hash(tuple(x for x in self))


def _entity_namespace(
    entity: Union[_HasEntityNamespace, ExternallyTraversible],
) -> _EntityNamespace:
    
    try:
        return cast(_HasEntityNamespace, entity).entity_namespace
    except AttributeError:
        for elem in visitors.iterate(cast(ExternallyTraversible, entity)):
            if _is_has_entity_namespace(elem):
                return elem.entity_namespace
        else:
            raise


def _entity_namespace_key(
    entity: Union[_HasEntityNamespace, ExternallyTraversible],
    key: str,
    default: Union[SQLCoreOperations[Any], _NoArg] = NO_ARG,
) -> SQLCoreOperations[Any]:
    

    try:
        ns = _entity_namespace(entity)
        if default is not NO_ARG:
            return getattr(ns, key, default)
        else:
            return getattr(ns, key)  
    except AttributeError as err:
        raise exc.InvalidRequestError(
            'Entity namespace for "%s" has no property "%s"' % (entity, key)
        ) from err
