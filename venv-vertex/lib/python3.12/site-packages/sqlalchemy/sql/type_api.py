








from __future__ import annotations

from enum import Enum
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generic
from typing import Mapping
from typing import NewType
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from .base import SchemaEventTarget
from .cache_key import CacheConst
from .cache_key import NO_CACHE
from .operators import ColumnOperators
from .visitors import Visitable
from .. import exc
from .. import util
from ..util.typing import Protocol
from ..util.typing import Self
from ..util.typing import TypeAliasType
from ..util.typing import TypedDict
from ..util.typing import TypeGuard


if typing.TYPE_CHECKING:
    from ._typing import _TypeEngineArgument
    from .elements import BindParameter
    from .elements import ColumnElement
    from .operators import OperatorType
    from .sqltypes import _resolve_value_to_type as _resolve_value_to_type
    from .sqltypes import BOOLEANTYPE as BOOLEANTYPE  
    from .sqltypes import INDEXABLE as INDEXABLE  
    from .sqltypes import INTEGERTYPE as INTEGERTYPE  
    from .sqltypes import MATCHTYPE as MATCHTYPE  
    from .sqltypes import NULLTYPE as NULLTYPE
    from .sqltypes import NUMERICTYPE as NUMERICTYPE  
    from .sqltypes import STRINGTYPE as STRINGTYPE  
    from .sqltypes import TABLEVALUE as TABLEVALUE  
    from ..engine.interfaces import DBAPIModule
    from ..engine.interfaces import Dialect
    from ..util.typing import GenericProtocol

_T = TypeVar("_T", bound=Any)
_T_co = TypeVar("_T_co", bound=Any, covariant=True)
_T_con = TypeVar("_T_con", bound=Any, contravariant=True)
_O = TypeVar("_O", bound=object)
_TE = TypeVar("_TE", bound="TypeEngine[Any]")
_CT = TypeVar("_CT", bound=Any)
_RT = TypeVar("_RT", bound=Any)

_MatchedOnType = Union[
    "GenericProtocol[Any]", TypeAliasType, NewType, Type[Any]
]


class _NoValueInList(Enum):
    NO_VALUE_IN_LIST = 0
    


_NO_VALUE_IN_LIST = _NoValueInList.NO_VALUE_IN_LIST


class _LiteralProcessorType(Protocol[_T_co]):
    def __call__(self, value: Any) -> str: ...


class _BindProcessorType(Protocol[_T_con]):
    def __call__(self, value: Optional[_T_con]) -> Any: ...


class _ResultProcessorType(Protocol[_T_co]):
    def __call__(self, value: Any) -> Optional[_T_co]: ...


class _SentinelProcessorType(Protocol[_T_co]):
    def __call__(self, value: Any) -> Optional[_T_co]: ...


class _BaseTypeMemoDict(TypedDict):
    impl: TypeEngine[Any]
    result: Dict[Any, Optional[_ResultProcessorType[Any]]]


class _TypeMemoDict(_BaseTypeMemoDict, total=False):
    literal: Optional[_LiteralProcessorType[Any]]
    bind: Optional[_BindProcessorType[Any]]
    sentinel: Optional[_SentinelProcessorType[Any]]
    custom: Dict[Any, object]


class _ComparatorFactory(Protocol[_T]):
    def __call__(
        self, expr: ColumnElement[_T]
    ) -> TypeEngine.Comparator[_T]: ...


class TypeEngine(Visitable, Generic[_T]):
    

    _sqla_type = True
    _isnull = False
    _is_tuple_type = False
    _is_table_value = False
    _is_array = False
    _is_type_decorator = False

    render_bind_cast = False
    

    render_literal_cast = False
    

    class Comparator(
        ColumnOperators,
        Generic[_CT],
    ):
        

        __slots__ = "expr", "type"

        expr: ColumnElement[_CT]
        type: TypeEngine[_CT]

        def __clause_element__(self) -> ColumnElement[_CT]:
            return self.expr

        def __init__(self, expr: ColumnElement[_CT]):
            self.expr = expr
            self.type = expr.type

        def __reduce__(self) -> Any:
            return self.__class__, (self.expr,)

        @overload
        def operate(
            self,
            op: OperatorType,
            *other: Any,
            result_type: Type[TypeEngine[_RT]],
            **kwargs: Any,
        ) -> ColumnElement[_RT]: ...

        @overload
        def operate(
            self, op: OperatorType, *other: Any, **kwargs: Any
        ) -> ColumnElement[_CT]: ...

        @util.preload_module("sqlalchemy.sql.default_comparator")
        def operate(
            self, op: OperatorType, *other: Any, **kwargs: Any
        ) -> ColumnElement[Any]:
            default_comparator = util.preloaded.sql_default_comparator
            op_fn, addtl_kw = default_comparator.operator_lookup[op.__name__]
            if kwargs:
                addtl_kw = addtl_kw.union(kwargs)
            return op_fn(self.expr, op, *other, **addtl_kw)

        @util.preload_module("sqlalchemy.sql.default_comparator")
        def reverse_operate(
            self, op: OperatorType, other: Any, **kwargs: Any
        ) -> ColumnElement[_CT]:
            default_comparator = util.preloaded.sql_default_comparator
            op_fn, addtl_kw = default_comparator.operator_lookup[op.__name__]
            if kwargs:
                addtl_kw = addtl_kw.union(kwargs)
            return op_fn(self.expr, op, other, reverse=True, **addtl_kw)

        def _adapt_expression(
            self,
            op: OperatorType,
            other_comparator: TypeEngine.Comparator[Any],
        ) -> Tuple[OperatorType, TypeEngine[Any]]:
            

            return op, self.type

    hashable = True
    

    comparator_factory: _ComparatorFactory[Any] = Comparator
    

    sort_key_function: Optional[Callable[[Any], Any]] = None
    

    should_evaluate_none: bool = False
    

    _variant_mapping: util.immutabledict[str, TypeEngine[Any]] = (
        util.EMPTY_DICT
    )

    def evaluates_none(self) -> Self:
        
        typ = self.copy()
        typ.should_evaluate_none = True
        return typ

    def copy(self, **kw: Any) -> Self:
        return self.adapt(self.__class__)

    def copy_value(self, value: Any) -> Any:
        return value

    def literal_processor(
        self, dialect: Dialect
    ) -> Optional[_LiteralProcessorType[_T]]:
        
        return None

    def bind_processor(
        self, dialect: Dialect
    ) -> Optional[_BindProcessorType[_T]]:
        
        return None

    def result_processor(
        self, dialect: Dialect, coltype: object
    ) -> Optional[_ResultProcessorType[_T]]:
        
        return None

    def column_expression(
        self, colexpr: ColumnElement[_T]
    ) -> Optional[ColumnElement[_T]]:
        

        return None

    @util.memoized_property
    def _has_column_expression(self) -> bool:
        

        return (
            self.__class__.column_expression.__code__
            is not TypeEngine.column_expression.__code__
        )

    def bind_expression(
        self, bindvalue: BindParameter[_T]
    ) -> Optional[ColumnElement[_T]]:
        
        return None

    @util.memoized_property
    def _has_bind_expression(self) -> bool:
        

        return util.method_is_overridden(self, TypeEngine.bind_expression)

    @staticmethod
    def _to_instance(cls_or_self: Union[Type[_TE], _TE]) -> _TE:
        return to_instance(cls_or_self)

    def compare_values(self, x: Any, y: Any) -> bool:
        

        return x == y  

    def get_dbapi_type(self, dbapi: DBAPIModule) -> Optional[Any]:
        
        return None

    @property
    def python_type(self) -> Type[Any]:
        
        raise NotImplementedError()

    def with_variant(
        self,
        type_: _TypeEngineArgument[Any],
        *dialect_names: str,
    ) -> Self:
        r

        if not dialect_names:
            raise exc.ArgumentError("At least one dialect name is required")
        for dialect_name in dialect_names:
            if dialect_name in self._variant_mapping:
                raise exc.ArgumentError(
                    f"Dialect {dialect_name!r} is already present in "
                    f"the mapping for this {self!r}"
                )
        new_type = self.copy()
        type_ = to_instance(type_)
        if type_._variant_mapping:
            raise exc.ArgumentError(
                "can't pass a type that already has variants as a "
                "dialect-level type to with_variant()"
            )

        new_type._variant_mapping = self._variant_mapping.union(
            {dialect_name: type_ for dialect_name in dialect_names}
        )
        return new_type

    def _resolve_for_literal(self, value: Any) -> Self:
        
        return self

    def _resolve_for_python_type(
        self,
        python_type: Type[Any],
        matched_on: _MatchedOnType,
        matched_on_flattened: Type[Any],
    ) -> Optional[Self]:
        

        if python_type is not matched_on_flattened:
            return None

        return self

    def _with_collation(self, collation: str) -> Self:
        
        raise NotImplementedError("this datatype does not support collation")

    @util.ro_memoized_property
    def _type_affinity(self) -> Optional[Type[TypeEngine[_T]]]:
        

        typ = None
        for t in self.__class__.__mro__:
            if t is TypeEngine or TypeEngineMixin in t.__bases__:
                return typ
            elif issubclass(t, TypeEngine):
                typ = t
        else:
            return self.__class__

    @util.ro_memoized_property
    def _generic_type_affinity(
        self,
    ) -> Type[TypeEngine[_T]]:
        best_camelcase = None
        best_uppercase = None

        if not isinstance(self, TypeEngine):
            return self.__class__

        for t in self.__class__.__mro__:
            if (
                t.__module__
                in (
                    "sqlalchemy.sql.sqltypes",
                    "sqlalchemy.sql.type_api",
                )
                and issubclass(t, TypeEngine)
                and TypeEngineMixin not in t.__bases__
                and t not in (TypeEngine, TypeEngineMixin)
                and t.__name__[0] != "_"
            ):
                if t.__name__.isupper() and not best_uppercase:
                    best_uppercase = t
                elif not t.__name__.isupper() and not best_camelcase:
                    best_camelcase = t

        return (
            best_camelcase
            or best_uppercase
            or cast("Type[TypeEngine[_T]]", NULLTYPE.__class__)
        )

    def as_generic(self, allow_nulltype: bool = False) -> TypeEngine[_T]:
        
        if (
            not allow_nulltype
            and self._generic_type_affinity == NULLTYPE.__class__
        ):
            raise NotImplementedError(
                "Default TypeEngine.as_generic() "
                "heuristic method was unsuccessful for {}. A custom "
                "as_generic() method must be implemented for this "
                "type class.".format(
                    self.__class__.__module__ + "." + self.__class__.__name__
                )
            )

        return util.constructor_copy(self, self._generic_type_affinity)

    def dialect_impl(self, dialect: Dialect) -> TypeEngine[_T]:
        
        try:
            tm = dialect._type_memos[self]
        except KeyError:
            pass
        else:
            return tm["impl"]
        return self._dialect_info(dialect)["impl"]

    def _unwrapped_dialect_impl(self, dialect: Dialect) -> TypeEngine[_T]:
        
        return self.dialect_impl(dialect)

    def _cached_literal_processor(
        self, dialect: Dialect
    ) -> Optional[_LiteralProcessorType[_T]]:
        

        try:
            return dialect._type_memos[self]["literal"]
        except KeyError:
            pass

        
        
        d = self._dialect_info(dialect)
        d["literal"] = lp = d["impl"].literal_processor(dialect)
        return lp

    def _cached_bind_processor(
        self, dialect: Dialect
    ) -> Optional[_BindProcessorType[_T]]:
        

        try:
            return dialect._type_memos[self]["bind"]
        except KeyError:
            pass

        
        
        d = self._dialect_info(dialect)
        d["bind"] = bp = d["impl"].bind_processor(dialect)
        return bp

    def _cached_result_processor(
        self, dialect: Dialect, coltype: Any
    ) -> Optional[_ResultProcessorType[_T]]:
        

        try:
            return dialect._type_memos[self]["result"][coltype]
        except KeyError:
            pass

        
        
        d = self._dialect_info(dialect)
        
        
        
        rp = d["impl"].result_processor(dialect, coltype)
        d["result"][coltype] = rp
        return rp

    def _cached_custom_processor(
        self, dialect: Dialect, key: str, fn: Callable[[TypeEngine[_T]], _O]
    ) -> _O:
        
        try:
            return cast(_O, dialect._type_memos[self]["custom"][key])
        except KeyError:
            pass
        
        
        d = self._dialect_info(dialect)
        impl = d["impl"]
        custom_dict = d.setdefault("custom", {})
        custom_dict[key] = result = fn(impl)
        return result

    def _dialect_info(self, dialect: Dialect) -> _TypeMemoDict:
        

        if self in dialect._type_memos:
            return dialect._type_memos[self]
        else:
            impl = self._gen_dialect_impl(dialect)
            if impl is self:
                impl = self.adapt(type(self))
            
            assert impl is not self
            d: _TypeMemoDict = {"impl": impl, "result": {}}
            dialect._type_memos[self] = d
            return d

    def _gen_dialect_impl(self, dialect: Dialect) -> TypeEngine[Any]:
        if dialect.name in self._variant_mapping:
            return self._variant_mapping[dialect.name]._gen_dialect_impl(
                dialect
            )
        else:
            return dialect.type_descriptor(self)

    @util.memoized_property
    def _static_cache_key(
        self,
    ) -> Union[CacheConst, Tuple[Any, ...]]:
        names = util.get_cls_kwargs(self.__class__)
        return (self.__class__,) + tuple(
            (
                k,
                (
                    self.__dict__[k]._static_cache_key
                    if isinstance(self.__dict__[k], TypeEngine)
                    else self.__dict__[k]
                ),
            )
            for k in names
            if k in self.__dict__
            and not k.startswith("_")
            and self.__dict__[k] is not None
        )

    @overload
    def adapt(self, cls: Type[_TE], **kw: Any) -> _TE: ...

    @overload
    def adapt(
        self, cls: Type[TypeEngineMixin], **kw: Any
    ) -> TypeEngine[Any]: ...

    def adapt(
        self, cls: Type[Union[TypeEngine[Any], TypeEngineMixin]], **kw: Any
    ) -> TypeEngine[Any]:
        
        typ = util.constructor_copy(
            self, cast(Type[TypeEngine[Any]], cls), **kw
        )
        typ._variant_mapping = self._variant_mapping
        return typ

    def coerce_compared_value(
        self, op: Optional[OperatorType], value: Any
    ) -> TypeEngine[Any]:
        
        _coerced_type = _resolve_value_to_type(value)
        if (
            _coerced_type is NULLTYPE
            or _coerced_type._type_affinity is self._type_affinity
        ):
            return self
        else:
            return _coerced_type

    def _compare_type_affinity(self, other: TypeEngine[Any]) -> bool:
        return self._type_affinity is other._type_affinity

    def compile(self, dialect: Optional[Dialect] = None) -> str:
        
        
        

        if dialect is None:
            dialect = self._default_dialect()

        return dialect.type_compiler_instance.process(self)

    @util.preload_module("sqlalchemy.engine.default")
    def _default_dialect(self) -> Dialect:
        default = util.preloaded.engine_default

        
        
        
        return default.StrCompileDialect()  

    def __str__(self) -> str:
        return str(self.compile())

    def __repr__(self) -> str:
        return util.generic_repr(self)


class TypeEngineMixin:
    

    __slots__ = ()

    if TYPE_CHECKING:

        @util.memoized_property
        def _static_cache_key(
            self,
        ) -> Union[CacheConst, Tuple[Any, ...]]: ...

        @overload
        def adapt(self, cls: Type[_TE], **kw: Any) -> _TE: ...

        @overload
        def adapt(
            self, cls: Type[TypeEngineMixin], **kw: Any
        ) -> TypeEngine[Any]: ...

        def adapt(
            self, cls: Type[Union[TypeEngine[Any], TypeEngineMixin]], **kw: Any
        ) -> TypeEngine[Any]: ...

        def dialect_impl(self, dialect: Dialect) -> TypeEngine[Any]: ...


class ExternalType(TypeEngineMixin):
    

    cache_ok: Optional[bool] = None
      

    @util.non_memoized_property
    def _static_cache_key(
        self,
    ) -> Union[CacheConst, Tuple[Any, ...]]:
        cache_ok = self.__class__.__dict__.get("cache_ok", None)

        if cache_ok is None:
            for subtype in self.__class__.__mro__:
                if ExternalType in subtype.__bases__:
                    break
            else:
                subtype = self.__class__.__mro__[1]

            util.warn(
                "%s %r will not produce a cache key because "
                "the ``cache_ok`` attribute is not set to True.  This can "
                "have significant performance implications including some "
                "performance degradations in comparison to prior SQLAlchemy "
                "versions.  Set this attribute to True if this type object's "
                "state is safe to use in a cache key, or False to "
                "disable this warning." % (subtype.__name__, self),
                code="cprf",
            )
        elif cache_ok is True:
            return super()._static_cache_key

        return NO_CACHE


class UserDefinedType(
    ExternalType, TypeEngineMixin, TypeEngine[_T], util.EnsureKWArg
):
    

    __visit_name__ = "user_defined"

    ensure_kwarg = "get_col_spec"

    def coerce_compared_value(
        self, op: Optional[OperatorType], value: Any
    ) -> TypeEngine[Any]:
        

        return self

    if TYPE_CHECKING:

        def get_col_spec(self, **kw: Any) -> str: ...


class Emulated(TypeEngineMixin):
    

    native: bool

    def adapt_to_emulated(
        self,
        impltype: Type[Union[TypeEngine[Any], TypeEngineMixin]],
        **kw: Any,
    ) -> TypeEngine[Any]:
        
        return super().adapt(impltype, **kw)

    @overload
    def adapt(self, cls: Type[_TE], **kw: Any) -> _TE: ...

    @overload
    def adapt(
        self, cls: Type[TypeEngineMixin], **kw: Any
    ) -> TypeEngine[Any]: ...

    def adapt(
        self, cls: Type[Union[TypeEngine[Any], TypeEngineMixin]], **kw: Any
    ) -> TypeEngine[Any]:
        if _is_native_for_emulated(cls):
            if self.native:
                
                
                return cls.adapt_emulated_to_native(self, **kw)
            else:
                
                
                
                return cls.adapt_native_to_emulated(self, **kw)
        else:
            
            
            if issubclass(cls, self.__class__):
                return self.adapt_to_emulated(cls, **kw)
            else:
                return super().adapt(cls, **kw)


def _is_native_for_emulated(
    typ: Type[Union[TypeEngine[Any], TypeEngineMixin]],
) -> TypeGuard[Type[NativeForEmulated]]:
    return hasattr(typ, "adapt_emulated_to_native")


class NativeForEmulated(TypeEngineMixin):
    

    @classmethod
    def adapt_native_to_emulated(
        cls,
        impl: Union[TypeEngine[Any], TypeEngineMixin],
        **kw: Any,
    ) -> TypeEngine[Any]:
        
        impltype = impl.__class__
        return impl.adapt(impltype, **kw)

    @classmethod
    def adapt_emulated_to_native(
        cls,
        impl: Union[TypeEngine[Any], TypeEngineMixin],
        **kw: Any,
    ) -> TypeEngine[Any]:
        

        
        return cls(**kw)  

    
    
    
    


class TypeDecorator(SchemaEventTarget, ExternalType, TypeEngine[_T]):
    

    __visit_name__ = "type_decorator"

    _is_type_decorator = True

    
    
    
    
    
    
    impl: Union[TypeEngine[Any], Type[TypeEngine[Any]]]

    
    
    
    
    
    @util.memoized_property
    def impl_instance(self) -> TypeEngine[Any]:
        return self.impl  

    def __init__(self, *args: Any, **kwargs: Any):
        

        if not hasattr(self.__class__, "impl"):
            raise AssertionError(
                "TypeDecorator implementations "
                "require a class-level variable "
                "'impl' which refers to the class of "
                "type being decorated"
            )

        self.impl = to_instance(self.__class__.impl, *args, **kwargs)

    coerce_to_is_types: Sequence[Type[Any]] = (type(None),)
    

    class Comparator(TypeEngine.Comparator[_CT]):
        

        __slots__ = ()

        def operate(
            self, op: OperatorType, *other: Any, **kwargs: Any
        ) -> ColumnElement[_CT]:
            if TYPE_CHECKING:
                assert isinstance(self.expr.type, TypeDecorator)
            kwargs["_python_is_types"] = self.expr.type.coerce_to_is_types
            return super().operate(op, *other, **kwargs)

        def reverse_operate(
            self, op: OperatorType, other: Any, **kwargs: Any
        ) -> ColumnElement[_CT]:
            if TYPE_CHECKING:
                assert isinstance(self.expr.type, TypeDecorator)
            kwargs["_python_is_types"] = self.expr.type.coerce_to_is_types
            return super().reverse_operate(op, other, **kwargs)

    @staticmethod
    def _reduce_td_comparator(
        impl: TypeEngine[Any], expr: ColumnElement[_T]
    ) -> Any:
        return TypeDecorator._create_td_comparator_type(impl)(expr)

    @staticmethod
    def _create_td_comparator_type(
        impl: TypeEngine[Any],
    ) -> _ComparatorFactory[Any]:

        def __reduce__(self: TypeDecorator.Comparator[Any]) -> Any:
            return (TypeDecorator._reduce_td_comparator, (impl, self.expr))

        return type(
            "TDComparator",
            (TypeDecorator.Comparator, impl.comparator_factory),  
            {"__reduce__": __reduce__},
        )

    @property
    def comparator_factory(  
        self,
    ) -> _ComparatorFactory[Any]:
        if TypeDecorator.Comparator in self.impl.comparator_factory.__mro__:  
            return self.impl_instance.comparator_factory
        else:
            
            
            
            
            return TypeDecorator._create_td_comparator_type(self.impl_instance)

    def _copy_with_check(self) -> Self:
        tt = self.copy()
        if not isinstance(tt, self.__class__):
            raise AssertionError(
                "Type object %s does not properly "
                "implement the copy() method, it must "
                "return an object of type %s" % (self, self.__class__)
            )
        return tt

    def _gen_dialect_impl(self, dialect: Dialect) -> TypeEngine[_T]:
        if dialect.name in self._variant_mapping:
            adapted = dialect.type_descriptor(
                self._variant_mapping[dialect.name]
            )
        else:
            adapted = dialect.type_descriptor(self)
        if adapted is not self:
            return adapted

        
        
        
        typedesc = self.load_dialect_impl(dialect).dialect_impl(dialect)
        tt = self._copy_with_check()
        tt.impl = tt.impl_instance = typedesc
        return tt

    def _with_collation(self, collation: str) -> Self:
        tt = self._copy_with_check()
        tt.impl = tt.impl_instance = self.impl_instance._with_collation(
            collation
        )
        return tt

    @util.ro_non_memoized_property
    def _type_affinity(self) -> Optional[Type[TypeEngine[Any]]]:
        return self.impl_instance._type_affinity

    def _set_parent(
        self, parent: SchemaEventTarget, outer: bool = False, **kw: Any
    ) -> None:
        

        super()._set_parent(parent)

        if not outer and isinstance(self.impl_instance, SchemaEventTarget):
            self.impl_instance._set_parent(parent, outer=False, **kw)

    def _set_parent_with_dispatch(
        self, parent: SchemaEventTarget, **kw: Any
    ) -> None:
        

        super()._set_parent_with_dispatch(parent, outer=True, **kw)

        if isinstance(self.impl_instance, SchemaEventTarget):
            self.impl_instance._set_parent_with_dispatch(parent)

    def type_engine(self, dialect: Dialect) -> TypeEngine[Any]:
        
        adapted = dialect.type_descriptor(self)
        if not isinstance(adapted, type(self)):
            return adapted
        else:
            return self.load_dialect_impl(dialect)

    def load_dialect_impl(self, dialect: Dialect) -> TypeEngine[Any]:
        
        return self.impl_instance

    def _unwrapped_dialect_impl(self, dialect: Dialect) -> TypeEngine[Any]:
        
        
        
        typ = self.dialect_impl(dialect)

        
        
        if isinstance(typ, self.__class__):
            return typ.load_dialect_impl(dialect).dialect_impl(dialect)
        else:
            return typ

    def __getattr__(self, key: str) -> Any:
        
        return getattr(self.impl_instance, key)

    def process_literal_param(
        self, value: Optional[_T], dialect: Dialect
    ) -> str:
        
        raise NotImplementedError()

    def process_bind_param(self, value: Optional[_T], dialect: Dialect) -> Any:
        

        raise NotImplementedError()

    def process_result_value(
        self, value: Optional[Any], dialect: Dialect
    ) -> Optional[_T]:
        

        raise NotImplementedError()

    @util.memoized_property
    def _has_bind_processor(self) -> bool:
        

        return util.method_is_overridden(
            self, TypeDecorator.process_bind_param
        )

    @util.memoized_property
    def _has_literal_processor(self) -> bool:
        

        return util.method_is_overridden(
            self, TypeDecorator.process_literal_param
        )

    def literal_processor(
        self, dialect: Dialect
    ) -> Optional[_LiteralProcessorType[_T]]:
        

        if self._has_literal_processor:
            process_literal_param = self.process_literal_param
            process_bind_param = None
        elif self._has_bind_processor:
            
            
            process_literal_param = None
            process_bind_param = self.process_bind_param
        else:
            process_literal_param = None
            process_bind_param = None

        if process_literal_param is not None:
            impl_processor = self.impl_instance.literal_processor(dialect)
            if impl_processor:
                fixed_impl_processor = impl_processor
                fixed_process_literal_param = process_literal_param

                def process(value: Any) -> str:
                    return fixed_impl_processor(
                        fixed_process_literal_param(value, dialect)
                    )

            else:
                fixed_process_literal_param = process_literal_param

                def process(value: Any) -> str:
                    return fixed_process_literal_param(value, dialect)

            return process

        elif process_bind_param is not None:
            impl_processor = self.impl_instance.literal_processor(dialect)
            if not impl_processor:
                return None
            else:
                fixed_impl_processor = impl_processor
                fixed_process_bind_param = process_bind_param

                def process(value: Any) -> str:
                    return fixed_impl_processor(
                        fixed_process_bind_param(value, dialect)
                    )

                return process
        else:
            return self.impl_instance.literal_processor(dialect)

    def bind_processor(
        self, dialect: Dialect
    ) -> Optional[_BindProcessorType[_T]]:
        
        if self._has_bind_processor:
            process_param = self.process_bind_param
            impl_processor = self.impl_instance.bind_processor(dialect)
            if impl_processor:
                fixed_impl_processor = impl_processor
                fixed_process_param = process_param

                def process(value: Optional[_T]) -> Any:
                    return fixed_impl_processor(
                        fixed_process_param(value, dialect)
                    )

            else:
                fixed_process_param = process_param

                def process(value: Optional[_T]) -> Any:
                    return fixed_process_param(value, dialect)

            return process
        else:
            return self.impl_instance.bind_processor(dialect)

    @util.memoized_property
    def _has_result_processor(self) -> bool:
        

        return util.method_is_overridden(
            self, TypeDecorator.process_result_value
        )

    def result_processor(
        self, dialect: Dialect, coltype: Any
    ) -> Optional[_ResultProcessorType[_T]]:
        
        if self._has_result_processor:
            process_value = self.process_result_value
            impl_processor = self.impl_instance.result_processor(
                dialect, coltype
            )
            if impl_processor:
                fixed_process_value = process_value
                fixed_impl_processor = impl_processor

                def process(value: Any) -> Optional[_T]:
                    return fixed_process_value(
                        fixed_impl_processor(value), dialect
                    )

            else:
                fixed_process_value = process_value

                def process(value: Any) -> Optional[_T]:
                    return fixed_process_value(value, dialect)

            return process
        else:
            return self.impl_instance.result_processor(dialect, coltype)

    @util.memoized_property
    def _has_bind_expression(self) -> bool:
        return (
            util.method_is_overridden(self, TypeDecorator.bind_expression)
            or self.impl_instance._has_bind_expression
        )

    def bind_expression(
        self, bindparam: BindParameter[_T]
    ) -> Optional[ColumnElement[_T]]:
        
        return self.impl_instance.bind_expression(bindparam)

    @util.memoized_property
    def _has_column_expression(self) -> bool:
        

        return (
            util.method_is_overridden(self, TypeDecorator.column_expression)
            or self.impl_instance._has_column_expression
        )

    def column_expression(
        self, column: ColumnElement[_T]
    ) -> Optional[ColumnElement[_T]]:
        

        return self.impl_instance.column_expression(column)

    def coerce_compared_value(
        self, op: Optional[OperatorType], value: Any
    ) -> Any:
        
        return self

    def copy(self, **kw: Any) -> Self:
        

        instance = self.__class__.__new__(self.__class__)
        instance.__dict__.update(self.__dict__)
        return instance

    def get_dbapi_type(self, dbapi: DBAPIModule) -> Optional[Any]:
        
        return self.impl_instance.get_dbapi_type(dbapi)

    def compare_values(self, x: Any, y: Any) -> bool:
        
        return self.impl_instance.compare_values(x, y)

    
    @property
    def sort_key_function(self) -> Optional[Callable[[Any], Any]]:  
        return self.impl_instance.sort_key_function

    def __repr__(self) -> str:
        return util.generic_repr(self, to_inspect=self.impl_instance)


class Variant(TypeDecorator[_T]):
    

    def __init__(self, *arg: Any, **kw: Any):
        raise NotImplementedError(
            "Variant is no longer used in SQLAlchemy; this is a "
            "placeholder symbol for backwards compatibility."
        )


@overload
def to_instance(
    typeobj: Union[Type[_TE], _TE], *arg: Any, **kw: Any
) -> _TE: ...


@overload
def to_instance(typeobj: None, *arg: Any, **kw: Any) -> TypeEngine[None]: ...


def to_instance(
    typeobj: Union[Type[_TE], _TE, None], *arg: Any, **kw: Any
) -> Union[_TE, TypeEngine[None]]:
    if typeobj is None:
        return NULLTYPE

    if callable(typeobj):
        return typeobj(*arg, **kw)
    else:
        return typeobj


def adapt_type(
    typeobj: _TypeEngineArgument[Any],
    colspecs: Mapping[Type[Any], Type[TypeEngine[Any]]],
) -> TypeEngine[Any]:
    typeobj = to_instance(typeobj)
    for t in typeobj.__class__.__mro__[0:-1]:
        try:
            impltype = colspecs[t]
            break
        except KeyError:
            pass
    else:
        
        
        return typeobj
    
    
    
    
    if issubclass(typeobj.__class__, impltype):
        return typeobj
    return typeobj.adapt(impltype)
