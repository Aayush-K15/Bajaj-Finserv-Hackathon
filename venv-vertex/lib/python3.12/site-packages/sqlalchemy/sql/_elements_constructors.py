






from __future__ import annotations

import typing
from typing import Any
from typing import Callable
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple as typing_Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from . import coercions
from . import roles
from .base import _NoArg
from .coercions import _document_text_coercion
from .elements import BindParameter
from .elements import BooleanClauseList
from .elements import Case
from .elements import Cast
from .elements import CollationClause
from .elements import CollectionAggregate
from .elements import ColumnClause
from .elements import ColumnElement
from .elements import Extract
from .elements import False_
from .elements import FunctionFilter
from .elements import Label
from .elements import Null
from .elements import Over
from .elements import TextClause
from .elements import True_
from .elements import TryCast
from .elements import Tuple
from .elements import TypeCoerce
from .elements import UnaryExpression
from .elements import WithinGroup
from .functions import FunctionElement
from ..util.typing import Literal

if typing.TYPE_CHECKING:
    from ._typing import _ByArgument
    from ._typing import _ColumnExpressionArgument
    from ._typing import _ColumnExpressionOrLiteralArgument
    from ._typing import _ColumnExpressionOrStrLabelArgument
    from ._typing import _TypeEngineArgument
    from .elements import BinaryExpression
    from .selectable import FromClause
    from .type_api import TypeEngine

_T = TypeVar("_T")


def all_(expr: _ColumnExpressionArgument[_T]) -> CollectionAggregate[bool]:
    
    return CollectionAggregate._create_all(expr)


def and_(  
    initial_clause: Union[Literal[True], _ColumnExpressionArgument[bool]],
    *clauses: _ColumnExpressionArgument[bool],
) -> ColumnElement[bool]:
    r
    ...


if not TYPE_CHECKING:
    
    def and_(*clauses):  
        r  
        return BooleanClauseList.and_(*clauses)


def any_(expr: _ColumnExpressionArgument[_T]) -> CollectionAggregate[bool]:
    
    return CollectionAggregate._create_any(expr)


def asc(
    column: _ColumnExpressionOrStrLabelArgument[_T],
) -> UnaryExpression[_T]:
    
    return UnaryExpression._create_asc(column)


def collate(
    expression: _ColumnExpressionArgument[str], collation: str
) -> BinaryExpression[str]:
    
    return CollationClause._create_collation_expression(expression, collation)


def between(
    expr: _ColumnExpressionOrLiteralArgument[_T],
    lower_bound: Any,
    upper_bound: Any,
    symmetric: bool = False,
) -> BinaryExpression[bool]:
    
    col_expr = coercions.expect(roles.ExpressionElementRole, expr)
    return col_expr.between(lower_bound, upper_bound, symmetric=symmetric)


def outparam(
    key: str, type_: Optional[TypeEngine[_T]] = None
) -> BindParameter[_T]:
    
    return BindParameter(key, None, type_=type_, unique=False, isoutparam=True)


@overload
def not_(clause: BinaryExpression[_T]) -> BinaryExpression[_T]: ...


@overload
def not_(clause: _ColumnExpressionArgument[_T]) -> ColumnElement[_T]: ...


def not_(clause: _ColumnExpressionArgument[_T]) -> ColumnElement[_T]:
    

    return coercions.expect(roles.ExpressionElementRole, clause).__invert__()


def bindparam(
    key: Optional[str],
    value: Any = _NoArg.NO_ARG,
    type_: Optional[_TypeEngineArgument[_T]] = None,
    unique: bool = False,
    required: Union[bool, Literal[_NoArg.NO_ARG]] = _NoArg.NO_ARG,
    quote: Optional[bool] = None,
    callable_: Optional[Callable[[], Any]] = None,
    expanding: bool = False,
    isoutparam: bool = False,
    literal_execute: bool = False,
) -> BindParameter[_T]:
    r
    return BindParameter(
        key,
        value,
        type_,
        unique,
        required,
        quote,
        callable_,
        expanding,
        isoutparam,
        literal_execute,
    )


def case(
    *whens: Union[
        typing_Tuple[_ColumnExpressionArgument[bool], Any], Mapping[Any, Any]
    ],
    value: Optional[Any] = None,
    else_: Optional[Any] = None,
) -> Case[Any]:
    r  
    return Case(*whens, value=value, else_=else_)


def cast(
    expression: _ColumnExpressionOrLiteralArgument[Any],
    type_: _TypeEngineArgument[_T],
) -> Cast[_T]:
    r
    return Cast(expression, type_)


def try_cast(
    expression: _ColumnExpressionOrLiteralArgument[Any],
    type_: _TypeEngineArgument[_T],
) -> TryCast[_T]:
    
    return TryCast(expression, type_)


def column(
    text: str,
    type_: Optional[_TypeEngineArgument[_T]] = None,
    is_literal: bool = False,
    _selectable: Optional[FromClause] = None,
) -> ColumnClause[_T]:
    
    return ColumnClause(text, type_, is_literal, _selectable)


def desc(
    column: _ColumnExpressionOrStrLabelArgument[_T],
) -> UnaryExpression[_T]:
    
    return UnaryExpression._create_desc(column)


def distinct(expr: _ColumnExpressionArgument[_T]) -> UnaryExpression[_T]:
      
    return UnaryExpression._create_distinct(expr)


def bitwise_not(expr: _ColumnExpressionArgument[_T]) -> UnaryExpression[_T]:
    

    return UnaryExpression._create_bitwise_not(expr)


def extract(field: str, expr: _ColumnExpressionArgument[Any]) -> Extract:
    
    return Extract(field, expr)


def false() -> False_:
    

    return False_._instance()


def funcfilter(
    func: FunctionElement[_T], *criterion: _ColumnExpressionArgument[bool]
) -> FunctionFilter[_T]:
    
    return FunctionFilter(func, *criterion)


def label(
    name: str,
    element: _ColumnExpressionArgument[_T],
    type_: Optional[_TypeEngineArgument[_T]] = None,
) -> Label[_T]:
    
    return Label(name, element, type_)


def null() -> Null:
    

    return Null._instance()


def nulls_first(column: _ColumnExpressionArgument[_T]) -> UnaryExpression[_T]:
      
    return UnaryExpression._create_nulls_first(column)


def nulls_last(column: _ColumnExpressionArgument[_T]) -> UnaryExpression[_T]:
      
    return UnaryExpression._create_nulls_last(column)


def or_(  
    initial_clause: Union[Literal[False], _ColumnExpressionArgument[bool]],
    *clauses: _ColumnExpressionArgument[bool],
) -> ColumnElement[bool]:
    
    ...


if not TYPE_CHECKING:
    
    def or_(*clauses):  
          
        return BooleanClauseList.or_(*clauses)


def over(
    element: FunctionElement[_T],
    partition_by: Optional[_ByArgument] = None,
    order_by: Optional[_ByArgument] = None,
    range_: Optional[typing_Tuple[Optional[int], Optional[int]]] = None,
    rows: Optional[typing_Tuple[Optional[int], Optional[int]]] = None,
    groups: Optional[typing_Tuple[Optional[int], Optional[int]]] = None,
) -> Over[_T]:
    r  
    return Over(element, partition_by, order_by, range_, rows, groups)


@_document_text_coercion("text", ":func:`.text`", ":paramref:`.text.text`")
def text(text: str) -> TextClause:
    r
    return TextClause(text)


def true() -> True_:
    

    return True_._instance()


def tuple_(
    *clauses: _ColumnExpressionArgument[Any],
    types: Optional[Sequence[_TypeEngineArgument[Any]]] = None,
) -> Tuple:
    
    return Tuple(*clauses, types=types)


def type_coerce(
    expression: _ColumnExpressionOrLiteralArgument[Any],
    type_: _TypeEngineArgument[_T],
) -> TypeCoerce[_T]:
    r  
    return TypeCoerce(expression, type_)


def within_group(
    element: FunctionElement[_T], *order_by: _ColumnExpressionArgument[Any]
) -> WithinGroup[_T]:
    r
    return WithinGroup(element, *order_by)
