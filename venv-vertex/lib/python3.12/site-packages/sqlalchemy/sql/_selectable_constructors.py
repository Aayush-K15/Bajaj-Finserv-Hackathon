






from __future__ import annotations

from typing import Any
from typing import Optional
from typing import overload
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

from . import coercions
from . import roles
from ._typing import _ColumnsClauseArgument
from ._typing import _no_kw
from .elements import ColumnClause
from .selectable import Alias
from .selectable import CompoundSelect
from .selectable import Exists
from .selectable import FromClause
from .selectable import Join
from .selectable import Lateral
from .selectable import LateralFromClause
from .selectable import NamedFromClause
from .selectable import Select
from .selectable import TableClause
from .selectable import TableSample
from .selectable import Values

if TYPE_CHECKING:
    from ._typing import _FromClauseArgument
    from ._typing import _OnClauseArgument
    from ._typing import _SelectStatementForCompoundArgument
    from ._typing import _T0
    from ._typing import _T1
    from ._typing import _T2
    from ._typing import _T3
    from ._typing import _T4
    from ._typing import _T5
    from ._typing import _T6
    from ._typing import _T7
    from ._typing import _T8
    from ._typing import _T9
    from ._typing import _TP
    from ._typing import _TypedColumnClauseArgument as _TCCA
    from .functions import Function
    from .selectable import CTE
    from .selectable import HasCTE
    from .selectable import ScalarSelect
    from .selectable import SelectBase


def alias(
    selectable: FromClause, name: Optional[str] = None, flat: bool = False
) -> NamedFromClause:
    
    return Alias._factory(selectable, name=name, flat=flat)


def cte(
    selectable: HasCTE, name: Optional[str] = None, recursive: bool = False
) -> CTE:
    r
    return coercions.expect(roles.HasCTERole, selectable).cte(
        name=name, recursive=recursive
    )






_TypedSelectable = Union["Select[_TP]", "CompoundSelect[_TP]"]


@overload
def except_(
    *selects: _TypedSelectable[_TP],
) -> CompoundSelect[_TP]: ...


@overload
def except_(
    *selects: _SelectStatementForCompoundArgument[_TP],
) -> CompoundSelect[_TP]: ...


def except_(
    *selects: _SelectStatementForCompoundArgument[_TP],
) -> CompoundSelect[_TP]:
    r
    return CompoundSelect._create_except(*selects)


@overload
def except_all(
    *selects: _TypedSelectable[_TP],
) -> CompoundSelect[_TP]: ...


@overload
def except_all(
    *selects: _SelectStatementForCompoundArgument[_TP],
) -> CompoundSelect[_TP]: ...


def except_all(
    *selects: _SelectStatementForCompoundArgument[_TP],
) -> CompoundSelect[_TP]:
    r
    return CompoundSelect._create_except_all(*selects)


def exists(
    __argument: Optional[
        Union[_ColumnsClauseArgument[Any], SelectBase, ScalarSelect[Any]]
    ] = None,
) -> Exists:
      

    return Exists(__argument)


@overload
def intersect(
    *selects: _TypedSelectable[_TP],
) -> CompoundSelect[_TP]: ...


@overload
def intersect(
    *selects: _SelectStatementForCompoundArgument[_TP],
) -> CompoundSelect[_TP]: ...


def intersect(
    *selects: _SelectStatementForCompoundArgument[_TP],
) -> CompoundSelect[_TP]:
    r
    return CompoundSelect._create_intersect(*selects)


@overload
def intersect_all(
    *selects: _TypedSelectable[_TP],
) -> CompoundSelect[_TP]: ...


@overload
def intersect_all(
    *selects: _SelectStatementForCompoundArgument[_TP],
) -> CompoundSelect[_TP]: ...


def intersect_all(
    *selects: _SelectStatementForCompoundArgument[_TP],
) -> CompoundSelect[_TP]:
    r
    return CompoundSelect._create_intersect_all(*selects)


def join(
    left: _FromClauseArgument,
    right: _FromClauseArgument,
    onclause: Optional[_OnClauseArgument] = None,
    isouter: bool = False,
    full: bool = False,
) -> Join:
      

    return Join(left, right, onclause, isouter, full)


def lateral(
    selectable: Union[SelectBase, _FromClauseArgument],
    name: Optional[str] = None,
) -> LateralFromClause:
    
    return Lateral._factory(selectable, name=name)


def outerjoin(
    left: _FromClauseArgument,
    right: _FromClauseArgument,
    onclause: Optional[_OnClauseArgument] = None,
    full: bool = False,
) -> Join:
    
    return Join(left, right, onclause, isouter=True, full=full)








@overload
def select(__ent0: _TCCA[_T0]) -> Select[Tuple[_T0]]: ...


@overload
def select(
    __ent0: _TCCA[_T0], __ent1: _TCCA[_T1]
) -> Select[Tuple[_T0, _T1]]: ...


@overload
def select(
    __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2]
) -> Select[Tuple[_T0, _T1, _T2]]: ...


@overload
def select(
    __ent0: _TCCA[_T0],
    __ent1: _TCCA[_T1],
    __ent2: _TCCA[_T2],
    __ent3: _TCCA[_T3],
) -> Select[Tuple[_T0, _T1, _T2, _T3]]: ...


@overload
def select(
    __ent0: _TCCA[_T0],
    __ent1: _TCCA[_T1],
    __ent2: _TCCA[_T2],
    __ent3: _TCCA[_T3],
    __ent4: _TCCA[_T4],
) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4]]: ...


@overload
def select(
    __ent0: _TCCA[_T0],
    __ent1: _TCCA[_T1],
    __ent2: _TCCA[_T2],
    __ent3: _TCCA[_T3],
    __ent4: _TCCA[_T4],
    __ent5: _TCCA[_T5],
) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5]]: ...


@overload
def select(
    __ent0: _TCCA[_T0],
    __ent1: _TCCA[_T1],
    __ent2: _TCCA[_T2],
    __ent3: _TCCA[_T3],
    __ent4: _TCCA[_T4],
    __ent5: _TCCA[_T5],
    __ent6: _TCCA[_T6],
) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6]]: ...


@overload
def select(
    __ent0: _TCCA[_T0],
    __ent1: _TCCA[_T1],
    __ent2: _TCCA[_T2],
    __ent3: _TCCA[_T3],
    __ent4: _TCCA[_T4],
    __ent5: _TCCA[_T5],
    __ent6: _TCCA[_T6],
    __ent7: _TCCA[_T7],
) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7]]: ...


@overload
def select(
    __ent0: _TCCA[_T0],
    __ent1: _TCCA[_T1],
    __ent2: _TCCA[_T2],
    __ent3: _TCCA[_T3],
    __ent4: _TCCA[_T4],
    __ent5: _TCCA[_T5],
    __ent6: _TCCA[_T6],
    __ent7: _TCCA[_T7],
    __ent8: _TCCA[_T8],
) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8]]: ...


@overload
def select(
    __ent0: _TCCA[_T0],
    __ent1: _TCCA[_T1],
    __ent2: _TCCA[_T2],
    __ent3: _TCCA[_T3],
    __ent4: _TCCA[_T4],
    __ent5: _TCCA[_T5],
    __ent6: _TCCA[_T6],
    __ent7: _TCCA[_T7],
    __ent8: _TCCA[_T8],
    __ent9: _TCCA[_T9],
) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9]]: ...





@overload
def select(
    *entities: _ColumnsClauseArgument[Any], **__kw: Any
) -> Select[Any]: ...


def select(*entities: _ColumnsClauseArgument[Any], **__kw: Any) -> Select[Any]:
    r
    
    
    
    if __kw:
        raise _no_kw()
    return Select(*entities)


def table(name: str, *columns: ColumnClause[Any], **kw: Any) -> TableClause:
    

    return TableClause(name, *columns, **kw)


def tablesample(
    selectable: _FromClauseArgument,
    sampling: Union[float, Function[Any]],
    name: Optional[str] = None,
    seed: Optional[roles.ExpressionElementRole[Any]] = None,
) -> TableSample:
    
    return TableSample._factory(selectable, sampling, name=name, seed=seed)


@overload
def union(
    *selects: _TypedSelectable[_TP],
) -> CompoundSelect[_TP]: ...


@overload
def union(
    *selects: _SelectStatementForCompoundArgument[_TP],
) -> CompoundSelect[_TP]: ...


def union(
    *selects: _SelectStatementForCompoundArgument[_TP],
) -> CompoundSelect[_TP]:
    r
    return CompoundSelect._create_union(*selects)


@overload
def union_all(
    *selects: _TypedSelectable[_TP],
) -> CompoundSelect[_TP]: ...


@overload
def union_all(
    *selects: _SelectStatementForCompoundArgument[_TP],
) -> CompoundSelect[_TP]: ...


def union_all(
    *selects: _SelectStatementForCompoundArgument[_TP],
) -> CompoundSelect[_TP]:
    r
    return CompoundSelect._create_union_all(*selects)


def values(
    *columns: ColumnClause[Any],
    name: Optional[str] = None,
    literal_binds: bool = False,
) -> Values:
    r  

    return Values(*columns, literal_binds=literal_binds, name=name)
