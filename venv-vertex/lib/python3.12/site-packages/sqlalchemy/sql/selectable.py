








from __future__ import annotations

import collections
from enum import Enum
import itertools
from typing import AbstractSet
from typing import Any as TODO_Any
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import NamedTuple
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from . import cache_key
from . import coercions
from . import operators
from . import roles
from . import traversals
from . import type_api
from . import visitors
from ._typing import _ColumnsClauseArgument
from ._typing import _no_kw
from ._typing import _T
from ._typing import _TP
from ._typing import is_column_element
from ._typing import is_select_statement
from ._typing import is_subquery
from ._typing import is_table
from ._typing import is_text_clause
from .annotation import Annotated
from .annotation import SupportsCloneAnnotations
from .base import _clone
from .base import _cloned_difference
from .base import _cloned_intersection
from .base import _entity_namespace_key
from .base import _EntityNamespace
from .base import _expand_cloned
from .base import _from_objects
from .base import _generative
from .base import _never_select_column
from .base import _NoArg
from .base import _select_iterables
from .base import CacheableOptions
from .base import ColumnCollection
from .base import ColumnSet
from .base import CompileState
from .base import DedupeColumnCollection
from .base import DialectKWArgs
from .base import Executable
from .base import Generative
from .base import HasCompileState
from .base import HasMemoized
from .base import Immutable
from .coercions import _document_text_coercion
from .elements import _anonymous_label
from .elements import BindParameter
from .elements import BooleanClauseList
from .elements import ClauseElement
from .elements import ClauseList
from .elements import ColumnClause
from .elements import ColumnElement
from .elements import DQLDMLClauseElement
from .elements import GroupedElement
from .elements import literal_column
from .elements import TableValuedColumn
from .elements import UnaryExpression
from .operators import OperatorType
from .sqltypes import NULLTYPE
from .visitors import _TraverseInternalsType
from .visitors import InternalTraversal
from .visitors import prefix_anon_map
from .. import exc
from .. import util
from ..util import HasMemoized_ro_memoized_attribute
from ..util.typing import Literal
from ..util.typing import Protocol
from ..util.typing import Self


and_ = BooleanClauseList.and_


if TYPE_CHECKING:
    from ._typing import _ColumnExpressionArgument
    from ._typing import _ColumnExpressionOrStrLabelArgument
    from ._typing import _FromClauseArgument
    from ._typing import _JoinTargetArgument
    from ._typing import _LimitOffsetType
    from ._typing import _MAYBE_ENTITY
    from ._typing import _NOT_ENTITY
    from ._typing import _OnClauseArgument
    from ._typing import _SelectStatementForCompoundArgument
    from ._typing import _T0
    from ._typing import _T1
    from ._typing import _T2
    from ._typing import _T3
    from ._typing import _T4
    from ._typing import _T5
    from ._typing import _T6
    from ._typing import _T7
    from ._typing import _TextCoercedExpressionArgument
    from ._typing import _TypedColumnClauseArgument as _TCCA
    from ._typing import _TypeEngineArgument
    from .base import _AmbiguousTableNameMap
    from .base import ExecutableOption
    from .base import ReadOnlyColumnCollection
    from .cache_key import _CacheKeyTraversalType
    from .compiler import SQLCompiler
    from .dml import Delete
    from .dml import Update
    from .elements import BinaryExpression
    from .elements import KeyedColumnElement
    from .elements import Label
    from .elements import NamedColumn
    from .elements import TextClause
    from .functions import Function
    from .schema import ForeignKey
    from .schema import ForeignKeyConstraint
    from .sqltypes import TableValueType
    from .type_api import TypeEngine
    from .visitors import _CloneCallableType


_ColumnsClauseElement = Union["FromClause", ColumnElement[Any], "TextClause"]
_LabelConventionCallable = Callable[
    [Union["ColumnElement[Any]", "TextClause"]], Optional[str]
]


class _JoinTargetProtocol(Protocol):
    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]: ...

    @util.ro_non_memoized_property
    def entity_namespace(self) -> _EntityNamespace: ...


_JoinTargetElement = Union["FromClause", _JoinTargetProtocol]
_OnClauseElement = Union["ColumnElement[bool]", _JoinTargetProtocol]

_ForUpdateOfArgument = Union[
    
    Union[
        "_ColumnExpressionArgument[Any]",
        "_FromClauseArgument",
    ],
    
    Sequence["_ColumnExpressionArgument[Any]"],
]


_SetupJoinsElement = Tuple[
    _JoinTargetElement,
    Optional[_OnClauseElement],
    Optional["FromClause"],
    Dict[str, Any],
]


_SelectIterable = Iterable[Union["ColumnElement[Any]", "TextClause"]]


class _OffsetLimitParam(BindParameter[int]):
    inherit_cache = True

    @property
    def _limit_offset_value(self) -> Optional[int]:
        return self.effective_value


class ReturnsRows(roles.ReturnsRowsRole, DQLDMLClauseElement):
    

    _is_returns_rows = True

    
    _is_from_clause = False
    _is_select_base = False
    _is_select_statement = False
    _is_lateral = False

    @property
    def selectable(self) -> ReturnsRows:
        return self

    @util.ro_non_memoized_property
    def _all_selected_columns(self) -> _SelectIterable:
        
        raise NotImplementedError()

    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool:
        
        raise NotImplementedError()

    def _generate_fromclause_column_proxies(
        self,
        fromclause: FromClause,
        columns: ColumnCollection[str, KeyedColumnElement[Any]],
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
    ) -> None:
        

        raise NotImplementedError()

    def _refresh_for_new_column(self, column: ColumnElement[Any]) -> None:
        
        raise NotImplementedError()

    @property
    def exported_columns(self) -> ReadOnlyColumnCollection[Any, Any]:
        

        raise NotImplementedError()


class ExecutableReturnsRows(Executable, ReturnsRows):
    


class TypedReturnsRows(ExecutableReturnsRows, Generic[_TP]):
    


class Selectable(ReturnsRows):
    

    __visit_name__ = "selectable"

    is_selectable = True

    def _refresh_for_new_column(self, column: ColumnElement[Any]) -> None:
        raise NotImplementedError()

    def lateral(self, name: Optional[str] = None) -> LateralFromClause:
        
        return Lateral._construct(self, name=name)

    @util.deprecated(
        "1.4",
        message="The :meth:`.Selectable.replace_selectable` method is "
        "deprecated, and will be removed in a future release.  Similar "
        "functionality is available via the sqlalchemy.sql.visitors module.",
    )
    @util.preload_module("sqlalchemy.sql.util")
    def replace_selectable(self, old: FromClause, alias: Alias) -> Self:
        
        return util.preloaded.sql_util.ClauseAdapter(alias).traverse(self)

    def corresponding_column(
        self, column: KeyedColumnElement[Any], require_embedded: bool = False
    ) -> Optional[KeyedColumnElement[Any]]:
        

        return self.exported_columns.corresponding_column(
            column, require_embedded
        )


class HasPrefixes:
    _prefixes: Tuple[Tuple[DQLDMLClauseElement, str], ...] = ()

    _has_prefixes_traverse_internals: _TraverseInternalsType = [
        ("_prefixes", InternalTraversal.dp_prefix_sequence)
    ]

    @_generative
    @_document_text_coercion(
        "prefixes",
        ":meth:`_expression.HasPrefixes.prefix_with`",
        ":paramref:`.HasPrefixes.prefix_with.*prefixes`",
    )
    def prefix_with(
        self,
        *prefixes: _TextCoercedExpressionArgument[Any],
        dialect: str = "*",
    ) -> Self:
        r
        self._prefixes = self._prefixes + tuple(
            [
                (coercions.expect(roles.StatementOptionRole, p), dialect)
                for p in prefixes
            ]
        )
        return self


class HasSuffixes:
    _suffixes: Tuple[Tuple[DQLDMLClauseElement, str], ...] = ()

    _has_suffixes_traverse_internals: _TraverseInternalsType = [
        ("_suffixes", InternalTraversal.dp_prefix_sequence)
    ]

    @_generative
    @_document_text_coercion(
        "suffixes",
        ":meth:`_expression.HasSuffixes.suffix_with`",
        ":paramref:`.HasSuffixes.suffix_with.*suffixes`",
    )
    def suffix_with(
        self,
        *suffixes: _TextCoercedExpressionArgument[Any],
        dialect: str = "*",
    ) -> Self:
        r
        self._suffixes = self._suffixes + tuple(
            [
                (coercions.expect(roles.StatementOptionRole, p), dialect)
                for p in suffixes
            ]
        )
        return self


class HasHints:
    _hints: util.immutabledict[Tuple[FromClause, str], str] = (
        util.immutabledict()
    )
    _statement_hints: Tuple[Tuple[str, str], ...] = ()

    _has_hints_traverse_internals: _TraverseInternalsType = [
        ("_statement_hints", InternalTraversal.dp_statement_hint_list),
        ("_hints", InternalTraversal.dp_table_hint_list),
    ]

    @_generative
    def with_statement_hint(self, text: str, dialect_name: str = "*") -> Self:
        
        return self._with_hint(None, text, dialect_name)

    @_generative
    def with_hint(
        self,
        selectable: _FromClauseArgument,
        text: str,
        dialect_name: str = "*",
    ) -> Self:
        r

        return self._with_hint(selectable, text, dialect_name)

    def _with_hint(
        self,
        selectable: Optional[_FromClauseArgument],
        text: str,
        dialect_name: str,
    ) -> Self:
        if selectable is None:
            self._statement_hints += ((dialect_name, text),)
        else:
            self._hints = self._hints.union(
                {
                    (
                        coercions.expect(roles.FromClauseRole, selectable),
                        dialect_name,
                    ): text
                }
            )
        return self


class FromClause(roles.AnonymizedFromClauseRole, Selectable):
    

    __visit_name__ = "fromclause"
    named_with_column = False

    @util.ro_non_memoized_property
    def _hide_froms(self) -> Iterable[FromClause]:
        return ()

    _is_clone_of: Optional[FromClause]

    _columns: ColumnCollection[Any, Any]

    schema: Optional[str] = None
    

    is_selectable = True
    _is_from_clause = True
    _is_join = False

    _use_schema_map = False

    def select(self) -> Select[Any]:
        r
        return Select(self)

    def join(
        self,
        right: _FromClauseArgument,
        onclause: Optional[_ColumnExpressionArgument[bool]] = None,
        isouter: bool = False,
        full: bool = False,
    ) -> Join:
        

        return Join(self, right, onclause, isouter, full)

    def outerjoin(
        self,
        right: _FromClauseArgument,
        onclause: Optional[_ColumnExpressionArgument[bool]] = None,
        full: bool = False,
    ) -> Join:
          

        return Join(self, right, onclause, True, full)

    def alias(
        self, name: Optional[str] = None, flat: bool = False
    ) -> NamedFromClause:
        

        return Alias._construct(self, name=name)

    def tablesample(
        self,
        sampling: Union[float, Function[Any]],
        name: Optional[str] = None,
        seed: Optional[roles.ExpressionElementRole[Any]] = None,
    ) -> TableSample:
        
        return TableSample._construct(
            self, sampling=sampling, name=name, seed=seed
        )

    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool:
        
        
        
        
        return fromclause in self._cloned_set

    def _is_lexical_equivalent(self, other: FromClause) -> bool:
        
        return bool(self._cloned_set.intersection(other._cloned_set))

    @util.ro_non_memoized_property
    def description(self) -> str:
        
        return getattr(self, "name", self.__class__.__name__ + " object")

    def _generate_fromclause_column_proxies(
        self,
        fromclause: FromClause,
        columns: ColumnCollection[str, KeyedColumnElement[Any]],
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
    ) -> None:
        columns._populate_separate_keys(
            col._make_proxy(
                fromclause, primary_key=primary_key, foreign_keys=foreign_keys
            )
            for col in self.c
        )

    @util.ro_non_memoized_property
    def exported_columns(
        self,
    ) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]:
        
        return self.c

    @util.ro_non_memoized_property
    def columns(
        self,
    ) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]:
        
        return self.c

    @util.ro_memoized_property
    def c(self) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]:
        
        if "_columns" not in self.__dict__:
            self._setup_collections()
        return self._columns.as_readonly()

    def _setup_collections(self) -> None:
        assert "_columns" not in self.__dict__
        assert "primary_key" not in self.__dict__
        assert "foreign_keys" not in self.__dict__

        _columns: ColumnCollection[Any, Any] = ColumnCollection()
        primary_key = ColumnSet()
        foreign_keys: Set[KeyedColumnElement[Any]] = set()

        self._populate_column_collection(
            columns=_columns,
            primary_key=primary_key,
            foreign_keys=foreign_keys,
        )

        
        
        self._columns = _columns
        self.primary_key = primary_key  
        self.foreign_keys = foreign_keys  

    @util.ro_non_memoized_property
    def entity_namespace(self) -> _EntityNamespace:
        
        return self.c

    @util.ro_memoized_property
    def primary_key(self) -> Iterable[NamedColumn[Any]]:
        
        self._setup_collections()
        return self.primary_key

    @util.ro_memoized_property
    def foreign_keys(self) -> Iterable[ForeignKey]:
        
        self._setup_collections()
        return self.foreign_keys

    def _reset_column_collection(self) -> None:
        

        for key in ["_columns", "columns", "c", "primary_key", "foreign_keys"]:
            self.__dict__.pop(key, None)

    @util.ro_non_memoized_property
    def _select_iterable(self) -> _SelectIterable:
        return (c for c in self.c if not _never_select_column(c))

    @property
    def _cols_populated(self) -> bool:
        return "_columns" in self.__dict__

    def _populate_column_collection(
        self,
        columns: ColumnCollection[str, KeyedColumnElement[Any]],
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
    ) -> None:
        

    def _refresh_for_new_column(self, column: ColumnElement[Any]) -> None:
        
        self._reset_column_collection()

    def _anonymous_fromclause(
        self, *, name: Optional[str] = None, flat: bool = False
    ) -> FromClause:
        return self.alias(name=name)

    if TYPE_CHECKING:

        def self_group(
            self, against: Optional[OperatorType] = None
        ) -> Union[FromGrouping, Self]: ...


class NamedFromClause(FromClause):
    

    named_with_column = True

    name: str

    @util.preload_module("sqlalchemy.sql.sqltypes")
    def table_valued(self) -> TableValuedColumn[Any]:
        
        return TableValuedColumn(self, type_api.TABLEVALUE)


class SelectLabelStyle(Enum):
    

    LABEL_STYLE_NONE = 0
      

    LABEL_STYLE_TABLENAME_PLUS_COL = 1
      

    LABEL_STYLE_DISAMBIGUATE_ONLY = 2
      

    LABEL_STYLE_DEFAULT = LABEL_STYLE_DISAMBIGUATE_ONLY
    

    LABEL_STYLE_LEGACY_ORM = 3


(
    LABEL_STYLE_NONE,
    LABEL_STYLE_TABLENAME_PLUS_COL,
    LABEL_STYLE_DISAMBIGUATE_ONLY,
    _,
) = list(SelectLabelStyle)

LABEL_STYLE_DEFAULT = LABEL_STYLE_DISAMBIGUATE_ONLY


class Join(roles.DMLTableRole, FromClause):
    

    __visit_name__ = "join"

    _traverse_internals: _TraverseInternalsType = [
        ("left", InternalTraversal.dp_clauseelement),
        ("right", InternalTraversal.dp_clauseelement),
        ("onclause", InternalTraversal.dp_clauseelement),
        ("isouter", InternalTraversal.dp_boolean),
        ("full", InternalTraversal.dp_boolean),
    ]

    _is_join = True

    left: FromClause
    right: FromClause
    onclause: Optional[ColumnElement[bool]]
    isouter: bool
    full: bool

    def __init__(
        self,
        left: _FromClauseArgument,
        right: _FromClauseArgument,
        onclause: Optional[_OnClauseArgument] = None,
        isouter: bool = False,
        full: bool = False,
    ):
        

        
        
        
        
        
        
        
        

        self.left = coercions.expect(
            roles.FromClauseRole,
            left,
        )
        self.right = coercions.expect(
            roles.FromClauseRole,
            right,
        ).self_group()

        if onclause is None:
            self.onclause = self._match_primaries(self.left, self.right)
        else:
            
            
            self.onclause = coercions.expect(
                roles.OnClauseRole, onclause
            ).self_group(against=operators._asbool)

        self.isouter = isouter
        self.full = full

    @util.ro_non_memoized_property
    def description(self) -> str:
        return "Join object on %s(%d) and %s(%d)" % (
            self.left.description,
            id(self.left),
            self.right.description,
            id(self.right),
        )

    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool:
        return (
            
            
            hash(fromclause) == hash(self)
            or self.left.is_derived_from(fromclause)
            or self.right.is_derived_from(fromclause)
        )

    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> FromGrouping:
        return FromGrouping(self)

    @util.preload_module("sqlalchemy.sql.util")
    def _populate_column_collection(
        self,
        columns: ColumnCollection[str, KeyedColumnElement[Any]],
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
    ) -> None:
        sqlutil = util.preloaded.sql_util
        _columns: List[KeyedColumnElement[Any]] = [c for c in self.left.c] + [
            c for c in self.right.c
        ]

        primary_key.extend(
            sqlutil.reduce_columns(
                (c for c in _columns if c.primary_key), self.onclause
            )
        )
        columns._populate_separate_keys(
            (col._tq_key_label, col) for col in _columns  
        )
        foreign_keys.update(
            itertools.chain(*[col.foreign_keys for col in _columns])  
        )

    def _copy_internals(
        self, clone: _CloneCallableType = _clone, **kw: Any
    ) -> None:
        

        
        
        all_the_froms = set(
            itertools.chain(
                _from_objects(self.left),
                _from_objects(self.right),
            )
        )

        
        
        new_froms = {f: clone(f, **kw) for f in all_the_froms}

        
        
        
        def replace(
            obj: Union[BinaryExpression[Any], ColumnClause[Any]],
            **kw: Any,
        ) -> Optional[KeyedColumnElement[Any]]:
            if isinstance(obj, ColumnClause) and obj.table in new_froms:
                newelem = new_froms[obj.table].corresponding_column(obj)
                return newelem
            return None

        kw["replace"] = replace

        
        
        
        super()._copy_internals(clone=clone, **kw)

        self._reset_memoizations()

    def _refresh_for_new_column(self, column: ColumnElement[Any]) -> None:
        super()._refresh_for_new_column(column)
        self.left._refresh_for_new_column(column)
        self.right._refresh_for_new_column(column)

    def _match_primaries(
        self,
        left: FromClause,
        right: FromClause,
    ) -> ColumnElement[bool]:
        if isinstance(left, Join):
            left_right = left.right
        else:
            left_right = None
        return self._join_condition(left, right, a_subset=left_right)

    @classmethod
    def _join_condition(
        cls,
        a: FromClause,
        b: FromClause,
        *,
        a_subset: Optional[FromClause] = None,
        consider_as_foreign_keys: Optional[
            AbstractSet[ColumnClause[Any]]
        ] = None,
    ) -> ColumnElement[bool]:
        
        constraints = cls._joincond_scan_left_right(
            a, a_subset, b, consider_as_foreign_keys
        )

        if len(constraints) > 1:
            cls._joincond_trim_constraints(
                a, b, constraints, consider_as_foreign_keys
            )

        if len(constraints) == 0:
            if isinstance(b, FromGrouping):
                hint = (
                    " Perhaps you meant to convert the right side to a "
                    "subquery using alias()?"
                )
            else:
                hint = ""
            raise exc.NoForeignKeysError(
                "Can't find any foreign key relationships "
                "between '%s' and '%s'.%s"
                % (a.description, b.description, hint)
            )

        crit = [(x == y) for x, y in list(constraints.values())[0]]
        if len(crit) == 1:
            return crit[0]
        else:
            return and_(*crit)

    @classmethod
    def _can_join(
        cls,
        left: FromClause,
        right: FromClause,
        *,
        consider_as_foreign_keys: Optional[
            AbstractSet[ColumnClause[Any]]
        ] = None,
    ) -> bool:
        if isinstance(left, Join):
            left_right = left.right
        else:
            left_right = None

        constraints = cls._joincond_scan_left_right(
            a=left,
            b=right,
            a_subset=left_right,
            consider_as_foreign_keys=consider_as_foreign_keys,
        )

        return bool(constraints)

    @classmethod
    @util.preload_module("sqlalchemy.sql.util")
    def _joincond_scan_left_right(
        cls,
        a: FromClause,
        a_subset: Optional[FromClause],
        b: FromClause,
        consider_as_foreign_keys: Optional[AbstractSet[ColumnClause[Any]]],
    ) -> collections.defaultdict[
        Optional[ForeignKeyConstraint],
        List[Tuple[ColumnClause[Any], ColumnClause[Any]]],
    ]:
        sql_util = util.preloaded.sql_util

        a = coercions.expect(roles.FromClauseRole, a)
        b = coercions.expect(roles.FromClauseRole, b)

        constraints: collections.defaultdict[
            Optional[ForeignKeyConstraint],
            List[Tuple[ColumnClause[Any], ColumnClause[Any]]],
        ] = collections.defaultdict(list)

        for left in (a_subset, a):
            if left is None:
                continue
            for fk in sorted(
                b.foreign_keys,
                key=lambda fk: fk.parent._creation_order,
            ):
                if (
                    consider_as_foreign_keys is not None
                    and fk.parent not in consider_as_foreign_keys
                ):
                    continue
                try:
                    col = fk.get_referent(left)
                except exc.NoReferenceError as nrte:
                    table_names = {t.name for t in sql_util.find_tables(left)}
                    if nrte.table_name in table_names:
                        raise
                    else:
                        continue

                if col is not None:
                    constraints[fk.constraint].append((col, fk.parent))
            if left is not b:
                for fk in sorted(
                    left.foreign_keys,
                    key=lambda fk: fk.parent._creation_order,
                ):
                    if (
                        consider_as_foreign_keys is not None
                        and fk.parent not in consider_as_foreign_keys
                    ):
                        continue
                    try:
                        col = fk.get_referent(b)
                    except exc.NoReferenceError as nrte:
                        table_names = {t.name for t in sql_util.find_tables(b)}
                        if nrte.table_name in table_names:
                            raise
                        else:
                            continue

                    if col is not None:
                        constraints[fk.constraint].append((col, fk.parent))
            if constraints:
                break
        return constraints

    @classmethod
    def _joincond_trim_constraints(
        cls,
        a: FromClause,
        b: FromClause,
        constraints: Dict[Any, Any],
        consider_as_foreign_keys: Optional[Any],
    ) -> None:
        
        
        
        if consider_as_foreign_keys:
            for const in list(constraints):
                if {f.parent for f in const.elements} != set(
                    consider_as_foreign_keys
                ):
                    del constraints[const]

        
        
        if len(constraints) > 1:
            dedupe = {tuple(crit) for crit in constraints.values()}
            if len(dedupe) == 1:
                key = list(constraints)[0]
                constraints = {key: constraints[key]}

        if len(constraints) != 1:
            raise exc.AmbiguousForeignKeysError(
                "Can't determine join between '%s' and '%s'; "
                "tables have more than one foreign key "
                "constraint relationship between them. "
                "Please specify the 'onclause' of this "
                "join explicitly." % (a.description, b.description)
            )

    def select(self) -> Select[Any]:
        r
        return Select(self.left, self.right).select_from(self)

    @util.preload_module("sqlalchemy.sql.util")
    def _anonymous_fromclause(
        self, name: Optional[str] = None, flat: bool = False
    ) -> TODO_Any:
        sqlutil = util.preloaded.sql_util
        if flat:
            if isinstance(self.left, (FromGrouping, Join)):
                left_name = name  
            else:
                if name and isinstance(self.left, NamedFromClause):
                    left_name = f"{name}_{self.left.name}"
                else:
                    left_name = name
            if isinstance(self.right, (FromGrouping, Join)):
                right_name = name  
            else:
                if name and isinstance(self.right, NamedFromClause):
                    right_name = f"{name}_{self.right.name}"
                else:
                    right_name = name
            left_a, right_a = (
                self.left._anonymous_fromclause(name=left_name, flat=flat),
                self.right._anonymous_fromclause(name=right_name, flat=flat),
            )
            adapter = sqlutil.ClauseAdapter(left_a).chain(
                sqlutil.ClauseAdapter(right_a)
            )

            return left_a.join(
                right_a,
                adapter.traverse(self.onclause),
                isouter=self.isouter,
                full=self.full,
            )
        else:
            return (
                self.select()
                .set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
                .correlate(None)
                .alias(name)
            )

    @util.ro_non_memoized_property
    def _hide_froms(self) -> Iterable[FromClause]:
        return itertools.chain(
            *[_from_objects(x.left, x.right) for x in self._cloned_set]
        )

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        self_list: List[FromClause] = [self]
        return self_list + self.left._from_objects + self.right._from_objects


class NoInit:
    def __init__(self, *arg: Any, **kw: Any):
        raise NotImplementedError(
            "The %s class is not intended to be constructed "
            "directly.  Please use the %s() standalone "
            "function or the %s() method available from appropriate "
            "selectable objects."
            % (
                self.__class__.__name__,
                self.__class__.__name__.lower(),
                self.__class__.__name__.lower(),
            )
        )


class LateralFromClause(NamedFromClause):
    












class AliasedReturnsRows(NoInit, NamedFromClause):
    

    _is_from_container = True

    _supports_derived_columns = False

    element: ReturnsRows

    _traverse_internals: _TraverseInternalsType = [
        ("element", InternalTraversal.dp_clauseelement),
        ("name", InternalTraversal.dp_anon_name),
    ]

    @classmethod
    def _construct(
        cls,
        selectable: Any,
        *,
        name: Optional[str] = None,
        **kw: Any,
    ) -> Self:
        obj = cls.__new__(cls)
        obj._init(selectable, name=name, **kw)
        return obj

    def _init(self, selectable: Any, *, name: Optional[str] = None) -> None:
        self.element = coercions.expect(
            roles.ReturnsRowsRole, selectable, apply_propagate_attrs=self
        )
        self.element = selectable
        self._orig_name = name
        if name is None:
            if (
                isinstance(selectable, FromClause)
                and selectable.named_with_column
            ):
                name = getattr(selectable, "name", None)
                if isinstance(name, _anonymous_label):
                    name = None
            name = _anonymous_label.safe_construct(id(self), name or "anon")
        self.name = name

    def _refresh_for_new_column(self, column: ColumnElement[Any]) -> None:
        super()._refresh_for_new_column(column)
        self.element._refresh_for_new_column(column)

    def _populate_column_collection(
        self,
        columns: ColumnCollection[str, KeyedColumnElement[Any]],
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
    ) -> None:
        self.element._generate_fromclause_column_proxies(
            self, columns, primary_key=primary_key, foreign_keys=foreign_keys
        )

    @util.ro_non_memoized_property
    def description(self) -> str:
        name = self.name
        if isinstance(name, _anonymous_label):
            return "anon_1"

        return name

    @util.ro_non_memoized_property
    def implicit_returning(self) -> bool:
        return self.element.implicit_returning  

    @property
    def original(self) -> ReturnsRows:
        
        return self.element

    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool:
        if fromclause in self._cloned_set:
            return True
        return self.element.is_derived_from(fromclause)

    def _copy_internals(
        self, clone: _CloneCallableType = _clone, **kw: Any
    ) -> None:
        existing_element = self.element

        super()._copy_internals(clone=clone, **kw)

        
        
        
        
        if existing_element is not self.element:
            self._reset_column_collection()

    @property
    def _from_objects(self) -> List[FromClause]:
        return [self]


class FromClauseAlias(AliasedReturnsRows):
    element: FromClause

    @util.ro_non_memoized_property
    def description(self) -> str:
        name = self.name
        if isinstance(name, _anonymous_label):
            return f"Anonymous alias of {self.element.description}"

        return name


class Alias(roles.DMLTableRole, FromClauseAlias):
    

    __visit_name__ = "alias"

    inherit_cache = True

    element: FromClause

    @classmethod
    def _factory(
        cls,
        selectable: FromClause,
        name: Optional[str] = None,
        flat: bool = False,
    ) -> NamedFromClause:
        return coercions.expect(
            roles.FromClauseRole, selectable, allow_select=True
        ).alias(name=name, flat=flat)


class TableValuedAlias(LateralFromClause, Alias):
      

    __visit_name__ = "table_valued_alias"

    _supports_derived_columns = True
    _render_derived = False
    _render_derived_w_types = False
    joins_implicitly = False

    _traverse_internals: _TraverseInternalsType = [
        ("element", InternalTraversal.dp_clauseelement),
        ("name", InternalTraversal.dp_anon_name),
        ("_tableval_type", InternalTraversal.dp_type),
        ("_render_derived", InternalTraversal.dp_boolean),
        ("_render_derived_w_types", InternalTraversal.dp_boolean),
    ]

    def _init(
        self,
        selectable: Any,
        *,
        name: Optional[str] = None,
        table_value_type: Optional[TableValueType] = None,
        joins_implicitly: bool = False,
    ) -> None:
        super()._init(selectable, name=name)

        self.joins_implicitly = joins_implicitly
        self._tableval_type = (
            type_api.TABLEVALUE
            if table_value_type is None
            else table_value_type
        )

    @HasMemoized.memoized_attribute
    def column(self) -> TableValuedColumn[Any]:
        

        return TableValuedColumn(self, self._tableval_type)

    def alias(
        self, name: Optional[str] = None, flat: bool = False
    ) -> TableValuedAlias:
        

        tva: TableValuedAlias = TableValuedAlias._construct(
            self,
            name=name,
            table_value_type=self._tableval_type,
            joins_implicitly=self.joins_implicitly,
        )

        if self._render_derived:
            tva._render_derived = True
            tva._render_derived_w_types = self._render_derived_w_types

        return tva

    def lateral(self, name: Optional[str] = None) -> LateralFromClause:
        
        tva = self.alias(name=name)
        tva._is_lateral = True
        return tva

    def render_derived(
        self,
        name: Optional[str] = None,
        with_types: bool = False,
    ) -> TableValuedAlias:
          

        
        
        
        
        

        
        
        new_alias: TableValuedAlias = TableValuedAlias._construct(
            self.element,
            name=name,
            table_value_type=self._tableval_type,
            joins_implicitly=self.joins_implicitly,
        )
        new_alias._render_derived = True
        new_alias._render_derived_w_types = with_types
        return new_alias


class Lateral(FromClauseAlias, LateralFromClause):
    

    __visit_name__ = "lateral"
    _is_lateral = True

    inherit_cache = True

    @classmethod
    def _factory(
        cls,
        selectable: Union[SelectBase, _FromClauseArgument],
        name: Optional[str] = None,
    ) -> LateralFromClause:
        return coercions.expect(
            roles.FromClauseRole, selectable, explicit_subquery=True
        ).lateral(name=name)


class TableSample(FromClauseAlias):
    

    __visit_name__ = "tablesample"

    _traverse_internals: _TraverseInternalsType = (
        AliasedReturnsRows._traverse_internals
        + [
            ("sampling", InternalTraversal.dp_clauseelement),
            ("seed", InternalTraversal.dp_clauseelement),
        ]
    )

    @classmethod
    def _factory(
        cls,
        selectable: _FromClauseArgument,
        sampling: Union[float, Function[Any]],
        name: Optional[str] = None,
        seed: Optional[roles.ExpressionElementRole[Any]] = None,
    ) -> TableSample:
        return coercions.expect(roles.FromClauseRole, selectable).tablesample(
            sampling, name=name, seed=seed
        )

    @util.preload_module("sqlalchemy.sql.functions")
    def _init(  
        self,
        selectable: Any,
        *,
        name: Optional[str] = None,
        sampling: Union[float, Function[Any]],
        seed: Optional[roles.ExpressionElementRole[Any]] = None,
    ) -> None:
        assert sampling is not None
        functions = util.preloaded.sql_functions
        if not isinstance(sampling, functions.Function):
            sampling = functions.func.system(sampling)

        self.sampling: Function[Any] = sampling
        self.seed = seed
        super()._init(selectable, name=name)

    def _get_method(self) -> Function[Any]:
        return self.sampling


class CTE(
    roles.DMLTableRole,
    roles.IsCTERole,
    Generative,
    HasPrefixes,
    HasSuffixes,
    AliasedReturnsRows,
):
    

    __visit_name__ = "cte"

    _traverse_internals: _TraverseInternalsType = (
        AliasedReturnsRows._traverse_internals
        + [
            ("_cte_alias", InternalTraversal.dp_clauseelement),
            ("_restates", InternalTraversal.dp_clauseelement),
            ("recursive", InternalTraversal.dp_boolean),
            ("nesting", InternalTraversal.dp_boolean),
        ]
        + HasPrefixes._has_prefixes_traverse_internals
        + HasSuffixes._has_suffixes_traverse_internals
    )

    element: HasCTE

    @classmethod
    def _factory(
        cls,
        selectable: HasCTE,
        name: Optional[str] = None,
        recursive: bool = False,
    ) -> CTE:
        r
        return coercions.expect(roles.HasCTERole, selectable).cte(
            name=name, recursive=recursive
        )

    def _init(
        self,
        selectable: Select[Any],
        *,
        name: Optional[str] = None,
        recursive: bool = False,
        nesting: bool = False,
        _cte_alias: Optional[CTE] = None,
        _restates: Optional[CTE] = None,
        _prefixes: Optional[Tuple[()]] = None,
        _suffixes: Optional[Tuple[()]] = None,
    ) -> None:
        self.recursive = recursive
        self.nesting = nesting
        self._cte_alias = _cte_alias
        
        self._restates = _restates
        if _prefixes:
            self._prefixes = _prefixes
        if _suffixes:
            self._suffixes = _suffixes
        super()._init(selectable, name=name)

    def _populate_column_collection(
        self,
        columns: ColumnCollection[str, KeyedColumnElement[Any]],
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
    ) -> None:
        if self._cte_alias is not None:
            self._cte_alias._generate_fromclause_column_proxies(
                self,
                columns,
                primary_key=primary_key,
                foreign_keys=foreign_keys,
            )
        else:
            self.element._generate_fromclause_column_proxies(
                self,
                columns,
                primary_key=primary_key,
                foreign_keys=foreign_keys,
            )

    def alias(self, name: Optional[str] = None, flat: bool = False) -> CTE:
        
        return CTE._construct(
            self.element,
            name=name,
            recursive=self.recursive,
            nesting=self.nesting,
            _cte_alias=self,
            _prefixes=self._prefixes,
            _suffixes=self._suffixes,
        )

    def union(self, *other: _SelectStatementForCompoundArgument[Any]) -> CTE:
        r
        assert is_select_statement(
            self.element
        ), f"CTE element f{self.element} does not support union()"

        return CTE._construct(
            self.element.union(*other),
            name=self.name,
            recursive=self.recursive,
            nesting=self.nesting,
            _restates=self,
            _prefixes=self._prefixes,
            _suffixes=self._suffixes,
        )

    def union_all(
        self, *other: _SelectStatementForCompoundArgument[Any]
    ) -> CTE:
        r

        assert is_select_statement(
            self.element
        ), f"CTE element f{self.element} does not support union_all()"

        return CTE._construct(
            self.element.union_all(*other),
            name=self.name,
            recursive=self.recursive,
            nesting=self.nesting,
            _restates=self,
            _prefixes=self._prefixes,
            _suffixes=self._suffixes,
        )

    def _get_reference_cte(self) -> CTE:
        
        return self._restates if self._restates is not None else self


class _CTEOpts(NamedTuple):
    nesting: bool


class _ColumnsPlusNames(NamedTuple):
    required_label_name: Optional[str]
    

    proxy_key: Optional[str]
    

    fallback_label_name: Optional[str]
    

    column: Union[ColumnElement[Any], TextClause]
    

    repeated: bool
    


class SelectsRows(ReturnsRows):
    

    _label_style: SelectLabelStyle = LABEL_STYLE_NONE

    def _generate_columns_plus_names(
        self,
        anon_for_dupe_key: bool,
        cols: Optional[_SelectIterable] = None,
    ) -> List[_ColumnsPlusNames]:
        

        if cols is None:
            cols = self._all_selected_columns

        key_naming_convention = SelectState._column_naming_convention(
            self._label_style
        )

        names = {}

        result: List[_ColumnsPlusNames] = []
        result_append = result.append

        table_qualified = self._label_style is LABEL_STYLE_TABLENAME_PLUS_COL
        label_style_none = self._label_style is LABEL_STYLE_NONE

        
        
        
        
        
        
        dedupe_hash = 1

        for c in cols:
            repeated = False

            if not c._render_label_in_columns_clause:
                effective_name = required_label_name = fallback_label_name = (
                    None
                )
            elif label_style_none:
                if TYPE_CHECKING:
                    assert is_column_element(c)

                effective_name = required_label_name = None
                fallback_label_name = c._non_anon_label or c._anon_name_label
            else:
                if TYPE_CHECKING:
                    assert is_column_element(c)

                if table_qualified:
                    required_label_name = effective_name = (
                        fallback_label_name
                    ) = c._tq_label
                else:
                    effective_name = fallback_label_name = c._non_anon_label
                    required_label_name = None

                if effective_name is None:
                    
                    
                    
                    expr_label = c._expression_label
                    if expr_label is None:
                        repeated = c._anon_name_label in names
                        names[c._anon_name_label] = c
                        effective_name = required_label_name = None

                        if repeated:
                            
                            
                            if table_qualified:
                                fallback_label_name = (
                                    c._dedupe_anon_tq_label_idx(dedupe_hash)
                                )
                                dedupe_hash += 1
                            else:
                                fallback_label_name = c._dedupe_anon_label_idx(
                                    dedupe_hash
                                )
                                dedupe_hash += 1
                        else:
                            fallback_label_name = c._anon_name_label
                    else:
                        required_label_name = effective_name = (
                            fallback_label_name
                        ) = expr_label

            if effective_name is not None:
                if TYPE_CHECKING:
                    assert is_column_element(c)

                if effective_name in names:
                    
                    
                    
                    if hash(names[effective_name]) != hash(c):
                        
                        
                        if table_qualified:
                            required_label_name = fallback_label_name = (
                                c._anon_tq_label
                            )
                        else:
                            required_label_name = fallback_label_name = (
                                c._anon_name_label
                            )

                        if anon_for_dupe_key and required_label_name in names:
                            
                            
                            
                            
                            
                            assert hash(names[required_label_name]) == hash(c)

                            
                            
                            
                            
                            if table_qualified:
                                required_label_name = fallback_label_name = (
                                    c._dedupe_anon_tq_label_idx(dedupe_hash)
                                )
                                dedupe_hash += 1
                            else:
                                required_label_name = fallback_label_name = (
                                    c._dedupe_anon_label_idx(dedupe_hash)
                                )
                                dedupe_hash += 1
                            repeated = True
                        else:
                            names[required_label_name] = c
                    elif anon_for_dupe_key:
                        
                        
                        if table_qualified:
                            required_label_name = fallback_label_name = (
                                c._dedupe_anon_tq_label_idx(dedupe_hash)
                            )
                            dedupe_hash += 1
                        else:
                            required_label_name = fallback_label_name = (
                                c._dedupe_anon_label_idx(dedupe_hash)
                            )
                            dedupe_hash += 1
                        repeated = True
                else:
                    names[effective_name] = c

            result_append(
                _ColumnsPlusNames(
                    required_label_name,
                    key_naming_convention(c),
                    fallback_label_name,
                    c,
                    repeated,
                )
            )

        return result


class HasCTE(roles.HasCTERole, SelectsRows):
    

    _has_ctes_traverse_internals: _TraverseInternalsType = [
        ("_independent_ctes", InternalTraversal.dp_clauseelement_list),
        ("_independent_ctes_opts", InternalTraversal.dp_plain_obj),
    ]

    _independent_ctes: Tuple[CTE, ...] = ()
    _independent_ctes_opts: Tuple[_CTEOpts, ...] = ()

    name_cte_columns: bool = False
    

    @_generative
    def add_cte(self, *ctes: CTE, nest_here: bool = False) -> Self:
        r  
        opt = _CTEOpts(nest_here)
        for cte in ctes:
            cte = coercions.expect(roles.IsCTERole, cte)
            self._independent_ctes += (cte,)
            self._independent_ctes_opts += (opt,)
        return self

    def cte(
        self,
        name: Optional[str] = None,
        recursive: bool = False,
        nesting: bool = False,
    ) -> CTE:
        r  
        return CTE._construct(
            self, name=name, recursive=recursive, nesting=nesting
        )


class Subquery(AliasedReturnsRows):
    

    __visit_name__ = "subquery"

    _is_subquery = True

    inherit_cache = True

    element: SelectBase

    @classmethod
    def _factory(
        cls, selectable: SelectBase, name: Optional[str] = None
    ) -> Subquery:
        

        return coercions.expect(
            roles.SelectStatementRole, selectable
        ).subquery(name=name)

    @util.deprecated(
        "1.4",
        "The :meth:`.Subquery.as_scalar` method, which was previously "
        "``Alias.as_scalar()`` prior to version 1.4, is deprecated and "
        "will be removed in a future release; Please use the "
        ":meth:`_expression.Select.scalar_subquery` method of the "
        ":func:`_expression.select` "
        "construct before constructing a subquery object, or with the ORM "
        "use the :meth:`_query.Query.scalar_subquery` method.",
    )
    def as_scalar(self) -> ScalarSelect[Any]:
        return self.element.set_label_style(LABEL_STYLE_NONE).scalar_subquery()


class FromGrouping(GroupedElement, FromClause):
    

    _traverse_internals: _TraverseInternalsType = [
        ("element", InternalTraversal.dp_clauseelement)
    ]

    element: FromClause

    def __init__(self, element: FromClause):
        self.element = coercions.expect(roles.FromClauseRole, element)

    @util.ro_non_memoized_property
    def columns(
        self,
    ) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]:
        return self.element.columns

    @util.ro_non_memoized_property
    def c(self) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]:
        return self.element.columns

    @property
    def primary_key(self) -> Iterable[NamedColumn[Any]]:
        return self.element.primary_key

    @property
    def foreign_keys(self) -> Iterable[ForeignKey]:
        return self.element.foreign_keys

    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool:
        return self.element.is_derived_from(fromclause)

    def alias(
        self, name: Optional[str] = None, flat: bool = False
    ) -> NamedFromGrouping:
        return NamedFromGrouping(self.element.alias(name=name, flat=flat))

    def _anonymous_fromclause(self, **kw: Any) -> FromGrouping:
        return FromGrouping(self.element._anonymous_fromclause(**kw))

    @util.ro_non_memoized_property
    def _hide_froms(self) -> Iterable[FromClause]:
        return self.element._hide_froms

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return self.element._from_objects

    def __getstate__(self) -> Dict[str, FromClause]:
        return {"element": self.element}

    def __setstate__(self, state: Dict[str, FromClause]) -> None:
        self.element = state["element"]

    if TYPE_CHECKING:

        def self_group(
            self, against: Optional[OperatorType] = None
        ) -> Self: ...


class NamedFromGrouping(FromGrouping, NamedFromClause):
    

    inherit_cache = True

    if TYPE_CHECKING:

        def self_group(
            self, against: Optional[OperatorType] = None
        ) -> Self: ...


class TableClause(roles.DMLTableRole, Immutable, NamedFromClause):
    

    __visit_name__ = "table"

    _traverse_internals: _TraverseInternalsType = [
        (
            "columns",
            InternalTraversal.dp_fromclause_canonical_column_collection,
        ),
        ("name", InternalTraversal.dp_string),
        ("schema", InternalTraversal.dp_string),
    ]

    _is_table = True

    fullname: str

    implicit_returning = False
    

    @util.ro_memoized_property
    def _autoincrement_column(self) -> Optional[ColumnClause[Any]]:
        
        return None

    def __init__(self, name: str, *columns: ColumnClause[Any], **kw: Any):
        super().__init__()
        self.name = name
        self._columns = DedupeColumnCollection()
        self.primary_key = ColumnSet()  
        self.foreign_keys = set()  
        for c in columns:
            self.append_column(c)

        schema = kw.pop("schema", None)
        if schema is not None:
            self.schema = schema
        if self.schema is not None:
            self.fullname = "%s.%s" % (self.schema, self.name)
        else:
            self.fullname = self.name
        if kw:
            raise exc.ArgumentError("Unsupported argument(s): %s" % list(kw))

    if TYPE_CHECKING:

        @util.ro_non_memoized_property
        def columns(
            self,
        ) -> ReadOnlyColumnCollection[str, ColumnClause[Any]]: ...

        @util.ro_non_memoized_property
        def c(self) -> ReadOnlyColumnCollection[str, ColumnClause[Any]]: ...

    def __str__(self) -> str:
        if self.schema is not None:
            return self.schema + "." + self.name
        else:
            return self.name

    def _refresh_for_new_column(self, column: ColumnElement[Any]) -> None:
        pass

    @util.ro_memoized_property
    def description(self) -> str:
        return self.name

    def append_column(self, c: ColumnClause[Any]) -> None:
        existing = c.table
        if existing is not None and existing is not self:
            raise exc.ArgumentError(
                "column object '%s' already assigned to table '%s'"
                % (c.key, existing)
            )

        self._columns.add(c)
        c.table = self

    @util.preload_module("sqlalchemy.sql.dml")
    def insert(self) -> util.preloaded.sql_dml.Insert:
        

        return util.preloaded.sql_dml.Insert(self)

    @util.preload_module("sqlalchemy.sql.dml")
    def update(self) -> Update:
        
        return util.preloaded.sql_dml.Update(
            self,
        )

    @util.preload_module("sqlalchemy.sql.dml")
    def delete(self) -> Delete:
        
        return util.preloaded.sql_dml.Delete(self)

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return [self]


ForUpdateParameter = Union["ForUpdateArg", None, bool, Dict[str, Any]]


class ForUpdateArg(ClauseElement):
    _traverse_internals: _TraverseInternalsType = [
        ("of", InternalTraversal.dp_clauseelement_list),
        ("nowait", InternalTraversal.dp_boolean),
        ("read", InternalTraversal.dp_boolean),
        ("skip_locked", InternalTraversal.dp_boolean),
        ("key_share", InternalTraversal.dp_boolean),
    ]

    of: Optional[Sequence[ClauseElement]]
    nowait: bool
    read: bool
    skip_locked: bool

    @classmethod
    def _from_argument(
        cls, with_for_update: ForUpdateParameter
    ) -> Optional[ForUpdateArg]:
        if isinstance(with_for_update, ForUpdateArg):
            return with_for_update
        elif with_for_update in (None, False):
            return None
        elif with_for_update is True:
            return ForUpdateArg()
        else:
            return ForUpdateArg(**cast("Dict[str, Any]", with_for_update))

    def __eq__(self, other: Any) -> bool:
        return (
            isinstance(other, ForUpdateArg)
            and other.nowait == self.nowait
            and other.read == self.read
            and other.skip_locked == self.skip_locked
            and other.key_share == self.key_share
            and other.of is self.of
        )

    def __ne__(self, other: Any) -> bool:
        return not self.__eq__(other)

    def __hash__(self) -> int:
        return id(self)

    def __init__(
        self,
        *,
        nowait: bool = False,
        read: bool = False,
        of: Optional[_ForUpdateOfArgument] = None,
        skip_locked: bool = False,
        key_share: bool = False,
    ):
        

        self.nowait = nowait
        self.read = read
        self.skip_locked = skip_locked
        self.key_share = key_share
        if of is not None:
            self.of = [
                coercions.expect(roles.ColumnsClauseRole, elem)
                for elem in util.to_list(of)
            ]
        else:
            self.of = None


class Values(roles.InElementRole, HasCTE, Generative, LateralFromClause):
    

    __visit_name__ = "values"

    _data: Tuple[Sequence[Tuple[Any, ...]], ...] = ()

    _unnamed: bool
    _traverse_internals: _TraverseInternalsType = [
        ("_column_args", InternalTraversal.dp_clauseelement_list),
        ("_data", InternalTraversal.dp_dml_multi_values),
        ("name", InternalTraversal.dp_string),
        ("literal_binds", InternalTraversal.dp_boolean),
    ] + HasCTE._has_ctes_traverse_internals

    name_cte_columns = True

    def __init__(
        self,
        *columns: ColumnClause[Any],
        name: Optional[str] = None,
        literal_binds: bool = False,
    ):
        super().__init__()
        self._column_args = columns

        if name is None:
            self._unnamed = True
            self.name = _anonymous_label.safe_construct(id(self), "anon")
        else:
            self._unnamed = False
            self.name = name
        self.literal_binds = literal_binds
        self.named_with_column = not self._unnamed

    @property
    def _column_types(self) -> List[TypeEngine[Any]]:
        return [col.type for col in self._column_args]

    @util.ro_non_memoized_property
    def _all_selected_columns(self) -> _SelectIterable:
        return self._column_args

    @_generative
    def alias(self, name: Optional[str] = None, flat: bool = False) -> Self:
        
        non_none_name: str

        if name is None:
            non_none_name = _anonymous_label.safe_construct(id(self), "anon")
        else:
            non_none_name = name

        self.name = non_none_name
        self.named_with_column = True
        self._unnamed = False
        return self

    @_generative
    def lateral(self, name: Optional[str] = None) -> Self:
        
        non_none_name: str

        if name is None:
            non_none_name = self.name
        else:
            non_none_name = name

        self._is_lateral = True
        self.name = non_none_name
        self._unnamed = False
        return self

    @_generative
    def data(self, values: Sequence[Tuple[Any, ...]]) -> Self:
        

        self._data += (values,)
        return self

    def scalar_values(self) -> ScalarValues:
        
        return ScalarValues(self._column_args, self._data, self.literal_binds)

    def _populate_column_collection(
        self,
        columns: ColumnCollection[str, KeyedColumnElement[Any]],
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
    ) -> None:
        for c in self._column_args:
            if c.table is not None and c.table is not self:
                _, c = c._make_proxy(
                    self, primary_key=primary_key, foreign_keys=foreign_keys
                )
            else:
                
                
                
                c._reset_memoizations()
            columns.add(c)
            c.table = self

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return [self]


class ScalarValues(roles.InElementRole, GroupedElement, ColumnElement[Any]):
    

    __visit_name__ = "scalar_values"

    _traverse_internals: _TraverseInternalsType = [
        ("_column_args", InternalTraversal.dp_clauseelement_list),
        ("_data", InternalTraversal.dp_dml_multi_values),
        ("literal_binds", InternalTraversal.dp_boolean),
    ]

    def __init__(
        self,
        columns: Sequence[ColumnClause[Any]],
        data: Tuple[Sequence[Tuple[Any, ...]], ...],
        literal_binds: bool,
    ):
        super().__init__()
        self._column_args = columns
        self._data = data
        self.literal_binds = literal_binds

    @property
    def _column_types(self) -> List[TypeEngine[Any]]:
        return [col.type for col in self._column_args]

    def __clause_element__(self) -> ScalarValues:
        return self

    if TYPE_CHECKING:

        def self_group(
            self, against: Optional[OperatorType] = None
        ) -> Self: ...

        def _ungroup(self) -> ColumnElement[Any]: ...


class SelectBase(
    roles.SelectStatementRole,
    roles.DMLSelectRole,
    roles.CompoundElementRole,
    roles.InElementRole,
    HasCTE,
    SupportsCloneAnnotations,
    Selectable,
):
    

    _is_select_base = True
    is_select = True

    _label_style: SelectLabelStyle = LABEL_STYLE_NONE

    def _refresh_for_new_column(self, column: ColumnElement[Any]) -> None:
        self._reset_memoizations()

    @util.ro_non_memoized_property
    def selected_columns(
        self,
    ) -> ColumnCollection[str, ColumnElement[Any]]:
        
        raise NotImplementedError()

    def _generate_fromclause_column_proxies(
        self,
        subquery: FromClause,
        columns: ColumnCollection[str, KeyedColumnElement[Any]],
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
        *,
        proxy_compound_columns: Optional[
            Iterable[Sequence[ColumnElement[Any]]]
        ] = None,
    ) -> None:
        raise NotImplementedError()

    @util.ro_non_memoized_property
    def _all_selected_columns(self) -> _SelectIterable:
        
        raise NotImplementedError()

    @property
    def exported_columns(
        self,
    ) -> ReadOnlyColumnCollection[str, ColumnElement[Any]]:
        
        return self.selected_columns.as_readonly()

    @property
    @util.deprecated(
        "1.4",
        "The :attr:`_expression.SelectBase.c` and "
        ":attr:`_expression.SelectBase.columns` attributes "
        "are deprecated and will be removed in a future release; these "
        "attributes implicitly create a subquery that should be explicit.  "
        "Please call :meth:`_expression.SelectBase.subquery` "
        "first in order to create "
        "a subquery, which then contains this attribute.  To access the "
        "columns that this SELECT object SELECTs "
        "from, use the :attr:`_expression.SelectBase.selected_columns` "
        "attribute.",
    )
    def c(self) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]:
        return self._implicit_subquery.columns

    @property
    def columns(
        self,
    ) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]:
        return self.c

    def get_label_style(self) -> SelectLabelStyle:
        
        raise NotImplementedError()

    def set_label_style(self, style: SelectLabelStyle) -> Self:
        

        raise NotImplementedError()

    @util.deprecated(
        "1.4",
        "The :meth:`_expression.SelectBase.select` method is deprecated "
        "and will be removed in a future release; this method implicitly "
        "creates a subquery that should be explicit.  "
        "Please call :meth:`_expression.SelectBase.subquery` "
        "first in order to create "
        "a subquery, which then can be selected.",
    )
    def select(self, *arg: Any, **kw: Any) -> Select[Any]:
        return self._implicit_subquery.select(*arg, **kw)

    @HasMemoized.memoized_attribute
    def _implicit_subquery(self) -> Subquery:
        return self.subquery()

    def _scalar_type(self) -> TypeEngine[Any]:
        raise NotImplementedError()

    @util.deprecated(
        "1.4",
        "The :meth:`_expression.SelectBase.as_scalar` "
        "method is deprecated and will be "
        "removed in a future release.  Please refer to "
        ":meth:`_expression.SelectBase.scalar_subquery`.",
    )
    def as_scalar(self) -> ScalarSelect[Any]:
        return self.scalar_subquery()

    def exists(self) -> Exists:
        
        return Exists(self)

    def scalar_subquery(self) -> ScalarSelect[Any]:
        
        if self._label_style is not LABEL_STYLE_NONE:
            self = self.set_label_style(LABEL_STYLE_NONE)

        return ScalarSelect(self)

    def label(self, name: Optional[str]) -> Label[Any]:
        
        return self.scalar_subquery().label(name)

    def lateral(self, name: Optional[str] = None) -> LateralFromClause:
        
        return Lateral._factory(self, name)

    def subquery(self, name: Optional[str] = None) -> Subquery:
        

        return Subquery._construct(
            self._ensure_disambiguated_names(), name=name
        )

    def _ensure_disambiguated_names(self) -> Self:
        

        raise NotImplementedError()

    def alias(
        self, name: Optional[str] = None, flat: bool = False
    ) -> Subquery:
        
        return self.subquery(name=name)


_SB = TypeVar("_SB", bound=SelectBase)


class SelectStatementGrouping(GroupedElement, SelectBase, Generic[_SB]):
    

    __visit_name__ = "select_statement_grouping"
    _traverse_internals: _TraverseInternalsType = [
        ("element", InternalTraversal.dp_clauseelement)
    ] + SupportsCloneAnnotations._clone_annotations_traverse_internals

    _is_select_container = True

    element: _SB

    def __init__(self, element: _SB) -> None:
        self.element = cast(
            _SB, coercions.expect(roles.SelectStatementRole, element)
        )

    def _ensure_disambiguated_names(self) -> SelectStatementGrouping[_SB]:
        new_element = self.element._ensure_disambiguated_names()
        if new_element is not self.element:
            return SelectStatementGrouping(new_element)
        else:
            return self

    def get_label_style(self) -> SelectLabelStyle:
        return self.element.get_label_style()

    def set_label_style(
        self, label_style: SelectLabelStyle
    ) -> SelectStatementGrouping[_SB]:
        return SelectStatementGrouping(
            self.element.set_label_style(label_style)
        )

    @property
    def select_statement(self) -> _SB:
        return self.element

    def self_group(self, against: Optional[OperatorType] = None) -> Self:
        return self

    if TYPE_CHECKING:

        def _ungroup(self) -> _SB: ...

    
    
    
    

    def _generate_fromclause_column_proxies(
        self,
        subquery: FromClause,
        columns: ColumnCollection[str, KeyedColumnElement[Any]],
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
        *,
        proxy_compound_columns: Optional[
            Iterable[Sequence[ColumnElement[Any]]]
        ] = None,
    ) -> None:
        self.element._generate_fromclause_column_proxies(
            subquery,
            columns,
            proxy_compound_columns=proxy_compound_columns,
            primary_key=primary_key,
            foreign_keys=foreign_keys,
        )

    @util.ro_non_memoized_property
    def _all_selected_columns(self) -> _SelectIterable:
        return self.element._all_selected_columns

    @util.ro_non_memoized_property
    def selected_columns(self) -> ColumnCollection[str, ColumnElement[Any]]:
        
        return self.element.selected_columns

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return self.element._from_objects

    def add_cte(self, *ctes: CTE, nest_here: bool = False) -> Self:
        
        raise NotImplementedError


class GenerativeSelect(DialectKWArgs, SelectBase, Generative):
    

    _order_by_clauses: Tuple[ColumnElement[Any], ...] = ()
    _group_by_clauses: Tuple[ColumnElement[Any], ...] = ()
    _limit_clause: Optional[ColumnElement[Any]] = None
    _offset_clause: Optional[ColumnElement[Any]] = None
    _fetch_clause: Optional[ColumnElement[Any]] = None
    _fetch_clause_options: Optional[Dict[str, bool]] = None
    _for_update_arg: Optional[ForUpdateArg] = None

    def __init__(self, _label_style: SelectLabelStyle = LABEL_STYLE_DEFAULT):
        self._label_style = _label_style

    @_generative
    def with_for_update(
        self,
        *,
        nowait: bool = False,
        read: bool = False,
        of: Optional[_ForUpdateOfArgument] = None,
        skip_locked: bool = False,
        key_share: bool = False,
    ) -> Self:
        
        self._for_update_arg = ForUpdateArg(
            nowait=nowait,
            read=read,
            of=of,
            skip_locked=skip_locked,
            key_share=key_share,
        )
        return self

    def get_label_style(self) -> SelectLabelStyle:
        
        return self._label_style

    def set_label_style(self, style: SelectLabelStyle) -> Self:
        
        if self._label_style is not style:
            self = self._generate()
            self._label_style = style
        return self

    @property
    def _group_by_clause(self) -> ClauseList:
        
        return ClauseList._construct_raw(
            operators.comma_op, self._group_by_clauses
        )

    @property
    def _order_by_clause(self) -> ClauseList:
        
        return ClauseList._construct_raw(
            operators.comma_op, self._order_by_clauses
        )

    def _offset_or_limit_clause(
        self,
        element: _LimitOffsetType,
        name: Optional[str] = None,
        type_: Optional[_TypeEngineArgument[int]] = None,
    ) -> ColumnElement[Any]:
        
        return coercions.expect(
            roles.LimitOffsetRole, element, name=name, type_=type_
        )

    @overload
    def _offset_or_limit_clause_asint(
        self, clause: ColumnElement[Any], attrname: str
    ) -> NoReturn: ...

    @overload
    def _offset_or_limit_clause_asint(
        self, clause: Optional[_OffsetLimitParam], attrname: str
    ) -> Optional[int]: ...

    def _offset_or_limit_clause_asint(
        self, clause: Optional[ColumnElement[Any]], attrname: str
    ) -> Union[NoReturn, Optional[int]]:
        
        if clause is None:
            return None
        try:
            value = clause._limit_offset_value
        except AttributeError as err:
            raise exc.CompileError(
                "This SELECT structure does not use a simple "
                "integer value for %s" % attrname
            ) from err
        else:
            return util.asint(value)

    @property
    def _limit(self) -> Optional[int]:
        
        return self._offset_or_limit_clause_asint(self._limit_clause, "limit")

    def _simple_int_clause(self, clause: ClauseElement) -> bool:
        
        return isinstance(clause, _OffsetLimitParam)

    @property
    def _offset(self) -> Optional[int]:
        
        return self._offset_or_limit_clause_asint(
            self._offset_clause, "offset"
        )

    @property
    def _has_row_limiting_clause(self) -> bool:
        return (
            self._limit_clause is not None
            or self._offset_clause is not None
            or self._fetch_clause is not None
        )

    @_generative
    def limit(self, limit: _LimitOffsetType) -> Self:
        

        self._fetch_clause = self._fetch_clause_options = None
        self._limit_clause = self._offset_or_limit_clause(limit)
        return self

    @_generative
    def fetch(
        self,
        count: _LimitOffsetType,
        with_ties: bool = False,
        percent: bool = False,
        **dialect_kw: Any,
    ) -> Self:
        r
        self._validate_dialect_kwargs(dialect_kw)
        self._limit_clause = None
        if count is None:
            self._fetch_clause = self._fetch_clause_options = None
        else:
            self._fetch_clause = self._offset_or_limit_clause(count)
            self._fetch_clause_options = {
                "with_ties": with_ties,
                "percent": percent,
            }
        return self

    @_generative
    def offset(self, offset: _LimitOffsetType) -> Self:
        

        self._offset_clause = self._offset_or_limit_clause(offset)
        return self

    @_generative
    @util.preload_module("sqlalchemy.sql.util")
    def slice(
        self,
        start: int,
        stop: int,
    ) -> Self:
        
        sql_util = util.preloaded.sql_util
        self._fetch_clause = self._fetch_clause_options = None
        self._limit_clause, self._offset_clause = sql_util._make_slice(
            self._limit_clause, self._offset_clause, start, stop
        )
        return self

    @_generative
    def order_by(
        self,
        __first: Union[
            Literal[None, _NoArg.NO_ARG],
            _ColumnExpressionOrStrLabelArgument[Any],
        ] = _NoArg.NO_ARG,
        *clauses: _ColumnExpressionOrStrLabelArgument[Any],
    ) -> Self:
        r

        if not clauses and __first is None:
            self._order_by_clauses = ()
        elif __first is not _NoArg.NO_ARG:
            self._order_by_clauses += tuple(
                coercions.expect(
                    roles.OrderByRole, clause, apply_propagate_attrs=self
                )
                for clause in (__first,) + clauses
            )
        return self

    @_generative
    def group_by(
        self,
        __first: Union[
            Literal[None, _NoArg.NO_ARG],
            _ColumnExpressionOrStrLabelArgument[Any],
        ] = _NoArg.NO_ARG,
        *clauses: _ColumnExpressionOrStrLabelArgument[Any],
    ) -> Self:
        r  

        if not clauses and __first is None:
            self._group_by_clauses = ()
        elif __first is not _NoArg.NO_ARG:
            self._group_by_clauses += tuple(
                coercions.expect(
                    roles.GroupByRole, clause, apply_propagate_attrs=self
                )
                for clause in (__first,) + clauses
            )
        return self


@CompileState.plugin_for("default", "compound_select")
class CompoundSelectState(CompileState):
    @util.memoized_property
    def _label_resolve_dict(
        self,
    ) -> Tuple[
        Dict[str, ColumnElement[Any]],
        Dict[str, ColumnElement[Any]],
        Dict[str, ColumnElement[Any]],
    ]:
        
        hacky_subquery = self.statement.subquery()
        hacky_subquery.named_with_column = False
        d = {c.key: c for c in hacky_subquery.c}
        return d, d, d


class _CompoundSelectKeyword(Enum):
    UNION = "UNION"
    UNION_ALL = "UNION ALL"
    EXCEPT = "EXCEPT"
    EXCEPT_ALL = "EXCEPT ALL"
    INTERSECT = "INTERSECT"
    INTERSECT_ALL = "INTERSECT ALL"


class CompoundSelect(HasCompileState, GenerativeSelect, TypedReturnsRows[_TP]):
    

    __visit_name__ = "compound_select"

    _traverse_internals: _TraverseInternalsType = (
        [
            ("selects", InternalTraversal.dp_clauseelement_list),
            ("_limit_clause", InternalTraversal.dp_clauseelement),
            ("_offset_clause", InternalTraversal.dp_clauseelement),
            ("_fetch_clause", InternalTraversal.dp_clauseelement),
            ("_fetch_clause_options", InternalTraversal.dp_plain_dict),
            ("_order_by_clauses", InternalTraversal.dp_clauseelement_list),
            ("_group_by_clauses", InternalTraversal.dp_clauseelement_list),
            ("_for_update_arg", InternalTraversal.dp_clauseelement),
            ("keyword", InternalTraversal.dp_string),
        ]
        + SupportsCloneAnnotations._clone_annotations_traverse_internals
        + HasCTE._has_ctes_traverse_internals
        + DialectKWArgs._dialect_kwargs_traverse_internals
    )

    selects: List[SelectBase]

    _is_from_container = True
    _auto_correlate = False

    def __init__(
        self,
        keyword: _CompoundSelectKeyword,
        *selects: _SelectStatementForCompoundArgument[_TP],
    ):
        self.keyword = keyword
        self.selects = [
            coercions.expect(
                roles.CompoundElementRole, s, apply_propagate_attrs=self
            ).self_group(against=self)
            for s in selects
        ]

        GenerativeSelect.__init__(self)

    @classmethod
    def _create_union(
        cls, *selects: _SelectStatementForCompoundArgument[_TP]
    ) -> CompoundSelect[_TP]:
        return CompoundSelect(_CompoundSelectKeyword.UNION, *selects)

    @classmethod
    def _create_union_all(
        cls, *selects: _SelectStatementForCompoundArgument[_TP]
    ) -> CompoundSelect[_TP]:
        return CompoundSelect(_CompoundSelectKeyword.UNION_ALL, *selects)

    @classmethod
    def _create_except(
        cls, *selects: _SelectStatementForCompoundArgument[_TP]
    ) -> CompoundSelect[_TP]:
        return CompoundSelect(_CompoundSelectKeyword.EXCEPT, *selects)

    @classmethod
    def _create_except_all(
        cls, *selects: _SelectStatementForCompoundArgument[_TP]
    ) -> CompoundSelect[_TP]:
        return CompoundSelect(_CompoundSelectKeyword.EXCEPT_ALL, *selects)

    @classmethod
    def _create_intersect(
        cls, *selects: _SelectStatementForCompoundArgument[_TP]
    ) -> CompoundSelect[_TP]:
        return CompoundSelect(_CompoundSelectKeyword.INTERSECT, *selects)

    @classmethod
    def _create_intersect_all(
        cls, *selects: _SelectStatementForCompoundArgument[_TP]
    ) -> CompoundSelect[_TP]:
        return CompoundSelect(_CompoundSelectKeyword.INTERSECT_ALL, *selects)

    def _scalar_type(self) -> TypeEngine[Any]:
        return self.selects[0]._scalar_type()

    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> GroupedElement:
        return SelectStatementGrouping(self)

    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool:
        for s in self.selects:
            if s.is_derived_from(fromclause):
                return True
        return False

    def set_label_style(self, style: SelectLabelStyle) -> Self:
        if self._label_style is not style:
            self = self._generate()
            select_0 = self.selects[0].set_label_style(style)
            self.selects = [select_0] + self.selects[1:]

        return self

    def _ensure_disambiguated_names(self) -> Self:
        new_select = self.selects[0]._ensure_disambiguated_names()
        if new_select is not self.selects[0]:
            self = self._generate()
            self.selects = [new_select] + self.selects[1:]

        return self

    def _generate_fromclause_column_proxies(
        self,
        subquery: FromClause,
        columns: ColumnCollection[str, KeyedColumnElement[Any]],
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
        *,
        proxy_compound_columns: Optional[
            Iterable[Sequence[ColumnElement[Any]]]
        ] = None,
    ) -> None:
        
        
        
        
        
        select_0 = self.selects[0]

        if self._label_style is not LABEL_STYLE_DEFAULT:
            select_0 = select_0.set_label_style(self._label_style)

        
        
        
        
        
        extra_col_iterator = zip(
            *[
                [
                    c._annotate(dd)
                    for c in stmt._all_selected_columns
                    if is_column_element(c)
                ]
                for dd, stmt in [
                    ({"weight": i + 1}, stmt)
                    for i, stmt in enumerate(self.selects)
                ]
            ]
        )

        
        
        
        
        
        select_0._generate_fromclause_column_proxies(
            subquery,
            columns,
            proxy_compound_columns=extra_col_iterator,
            primary_key=primary_key,
            foreign_keys=foreign_keys,
        )

    def _refresh_for_new_column(self, column: ColumnElement[Any]) -> None:
        super()._refresh_for_new_column(column)
        for select in self.selects:
            select._refresh_for_new_column(column)

    @util.ro_non_memoized_property
    def _all_selected_columns(self) -> _SelectIterable:
        return self.selects[0]._all_selected_columns

    @util.ro_non_memoized_property
    def selected_columns(
        self,
    ) -> ColumnCollection[str, ColumnElement[Any]]:
        
        return self.selects[0].selected_columns



for elem in _CompoundSelectKeyword:
    setattr(CompoundSelect, elem.name, elem)


@CompileState.plugin_for("default", "select")
class SelectState(util.MemoizedSlots, CompileState):
    __slots__ = (
        "from_clauses",
        "froms",
        "columns_plus_names",
        "_label_resolve_dict",
    )

    if TYPE_CHECKING:
        default_select_compile_options: CacheableOptions
    else:

        class default_select_compile_options(CacheableOptions):
            _cache_key_traversal = []

    if TYPE_CHECKING:

        @classmethod
        def get_plugin_class(
            cls, statement: Executable
        ) -> Type[SelectState]: ...

    def __init__(
        self,
        statement: Select[Any],
        compiler: SQLCompiler,
        **kw: Any,
    ):
        self.statement = statement
        self.from_clauses = statement._from_obj

        for memoized_entities in statement._memoized_select_entities:
            self._setup_joins(
                memoized_entities._setup_joins, memoized_entities._raw_columns
            )

        if statement._setup_joins:
            self._setup_joins(statement._setup_joins, statement._raw_columns)

        self.froms = self._get_froms(statement)

        self.columns_plus_names = statement._generate_columns_plus_names(True)

    @classmethod
    def _plugin_not_implemented(cls) -> NoReturn:
        raise NotImplementedError(
            "The default SELECT construct without plugins does not "
            "implement this method."
        )

    @classmethod
    def get_column_descriptions(
        cls, statement: Select[Any]
    ) -> List[Dict[str, Any]]:
        return [
            {
                "name": name,
                "type": element.type,
                "expr": element,
            }
            for _, name, _, element, _ in (
                statement._generate_columns_plus_names(False)
            )
        ]

    @classmethod
    def from_statement(
        cls, statement: Select[Any], from_statement: roles.ReturnsRowsRole
    ) -> ExecutableReturnsRows:
        cls._plugin_not_implemented()

    @classmethod
    def get_columns_clause_froms(
        cls, statement: Select[Any]
    ) -> List[FromClause]:
        return cls._normalize_froms(
            itertools.chain.from_iterable(
                element._from_objects for element in statement._raw_columns
            )
        )

    @classmethod
    def _column_naming_convention(
        cls, label_style: SelectLabelStyle
    ) -> _LabelConventionCallable:
        table_qualified = label_style is LABEL_STYLE_TABLENAME_PLUS_COL

        dedupe = label_style is not LABEL_STYLE_NONE

        pa = prefix_anon_map()
        names = set()

        def go(
            c: Union[ColumnElement[Any], TextClause],
            col_name: Optional[str] = None,
        ) -> Optional[str]:
            if is_text_clause(c):
                return None
            elif TYPE_CHECKING:
                assert is_column_element(c)

            if not dedupe:
                name = c._proxy_key
                if name is None:
                    name = "_no_label"
                return name

            name = c._tq_key_label if table_qualified else c._proxy_key

            if name is None:
                name = "_no_label"
                if name in names:
                    return c._anon_label(name) % pa
                else:
                    names.add(name)
                    return name

            elif name in names:
                return (
                    c._anon_tq_key_label % pa
                    if table_qualified
                    else c._anon_key_label % pa
                )
            else:
                names.add(name)
                return name

        return go

    def _get_froms(self, statement: Select[Any]) -> List[FromClause]:
        ambiguous_table_name_map: _AmbiguousTableNameMap
        self._ambiguous_table_name_map = ambiguous_table_name_map = {}

        return self._normalize_froms(
            itertools.chain(
                self.from_clauses,
                itertools.chain.from_iterable(
                    [
                        element._from_objects
                        for element in statement._raw_columns
                    ]
                ),
                itertools.chain.from_iterable(
                    [
                        element._from_objects
                        for element in statement._where_criteria
                    ]
                ),
            ),
            check_statement=statement,
            ambiguous_table_name_map=ambiguous_table_name_map,
        )

    @classmethod
    def _normalize_froms(
        cls,
        iterable_of_froms: Iterable[FromClause],
        check_statement: Optional[Select[Any]] = None,
        ambiguous_table_name_map: Optional[_AmbiguousTableNameMap] = None,
    ) -> List[FromClause]:
        
        seen: Set[FromClause] = set()
        froms: List[FromClause] = []

        for item in iterable_of_froms:
            if is_subquery(item) and item.element is check_statement:
                raise exc.InvalidRequestError(
                    "select() construct refers to itself as a FROM"
                )

            if not seen.intersection(item._cloned_set):
                froms.append(item)
                seen.update(item._cloned_set)

        if froms:
            toremove = set(
                itertools.chain.from_iterable(
                    [_expand_cloned(f._hide_froms) for f in froms]
                )
            )
            if toremove:
                
                
                froms = [f for f in froms if f not in toremove]

            if ambiguous_table_name_map is not None:
                ambiguous_table_name_map.update(
                    (
                        fr.name,
                        _anonymous_label.safe_construct(
                            hash(fr.name), fr.name
                        ),
                    )
                    for item in froms
                    for fr in item._from_objects
                    if is_table(fr)
                    and fr.schema
                    and fr.name not in ambiguous_table_name_map
                )

        return froms

    def _get_display_froms(
        self,
        explicit_correlate_froms: Optional[Sequence[FromClause]] = None,
        implicit_correlate_froms: Optional[Sequence[FromClause]] = None,
    ) -> List[FromClause]:
        

        froms = self.froms

        if self.statement._correlate:
            to_correlate = self.statement._correlate
            if to_correlate:
                froms = [
                    f
                    for f in froms
                    if f
                    not in _cloned_intersection(
                        _cloned_intersection(
                            froms, explicit_correlate_froms or ()
                        ),
                        to_correlate,
                    )
                ]

        if self.statement._correlate_except is not None:
            froms = [
                f
                for f in froms
                if f
                not in _cloned_difference(
                    _cloned_intersection(
                        froms, explicit_correlate_froms or ()
                    ),
                    self.statement._correlate_except,
                )
            ]

        if (
            self.statement._auto_correlate
            and implicit_correlate_froms
            and len(froms) > 1
        ):
            froms = [
                f
                for f in froms
                if f
                not in _cloned_intersection(froms, implicit_correlate_froms)
            ]

            if not len(froms):
                raise exc.InvalidRequestError(
                    "Select statement '%r"
                    "' returned no FROM clauses "
                    "due to auto-correlation; "
                    "specify correlate(<tables>) "
                    "to control correlation "
                    "manually." % self.statement
                )

        return froms

    def _memoized_attr__label_resolve_dict(
        self,
    ) -> Tuple[
        Dict[str, ColumnElement[Any]],
        Dict[str, ColumnElement[Any]],
        Dict[str, ColumnElement[Any]],
    ]:
        with_cols: Dict[str, ColumnElement[Any]] = {
            c._tq_label or c.key: c
            for c in self.statement._all_selected_columns
            if c._allow_label_resolve
        }
        only_froms: Dict[str, ColumnElement[Any]] = {
            c.key: c  
            for c in _select_iterables(self.froms)
            if c._allow_label_resolve
        }
        only_cols: Dict[str, ColumnElement[Any]] = with_cols.copy()
        for key, value in only_froms.items():
            with_cols.setdefault(key, value)

        return with_cols, only_froms, only_cols

    @classmethod
    def determine_last_joined_entity(
        cls, stmt: Select[Any]
    ) -> Optional[_JoinTargetElement]:
        if stmt._setup_joins:
            return stmt._setup_joins[-1][0]
        else:
            return None

    @classmethod
    def all_selected_columns(cls, statement: Select[Any]) -> _SelectIterable:
        return [c for c in _select_iterables(statement._raw_columns)]

    def _setup_joins(
        self,
        args: Tuple[_SetupJoinsElement, ...],
        raw_columns: List[_ColumnsClauseElement],
    ) -> None:
        for right, onclause, left, flags in args:
            if TYPE_CHECKING:
                if onclause is not None:
                    assert isinstance(onclause, ColumnElement)

            isouter = flags["isouter"]
            full = flags["full"]

            if left is None:
                (
                    left,
                    replace_from_obj_index,
                ) = self._join_determine_implicit_left_side(
                    raw_columns, left, right, onclause
                )
            else:
                (replace_from_obj_index) = self._join_place_explicit_left_side(
                    left
                )

            
            
            
            
            
            if TYPE_CHECKING:
                assert isinstance(right, FromClause)
                if onclause is not None:
                    assert isinstance(onclause, ColumnElement)

            if replace_from_obj_index is not None:
                
                
                left_clause = self.from_clauses[replace_from_obj_index]

                self.from_clauses = (
                    self.from_clauses[:replace_from_obj_index]
                    + (
                        Join(
                            left_clause,
                            right,
                            onclause,
                            isouter=isouter,
                            full=full,
                        ),
                    )
                    + self.from_clauses[replace_from_obj_index + 1 :]
                )
            else:
                assert left is not None
                self.from_clauses = self.from_clauses + (
                    Join(left, right, onclause, isouter=isouter, full=full),
                )

    @util.preload_module("sqlalchemy.sql.util")
    def _join_determine_implicit_left_side(
        self,
        raw_columns: List[_ColumnsClauseElement],
        left: Optional[FromClause],
        right: _JoinTargetElement,
        onclause: Optional[ColumnElement[Any]],
    ) -> Tuple[Optional[FromClause], Optional[int]]:
        

        sql_util = util.preloaded.sql_util

        replace_from_obj_index: Optional[int] = None

        from_clauses = self.from_clauses

        if from_clauses:
            indexes: List[int] = sql_util.find_left_clause_to_join_from(
                from_clauses, right, onclause
            )

            if len(indexes) == 1:
                replace_from_obj_index = indexes[0]
                left = from_clauses[replace_from_obj_index]
        else:
            potential = {}
            statement = self.statement

            for from_clause in itertools.chain(
                itertools.chain.from_iterable(
                    [element._from_objects for element in raw_columns]
                ),
                itertools.chain.from_iterable(
                    [
                        element._from_objects
                        for element in statement._where_criteria
                    ]
                ),
            ):
                potential[from_clause] = ()

            all_clauses = list(potential.keys())
            indexes = sql_util.find_left_clause_to_join_from(
                all_clauses, right, onclause
            )

            if len(indexes) == 1:
                left = all_clauses[indexes[0]]

        if len(indexes) > 1:
            raise exc.InvalidRequestError(
                "Can't determine which FROM clause to join "
                "from, there are multiple FROMS which can "
                "join to this entity. Please use the .select_from() "
                "method to establish an explicit left side, as well as "
                "providing an explicit ON clause if not present already to "
                "help resolve the ambiguity."
            )
        elif not indexes:
            raise exc.InvalidRequestError(
                "Don't know how to join to %r. "
                "Please use the .select_from() "
                "method to establish an explicit left side, as well as "
                "providing an explicit ON clause if not present already to "
                "help resolve the ambiguity." % (right,)
            )
        return left, replace_from_obj_index

    @util.preload_module("sqlalchemy.sql.util")
    def _join_place_explicit_left_side(
        self, left: FromClause
    ) -> Optional[int]:
        replace_from_obj_index: Optional[int] = None

        sql_util = util.preloaded.sql_util

        from_clauses = list(self.statement._iterate_from_elements())

        if from_clauses:
            indexes: List[int] = sql_util.find_left_clause_that_matches_given(
                self.from_clauses, left
            )
        else:
            indexes = []

        if len(indexes) > 1:
            raise exc.InvalidRequestError(
                "Can't identify which entity in which to assign the "
                "left side of this join.   Please use a more specific "
                "ON clause."
            )

        
        
        if indexes:
            replace_from_obj_index = indexes[0]

        
        

        return replace_from_obj_index


class _SelectFromElements:
    __slots__ = ()

    _raw_columns: List[_ColumnsClauseElement]
    _where_criteria: Tuple[ColumnElement[Any], ...]
    _from_obj: Tuple[FromClause, ...]

    def _iterate_from_elements(self) -> Iterator[FromClause]:
        
        

        seen = set()
        for element in self._raw_columns:
            for fr in element._from_objects:
                if fr in seen:
                    continue
                seen.add(fr)
                yield fr
        for element in self._where_criteria:
            for fr in element._from_objects:
                if fr in seen:
                    continue
                seen.add(fr)
                yield fr
        for element in self._from_obj:
            if element in seen:
                continue
            seen.add(element)
            yield element


class _MemoizedSelectEntities(
    cache_key.HasCacheKey, traversals.HasCopyInternals, visitors.Traversible
):
    

    __visit_name__ = "memoized_select_entities"

    _traverse_internals: _TraverseInternalsType = [
        ("_raw_columns", InternalTraversal.dp_clauseelement_list),
        ("_setup_joins", InternalTraversal.dp_setup_join_tuple),
        ("_with_options", InternalTraversal.dp_executable_options),
    ]

    _is_clone_of: Optional[ClauseElement]
    _raw_columns: List[_ColumnsClauseElement]
    _setup_joins: Tuple[_SetupJoinsElement, ...]
    _with_options: Tuple[ExecutableOption, ...]

    _annotations = util.EMPTY_DICT

    def _clone(self, **kw: Any) -> Self:
        c = self.__class__.__new__(self.__class__)
        c.__dict__ = {k: v for k, v in self.__dict__.items()}

        c._is_clone_of = self.__dict__.get("_is_clone_of", self)
        return c

    @classmethod
    def _generate_for_statement(cls, select_stmt: Select[Any]) -> None:
        if select_stmt._setup_joins or select_stmt._with_options:
            self = _MemoizedSelectEntities()
            self._raw_columns = select_stmt._raw_columns
            self._setup_joins = select_stmt._setup_joins
            self._with_options = select_stmt._with_options

            select_stmt._memoized_select_entities += (self,)
            select_stmt._raw_columns = []
            select_stmt._setup_joins = select_stmt._with_options = ()


class Select(
    HasPrefixes,
    HasSuffixes,
    HasHints,
    HasCompileState,
    _SelectFromElements,
    GenerativeSelect,
    TypedReturnsRows[_TP],
):
    

    __visit_name__ = "select"

    _setup_joins: Tuple[_SetupJoinsElement, ...] = ()
    _memoized_select_entities: Tuple[TODO_Any, ...] = ()

    _raw_columns: List[_ColumnsClauseElement]

    _distinct: bool = False
    _distinct_on: Tuple[ColumnElement[Any], ...] = ()
    _correlate: Tuple[FromClause, ...] = ()
    _correlate_except: Optional[Tuple[FromClause, ...]] = None
    _where_criteria: Tuple[ColumnElement[Any], ...] = ()
    _having_criteria: Tuple[ColumnElement[Any], ...] = ()
    _from_obj: Tuple[FromClause, ...] = ()
    _auto_correlate = True
    _is_select_statement = True
    _compile_options: CacheableOptions = (
        SelectState.default_select_compile_options
    )

    _traverse_internals: _TraverseInternalsType = (
        [
            ("_raw_columns", InternalTraversal.dp_clauseelement_list),
            (
                "_memoized_select_entities",
                InternalTraversal.dp_memoized_select_entities,
            ),
            ("_from_obj", InternalTraversal.dp_clauseelement_list),
            ("_where_criteria", InternalTraversal.dp_clauseelement_tuple),
            ("_having_criteria", InternalTraversal.dp_clauseelement_tuple),
            ("_order_by_clauses", InternalTraversal.dp_clauseelement_tuple),
            ("_group_by_clauses", InternalTraversal.dp_clauseelement_tuple),
            ("_setup_joins", InternalTraversal.dp_setup_join_tuple),
            ("_correlate", InternalTraversal.dp_clauseelement_tuple),
            ("_correlate_except", InternalTraversal.dp_clauseelement_tuple),
            ("_limit_clause", InternalTraversal.dp_clauseelement),
            ("_offset_clause", InternalTraversal.dp_clauseelement),
            ("_fetch_clause", InternalTraversal.dp_clauseelement),
            ("_fetch_clause_options", InternalTraversal.dp_plain_dict),
            ("_for_update_arg", InternalTraversal.dp_clauseelement),
            ("_distinct", InternalTraversal.dp_boolean),
            ("_distinct_on", InternalTraversal.dp_clauseelement_tuple),
            ("_label_style", InternalTraversal.dp_plain_obj),
        ]
        + HasCTE._has_ctes_traverse_internals
        + HasPrefixes._has_prefixes_traverse_internals
        + HasSuffixes._has_suffixes_traverse_internals
        + HasHints._has_hints_traverse_internals
        + SupportsCloneAnnotations._clone_annotations_traverse_internals
        + Executable._executable_traverse_internals
        + DialectKWArgs._dialect_kwargs_traverse_internals
    )

    _cache_key_traversal: _CacheKeyTraversalType = _traverse_internals + [
        ("_compile_options", InternalTraversal.dp_has_cache_key)
    ]

    _compile_state_factory: Type[SelectState]

    @classmethod
    def _create_raw_select(cls, **kw: Any) -> Select[Any]:
        

        stmt = Select.__new__(Select)
        stmt.__dict__.update(kw)
        return stmt

    def __init__(
        self, *entities: _ColumnsClauseArgument[Any], **dialect_kw: Any
    ):
        r
        self._raw_columns = [
            coercions.expect(
                roles.ColumnsClauseRole, ent, apply_propagate_attrs=self
            )
            for ent in entities
        ]
        GenerativeSelect.__init__(self)

    def _scalar_type(self) -> TypeEngine[Any]:
        if not self._raw_columns:
            return NULLTYPE
        elem = self._raw_columns[0]
        cols = list(elem._select_iterable)
        return cols[0].type

    def filter(self, *criteria: _ColumnExpressionArgument[bool]) -> Self:
        

        return self.where(*criteria)

    def _filter_by_zero(
        self,
    ) -> Union[
        FromClause, _JoinTargetProtocol, ColumnElement[Any], TextClause
    ]:
        if self._setup_joins:
            meth = SelectState.get_plugin_class(
                self
            ).determine_last_joined_entity
            _last_joined_entity = meth(self)
            if _last_joined_entity is not None:
                return _last_joined_entity

        if self._from_obj:
            return self._from_obj[0]

        return self._raw_columns[0]

    if TYPE_CHECKING:

        @overload
        def scalar_subquery(
            self: Select[Tuple[_MAYBE_ENTITY]],
        ) -> ScalarSelect[Any]: ...

        @overload
        def scalar_subquery(
            self: Select[Tuple[_NOT_ENTITY]],
        ) -> ScalarSelect[_NOT_ENTITY]: ...

        @overload
        def scalar_subquery(self) -> ScalarSelect[Any]: ...

        def scalar_subquery(self) -> ScalarSelect[Any]: ...

    def filter_by(self, **kwargs: Any) -> Self:
        r
        from_entity = self._filter_by_zero()

        clauses = [
            _entity_namespace_key(from_entity, key) == value
            for key, value in kwargs.items()
        ]
        return self.filter(*clauses)

    @property
    def column_descriptions(self) -> Any:
        
        meth = SelectState.get_plugin_class(self).get_column_descriptions
        return meth(self)

    def from_statement(
        self, statement: roles.ReturnsRowsRole
    ) -> ExecutableReturnsRows:
        
        meth = SelectState.get_plugin_class(self).from_statement
        return meth(self, statement)

    @_generative
    def join(
        self,
        target: _JoinTargetArgument,
        onclause: Optional[_OnClauseArgument] = None,
        *,
        isouter: bool = False,
        full: bool = False,
    ) -> Self:
        r  
        join_target = coercions.expect(
            roles.JoinTargetRole, target, apply_propagate_attrs=self
        )
        if onclause is not None:
            onclause_element = coercions.expect(roles.OnClauseRole, onclause)
        else:
            onclause_element = None

        self._setup_joins += (
            (
                join_target,
                onclause_element,
                None,
                {"isouter": isouter, "full": full},
            ),
        )
        return self

    def outerjoin_from(
        self,
        from_: _FromClauseArgument,
        target: _JoinTargetArgument,
        onclause: Optional[_OnClauseArgument] = None,
        *,
        full: bool = False,
    ) -> Self:
        r
        return self.join_from(
            from_, target, onclause=onclause, isouter=True, full=full
        )

    @_generative
    def join_from(
        self,
        from_: _FromClauseArgument,
        target: _JoinTargetArgument,
        onclause: Optional[_OnClauseArgument] = None,
        *,
        isouter: bool = False,
        full: bool = False,
    ) -> Self:
        r  

        
        
        

        from_ = coercions.expect(
            roles.FromClauseRole, from_, apply_propagate_attrs=self
        )
        join_target = coercions.expect(
            roles.JoinTargetRole, target, apply_propagate_attrs=self
        )
        if onclause is not None:
            onclause_element = coercions.expect(roles.OnClauseRole, onclause)
        else:
            onclause_element = None

        self._setup_joins += (
            (
                join_target,
                onclause_element,
                from_,
                {"isouter": isouter, "full": full},
            ),
        )
        return self

    def outerjoin(
        self,
        target: _JoinTargetArgument,
        onclause: Optional[_OnClauseArgument] = None,
        *,
        full: bool = False,
    ) -> Self:
        
        return self.join(target, onclause=onclause, isouter=True, full=full)

    def get_final_froms(self) -> Sequence[FromClause]:
        
        compiler = self._default_compiler()

        return self._compile_state_factory(self, compiler)._get_display_froms()

    @property
    @util.deprecated(
        "1.4.23",
        "The :attr:`_expression.Select.froms` attribute is moved to "
        "the :meth:`_expression.Select.get_final_froms` method.",
    )
    def froms(self) -> Sequence[FromClause]:
        
        return self.get_final_froms()

    @property
    def columns_clause_froms(self) -> List[FromClause]:
        

        return SelectState.get_plugin_class(self).get_columns_clause_froms(
            self
        )

    @property
    def inner_columns(self) -> _SelectIterable:
        

        return iter(self._all_selected_columns)

    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool:
        if fromclause is not None and self in fromclause._cloned_set:
            return True

        for f in self._iterate_from_elements():
            if f.is_derived_from(fromclause):
                return True
        return False

    def _copy_internals(
        self, clone: _CloneCallableType = _clone, **kw: Any
    ) -> None:
        
        
        

        
        
        

        all_the_froms = set(
            itertools.chain(
                _from_objects(*self._raw_columns),
                _from_objects(*self._where_criteria),
                _from_objects(*[elem[0] for elem in self._setup_joins]),
            )
        )

        
        
        
        
        
        
        new_froms = {f: clone(f, **kw) for f in all_the_froms}

        
        existing_from_obj = [clone(f, **kw) for f in self._from_obj]
        add_froms = (
            {f for f in new_froms.values() if isinstance(f, Join)}
            .difference(all_the_froms)
            .difference(existing_from_obj)
        )

        self._from_obj = tuple(existing_from_obj) + tuple(add_froms)

        
        
        def replace(
            obj: Union[BinaryExpression[Any], ColumnClause[Any]],
            **kw: Any,
        ) -> Optional[KeyedColumnElement[Any]]:
            if isinstance(obj, ColumnClause) and obj.table in new_froms:
                newelem = new_froms[obj.table].corresponding_column(obj)
                return newelem
            return None

        kw["replace"] = replace

        
        
        
        
        super()._copy_internals(clone=clone, omit_attrs=("_from_obj",), **kw)

        self._reset_memoizations()

    def get_children(self, **kw: Any) -> Iterable[ClauseElement]:
        return itertools.chain(
            super().get_children(
                omit_attrs=("_from_obj", "_correlate", "_correlate_except"),
                **kw,
            ),
            self._iterate_from_elements(),
        )

    @_generative
    def add_columns(
        self, *entities: _ColumnsClauseArgument[Any]
    ) -> Select[Any]:
        r
        self._reset_memoizations()

        self._raw_columns = self._raw_columns + [
            coercions.expect(
                roles.ColumnsClauseRole, column, apply_propagate_attrs=self
            )
            for column in entities
        ]
        return self

    def _set_entities(
        self, entities: Iterable[_ColumnsClauseArgument[Any]]
    ) -> None:
        self._raw_columns = [
            coercions.expect(
                roles.ColumnsClauseRole, ent, apply_propagate_attrs=self
            )
            for ent in util.to_list(entities)
        ]

    @util.deprecated(
        "1.4",
        "The :meth:`_expression.Select.column` method is deprecated and will "
        "be removed in a future release.  Please use "
        ":meth:`_expression.Select.add_columns`",
    )
    def column(self, column: _ColumnsClauseArgument[Any]) -> Select[Any]:
        
        return self.add_columns(column)

    @util.preload_module("sqlalchemy.sql.util")
    def reduce_columns(self, only_synonyms: bool = True) -> Select[Any]:
        
        woc: Select[Any]
        woc = self.with_only_columns(
            *util.preloaded.sql_util.reduce_columns(
                self._all_selected_columns,
                only_synonyms=only_synonyms,
                *(self._where_criteria + self._from_obj),
            )
        )
        return woc

    

    
    

    @overload
    def with_only_columns(
        self, __ent0: _TCCA[_T0], *, maintain_column_froms: bool = ...
    ) -> Select[Tuple[_T0]]: ...

    @overload
    def with_only_columns(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        *,
        maintain_column_froms: bool = ...,
    ) -> Select[Tuple[_T0, _T1]]: ...

    @overload
    def with_only_columns(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        *,
        maintain_column_froms: bool = ...,
    ) -> Select[Tuple[_T0, _T1, _T2]]: ...

    @overload
    def with_only_columns(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        *,
        maintain_column_froms: bool = ...,
    ) -> Select[Tuple[_T0, _T1, _T2, _T3]]: ...

    @overload
    def with_only_columns(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        __ent4: _TCCA[_T4],
        *,
        maintain_column_froms: bool = ...,
    ) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4]]: ...

    @overload
    def with_only_columns(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        __ent4: _TCCA[_T4],
        __ent5: _TCCA[_T5],
        *,
        maintain_column_froms: bool = ...,
    ) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5]]: ...

    @overload
    def with_only_columns(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        __ent4: _TCCA[_T4],
        __ent5: _TCCA[_T5],
        __ent6: _TCCA[_T6],
        *,
        maintain_column_froms: bool = ...,
    ) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6]]: ...

    @overload
    def with_only_columns(
        self,
        __ent0: _TCCA[_T0],
        __ent1: _TCCA[_T1],
        __ent2: _TCCA[_T2],
        __ent3: _TCCA[_T3],
        __ent4: _TCCA[_T4],
        __ent5: _TCCA[_T5],
        __ent6: _TCCA[_T6],
        __ent7: _TCCA[_T7],
        *,
        maintain_column_froms: bool = ...,
    ) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7]]: ...

    

    @overload
    def with_only_columns(
        self,
        *entities: _ColumnsClauseArgument[Any],
        maintain_column_froms: bool = False,
        **__kw: Any,
    ) -> Select[Any]: ...

    @_generative
    def with_only_columns(
        self,
        *entities: _ColumnsClauseArgument[Any],
        maintain_column_froms: bool = False,
        **__kw: Any,
    ) -> Select[Any]:
        r  

        if __kw:
            raise _no_kw()

        
        
        
        self._assert_no_memoizations()

        if maintain_column_froms:
            self.select_from.non_generative(  
                self, *self.columns_clause_froms
            )

        
        _MemoizedSelectEntities._generate_for_statement(self)

        self._raw_columns = [
            coercions.expect(roles.ColumnsClauseRole, c)
            for c in coercions._expression_collection_was_a_list(
                "entities", "Select.with_only_columns", entities
            )
        ]
        return self

    @property
    def whereclause(self) -> Optional[ColumnElement[Any]]:
        

        return BooleanClauseList._construct_for_whereclause(
            self._where_criteria
        )

    _whereclause = whereclause

    @_generative
    def where(self, *whereclause: _ColumnExpressionArgument[bool]) -> Self:
        

        assert isinstance(self._where_criteria, tuple)

        for criterion in whereclause:
            where_criteria: ColumnElement[Any] = coercions.expect(
                roles.WhereHavingRole, criterion, apply_propagate_attrs=self
            )
            self._where_criteria += (where_criteria,)
        return self

    @_generative
    def having(self, *having: _ColumnExpressionArgument[bool]) -> Self:
        

        for criterion in having:
            having_criteria = coercions.expect(
                roles.WhereHavingRole, criterion, apply_propagate_attrs=self
            )
            self._having_criteria += (having_criteria,)
        return self

    @_generative
    def distinct(self, *expr: _ColumnExpressionArgument[Any]) -> Self:
        r
        if expr:
            self._distinct = True
            self._distinct_on = self._distinct_on + tuple(
                coercions.expect(roles.ByOfRole, e, apply_propagate_attrs=self)
                for e in expr
            )
        else:
            self._distinct = True
        return self

    @_generative
    def select_from(self, *froms: _FromClauseArgument) -> Self:
        r

        self._from_obj += tuple(
            coercions.expect(
                roles.FromClauseRole, fromclause, apply_propagate_attrs=self
            )
            for fromclause in froms
        )
        return self

    @_generative
    def correlate(
        self,
        *fromclauses: Union[Literal[None, False], _FromClauseArgument],
    ) -> Self:
        r

        
        

        self._auto_correlate = False
        if not fromclauses or fromclauses[0] in {None, False}:
            if len(fromclauses) > 1:
                raise exc.ArgumentError(
                    "additional FROM objects not accepted when "
                    "passing None/False to correlate()"
                )
            self._correlate = ()
        else:
            self._correlate = self._correlate + tuple(
                coercions.expect(roles.FromClauseRole, f) for f in fromclauses
            )
        return self

    @_generative
    def correlate_except(
        self,
        *fromclauses: Union[Literal[None, False], _FromClauseArgument],
    ) -> Self:
        r

        self._auto_correlate = False
        if not fromclauses or fromclauses[0] in {None, False}:
            if len(fromclauses) > 1:
                raise exc.ArgumentError(
                    "additional FROM objects not accepted when "
                    "passing None/False to correlate_except()"
                )
            self._correlate_except = ()
        else:
            self._correlate_except = (self._correlate_except or ()) + tuple(
                coercions.expect(roles.FromClauseRole, f) for f in fromclauses
            )

        return self

    @HasMemoized_ro_memoized_attribute
    def selected_columns(
        self,
    ) -> ColumnCollection[str, ColumnElement[Any]]:
        

        
        
        
        
        conv = cast(
            "Callable[[Any], str]",
            SelectState._column_naming_convention(self._label_style),
        )

        cc: ColumnCollection[str, ColumnElement[Any]] = ColumnCollection(
            [
                (conv(c), c)
                for c in self._all_selected_columns
                if is_column_element(c)
            ]
        )
        return cc.as_readonly()

    @HasMemoized_ro_memoized_attribute
    def _all_selected_columns(self) -> _SelectIterable:
        meth = SelectState.get_plugin_class(self).all_selected_columns
        return list(meth(self))

    def _ensure_disambiguated_names(self) -> Select[Any]:
        if self._label_style is LABEL_STYLE_NONE:
            self = self.set_label_style(LABEL_STYLE_DISAMBIGUATE_ONLY)
        return self

    def _generate_fromclause_column_proxies(
        self,
        subquery: FromClause,
        columns: ColumnCollection[str, KeyedColumnElement[Any]],
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
        *,
        proxy_compound_columns: Optional[
            Iterable[Sequence[ColumnElement[Any]]]
        ] = None,
    ) -> None:
        

        if proxy_compound_columns:
            extra_col_iterator = proxy_compound_columns
            prox = [
                c._make_proxy(
                    subquery,
                    key=proxy_key,
                    name=required_label_name,
                    name_is_truncatable=True,
                    compound_select_cols=extra_cols,
                    primary_key=primary_key,
                    foreign_keys=foreign_keys,
                )
                for (
                    (
                        required_label_name,
                        proxy_key,
                        fallback_label_name,
                        c,
                        repeated,
                    ),
                    extra_cols,
                ) in (
                    zip(
                        self._generate_columns_plus_names(False),
                        extra_col_iterator,
                    )
                )
                if is_column_element(c)
            ]
        else:
            prox = [
                c._make_proxy(
                    subquery,
                    key=proxy_key,
                    name=required_label_name,
                    name_is_truncatable=True,
                    primary_key=primary_key,
                    foreign_keys=foreign_keys,
                )
                for (
                    required_label_name,
                    proxy_key,
                    fallback_label_name,
                    c,
                    repeated,
                ) in (self._generate_columns_plus_names(False))
                if is_column_element(c)
            ]

        columns._populate_separate_keys(prox)

    def _needs_parens_for_grouping(self) -> bool:
        return self._has_row_limiting_clause or bool(
            self._order_by_clause.clauses
        )

    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> Union[SelectStatementGrouping[Self], Self]:
        
        if (
            isinstance(against, CompoundSelect)
            and not self._needs_parens_for_grouping()
        ):
            return self
        else:
            return SelectStatementGrouping(self)

    def union(
        self, *other: _SelectStatementForCompoundArgument[_TP]
    ) -> CompoundSelect[_TP]:
        r
        return CompoundSelect._create_union(self, *other)

    def union_all(
        self, *other: _SelectStatementForCompoundArgument[_TP]
    ) -> CompoundSelect[_TP]:
        r
        return CompoundSelect._create_union_all(self, *other)

    def except_(
        self, *other: _SelectStatementForCompoundArgument[_TP]
    ) -> CompoundSelect[_TP]:
        r
        return CompoundSelect._create_except(self, *other)

    def except_all(
        self, *other: _SelectStatementForCompoundArgument[_TP]
    ) -> CompoundSelect[_TP]:
        r
        return CompoundSelect._create_except_all(self, *other)

    def intersect(
        self, *other: _SelectStatementForCompoundArgument[_TP]
    ) -> CompoundSelect[_TP]:
        r
        return CompoundSelect._create_intersect(self, *other)

    def intersect_all(
        self, *other: _SelectStatementForCompoundArgument[_TP]
    ) -> CompoundSelect[_TP]:
        r
        return CompoundSelect._create_intersect_all(self, *other)


class ScalarSelect(
    roles.InElementRole, Generative, GroupedElement, ColumnElement[_T]
):
    

    _traverse_internals: _TraverseInternalsType = [
        ("element", InternalTraversal.dp_clauseelement),
        ("type", InternalTraversal.dp_type),
    ]

    _from_objects: List[FromClause] = []
    _is_from_container = True
    if not TYPE_CHECKING:
        _is_implicitly_boolean = False
    inherit_cache = True

    element: SelectBase

    def __init__(self, element: SelectBase) -> None:
        self.element = element
        self.type = element._scalar_type()
        self._propagate_attrs = element._propagate_attrs

    def __getattr__(self, attr: str) -> Any:
        return getattr(self.element, attr)

    def __getstate__(self) -> Dict[str, Any]:
        return {"element": self.element, "type": self.type}

    def __setstate__(self, state: Dict[str, Any]) -> None:
        self.element = state["element"]
        self.type = state["type"]

    @property
    def columns(self) -> NoReturn:
        raise exc.InvalidRequestError(
            "Scalar Select expression has no "
            "columns; use this object directly "
            "within a column-level expression."
        )

    c = columns

    @_generative
    def where(self, crit: _ColumnExpressionArgument[bool]) -> Self:
        
        self.element = cast("Select[Any]", self.element).where(crit)
        return self

    def self_group(self, against: Optional[OperatorType] = None) -> Self:
        return self

    def _ungroup(self) -> Self:
        return self

    @_generative
    def correlate(
        self,
        *fromclauses: Union[Literal[None, False], _FromClauseArgument],
    ) -> Self:
        r
        self.element = cast("Select[Any]", self.element).correlate(
            *fromclauses
        )
        return self

    @_generative
    def correlate_except(
        self,
        *fromclauses: Union[Literal[None, False], _FromClauseArgument],
    ) -> Self:
        r

        self.element = cast("Select[Any]", self.element).correlate_except(
            *fromclauses
        )
        return self


class Exists(UnaryExpression[bool]):
    

    inherit_cache = True

    def __init__(
        self,
        __argument: Optional[
            Union[_ColumnsClauseArgument[Any], SelectBase, ScalarSelect[Any]]
        ] = None,
    ):
        s: ScalarSelect[Any]

        
        if __argument is None:
            s = Select(literal_column("*")).scalar_subquery()
        elif isinstance(__argument, SelectBase):
            s = __argument.scalar_subquery()
            s._propagate_attrs = __argument._propagate_attrs
        elif isinstance(__argument, ScalarSelect):
            s = __argument
        else:
            s = Select(__argument).scalar_subquery()

        UnaryExpression.__init__(
            self,
            s,
            operator=operators.exists,
            type_=type_api.BOOLEANTYPE,
        )

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return []

    def _regroup(
        self,
        fn: Callable[[Select[Any]], Select[Any]],
    ) -> ScalarSelect[Any]:

        assert isinstance(self.element, ScalarSelect)
        element = self.element.element
        if not isinstance(element, Select):
            raise exc.InvalidRequestError(
                "Can only apply this operation to a plain SELECT construct"
            )
        new_element = fn(element)

        return_value = new_element.scalar_subquery()
        return return_value

    def select(self) -> Select[Tuple[bool]]:
        r  

        return Select(self)

    def correlate(
        self,
        *fromclauses: Union[Literal[None, False], _FromClauseArgument],
    ) -> Self:
        
        e = self._clone()
        e.element = self._regroup(
            lambda element: element.correlate(*fromclauses)
        )
        return e

    def correlate_except(
        self,
        *fromclauses: Union[Literal[None, False], _FromClauseArgument],
    ) -> Self:
        
        e = self._clone()
        e.element = self._regroup(
            lambda element: element.correlate_except(*fromclauses)
        )
        return e

    def select_from(self, *froms: _FromClauseArgument) -> Self:
        
        e = self._clone()
        e.element = self._regroup(lambda element: element.select_from(*froms))
        return e

    def where(self, *clause: _ColumnExpressionArgument[bool]) -> Self:
        
        e = self._clone()
        e.element = self._regroup(lambda element: element.where(*clause))
        return e


class TextualSelect(SelectBase, ExecutableReturnsRows, Generative):
    

    __visit_name__ = "textual_select"

    _label_style = LABEL_STYLE_NONE

    _traverse_internals: _TraverseInternalsType = (
        [
            ("element", InternalTraversal.dp_clauseelement),
            ("column_args", InternalTraversal.dp_clauseelement_list),
        ]
        + SupportsCloneAnnotations._clone_annotations_traverse_internals
        + HasCTE._has_ctes_traverse_internals
    )

    _is_textual = True

    is_text = True
    is_select = True

    def __init__(
        self,
        text: TextClause,
        columns: List[_ColumnExpressionArgument[Any]],
        positional: bool = False,
    ) -> None:
        self._init(
            text,
            
            [
                coercions.expect(roles.LabeledColumnExprRole, c)
                for c in columns
            ],
            positional,
        )

    def _init(
        self,
        text: TextClause,
        columns: List[NamedColumn[Any]],
        positional: bool = False,
    ) -> None:
        self.element = text
        self.column_args = columns
        self.positional = positional

    @HasMemoized_ro_memoized_attribute
    def selected_columns(
        self,
    ) -> ColumnCollection[str, KeyedColumnElement[Any]]:
        
        return ColumnCollection(
            (c.key, c) for c in self.column_args
        ).as_readonly()

    @util.ro_non_memoized_property
    def _all_selected_columns(self) -> _SelectIterable:
        return self.column_args

    def set_label_style(self, style: SelectLabelStyle) -> TextualSelect:
        return self

    def _ensure_disambiguated_names(self) -> TextualSelect:
        return self

    @_generative
    def bindparams(
        self,
        *binds: BindParameter[Any],
        **bind_as_values: Any,
    ) -> Self:
        self.element = self.element.bindparams(*binds, **bind_as_values)
        return self

    def _generate_fromclause_column_proxies(
        self,
        fromclause: FromClause,
        columns: ColumnCollection[str, KeyedColumnElement[Any]],
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
        *,
        proxy_compound_columns: Optional[
            Iterable[Sequence[ColumnElement[Any]]]
        ] = None,
    ) -> None:
        if TYPE_CHECKING:
            assert isinstance(fromclause, Subquery)

        if proxy_compound_columns:
            columns._populate_separate_keys(
                c._make_proxy(
                    fromclause,
                    compound_select_cols=extra_cols,
                    primary_key=primary_key,
                    foreign_keys=foreign_keys,
                )
                for c, extra_cols in zip(
                    self.column_args, proxy_compound_columns
                )
            )
        else:
            columns._populate_separate_keys(
                c._make_proxy(
                    fromclause,
                    primary_key=primary_key,
                    foreign_keys=foreign_keys,
                )
                for c in self.column_args
            )

    def _scalar_type(self) -> Union[TypeEngine[Any], Any]:
        return self.column_args[0].type


TextAsFrom = TextualSelect



class AnnotatedFromClause(Annotated):
    def _copy_internals(self, **kw: Any) -> None:
        super()._copy_internals(**kw)
        if kw.get("ind_cols_on_fromclause", False):
            ee = self._Annotated__element  

            self.c = ee.__class__.c.fget(self)  

    @util.ro_memoized_property
    def c(self) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]:
        
        ee = self._Annotated__element  
        return ee.c  
