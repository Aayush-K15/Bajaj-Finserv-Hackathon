









from __future__ import annotations

from decimal import Decimal
from enum import Enum
import itertools
import operator
import re
import typing
from typing import AbstractSet
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import FrozenSet
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple as typing_Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from . import coercions
from . import operators
from . import roles
from . import traversals
from . import type_api
from ._typing import has_schema_attr
from ._typing import is_named_from_clause
from ._typing import is_quoted_name
from ._typing import is_tuple_type
from .annotation import Annotated
from .annotation import SupportsWrappingAnnotations
from .base import _clone
from .base import _expand_cloned
from .base import _generative
from .base import _NoArg
from .base import Executable
from .base import Generative
from .base import HasMemoized
from .base import Immutable
from .base import NO_ARG
from .base import SingletonConstant
from .cache_key import MemoizedHasCacheKey
from .cache_key import NO_CACHE
from .coercions import _document_text_coercion  
from .operators import ColumnOperators
from .traversals import HasCopyInternals
from .visitors import cloned_traverse
from .visitors import ExternallyTraversible
from .visitors import InternalTraversal
from .visitors import traverse
from .visitors import Visitable
from .. import exc
from .. import inspection
from .. import util
from ..util import HasMemoized_ro_memoized_attribute
from ..util import TypingOnly
from ..util.typing import Literal
from ..util.typing import ParamSpec
from ..util.typing import Self


if typing.TYPE_CHECKING:
    from ._typing import _ByArgument
    from ._typing import _ColumnExpressionArgument
    from ._typing import _ColumnExpressionOrStrLabelArgument
    from ._typing import _HasDialect
    from ._typing import _InfoType
    from ._typing import _PropagateAttrsType
    from ._typing import _TypeEngineArgument
    from .base import _EntityNamespace
    from .base import ColumnSet
    from .cache_key import _CacheKeyTraversalType
    from .cache_key import CacheKey
    from .compiler import Compiled
    from .compiler import SQLCompiler
    from .functions import FunctionElement
    from .operators import OperatorType
    from .schema import Column
    from .schema import DefaultGenerator
    from .schema import FetchedValue
    from .schema import ForeignKey
    from .selectable import _SelectIterable
    from .selectable import FromClause
    from .selectable import NamedFromClause
    from .selectable import TextualSelect
    from .sqltypes import TupleType
    from .type_api import TypeEngine
    from .visitors import _CloneCallableType
    from .visitors import _TraverseInternalsType
    from .visitors import anon_map
    from ..engine import Connection
    from ..engine import Dialect
    from ..engine.interfaces import _CoreMultiExecuteParams
    from ..engine.interfaces import CacheStats
    from ..engine.interfaces import CompiledCacheType
    from ..engine.interfaces import CoreExecuteOptionsParameter
    from ..engine.interfaces import SchemaTranslateMapType
    from ..engine.result import Result


_NUMERIC = Union[float, Decimal]
_NUMBER = Union[float, int, Decimal]

_T = TypeVar("_T", bound="Any")
_T_co = TypeVar("_T_co", bound=Any, covariant=True)
_OPT = TypeVar("_OPT", bound="Any")
_NT = TypeVar("_NT", bound="_NUMERIC")

_NMT = TypeVar("_NMT", bound="_NUMBER")


@overload
def literal(
    value: Any,
    type_: _TypeEngineArgument[_T],
    literal_execute: bool = False,
) -> BindParameter[_T]: ...


@overload
def literal(
    value: _T,
    type_: None = None,
    literal_execute: bool = False,
) -> BindParameter[_T]: ...


@overload
def literal(
    value: Any,
    type_: Optional[_TypeEngineArgument[Any]] = None,
    literal_execute: bool = False,
) -> BindParameter[Any]: ...


def literal(
    value: Any,
    type_: Optional[_TypeEngineArgument[Any]] = None,
    literal_execute: bool = False,
) -> BindParameter[Any]:
    r
    return coercions.expect(
        roles.LiteralValueRole,
        value,
        type_=type_,
        literal_execute=literal_execute,
    )


def literal_column(
    text: str, type_: Optional[_TypeEngineArgument[_T]] = None
) -> ColumnClause[_T]:
    r
    return ColumnClause(text, type_=type_, is_literal=True)


class CompilerElement(Visitable):
    

    __slots__ = ()
    __visit_name__ = "compiler_element"

    supports_execution = False

    stringify_dialect = "default"

    @util.preload_module("sqlalchemy.engine.default")
    @util.preload_module("sqlalchemy.engine.url")
    def compile(
        self,
        bind: Optional[_HasDialect] = None,
        dialect: Optional[Dialect] = None,
        **kw: Any,
    ) -> Compiled:
        

        if dialect is None:
            if bind:
                dialect = bind.dialect
            elif self.stringify_dialect == "default":
                dialect = self._default_dialect()
            else:
                url = util.preloaded.engine_url
                dialect = url.URL.create(
                    self.stringify_dialect
                ).get_dialect()()

        return self._compiler(dialect, **kw)

    def _default_dialect(self):
        default = util.preloaded.engine_default
        return default.StrCompileDialect()

    def _compiler(self, dialect: Dialect, **kw: Any) -> Compiled:
        

        if TYPE_CHECKING:
            assert isinstance(self, ClauseElement)
        return dialect.statement_compiler(dialect, self, **kw)

    def __str__(self) -> str:
        return str(self.compile())


@inspection._self_inspects
class ClauseElement(
    SupportsWrappingAnnotations,
    MemoizedHasCacheKey,
    HasCopyInternals,
    ExternallyTraversible,
    CompilerElement,
):
    

    __visit_name__ = "clause"

    if TYPE_CHECKING:

        @util.memoized_property
        def _propagate_attrs(self) -> _PropagateAttrsType:
            
            ...

    else:
        _propagate_attrs = util.EMPTY_DICT

    @util.ro_memoized_property
    def description(self) -> Optional[str]:
        return None

    _is_clone_of: Optional[Self] = None

    is_clause_element = True
    is_selectable = False
    is_dml = False
    _is_column_element = False
    _is_keyed_column_element = False
    _is_table = False
    _gen_static_annotations_cache_key = False
    _is_textual = False
    _is_from_clause = False
    _is_returns_rows = False
    _is_text_clause = False
    _is_from_container = False
    _is_select_container = False
    _is_select_base = False
    _is_select_statement = False
    _is_bind_parameter = False
    _is_clause_list = False
    _is_lambda_element = False
    _is_singleton_constant = False
    _is_immutable = False
    _is_star = False

    @property
    def _order_by_label_element(self) -> Optional[Label[Any]]:
        return None

    _cache_key_traversal: _CacheKeyTraversalType = None

    negation_clause: ColumnElement[bool]

    if typing.TYPE_CHECKING:

        def get_children(
            self, *, omit_attrs: typing_Tuple[str, ...] = ..., **kw: Any
        ) -> Iterable[ClauseElement]: ...

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return []

    def _set_propagate_attrs(self, values: Mapping[str, Any]) -> Self:
        
        
        

        

        self._propagate_attrs = util.immutabledict(values)
        return self

    def _default_compiler(self) -> SQLCompiler:
        dialect = self._default_dialect()
        return dialect.statement_compiler(dialect, self)  

    def _clone(self, **kw: Any) -> Self:
        

        skip = self._memoized_keys
        c = self.__class__.__new__(self.__class__)

        if skip:
            
            c.__dict__ = {
                k: v for k, v in self.__dict__.copy().items() if k not in skip
            }
        else:
            c.__dict__ = self.__dict__.copy()

        
        
        
        
        
        cc = self._is_clone_of
        c._is_clone_of = cc if cc is not None else self
        return c

    def _negate_in_binary(self, negated_op, original_op):
        
        return self

    def _with_binary_element_type(self, type_):
        
        return self

    @property
    def _constructor(self):  
        
        return self.__class__

    @HasMemoized.memoized_attribute
    def _cloned_set(self):
        
        s = util.column_set()
        f: Optional[ClauseElement] = self

        
        
        
        
        
        while f is not None:
            s.add(f)
            f = f._is_clone_of
        return s

    def _de_clone(self):
        while self._is_clone_of is not None:
            self = self._is_clone_of
        return self

    @util.ro_non_memoized_property
    def entity_namespace(self) -> _EntityNamespace:
        raise AttributeError(
            "This SQL expression has no entity namespace "
            "with which to filter from."
        )

    def __getstate__(self):
        d = self.__dict__.copy()
        d.pop("_is_clone_of", None)
        d.pop("_generate_cache_key", None)
        return d

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
            return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )
        else:
            raise exc.ObjectNotExecutableError(self)

    def _execute_on_scalar(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Any:
        
        return self._execute_on_connection(
            connection, distilled_params, execution_options
        ).scalar()

    def _get_embedded_bindparams(self) -> Sequence[BindParameter[Any]]:
        

        key = self._generate_cache_key()
        if key is None:
            bindparams: List[BindParameter[Any]] = []

            traverse(self, {}, {"bindparam": bindparams.append})
            return bindparams

        else:
            return key.bindparams

    def unique_params(
        self,
        __optionaldict: Optional[Dict[str, Any]] = None,
        **kwargs: Any,
    ) -> Self:
        
        return self._replace_params(True, __optionaldict, kwargs)

    def params(
        self,
        __optionaldict: Optional[Mapping[str, Any]] = None,
        **kwargs: Any,
    ) -> Self:
        
        return self._replace_params(False, __optionaldict, kwargs)

    def _replace_params(
        self,
        unique: bool,
        optionaldict: Optional[Mapping[str, Any]],
        kwargs: Dict[str, Any],
    ) -> Self:
        if optionaldict:
            kwargs.update(optionaldict)

        def visit_bindparam(bind: BindParameter[Any]) -> None:
            if bind.key in kwargs:
                bind.value = kwargs[bind.key]
                bind.required = False
            if unique:
                bind._convert_to_unique()

        return cloned_traverse(
            self,
            {"maintain_key": True, "detect_subquery_cols": True},
            {"bindparam": visit_bindparam},
        )

    def compare(self, other: ClauseElement, **kw: Any) -> bool:
        r
        return traversals.compare(self, other, **kw)

    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> ClauseElement:
        
        return self

    def _ungroup(self) -> ClauseElement:
        

        return self

    def _compile_w_cache(
        self,
        dialect: Dialect,
        *,
        compiled_cache: Optional[CompiledCacheType],
        column_keys: List[str],
        for_executemany: bool = False,
        schema_translate_map: Optional[SchemaTranslateMapType] = None,
        **kw: Any,
    ) -> typing_Tuple[
        Compiled, Optional[Sequence[BindParameter[Any]]], CacheStats
    ]:
        elem_cache_key: Optional[CacheKey]

        if compiled_cache is not None and dialect._supports_statement_cache:
            elem_cache_key = self._generate_cache_key()
        else:
            elem_cache_key = None

        extracted_params: Optional[Sequence[BindParameter[Any]]]
        if elem_cache_key is not None:
            if TYPE_CHECKING:
                assert compiled_cache is not None

            cache_key, extracted_params = elem_cache_key
            key = (
                dialect,
                cache_key,
                tuple(column_keys),
                bool(schema_translate_map),
                for_executemany,
            )
            compiled_sql = compiled_cache.get(key)

            if compiled_sql is None:
                cache_hit = dialect.CACHE_MISS
                compiled_sql = self._compiler(
                    dialect,
                    cache_key=elem_cache_key,
                    column_keys=column_keys,
                    for_executemany=for_executemany,
                    schema_translate_map=schema_translate_map,
                    **kw,
                )
                compiled_cache[key] = compiled_sql
            else:
                cache_hit = dialect.CACHE_HIT
        else:
            extracted_params = None
            compiled_sql = self._compiler(
                dialect,
                cache_key=elem_cache_key,
                column_keys=column_keys,
                for_executemany=for_executemany,
                schema_translate_map=schema_translate_map,
                **kw,
            )

            if not dialect._supports_statement_cache:
                cache_hit = dialect.NO_DIALECT_SUPPORT
            elif compiled_cache is None:
                cache_hit = dialect.CACHING_DISABLED
            else:
                cache_hit = dialect.NO_CACHE_KEY

        return compiled_sql, extracted_params, cache_hit

    def __invert__(self):
        
        
        if hasattr(self, "negation_clause"):
            return self.negation_clause
        else:
            return self._negate()

    def _negate(self) -> ClauseElement:
        
        
        grouped = self.self_group(against=operators.inv)
        assert isinstance(grouped, ColumnElement)
        return UnaryExpression(grouped, operator=operators.inv)

    def __bool__(self):
        raise TypeError("Boolean value of this clause is not defined")

    def __repr__(self):
        friendly = self.description
        if friendly is None:
            return object.__repr__(self)
        else:
            return "<%s.%s at 0x%x; %s>" % (
                self.__module__,
                self.__class__.__name__,
                id(self),
                friendly,
            )


class DQLDMLClauseElement(ClauseElement):
    

    if typing.TYPE_CHECKING:

        def _compiler(self, dialect: Dialect, **kw: Any) -> SQLCompiler:
            
            ...

        def compile(  
            self,
            bind: Optional[_HasDialect] = None,
            dialect: Optional[Dialect] = None,
            **kw: Any,
        ) -> SQLCompiler: ...


class CompilerColumnElement(
    roles.DMLColumnRole,
    roles.DDLConstraintColumnRole,
    roles.ColumnsClauseRole,
    CompilerElement,
):
    

    __slots__ = ()

    _propagate_attrs = util.EMPTY_DICT
    _is_collection_aggregate = False





class SQLCoreOperations(Generic[_T_co], ColumnOperators, TypingOnly):
    __slots__ = ()

    
    
    
    if typing.TYPE_CHECKING:

        @util.non_memoized_property
        def _propagate_attrs(self) -> _PropagateAttrsType: ...

        def operate(
            self, op: OperatorType, *other: Any, **kwargs: Any
        ) -> ColumnElement[Any]: ...

        def reverse_operate(
            self, op: OperatorType, other: Any, **kwargs: Any
        ) -> ColumnElement[Any]: ...

        @overload
        def op(
            self,
            opstring: str,
            precedence: int = ...,
            is_comparison: bool = ...,
            *,
            return_type: _TypeEngineArgument[_OPT],
            python_impl: Optional[Callable[..., Any]] = None,
        ) -> Callable[[Any], BinaryExpression[_OPT]]: ...

        @overload
        def op(
            self,
            opstring: str,
            precedence: int = ...,
            is_comparison: bool = ...,
            return_type: Optional[_TypeEngineArgument[Any]] = ...,
            python_impl: Optional[Callable[..., Any]] = ...,
        ) -> Callable[[Any], BinaryExpression[Any]]: ...

        def op(
            self,
            opstring: str,
            precedence: int = 0,
            is_comparison: bool = False,
            return_type: Optional[_TypeEngineArgument[Any]] = None,
            python_impl: Optional[Callable[..., Any]] = None,
        ) -> Callable[[Any], BinaryExpression[Any]]: ...

        def bool_op(
            self,
            opstring: str,
            precedence: int = 0,
            python_impl: Optional[Callable[..., Any]] = None,
        ) -> Callable[[Any], BinaryExpression[bool]]: ...

        def __and__(self, other: Any) -> BooleanClauseList: ...

        def __or__(self, other: Any) -> BooleanClauseList: ...

        def __invert__(self) -> ColumnElement[_T_co]: ...

        def __lt__(self, other: Any) -> ColumnElement[bool]: ...

        def __le__(self, other: Any) -> ColumnElement[bool]: ...

        
        
        
        
        def __hash__(self) -> int: ...

        def __eq__(self, other: Any) -> ColumnElement[bool]:  
            ...

        def __ne__(self, other: Any) -> ColumnElement[bool]:  
            ...

        def is_distinct_from(self, other: Any) -> ColumnElement[bool]: ...

        def is_not_distinct_from(self, other: Any) -> ColumnElement[bool]: ...

        def __gt__(self, other: Any) -> ColumnElement[bool]: ...

        def __ge__(self, other: Any) -> ColumnElement[bool]: ...

        def __neg__(self) -> UnaryExpression[_T_co]: ...

        def __contains__(self, other: Any) -> ColumnElement[bool]: ...

        def __getitem__(self, index: Any) -> ColumnElement[Any]: ...

        @overload
        def __lshift__(self: _SQO[int], other: Any) -> ColumnElement[int]: ...

        @overload
        def __lshift__(self, other: Any) -> ColumnElement[Any]: ...

        def __lshift__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def __rshift__(self: _SQO[int], other: Any) -> ColumnElement[int]: ...

        @overload
        def __rshift__(self, other: Any) -> ColumnElement[Any]: ...

        def __rshift__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def concat(self: _SQO[str], other: Any) -> ColumnElement[str]: ...

        @overload
        def concat(self, other: Any) -> ColumnElement[Any]: ...

        def concat(self, other: Any) -> ColumnElement[Any]: ...

        def like(
            self, other: Any, escape: Optional[str] = None
        ) -> BinaryExpression[bool]: ...

        def ilike(
            self, other: Any, escape: Optional[str] = None
        ) -> BinaryExpression[bool]: ...

        def bitwise_xor(self, other: Any) -> BinaryExpression[Any]: ...

        def bitwise_or(self, other: Any) -> BinaryExpression[Any]: ...

        def bitwise_and(self, other: Any) -> BinaryExpression[Any]: ...

        def bitwise_not(self) -> UnaryExpression[_T_co]: ...

        def bitwise_lshift(self, other: Any) -> BinaryExpression[Any]: ...

        def bitwise_rshift(self, other: Any) -> BinaryExpression[Any]: ...

        def in_(
            self,
            other: Union[
                Iterable[Any], BindParameter[Any], roles.InElementRole
            ],
        ) -> BinaryExpression[bool]: ...

        def not_in(
            self,
            other: Union[
                Iterable[Any], BindParameter[Any], roles.InElementRole
            ],
        ) -> BinaryExpression[bool]: ...

        def notin_(
            self,
            other: Union[
                Iterable[Any], BindParameter[Any], roles.InElementRole
            ],
        ) -> BinaryExpression[bool]: ...

        def not_like(
            self, other: Any, escape: Optional[str] = None
        ) -> BinaryExpression[bool]: ...

        def notlike(
            self, other: Any, escape: Optional[str] = None
        ) -> BinaryExpression[bool]: ...

        def not_ilike(
            self, other: Any, escape: Optional[str] = None
        ) -> BinaryExpression[bool]: ...

        def notilike(
            self, other: Any, escape: Optional[str] = None
        ) -> BinaryExpression[bool]: ...

        def is_(self, other: Any) -> BinaryExpression[bool]: ...

        def is_not(self, other: Any) -> BinaryExpression[bool]: ...

        def isnot(self, other: Any) -> BinaryExpression[bool]: ...

        def startswith(
            self,
            other: Any,
            escape: Optional[str] = None,
            autoescape: bool = False,
        ) -> ColumnElement[bool]: ...

        def istartswith(
            self,
            other: Any,
            escape: Optional[str] = None,
            autoescape: bool = False,
        ) -> ColumnElement[bool]: ...

        def endswith(
            self,
            other: Any,
            escape: Optional[str] = None,
            autoescape: bool = False,
        ) -> ColumnElement[bool]: ...

        def iendswith(
            self,
            other: Any,
            escape: Optional[str] = None,
            autoescape: bool = False,
        ) -> ColumnElement[bool]: ...

        def contains(self, other: Any, **kw: Any) -> ColumnElement[bool]: ...

        def icontains(self, other: Any, **kw: Any) -> ColumnElement[bool]: ...

        def match(self, other: Any, **kwargs: Any) -> ColumnElement[bool]: ...

        def regexp_match(
            self, pattern: Any, flags: Optional[str] = None
        ) -> ColumnElement[bool]: ...

        def regexp_replace(
            self, pattern: Any, replacement: Any, flags: Optional[str] = None
        ) -> ColumnElement[str]: ...

        def desc(self) -> UnaryExpression[_T_co]: ...

        def asc(self) -> UnaryExpression[_T_co]: ...

        def nulls_first(self) -> UnaryExpression[_T_co]: ...

        def nullsfirst(self) -> UnaryExpression[_T_co]: ...

        def nulls_last(self) -> UnaryExpression[_T_co]: ...

        def nullslast(self) -> UnaryExpression[_T_co]: ...

        def collate(self, collation: str) -> CollationClause: ...

        def between(
            self, cleft: Any, cright: Any, symmetric: bool = False
        ) -> BinaryExpression[bool]: ...

        def distinct(self: _SQO[_T_co]) -> UnaryExpression[_T_co]: ...

        def any_(self) -> CollectionAggregate[Any]: ...

        def all_(self) -> CollectionAggregate[Any]: ...

        
        
        
        

        @overload
        def __add__(
            self: _SQO[_NMT],
            other: Any,
        ) -> ColumnElement[_NMT]: ...

        @overload
        def __add__(
            self: _SQO[str],
            other: Any,
        ) -> ColumnElement[str]: ...

        @overload
        def __add__(self, other: Any) -> ColumnElement[Any]: ...

        def __add__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def __radd__(self: _SQO[_NMT], other: Any) -> ColumnElement[_NMT]: ...

        @overload
        def __radd__(self: _SQO[str], other: Any) -> ColumnElement[str]: ...

        def __radd__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def __sub__(
            self: _SQO[_NMT],
            other: Any,
        ) -> ColumnElement[_NMT]: ...

        @overload
        def __sub__(self, other: Any) -> ColumnElement[Any]: ...

        def __sub__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def __rsub__(
            self: _SQO[_NMT],
            other: Any,
        ) -> ColumnElement[_NMT]: ...

        @overload
        def __rsub__(self, other: Any) -> ColumnElement[Any]: ...

        def __rsub__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def __mul__(
            self: _SQO[_NMT],
            other: Any,
        ) -> ColumnElement[_NMT]: ...

        @overload
        def __mul__(self, other: Any) -> ColumnElement[Any]: ...

        def __mul__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def __rmul__(
            self: _SQO[_NMT],
            other: Any,
        ) -> ColumnElement[_NMT]: ...

        @overload
        def __rmul__(self, other: Any) -> ColumnElement[Any]: ...

        def __rmul__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def __mod__(self: _SQO[_NMT], other: Any) -> ColumnElement[_NMT]: ...

        @overload
        def __mod__(self, other: Any) -> ColumnElement[Any]: ...

        def __mod__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def __rmod__(self: _SQO[_NMT], other: Any) -> ColumnElement[_NMT]: ...

        @overload
        def __rmod__(self, other: Any) -> ColumnElement[Any]: ...

        def __rmod__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def __truediv__(
            self: _SQO[int], other: Any
        ) -> ColumnElement[_NUMERIC]: ...

        @overload
        def __truediv__(self: _SQO[_NT], other: Any) -> ColumnElement[_NT]: ...

        @overload
        def __truediv__(self, other: Any) -> ColumnElement[Any]: ...

        def __truediv__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def __rtruediv__(
            self: _SQO[_NMT], other: Any
        ) -> ColumnElement[_NUMERIC]: ...

        @overload
        def __rtruediv__(self, other: Any) -> ColumnElement[Any]: ...

        def __rtruediv__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def __floordiv__(
            self: _SQO[_NMT], other: Any
        ) -> ColumnElement[_NMT]: ...

        @overload
        def __floordiv__(self, other: Any) -> ColumnElement[Any]: ...

        def __floordiv__(self, other: Any) -> ColumnElement[Any]: ...

        @overload
        def __rfloordiv__(
            self: _SQO[_NMT], other: Any
        ) -> ColumnElement[_NMT]: ...

        @overload
        def __rfloordiv__(self, other: Any) -> ColumnElement[Any]: ...

        def __rfloordiv__(self, other: Any) -> ColumnElement[Any]: ...


class SQLColumnExpression(
    SQLCoreOperations[_T_co], roles.ExpressionElementRole[_T_co], TypingOnly
):
    

    __slots__ = ()


_SQO = SQLCoreOperations


class ColumnElement(
    roles.ColumnArgumentOrKeyRole,
    roles.StatementOptionRole,
    roles.WhereHavingRole,
    roles.BinaryElementRole[_T],
    roles.OrderByRole,
    roles.ColumnsClauseRole,
    roles.LimitOffsetRole,
    roles.DMLColumnRole,
    roles.DDLConstraintColumnRole,
    roles.DDLExpressionRole,
    SQLColumnExpression[_T],
    DQLDMLClauseElement,
):
    

    __visit_name__ = "column_element"

    primary_key: bool = False
    _is_clone_of: Optional[ColumnElement[_T]]
    _is_column_element = True
    _insert_sentinel: bool = False
    _omit_from_statements = False
    _is_collection_aggregate = False

    foreign_keys: AbstractSet[ForeignKey] = frozenset()

    @util.memoized_property
    def _proxies(self) -> List[ColumnElement[Any]]:
        return []

    @util.non_memoized_property
    def _tq_label(self) -> Optional[str]:
        
        return None

    key: Optional[str] = None
    

    @HasMemoized.memoized_attribute
    def _tq_key_label(self) -> Optional[str]:
        
        return self._proxy_key

    @property
    def _key_label(self) -> Optional[str]:
        
        return self._tq_key_label

    @property
    def _label(self) -> Optional[str]:
        
        return self._tq_label

    @property
    def _non_anon_label(self) -> Optional[str]:
        
        return getattr(self, "name", None)

    _render_label_in_columns_clause = True
    

    _allow_label_resolve = True
    

    _is_implicitly_boolean = False

    _alt_names: Sequence[str] = ()

    if TYPE_CHECKING:

        def _ungroup(self) -> ColumnElement[_T]: ...

    @overload
    def self_group(self, against: None = None) -> ColumnElement[_T]: ...

    @overload
    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> ColumnElement[Any]: ...

    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> ColumnElement[Any]:
        if (
            against in (operators.and_, operators.or_, operators._asbool)
            and self.type._type_affinity is type_api.BOOLEANTYPE._type_affinity
        ):
            return AsBoolean(self, operators.is_true, operators.is_false)
        elif against in (operators.any_op, operators.all_op):
            return Grouping(self)
        else:
            return self

    @overload
    def _negate(self: ColumnElement[bool]) -> ColumnElement[bool]: ...

    @overload
    def _negate(self: ColumnElement[_T]) -> ColumnElement[_T]: ...

    def _negate(self) -> ColumnElement[Any]:
        if self.type._type_affinity is type_api.BOOLEANTYPE._type_affinity:
            return AsBoolean(self, operators.is_false, operators.is_true)
        else:
            grouped = self.self_group(against=operators.inv)
            assert isinstance(grouped, ColumnElement)
            return UnaryExpression(
                grouped,
                operator=operators.inv,
            )

    type: TypeEngine[_T]

    if not TYPE_CHECKING:

        @util.memoized_property
        def type(self) -> TypeEngine[_T]:  
            
            
            return type_api.NULLTYPE

    @HasMemoized.memoized_attribute
    def comparator(self) -> TypeEngine.Comparator[_T]:
        try:
            comparator_factory = self.type.comparator_factory
        except AttributeError as err:
            raise TypeError(
                "Object %r associated with '.type' attribute "
                "is not a TypeEngine class or object" % self.type
            ) from err
        else:
            return comparator_factory(self)

    def __setstate__(self, state):
        self.__dict__.update(state)

    def __getattr__(self, key: str) -> Any:
        try:
            return getattr(self.comparator, key)
        except AttributeError as err:
            raise AttributeError(
                "Neither %r object nor %r object has an attribute %r"
                % (
                    type(self).__name__,
                    type(self.comparator).__name__,
                    key,
                )
            ) from err

    def operate(
        self,
        op: operators.OperatorType,
        *other: Any,
        **kwargs: Any,
    ) -> ColumnElement[Any]:
        return op(self.comparator, *other, **kwargs)  

    def reverse_operate(
        self, op: operators.OperatorType, other: Any, **kwargs: Any
    ) -> ColumnElement[Any]:
        return op(other, self.comparator, **kwargs)  

    def _bind_param(
        self,
        operator: operators.OperatorType,
        obj: Any,
        type_: Optional[TypeEngine[_T]] = None,
        expanding: bool = False,
    ) -> BindParameter[_T]:
        return BindParameter(
            None,
            obj,
            _compared_to_operator=operator,
            type_=type_,
            _compared_to_type=self.type,
            unique=True,
            expanding=expanding,
        )

    @property
    def expression(self) -> ColumnElement[Any]:
        
        return self

    @property
    def _select_iterable(self) -> _SelectIterable:
        return (self,)

    @util.memoized_property
    def base_columns(self) -> FrozenSet[ColumnElement[Any]]:
        return frozenset(c for c in self.proxy_set if not c._proxies)

    @util.memoized_property
    def proxy_set(self) -> FrozenSet[ColumnElement[Any]]:
        
        return frozenset([self._deannotate()]).union(
            itertools.chain(*[c.proxy_set for c in self._proxies])
        )

    @util.memoized_property
    def _expanded_proxy_set(self) -> FrozenSet[ColumnElement[Any]]:
        return frozenset(_expand_cloned(self.proxy_set))

    def _uncached_proxy_list(self) -> List[ColumnElement[Any]]:
        

        return [self] + list(
            itertools.chain(*[c._uncached_proxy_list() for c in self._proxies])
        )

    def shares_lineage(self, othercolumn: ColumnElement[Any]) -> bool:
        

        return bool(self.proxy_set.intersection(othercolumn.proxy_set))

    def _compare_name_for_result(self, other: ColumnElement[Any]) -> bool:
        

        return (
            hasattr(other, "name")
            and hasattr(self, "name")
            and other.name == self.name
        )

    @HasMemoized.memoized_attribute
    def _proxy_key(self) -> Optional[str]:
        if self._annotations and "proxy_key" in self._annotations:
            return cast(str, self._annotations["proxy_key"])

        name = self.key
        if not name:
            
            
            
            
            name = self._non_anon_label

        if isinstance(name, _anonymous_label):
            return None
        else:
            return name

    @HasMemoized.memoized_attribute
    def _expression_label(self) -> Optional[str]:
        

        if getattr(self, "name", None) is not None:
            return None
        elif self._annotations and "proxy_key" in self._annotations:
            return cast(str, self._annotations["proxy_key"])
        else:
            return None

    def _make_proxy(
        self,
        selectable: FromClause,
        *,
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
        name: Optional[str] = None,
        key: Optional[str] = None,
        name_is_truncatable: bool = False,
        compound_select_cols: Optional[Sequence[ColumnElement[Any]]] = None,
        **kw: Any,
    ) -> typing_Tuple[str, ColumnClause[_T]]:
        
        if name is None:
            name = self._anon_name_label
            if key is None:
                key = self._proxy_key
        else:
            key = name

        assert key is not None

        co: ColumnClause[_T] = ColumnClause(
            (
                coercions.expect(roles.TruncatedLabelRole, name)
                if name_is_truncatable
                else name
            ),
            type_=getattr(self, "type", None),
            _selectable=selectable,
        )

        co._propagate_attrs = selectable._propagate_attrs
        if compound_select_cols:
            co._proxies = list(compound_select_cols)
        else:
            co._proxies = [self]
        if selectable._is_clone_of is not None:
            co._is_clone_of = selectable._is_clone_of.columns.get(key)
        return key, co

    def cast(self, type_: _TypeEngineArgument[_OPT]) -> Cast[_OPT]:
        
        return Cast(self, type_)

    def label(self, name: Optional[str]) -> Label[_T]:
        
        return Label(name, self, self.type)

    def _anon_label(
        self, seed: Optional[str], add_hash: Optional[int] = None
    ) -> _anonymous_label:
        while self._is_clone_of is not None:
            self = self._is_clone_of

        
        
        
        hash_value = hash(self)

        if add_hash:
            
            
            

            
            
            assert add_hash < (2 << 15)
            assert seed
            hash_value = (hash_value << 16) | add_hash

            
            
            
            
            
            seed = seed + "_"

        if isinstance(seed, _anonymous_label):
            return _anonymous_label.safe_construct(
                hash_value, "", enclosing_label=seed
            )

        return _anonymous_label.safe_construct(hash_value, seed or "anon")

    @util.memoized_property
    def _anon_name_label(self) -> str:
        
        name = getattr(self, "name", None)
        return self._anon_label(name)

    @util.memoized_property
    def _anon_key_label(self) -> _anonymous_label:
        
        return self._anon_label(self._proxy_key)

    @property
    @util.deprecated(
        "1.4",
        "The :attr:`_expression.ColumnElement.anon_label` attribute is now "
        "private, and the public accessor is deprecated.",
    )
    def anon_label(self) -> str:
        return self._anon_name_label

    @property
    @util.deprecated(
        "1.4",
        "The :attr:`_expression.ColumnElement.anon_key_label` attribute is "
        "now private, and the public accessor is deprecated.",
    )
    def anon_key_label(self) -> str:
        return self._anon_key_label

    def _dedupe_anon_label_idx(self, idx: int) -> str:
        
        label = getattr(self, "name", None)

        
        
        
        
        
        

        if label is None:
            return self._dedupe_anon_tq_label_idx(idx)
        else:
            return self._anon_label(label, add_hash=idx)

    @util.memoized_property
    def _anon_tq_label(self) -> _anonymous_label:
        return self._anon_label(getattr(self, "_tq_label", None))

    @util.memoized_property
    def _anon_tq_key_label(self) -> _anonymous_label:
        return self._anon_label(getattr(self, "_tq_key_label", None))

    def _dedupe_anon_tq_label_idx(self, idx: int) -> _anonymous_label:
        label = getattr(self, "_tq_label", None) or "anon"

        return self._anon_label(label, add_hash=idx)


class KeyedColumnElement(ColumnElement[_T]):
    

    _is_keyed_column_element = True

    key: str


class WrapsColumnExpression(ColumnElement[_T]):
    

    @property
    def wrapped_column_expression(self) -> ColumnElement[_T]:
        raise NotImplementedError()

    @util.non_memoized_property
    def _tq_label(self) -> Optional[str]:
        wce = self.wrapped_column_expression
        if hasattr(wce, "_tq_label"):
            return wce._tq_label
        else:
            return None

    @property
    def _label(self) -> Optional[str]:
        return self._tq_label

    @property
    def _non_anon_label(self) -> Optional[str]:
        return None

    @util.non_memoized_property
    def _anon_name_label(self) -> str:
        wce = self.wrapped_column_expression

        
        
        
        if not wce._is_text_clause:
            nal = wce._non_anon_label
            if nal:
                return nal
            elif hasattr(wce, "_anon_name_label"):
                return wce._anon_name_label
        return super()._anon_name_label

    def _dedupe_anon_label_idx(self, idx: int) -> str:
        wce = self.wrapped_column_expression
        nal = wce._non_anon_label
        if nal:
            return self._anon_label(nal + "_")
        else:
            return self._dedupe_anon_tq_label_idx(idx)

    @property
    def _proxy_key(self):
        wce = self.wrapped_column_expression

        if not wce._is_text_clause:
            return wce._proxy_key
        return super()._proxy_key


class BindParameter(roles.InElementRole, KeyedColumnElement[_T]):
    r

    __visit_name__ = "bindparam"

    _traverse_internals: _TraverseInternalsType = [
        ("key", InternalTraversal.dp_anon_name),
        ("type", InternalTraversal.dp_type),
        ("callable", InternalTraversal.dp_plain_dict),
        ("value", InternalTraversal.dp_plain_obj),
        ("literal_execute", InternalTraversal.dp_boolean),
    ]

    key: str
    type: TypeEngine[_T]
    value: Optional[_T]

    _is_crud = False
    _is_bind_parameter = True
    _key_is_anon = False

    
    
    inherit_cache = True

    def __init__(
        self,
        key: Optional[str],
        value: Any = _NoArg.NO_ARG,
        type_: Optional[_TypeEngineArgument[_T]] = None,
        unique: bool = False,
        required: Union[bool, Literal[_NoArg.NO_ARG]] = _NoArg.NO_ARG,
        quote: Optional[bool] = None,
        callable_: Optional[Callable[[], Any]] = None,
        expanding: bool = False,
        isoutparam: bool = False,
        literal_execute: bool = False,
        _compared_to_operator: Optional[OperatorType] = None,
        _compared_to_type: Optional[TypeEngine[Any]] = None,
        _is_crud: bool = False,
    ):
        if required is _NoArg.NO_ARG:
            required = value is _NoArg.NO_ARG and callable_ is None
        if value is _NoArg.NO_ARG:
            value = None

        if quote is not None:
            key = quoted_name.construct(key, quote)

        if unique:
            self.key = _anonymous_label.safe_construct(
                id(self),
                (
                    key
                    if key is not None
                    and not isinstance(key, _anonymous_label)
                    else "param"
                ),
                sanitize_key=True,
            )
            self._key_is_anon = True
        elif key:
            self.key = key
        else:
            self.key = _anonymous_label.safe_construct(id(self), "param")
            self._key_is_anon = True

        
        
        
        self._identifying_key = self.key

        
        
        self._orig_key = key or "param"

        self.unique = unique
        self.value = value
        self.callable = callable_
        self.isoutparam = isoutparam
        self.required = required

        
        
        
        self.expanding = expanding

        
        
        
        self.expand_op = None

        self.literal_execute = literal_execute
        if _is_crud:
            self._is_crud = True

        if type_ is None:
            if expanding:
                if value:
                    check_value = value[0]
                else:
                    check_value = type_api._NO_VALUE_IN_LIST
            else:
                check_value = value
            if _compared_to_type is not None:
                self.type = _compared_to_type.coerce_compared_value(
                    _compared_to_operator, check_value
                )
            else:
                self.type = type_api._resolve_value_to_type(check_value)
        elif isinstance(type_, type):
            self.type = type_()
        elif is_tuple_type(type_):
            if value:
                if expanding:
                    check_value = value[0]
                else:
                    check_value = value
                cast("BindParameter[typing_Tuple[Any, ...]]", self).type = (
                    type_._resolve_values_to_types(check_value)
                )
            else:
                cast("BindParameter[typing_Tuple[Any, ...]]", self).type = (
                    type_
                )
        else:
            self.type = type_

    def _with_value(self, value, maintain_key=False, required=NO_ARG):
        
        cloned = self._clone(maintain_key=maintain_key)
        cloned.value = value
        cloned.callable = None
        cloned.required = required if required is not NO_ARG else self.required
        if cloned.type is type_api.NULLTYPE:
            cloned.type = type_api._resolve_value_to_type(value)
        return cloned

    @property
    def effective_value(self) -> Optional[_T]:
        
        if self.callable:
            
            return self.callable()  
        else:
            return self.value

    def render_literal_execute(self) -> BindParameter[_T]:
        
        c = ClauseElement._clone(self)
        c.literal_execute = True
        return c

    def _negate_in_binary(self, negated_op, original_op):
        if self.expand_op is original_op:
            bind = self._clone()
            bind.expand_op = negated_op
            return bind
        else:
            return self

    def _with_binary_element_type(self, type_: TypeEngine[Any]) -> Self:
        c: Self = ClauseElement._clone(self)
        c.type = type_
        return c

    def _clone(self, maintain_key: bool = False, **kw: Any) -> Self:
        c = ClauseElement._clone(self, **kw)
        
        
        
        
        
        
        
        
        c._cloned_set.update(self._cloned_set)
        if not maintain_key and self.unique:
            c.key = _anonymous_label.safe_construct(
                id(c), c._orig_key or "param", sanitize_key=True
            )
        return c

    def _gen_cache_key(self, anon_map, bindparams):
        _gen_cache_ok = self.__class__.__dict__.get("inherit_cache", False)

        if not _gen_cache_ok:
            if anon_map is not None:
                anon_map[NO_CACHE] = True
            return None

        id_, found = anon_map.get_anon(self)
        if found:
            return (id_, self.__class__)

        if bindparams is not None:
            bindparams.append(self)

        return (
            id_,
            self.__class__,
            self.type._static_cache_key,
            self.key % anon_map if self._key_is_anon else self.key,
            self.literal_execute,
        )

    def _convert_to_unique(self):
        if not self.unique:
            self.unique = True
            self.key = _anonymous_label.safe_construct(
                id(self), self._orig_key or "param", sanitize_key=True
            )

    def __getstate__(self):
        

        d = self.__dict__.copy()
        v = self.value
        if self.callable:
            v = self.callable()
            d["callable"] = None
        d["value"] = v
        return d

    def __setstate__(self, state):
        if state.get("unique", False):
            state["key"] = _anonymous_label.safe_construct(
                id(self), state.get("_orig_key", "param"), sanitize_key=True
            )
        self.__dict__.update(state)

    def __repr__(self):
        return "%s(%r, %r, type_=%r)" % (
            self.__class__.__name__,
            self.key,
            self.value,
            self.type,
        )


class TypeClause(DQLDMLClauseElement):
    

    __visit_name__ = "typeclause"

    _traverse_internals: _TraverseInternalsType = [
        ("type", InternalTraversal.dp_type)
    ]
    type: TypeEngine[Any]

    def __init__(self, type_: TypeEngine[Any]):
        self.type = type_


class TextClause(
    roles.DDLConstraintColumnRole,
    roles.DDLExpressionRole,
    roles.StatementOptionRole,
    roles.WhereHavingRole,
    roles.OrderByRole,
    roles.FromClauseRole,
    roles.SelectStatementRole,
    roles.InElementRole,
    Generative,
    Executable,
    DQLDMLClauseElement,
    roles.BinaryElementRole[Any],
    inspection.Inspectable["TextClause"],
):
    

    __visit_name__ = "textclause"

    _traverse_internals: _TraverseInternalsType = [
        ("_bindparams", InternalTraversal.dp_string_clauseelement_dict),
        ("text", InternalTraversal.dp_string),
    ]

    _is_text_clause = True

    _is_textual = True

    _bind_params_regex = re.compile(r"(?<![:\w\x5c]):(\w+)(?!:)", re.UNICODE)
    _is_implicitly_boolean = False

    _render_label_in_columns_clause = False

    _omit_from_statements = False

    _is_collection_aggregate = False

    @property
    def _hide_froms(self) -> Iterable[FromClause]:
        return ()

    def __and__(self, other):
        
        return and_(self, other)

    @property
    def _select_iterable(self) -> _SelectIterable:
        return (self,)

    
    
    key: Optional[str] = None
    _label: Optional[str] = None

    _allow_label_resolve = False

    @property
    def _is_star(self):  
        return self.text == "*"

    def __init__(self, text: str):
        self._bindparams: Dict[str, BindParameter[Any]] = {}

        def repl(m):
            self._bindparams[m.group(1)] = BindParameter(m.group(1))
            return ":%s" % m.group(1)

        
        
        self.text = self._bind_params_regex.sub(repl, text)

    @_generative
    def bindparams(
        self,
        *binds: BindParameter[Any],
        **names_to_values: Any,
    ) -> Self:
          
        self._bindparams = new_params = self._bindparams.copy()

        for bind in binds:
            try:
                
                
                
                existing = new_params[bind._orig_key]
            except KeyError as err:
                raise exc.ArgumentError(
                    "This text() construct doesn't define a "
                    "bound parameter named %r" % bind._orig_key
                ) from err
            else:
                new_params[existing._orig_key] = bind

        for key, value in names_to_values.items():
            try:
                existing = new_params[key]
            except KeyError as err:
                raise exc.ArgumentError(
                    "This text() construct doesn't define a "
                    "bound parameter named %r" % key
                ) from err
            else:
                new_params[key] = existing._with_value(value, required=False)
        return self

    @util.preload_module("sqlalchemy.sql.selectable")
    def columns(
        self,
        *cols: _ColumnExpressionArgument[Any],
        **types: _TypeEngineArgument[Any],
    ) -> TextualSelect:
        r
        selectable = util.preloaded.sql_selectable

        input_cols: List[NamedColumn[Any]] = [
            coercions.expect(roles.LabeledColumnExprRole, col) for col in cols
        ]

        positional_input_cols = [
            (
                ColumnClause(col.key, types.pop(col.key))
                if col.key in types
                else col
            )
            for col in input_cols
        ]
        keyed_input_cols: List[NamedColumn[Any]] = [
            ColumnClause(key, type_) for key, type_ in types.items()
        ]

        elem = selectable.TextualSelect.__new__(selectable.TextualSelect)
        elem._init(
            self,
            positional_input_cols + keyed_input_cols,
            positional=bool(positional_input_cols) and not keyed_input_cols,
        )
        return elem

    @property
    def type(self) -> TypeEngine[Any]:
        return type_api.NULLTYPE

    @property
    def comparator(self):
        
        
        return self.type.comparator_factory(self)  

    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> Union[Self, Grouping[Any]]:
        if against is operators.in_op:
            return Grouping(self)
        else:
            return self


class Null(SingletonConstant, roles.ConstExprRole[None], ColumnElement[None]):
    

    __visit_name__ = "null"

    _traverse_internals: _TraverseInternalsType = []
    _singleton: Null

    if not TYPE_CHECKING:

        @util.memoized_property
        def type(self) -> TypeEngine[_T]:  
            return type_api.NULLTYPE

    @classmethod
    def _instance(cls) -> Null:
        

        return Null._singleton


Null._create_singleton()


class False_(
    SingletonConstant, roles.ConstExprRole[bool], ColumnElement[bool]
):
    

    __visit_name__ = "false"
    _traverse_internals: _TraverseInternalsType = []
    _singleton: False_

    if not TYPE_CHECKING:

        @util.memoized_property
        def type(self) -> TypeEngine[_T]:  
            return type_api.BOOLEANTYPE

    def _negate(self) -> True_:
        return True_._singleton

    @classmethod
    def _instance(cls) -> False_:
        return False_._singleton


False_._create_singleton()


class True_(SingletonConstant, roles.ConstExprRole[bool], ColumnElement[bool]):
    

    __visit_name__ = "true"

    _traverse_internals: _TraverseInternalsType = []
    _singleton: True_

    if not TYPE_CHECKING:

        @util.memoized_property
        def type(self) -> TypeEngine[_T]:  
            return type_api.BOOLEANTYPE

    def _negate(self) -> False_:
        return False_._singleton

    @classmethod
    def _ifnone(
        cls, other: Optional[ColumnElement[Any]]
    ) -> ColumnElement[Any]:
        if other is None:
            return cls._instance()
        else:
            return other

    @classmethod
    def _instance(cls) -> True_:
        return True_._singleton


True_._create_singleton()


class ClauseList(
    roles.InElementRole,
    roles.OrderByRole,
    roles.ColumnsClauseRole,
    roles.DMLColumnRole,
    DQLDMLClauseElement,
):
    

    __visit_name__ = "clauselist"

    
    
    _is_clause_list = True

    _traverse_internals: _TraverseInternalsType = [
        ("clauses", InternalTraversal.dp_clauseelement_list),
        ("operator", InternalTraversal.dp_operator),
    ]

    clauses: List[ColumnElement[Any]]

    def __init__(
        self,
        *clauses: _ColumnExpressionArgument[Any],
        operator: OperatorType = operators.comma_op,
        group: bool = True,
        group_contents: bool = True,
        _literal_as_text_role: Type[roles.SQLRole] = roles.WhereHavingRole,
    ):
        self.operator = operator
        self.group = group
        self.group_contents = group_contents
        clauses_iterator: Iterable[_ColumnExpressionArgument[Any]] = clauses
        text_converter_role: Type[roles.SQLRole] = _literal_as_text_role
        self._text_converter_role = text_converter_role

        if self.group_contents:
            self.clauses = [
                coercions.expect(
                    text_converter_role, clause, apply_propagate_attrs=self
                ).self_group(against=self.operator)
                for clause in clauses_iterator
            ]
        else:
            self.clauses = [
                coercions.expect(
                    text_converter_role, clause, apply_propagate_attrs=self
                )
                for clause in clauses_iterator
            ]
        self._is_implicitly_boolean = operators.is_boolean(self.operator)

    @classmethod
    def _construct_raw(
        cls,
        operator: OperatorType,
        clauses: Optional[Sequence[ColumnElement[Any]]] = None,
    ) -> ClauseList:
        self = cls.__new__(cls)
        self.clauses = list(clauses) if clauses else []
        self.group = True
        self.operator = operator
        self.group_contents = True
        self._is_implicitly_boolean = False
        return self

    def __iter__(self) -> Iterator[ColumnElement[Any]]:
        return iter(self.clauses)

    def __len__(self) -> int:
        return len(self.clauses)

    @property
    def _select_iterable(self) -> _SelectIterable:
        return itertools.chain.from_iterable(
            [elem._select_iterable for elem in self.clauses]
        )

    def append(self, clause):
        if self.group_contents:
            self.clauses.append(
                coercions.expect(self._text_converter_role, clause).self_group(
                    against=self.operator
                )
            )
        else:
            self.clauses.append(
                coercions.expect(self._text_converter_role, clause)
            )

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return list(itertools.chain(*[c._from_objects for c in self.clauses]))

    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> Union[Self, Grouping[Any]]:
        if self.group and operators.is_precedent(self.operator, against):
            return Grouping(self)
        else:
            return self


class OperatorExpression(ColumnElement[_T]):
    

    operator: OperatorType
    type: TypeEngine[_T]

    group: bool = True

    @property
    def is_comparison(self):
        return operators.is_comparison(self.operator)

    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> Union[Self, Grouping[_T]]:
        if (
            self.group
            and operators.is_precedent(self.operator, against)
            or (
                
                
                
                against is operators.inv
                and not operators.is_boolean(self.operator)
            )
        ):
            return Grouping(self)
        else:
            return self

    @property
    def _flattened_operator_clauses(
        self,
    ) -> typing_Tuple[ColumnElement[Any], ...]:
        raise NotImplementedError()

    @classmethod
    def _construct_for_op(
        cls,
        left: ColumnElement[Any],
        right: ColumnElement[Any],
        op: OperatorType,
        *,
        type_: TypeEngine[_T],
        negate: Optional[OperatorType] = None,
        modifiers: Optional[Mapping[str, Any]] = None,
    ) -> OperatorExpression[_T]:
        if operators.is_associative(op):
            assert (
                negate is None
            ), f"negate not supported for associative operator {op}"

            multi = False
            if getattr(
                left, "operator", None
            ) is op and type_._compare_type_affinity(left.type):
                multi = True
                left_flattened = left._flattened_operator_clauses
            else:
                left_flattened = (left,)

            if getattr(
                right, "operator", None
            ) is op and type_._compare_type_affinity(right.type):
                multi = True
                right_flattened = right._flattened_operator_clauses
            else:
                right_flattened = (right,)

            if multi:
                return ExpressionClauseList._construct_for_list(
                    op,
                    type_,
                    *(left_flattened + right_flattened),
                )

        if right._is_collection_aggregate:
            negate = None

        return BinaryExpression(
            left, right, op, type_=type_, negate=negate, modifiers=modifiers
        )


class ExpressionClauseList(OperatorExpression[_T]):
    

    __visit_name__ = "expression_clauselist"

    _traverse_internals: _TraverseInternalsType = [
        ("clauses", InternalTraversal.dp_clauseelement_tuple),
        ("operator", InternalTraversal.dp_operator),
    ]

    clauses: typing_Tuple[ColumnElement[Any], ...]

    group: bool

    def __init__(
        self,
        operator: OperatorType,
        *clauses: _ColumnExpressionArgument[Any],
        type_: Optional[_TypeEngineArgument[_T]] = None,
    ):
        self.operator = operator

        self.clauses = tuple(
            coercions.expect(
                roles.ExpressionElementRole, clause, apply_propagate_attrs=self
            )
            for clause in clauses
        )
        self._is_implicitly_boolean = operators.is_boolean(self.operator)
        self.type = type_api.to_instance(type_)  

    @property
    def _flattened_operator_clauses(
        self,
    ) -> typing_Tuple[ColumnElement[Any], ...]:
        return self.clauses

    def __iter__(self) -> Iterator[ColumnElement[Any]]:
        return iter(self.clauses)

    def __len__(self) -> int:
        return len(self.clauses)

    @property
    def _select_iterable(self) -> _SelectIterable:
        return (self,)

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return list(itertools.chain(*[c._from_objects for c in self.clauses]))

    def _append_inplace(self, clause: ColumnElement[Any]) -> None:
        self.clauses += (clause,)

    @classmethod
    def _construct_for_list(
        cls,
        operator: OperatorType,
        type_: TypeEngine[_T],
        *clauses: ColumnElement[Any],
        group: bool = True,
    ) -> ExpressionClauseList[_T]:
        self = cls.__new__(cls)
        self.group = group
        if group:
            self.clauses = tuple(
                c.self_group(against=operator) for c in clauses
            )
        else:
            self.clauses = clauses
        self.operator = operator
        self.type = type_
        for c in clauses:
            if c._propagate_attrs:
                self._propagate_attrs = c._propagate_attrs
                break
        return self

    def _negate(self) -> Any:
        grouped = self.self_group(against=operators.inv)
        assert isinstance(grouped, ColumnElement)
        return UnaryExpression(grouped, operator=operators.inv)


class BooleanClauseList(ExpressionClauseList[bool]):
    __visit_name__ = "expression_clauselist"
    inherit_cache = True

    def __init__(self, *arg, **kw):
        raise NotImplementedError(
            "BooleanClauseList has a private constructor"
        )

    @classmethod
    def _process_clauses_for_boolean(
        cls,
        operator: OperatorType,
        continue_on: Any,
        skip_on: Any,
        clauses: Iterable[ColumnElement[Any]],
    ) -> typing_Tuple[int, List[ColumnElement[Any]]]:
        has_continue_on = None

        convert_clauses = []

        against = operators._asbool
        lcc = 0

        for clause in clauses:
            if clause is continue_on:
                
                
                
                has_continue_on = clause
            elif clause is skip_on:
                
                
                convert_clauses = [clause]
                lcc = 1
                break
            else:
                if not lcc:
                    lcc = 1
                else:
                    against = operator
                    
                    
                    lcc = 2
                convert_clauses.append(clause)

        if not convert_clauses and has_continue_on is not None:
            convert_clauses = [has_continue_on]
            lcc = 1

        return lcc, [c.self_group(against=against) for c in convert_clauses]

    @classmethod
    def _construct(
        cls,
        operator: OperatorType,
        continue_on: Any,
        skip_on: Any,
        initial_clause: Any = _NoArg.NO_ARG,
        *clauses: Any,
        **kw: Any,
    ) -> ColumnElement[Any]:
        if initial_clause is _NoArg.NO_ARG:
            
            
            
            name = operator.__name__

            util.warn_deprecated(
                f"Invoking {name}() without arguments is deprecated, and "
                f"will be disallowed in a future release.   For an empty "
                f
                f,
                version="1.4",
            )
            return cls._construct_raw(operator)

        lcc, convert_clauses = cls._process_clauses_for_boolean(
            operator,
            continue_on,
            skip_on,
            [
                coercions.expect(roles.WhereHavingRole, clause)
                for clause in util.coerce_generator_arg(
                    (initial_clause,) + clauses
                )
            ],
        )

        if lcc > 1:
            
            

            flattened_clauses = itertools.chain.from_iterable(
                (
                    (c for c in to_flat._flattened_operator_clauses)
                    if getattr(to_flat, "operator", None) is operator
                    else (to_flat,)
                )
                for to_flat in convert_clauses
            )

            return cls._construct_raw(operator, flattened_clauses)  
        else:
            assert lcc
            
            
            return convert_clauses[0]

    @classmethod
    def _construct_for_whereclause(
        cls, clauses: Iterable[ColumnElement[Any]]
    ) -> Optional[ColumnElement[bool]]:
        operator, continue_on, skip_on = (
            operators.and_,
            True_._singleton,
            False_._singleton,
        )

        lcc, convert_clauses = cls._process_clauses_for_boolean(
            operator,
            continue_on,
            skip_on,
            clauses,  
        )

        if lcc > 1:
            
            
            return cls._construct_raw(operator, convert_clauses)
        elif lcc == 1:
            
            
            return convert_clauses[0]
        else:
            return None

    @classmethod
    def _construct_raw(
        cls,
        operator: OperatorType,
        clauses: Optional[Sequence[ColumnElement[Any]]] = None,
    ) -> BooleanClauseList:
        self = cls.__new__(cls)
        self.clauses = tuple(clauses) if clauses else ()
        self.group = True
        self.operator = operator
        self.type = type_api.BOOLEANTYPE
        self._is_implicitly_boolean = True
        return self

    @classmethod
    def and_(
        cls,
        initial_clause: Union[
            Literal[True], _ColumnExpressionArgument[bool], _NoArg
        ] = _NoArg.NO_ARG,
        *clauses: _ColumnExpressionArgument[bool],
    ) -> ColumnElement[bool]:
        r
        return cls._construct(
            operators.and_,
            True_._singleton,
            False_._singleton,
            initial_clause,
            *clauses,
        )

    @classmethod
    def or_(
        cls,
        initial_clause: Union[
            Literal[False], _ColumnExpressionArgument[bool], _NoArg
        ] = _NoArg.NO_ARG,
        *clauses: _ColumnExpressionArgument[bool],
    ) -> ColumnElement[bool]:
        
        return cls._construct(
            operators.or_,
            False_._singleton,
            True_._singleton,
            initial_clause,
            *clauses,
        )

    @property
    def _select_iterable(self) -> _SelectIterable:
        return (self,)

    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> Union[Self, Grouping[bool]]:
        if not self.clauses:
            return self
        else:
            return super().self_group(against=against)


and_ = BooleanClauseList.and_
or_ = BooleanClauseList.or_


class Tuple(ClauseList, ColumnElement[typing_Tuple[Any, ...]]):
    

    __visit_name__ = "tuple"

    _traverse_internals: _TraverseInternalsType = (
        ClauseList._traverse_internals + []
    )

    type: TupleType

    @util.preload_module("sqlalchemy.sql.sqltypes")
    def __init__(
        self,
        *clauses: _ColumnExpressionArgument[Any],
        types: Optional[Sequence[_TypeEngineArgument[Any]]] = None,
    ):
        sqltypes = util.preloaded.sql_sqltypes

        if types is None:
            init_clauses: List[ColumnElement[Any]] = [
                coercions.expect(roles.ExpressionElementRole, c)
                for c in clauses
            ]
        else:
            if len(types) != len(clauses):
                raise exc.ArgumentError(
                    "Wrong number of elements for %d-tuple: %r "
                    % (len(types), clauses)
                )
            init_clauses = [
                coercions.expect(
                    roles.ExpressionElementRole,
                    c,
                    type_=typ if not typ._isnull else None,
                )
                for typ, c in zip(types, clauses)
            ]

        self.type = sqltypes.TupleType(*[arg.type for arg in init_clauses])
        super().__init__(*init_clauses)

    @property
    def _select_iterable(self) -> _SelectIterable:
        return (self,)

    def _bind_param(self, operator, obj, type_=None, expanding=False):
        if expanding:
            return BindParameter(
                None,
                value=obj,
                _compared_to_operator=operator,
                unique=True,
                expanding=True,
                type_=type_,
                _compared_to_type=self.type,
            )
        else:
            return Tuple(
                *[
                    BindParameter(
                        None,
                        o,
                        _compared_to_operator=operator,
                        _compared_to_type=compared_to_type,
                        unique=True,
                        type_=type_,
                    )
                    for o, compared_to_type in zip(obj, self.type.types)
                ]
            )

    def self_group(self, against: Optional[OperatorType] = None) -> Self:
        
        return self


class Case(ColumnElement[_T]):
    

    __visit_name__ = "case"

    _traverse_internals: _TraverseInternalsType = [
        ("value", InternalTraversal.dp_clauseelement),
        ("whens", InternalTraversal.dp_clauseelement_tuples),
        ("else_", InternalTraversal.dp_clauseelement),
    ]

    
    

    whens: List[typing_Tuple[ColumnElement[bool], ColumnElement[_T]]]
    else_: Optional[ColumnElement[_T]]
    value: Optional[ColumnElement[Any]]

    def __init__(
        self,
        *whens: Union[
            typing_Tuple[_ColumnExpressionArgument[bool], Any],
            Mapping[Any, Any],
        ],
        value: Optional[Any] = None,
        else_: Optional[Any] = None,
    ):
        new_whens: Iterable[Any] = coercions._expression_collection_was_a_list(
            "whens", "case", whens
        )
        try:
            new_whens = util.dictlike_iteritems(new_whens)
        except TypeError:
            pass

        self.whens = [
            (
                coercions.expect(
                    roles.ExpressionElementRole,
                    c,
                    apply_propagate_attrs=self,
                ).self_group(),
                coercions.expect(roles.ExpressionElementRole, r),
            )
            for (c, r) in new_whens
        ]

        if value is None:
            self.value = None
        else:
            self.value = coercions.expect(roles.ExpressionElementRole, value)

        if else_ is not None:
            self.else_ = coercions.expect(roles.ExpressionElementRole, else_)
        else:
            self.else_ = None

        type_ = next(
            (
                then.type
                
                
                for *_, then in reversed(self.whens)
                if not then.type._isnull
            ),
            self.else_.type if self.else_ is not None else type_api.NULLTYPE,
        )
        self.type = cast(_T, type_)

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return list(
            itertools.chain(*[x._from_objects for x in self.get_children()])
        )


class Cast(WrapsColumnExpression[_T]):
    

    __visit_name__ = "cast"

    _traverse_internals: _TraverseInternalsType = [
        ("clause", InternalTraversal.dp_clauseelement),
        ("type", InternalTraversal.dp_type),
    ]

    clause: ColumnElement[Any]
    type: TypeEngine[_T]
    typeclause: TypeClause

    def __init__(
        self,
        expression: _ColumnExpressionArgument[Any],
        type_: _TypeEngineArgument[_T],
    ):
        self.type = type_api.to_instance(type_)
        self.clause = coercions.expect(
            roles.ExpressionElementRole,
            expression,
            type_=self.type,
            apply_propagate_attrs=self,
        )
        self.typeclause = TypeClause(self.type)

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return self.clause._from_objects

    @property
    def wrapped_column_expression(self):
        return self.clause


class TryCast(Cast[_T]):
    

    __visit_name__ = "try_cast"
    inherit_cache = True


class TypeCoerce(WrapsColumnExpression[_T]):
    

    __visit_name__ = "type_coerce"

    _traverse_internals: _TraverseInternalsType = [
        ("clause", InternalTraversal.dp_clauseelement),
        ("type", InternalTraversal.dp_type),
    ]

    clause: ColumnElement[Any]
    type: TypeEngine[_T]

    def __init__(
        self,
        expression: _ColumnExpressionArgument[Any],
        type_: _TypeEngineArgument[_T],
    ):
        self.type = type_api.to_instance(type_)
        self.clause = coercions.expect(
            roles.ExpressionElementRole,
            expression,
            type_=self.type,
            apply_propagate_attrs=self,
        )

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return self.clause._from_objects

    @HasMemoized.memoized_attribute
    def typed_expression(self):
        if isinstance(self.clause, BindParameter):
            bp = self.clause._clone()
            bp.type = self.type
            return bp
        else:
            return self.clause

    @property
    def wrapped_column_expression(self):
        return self.clause

    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> TypeCoerce[_T]:
        grouped = self.clause.self_group(against=against)
        if grouped is not self.clause:
            return TypeCoerce(grouped, self.type)
        else:
            return self


class Extract(ColumnElement[int]):
    

    __visit_name__ = "extract"

    _traverse_internals: _TraverseInternalsType = [
        ("expr", InternalTraversal.dp_clauseelement),
        ("field", InternalTraversal.dp_string),
    ]

    expr: ColumnElement[Any]
    field: str

    def __init__(self, field: str, expr: _ColumnExpressionArgument[Any]):
        self.type = type_api.INTEGERTYPE
        self.field = field
        self.expr = coercions.expect(roles.ExpressionElementRole, expr)

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return self.expr._from_objects


class _label_reference(ColumnElement[_T]):
    

    __visit_name__ = "label_reference"

    _traverse_internals: _TraverseInternalsType = [
        ("element", InternalTraversal.dp_clauseelement)
    ]

    element: ColumnElement[_T]

    def __init__(self, element: ColumnElement[_T]):
        self.element = element

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return []


class _textual_label_reference(ColumnElement[Any]):
    __visit_name__ = "textual_label_reference"

    _traverse_internals: _TraverseInternalsType = [
        ("element", InternalTraversal.dp_string)
    ]

    def __init__(self, element: str):
        self.element = element

    @util.memoized_property
    def _text_clause(self) -> TextClause:
        return TextClause(self.element)


class UnaryExpression(ColumnElement[_T]):
    

    __visit_name__ = "unary"

    _traverse_internals: _TraverseInternalsType = [
        ("element", InternalTraversal.dp_clauseelement),
        ("operator", InternalTraversal.dp_operator),
        ("modifier", InternalTraversal.dp_operator),
    ]

    element: ColumnElement[Any]
    operator: Optional[OperatorType]
    modifier: Optional[OperatorType]

    def __init__(
        self,
        element: ColumnElement[Any],
        *,
        operator: Optional[OperatorType] = None,
        modifier: Optional[OperatorType] = None,
        type_: Optional[_TypeEngineArgument[_T]] = None,
        wraps_column_expression: bool = False,  
    ):
        self.operator = operator
        self.modifier = modifier
        self._propagate_attrs = element._propagate_attrs
        self.element = element.self_group(
            against=self.operator or self.modifier
        )

        
        
        self.type = type_api.to_instance(type_)  

    def _wraps_unnamed_column(self):
        ungrouped = self.element._ungroup()
        return (
            not isinstance(ungrouped, NamedColumn)
            or ungrouped._non_anon_label is None
        )

    @classmethod
    def _create_nulls_first(
        cls,
        column: _ColumnExpressionArgument[_T],
    ) -> UnaryExpression[_T]:
        return UnaryExpression(
            coercions.expect(roles.ByOfRole, column),
            modifier=operators.nulls_first_op,
        )

    @classmethod
    def _create_nulls_last(
        cls,
        column: _ColumnExpressionArgument[_T],
    ) -> UnaryExpression[_T]:
        return UnaryExpression(
            coercions.expect(roles.ByOfRole, column),
            modifier=operators.nulls_last_op,
        )

    @classmethod
    def _create_desc(
        cls, column: _ColumnExpressionOrStrLabelArgument[_T]
    ) -> UnaryExpression[_T]:
        return UnaryExpression(
            coercions.expect(roles.ByOfRole, column),
            modifier=operators.desc_op,
        )

    @classmethod
    def _create_asc(
        cls,
        column: _ColumnExpressionOrStrLabelArgument[_T],
    ) -> UnaryExpression[_T]:
        return UnaryExpression(
            coercions.expect(roles.ByOfRole, column),
            modifier=operators.asc_op,
        )

    @classmethod
    def _create_distinct(
        cls,
        expr: _ColumnExpressionArgument[_T],
    ) -> UnaryExpression[_T]:
        col_expr: ColumnElement[_T] = coercions.expect(
            roles.ExpressionElementRole, expr
        )
        return UnaryExpression(
            col_expr,
            operator=operators.distinct_op,
            type_=col_expr.type,
        )

    @classmethod
    def _create_bitwise_not(
        cls,
        expr: _ColumnExpressionArgument[_T],
    ) -> UnaryExpression[_T]:
        col_expr: ColumnElement[_T] = coercions.expect(
            roles.ExpressionElementRole, expr
        )
        return UnaryExpression(
            col_expr,
            operator=operators.bitwise_not_op,
            type_=col_expr.type,
        )

    @property
    def _order_by_label_element(self) -> Optional[Label[Any]]:
        if operators.is_order_by_modifier(self.modifier):
            return self.element._order_by_label_element
        else:
            return None

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return self.element._from_objects

    def _negate(self) -> ColumnElement[Any]:
        if self.type._type_affinity is type_api.BOOLEANTYPE._type_affinity:
            return UnaryExpression(
                self.self_group(against=operators.inv),
                operator=operators.inv,
                type_=type_api.BOOLEANTYPE,
            )
        else:
            return ColumnElement._negate(self)

    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> Union[Self, Grouping[_T]]:
        if self.operator and operators.is_precedent(self.operator, against):
            return Grouping(self)
        else:
            return self


class CollectionAggregate(UnaryExpression[_T]):
    

    inherit_cache = True
    _is_collection_aggregate = True

    @classmethod
    def _create_any(
        cls, expr: _ColumnExpressionArgument[_T]
    ) -> CollectionAggregate[bool]:
        col_expr: ColumnElement[_T] = coercions.expect(
            roles.ExpressionElementRole,
            expr,
        )
        col_expr = col_expr.self_group()
        return CollectionAggregate(
            col_expr,
            operator=operators.any_op,
            type_=type_api.BOOLEANTYPE,
        )

    @classmethod
    def _create_all(
        cls, expr: _ColumnExpressionArgument[_T]
    ) -> CollectionAggregate[bool]:
        col_expr: ColumnElement[_T] = coercions.expect(
            roles.ExpressionElementRole,
            expr,
        )
        col_expr = col_expr.self_group()
        return CollectionAggregate(
            col_expr,
            operator=operators.all_op,
            type_=type_api.BOOLEANTYPE,
        )

    
    
    
    def operate(
        self, op: OperatorType, *other: Any, **kwargs: Any
    ) -> ColumnElement[_T]:
        if not operators.is_comparison(op):
            raise exc.ArgumentError(
                "Only comparison operators may be used with ANY/ALL"
            )
        kwargs["reverse"] = True
        return self.comparator.operate(operators.mirror(op), *other, **kwargs)

    def reverse_operate(
        self, op: OperatorType, other: Any, **kwargs: Any
    ) -> ColumnElement[_T]:
        
        assert not operators.is_comparison(op)
        raise exc.ArgumentError(
            "Only comparison operators may be used with ANY/ALL"
        )


class AsBoolean(WrapsColumnExpression[bool], UnaryExpression[bool]):
    inherit_cache = True

    def __init__(self, element, operator, negate):
        self.element = element
        self.type = type_api.BOOLEANTYPE
        self.operator = operator
        self.negate = negate
        self.modifier = None
        self._is_implicitly_boolean = element._is_implicitly_boolean

    @property
    def wrapped_column_expression(self):
        return self.element

    def self_group(self, against: Optional[OperatorType] = None) -> Self:
        return self

    def _negate(self):
        if isinstance(self.element, (True_, False_)):
            return self.element._negate()
        else:
            return AsBoolean(self.element, self.negate, self.operator)


class BinaryExpression(OperatorExpression[_T]):
    

    __visit_name__ = "binary"

    _traverse_internals: _TraverseInternalsType = [
        ("left", InternalTraversal.dp_clauseelement),
        ("right", InternalTraversal.dp_clauseelement),
        ("operator", InternalTraversal.dp_operator),
        ("negate", InternalTraversal.dp_operator),
        ("modifiers", InternalTraversal.dp_plain_dict),
        (
            "type",
            InternalTraversal.dp_type,
        ),
    ]

    _cache_key_traversal = [
        ("left", InternalTraversal.dp_clauseelement),
        ("right", InternalTraversal.dp_clauseelement),
        ("operator", InternalTraversal.dp_operator),
        ("modifiers", InternalTraversal.dp_plain_dict),
        
        
        (
            "type",
            InternalTraversal.dp_type,
        ),
    ]

    _is_implicitly_boolean = True
    

    left: ColumnElement[Any]
    right: ColumnElement[Any]
    modifiers: Mapping[str, Any]

    def __init__(
        self,
        left: ColumnElement[Any],
        right: ColumnElement[Any],
        operator: OperatorType,
        type_: Optional[_TypeEngineArgument[_T]] = None,
        negate: Optional[OperatorType] = None,
        modifiers: Optional[Mapping[str, Any]] = None,
    ):
        
        
        if isinstance(operator, str):
            operator = operators.custom_op(operator)
        self._orig = (left.__hash__(), right.__hash__())
        self._propagate_attrs = left._propagate_attrs or right._propagate_attrs
        self.left = left.self_group(against=operator)
        self.right = right.self_group(against=operator)
        self.operator = operator

        
        
        self.type = type_api.to_instance(type_)  

        self.negate = negate
        self._is_implicitly_boolean = operators.is_boolean(operator)

        if modifiers is None:
            self.modifiers = {}
        else:
            self.modifiers = modifiers

    @property
    def _flattened_operator_clauses(
        self,
    ) -> typing_Tuple[ColumnElement[Any], ...]:
        return (self.left, self.right)

    def __bool__(self):
        
        if self.operator in (operators.eq, operators.ne):
            
            
            
            return self.operator(*self._orig)  
        else:
            raise TypeError("Boolean value of this clause is not defined")

    if typing.TYPE_CHECKING:

        def __invert__(
            self: BinaryExpression[_T],
        ) -> BinaryExpression[_T]: ...

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return self.left._from_objects + self.right._from_objects

    def _negate(self):
        if self.negate is not None:
            return BinaryExpression(
                self.left,
                self.right._negate_in_binary(self.negate, self.operator),
                self.negate,
                negate=self.operator,
                type_=self.type,
                modifiers=self.modifiers,
            )
        else:
            return self.self_group()._negate()


class Slice(ColumnElement[Any]):
    

    __visit_name__ = "slice"

    _traverse_internals: _TraverseInternalsType = [
        ("start", InternalTraversal.dp_clauseelement),
        ("stop", InternalTraversal.dp_clauseelement),
        ("step", InternalTraversal.dp_clauseelement),
    ]

    def __init__(self, start, stop, step, _name=None):
        self.start = coercions.expect(
            roles.ExpressionElementRole,
            start,
            name=_name,
            type_=type_api.INTEGERTYPE,
        )
        self.stop = coercions.expect(
            roles.ExpressionElementRole,
            stop,
            name=_name,
            type_=type_api.INTEGERTYPE,
        )
        self.step = coercions.expect(
            roles.ExpressionElementRole,
            step,
            name=_name,
            type_=type_api.INTEGERTYPE,
        )
        self.type = type_api.NULLTYPE

    def self_group(self, against: Optional[OperatorType] = None) -> Self:
        assert against is operator.getitem
        return self


class IndexExpression(BinaryExpression[Any]):
    

    inherit_cache = True


class GroupedElement(DQLDMLClauseElement):
    

    __visit_name__ = "grouping"

    def self_group(self, against: Optional[OperatorType] = None) -> Self:
        return self

    def _ungroup(self) -> ClauseElement:
        raise NotImplementedError()


class Grouping(GroupedElement, ColumnElement[_T]):
    

    _traverse_internals: _TraverseInternalsType = [
        ("element", InternalTraversal.dp_clauseelement),
        ("type", InternalTraversal.dp_type),
    ]

    _cache_key_traversal = [
        ("element", InternalTraversal.dp_clauseelement),
    ]

    element: Union[TextClause, ClauseList, ColumnElement[_T]]

    def __init__(
        self, element: Union[TextClause, ClauseList, ColumnElement[_T]]
    ):
        self.element = element

        
        self.type = getattr(element, "type", type_api.NULLTYPE)  
        self._propagate_attrs = element._propagate_attrs

    def _with_binary_element_type(self, type_):
        return self.__class__(self.element._with_binary_element_type(type_))

    def _ungroup(self) -> ColumnElement[_T]:
        assert isinstance(self.element, ColumnElement)
        return self.element._ungroup()

    @util.memoized_property
    def _is_implicitly_boolean(self):
        return self.element._is_implicitly_boolean

    @util.non_memoized_property
    def _tq_label(self) -> Optional[str]:
        return (
            getattr(self.element, "_tq_label", None) or self._anon_name_label
        )

    @util.non_memoized_property
    def _proxies(self) -> List[ColumnElement[Any]]:
        if isinstance(self.element, ColumnElement):
            return [self.element]
        else:
            return []

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return self.element._from_objects

    def __getattr__(self, attr):
        return getattr(self.element, attr)

    def __getstate__(self):
        return {"element": self.element, "type": self.type}

    def __setstate__(self, state):
        self.element = state["element"]
        self.type = state["type"]

    if TYPE_CHECKING:

        def self_group(
            self, against: Optional[OperatorType] = None
        ) -> Self: ...


class _OverrideBinds(Grouping[_T]):
    

    __visit_name__ = "override_binds"

    def __init__(
        self,
        element: ColumnElement[_T],
        bindparams: Sequence[BindParameter[Any]],
        replaces_params: Sequence[BindParameter[Any]],
    ):
        self.element = element
        self.translate = {
            k.key: v.value for k, v in zip(replaces_params, bindparams)
        }

    def _gen_cache_key(
        self, anon_map: anon_map, bindparams: List[BindParameter[Any]]
    ) -> Optional[typing_Tuple[Any, ...]]:
        

        existing_bps: List[BindParameter[Any]] = []
        ck = self.element._gen_cache_key(anon_map, existing_bps)

        bindparams.extend(
            (
                bp._with_value(
                    self.translate[bp.key], maintain_key=True, required=False
                )
                if bp.key in self.translate
                else bp
            )
            for bp in existing_bps
        )

        return ck


class _OverRange(Enum):
    RANGE_UNBOUNDED = 0
    RANGE_CURRENT = 1


RANGE_UNBOUNDED = _OverRange.RANGE_UNBOUNDED
RANGE_CURRENT = _OverRange.RANGE_CURRENT

_IntOrRange = Union[int, _OverRange]


class Over(ColumnElement[_T]):
    

    __visit_name__ = "over"

    _traverse_internals: _TraverseInternalsType = [
        ("element", InternalTraversal.dp_clauseelement),
        ("order_by", InternalTraversal.dp_clauseelement),
        ("partition_by", InternalTraversal.dp_clauseelement),
        ("range_", InternalTraversal.dp_plain_obj),
        ("rows", InternalTraversal.dp_plain_obj),
        ("groups", InternalTraversal.dp_plain_obj),
    ]

    order_by: Optional[ClauseList] = None
    partition_by: Optional[ClauseList] = None

    element: ColumnElement[_T]
    

    range_: Optional[typing_Tuple[_IntOrRange, _IntOrRange]]
    rows: Optional[typing_Tuple[_IntOrRange, _IntOrRange]]
    groups: Optional[typing_Tuple[_IntOrRange, _IntOrRange]]

    def __init__(
        self,
        element: ColumnElement[_T],
        partition_by: Optional[_ByArgument] = None,
        order_by: Optional[_ByArgument] = None,
        range_: Optional[typing_Tuple[Optional[int], Optional[int]]] = None,
        rows: Optional[typing_Tuple[Optional[int], Optional[int]]] = None,
        groups: Optional[typing_Tuple[Optional[int], Optional[int]]] = None,
    ):
        self.element = element
        if order_by is not None:
            self.order_by = ClauseList(
                *util.to_list(order_by), _literal_as_text_role=roles.ByOfRole
            )
        if partition_by is not None:
            self.partition_by = ClauseList(
                *util.to_list(partition_by),
                _literal_as_text_role=roles.ByOfRole,
            )

        if sum(bool(item) for item in (range_, rows, groups)) > 1:
            raise exc.ArgumentError(
                "only one of 'rows', 'range_', or 'groups' may be provided"
            )
        else:
            self.range_ = self._interpret_range(range_) if range_ else None
            self.rows = self._interpret_range(rows) if rows else None
            self.groups = self._interpret_range(groups) if groups else None

    def __reduce__(self):
        return self.__class__, (
            self.element,
            self.partition_by,
            self.order_by,
            self.range_,
            self.rows,
            self.groups,
        )

    def _interpret_range(
        self,
        range_: typing_Tuple[Optional[_IntOrRange], Optional[_IntOrRange]],
    ) -> typing_Tuple[_IntOrRange, _IntOrRange]:
        if not isinstance(range_, tuple) or len(range_) != 2:
            raise exc.ArgumentError("2-tuple expected for range/rows")

        r0, r1 = range_

        lower: _IntOrRange
        upper: _IntOrRange

        if r0 is None:
            lower = RANGE_UNBOUNDED
        elif isinstance(r0, _OverRange):
            lower = r0
        else:
            try:
                lower = int(r0)
            except ValueError as err:
                raise exc.ArgumentError(
                    "Integer or None expected for range value"
                ) from err
            else:
                if lower == 0:
                    lower = RANGE_CURRENT

        if r1 is None:
            upper = RANGE_UNBOUNDED
        elif isinstance(r1, _OverRange):
            upper = r1
        else:
            try:
                upper = int(r1)
            except ValueError as err:
                raise exc.ArgumentError(
                    "Integer or None expected for range value"
                ) from err
            else:
                if upper == 0:
                    upper = RANGE_CURRENT

        return lower, upper

    if not TYPE_CHECKING:

        @util.memoized_property
        def type(self) -> TypeEngine[_T]:  
            return self.element.type

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return list(
            itertools.chain(
                *[
                    c._from_objects
                    for c in (self.element, self.partition_by, self.order_by)
                    if c is not None
                ]
            )
        )


class WithinGroup(ColumnElement[_T]):
    

    __visit_name__ = "withingroup"

    _traverse_internals: _TraverseInternalsType = [
        ("element", InternalTraversal.dp_clauseelement),
        ("order_by", InternalTraversal.dp_clauseelement),
    ]

    order_by: Optional[ClauseList] = None

    def __init__(
        self,
        element: Union[FunctionElement[_T], FunctionFilter[_T]],
        *order_by: _ColumnExpressionArgument[Any],
    ):
        self.element = element
        if order_by is not None:
            self.order_by = ClauseList(
                *util.to_list(order_by), _literal_as_text_role=roles.ByOfRole
            )

    def __reduce__(self):
        return self.__class__, (self.element,) + (
            tuple(self.order_by) if self.order_by is not None else ()
        )

    def over(
        self,
        *,
        partition_by: Optional[_ByArgument] = None,
        order_by: Optional[_ByArgument] = None,
        rows: Optional[typing_Tuple[Optional[int], Optional[int]]] = None,
        range_: Optional[typing_Tuple[Optional[int], Optional[int]]] = None,
        groups: Optional[typing_Tuple[Optional[int], Optional[int]]] = None,
    ) -> Over[_T]:
        
        return Over(
            self,
            partition_by=partition_by,
            order_by=order_by,
            range_=range_,
            rows=rows,
            groups=groups,
        )

    @overload
    def filter(self) -> Self: ...

    @overload
    def filter(
        self,
        __criterion0: _ColumnExpressionArgument[bool],
        *criterion: _ColumnExpressionArgument[bool],
    ) -> FunctionFilter[_T]: ...

    def filter(
        self, *criterion: _ColumnExpressionArgument[bool]
    ) -> Union[Self, FunctionFilter[_T]]:
        
        if not criterion:
            return self
        return FunctionFilter(self, *criterion)

    if not TYPE_CHECKING:

        @util.memoized_property
        def type(self) -> TypeEngine[_T]:  
            wgt = self.element.within_group_type(self)
            if wgt is not None:
                return wgt
            else:
                return self.element.type

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return list(
            itertools.chain(
                *[
                    c._from_objects
                    for c in (self.element, self.order_by)
                    if c is not None
                ]
            )
        )


class FunctionFilter(Generative, ColumnElement[_T]):
    

    __visit_name__ = "funcfilter"

    _traverse_internals: _TraverseInternalsType = [
        ("func", InternalTraversal.dp_clauseelement),
        ("criterion", InternalTraversal.dp_clauseelement),
    ]

    criterion: Optional[ColumnElement[bool]] = None

    def __init__(
        self,
        func: Union[FunctionElement[_T], WithinGroup[_T]],
        *criterion: _ColumnExpressionArgument[bool],
    ):
        self.func = func
        self.filter.non_generative(self, *criterion)  

    @_generative
    def filter(self, *criterion: _ColumnExpressionArgument[bool]) -> Self:
        

        for crit in list(criterion):
            crit = coercions.expect(roles.WhereHavingRole, crit)

            if self.criterion is not None:
                self.criterion = self.criterion & crit
            else:
                self.criterion = crit

        return self

    def over(
        self,
        partition_by: Optional[
            Union[
                Iterable[_ColumnExpressionArgument[Any]],
                _ColumnExpressionArgument[Any],
            ]
        ] = None,
        order_by: Optional[
            Union[
                Iterable[_ColumnExpressionArgument[Any]],
                _ColumnExpressionArgument[Any],
            ]
        ] = None,
        range_: Optional[typing_Tuple[Optional[int], Optional[int]]] = None,
        rows: Optional[typing_Tuple[Optional[int], Optional[int]]] = None,
        groups: Optional[typing_Tuple[Optional[int], Optional[int]]] = None,
    ) -> Over[_T]:
        
        return Over(
            self,
            partition_by=partition_by,
            order_by=order_by,
            range_=range_,
            rows=rows,
            groups=groups,
        )

    def within_group(
        self, *order_by: _ColumnExpressionArgument[Any]
    ) -> WithinGroup[_T]:
        
        return WithinGroup(self, *order_by)

    def within_group_type(
        self, within_group: WithinGroup[_T]
    ) -> Optional[TypeEngine[_T]]:
        return None

    def self_group(
        self, against: Optional[OperatorType] = None
    ) -> Union[Self, Grouping[_T]]:
        if operators.is_precedent(operators.filter_op, against):
            return Grouping(self)
        else:
            return self

    if not TYPE_CHECKING:

        @util.memoized_property
        def type(self) -> TypeEngine[_T]:  
            return self.func.type

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return list(
            itertools.chain(
                *[
                    c._from_objects
                    for c in (self.func, self.criterion)
                    if c is not None
                ]
            )
        )


class NamedColumn(KeyedColumnElement[_T]):
    is_literal = False
    table: Optional[FromClause] = None
    name: str
    key: str

    def _compare_name_for_result(self, other):
        return (hasattr(other, "name") and self.name == other.name) or (
            hasattr(other, "_label") and self._label == other._label
        )

    @util.ro_memoized_property
    def description(self) -> str:
        return self.name

    @HasMemoized.memoized_attribute
    def _tq_key_label(self) -> Optional[str]:
        
        proxy_key = self._proxy_key
        if proxy_key and proxy_key != self.name:
            return self._gen_tq_label(proxy_key)
        else:
            return self._tq_label

    @HasMemoized.memoized_attribute
    def _tq_label(self) -> Optional[str]:
        
        return self._gen_tq_label(self.name)

    @HasMemoized.memoized_attribute
    def _render_label_in_columns_clause(self):
        return True

    @HasMemoized.memoized_attribute
    def _non_anon_label(self):
        return self.name

    def _gen_tq_label(
        self, name: str, dedupe_on_key: bool = True
    ) -> Optional[str]:
        return name

    def _bind_param(
        self,
        operator: OperatorType,
        obj: Any,
        type_: Optional[TypeEngine[_T]] = None,
        expanding: bool = False,
    ) -> BindParameter[_T]:
        return BindParameter(
            self.key,
            obj,
            _compared_to_operator=operator,
            _compared_to_type=self.type,
            type_=type_,
            unique=True,
            expanding=expanding,
        )

    def _make_proxy(
        self,
        selectable: FromClause,
        *,
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
        name: Optional[str] = None,
        key: Optional[str] = None,
        name_is_truncatable: bool = False,
        compound_select_cols: Optional[Sequence[ColumnElement[Any]]] = None,
        disallow_is_literal: bool = False,
        **kw: Any,
    ) -> typing_Tuple[str, ColumnClause[_T]]:
        c = ColumnClause(
            (
                coercions.expect(roles.TruncatedLabelRole, name or self.name)
                if name_is_truncatable
                else (name or self.name)
            ),
            type_=self.type,
            _selectable=selectable,
            is_literal=False,
        )

        c._propagate_attrs = selectable._propagate_attrs
        if name is None:
            c.key = self.key
        if compound_select_cols:
            c._proxies = list(compound_select_cols)
        else:
            c._proxies = [self]

        if selectable._is_clone_of is not None:
            c._is_clone_of = selectable._is_clone_of.columns.get(c.key)
        return c.key, c


_PS = ParamSpec("_PS")


class Label(roles.LabeledColumnExprRole[_T], NamedColumn[_T]):
    

    __visit_name__ = "label"

    _traverse_internals: _TraverseInternalsType = [
        ("name", InternalTraversal.dp_anon_name),
        ("type", InternalTraversal.dp_type),
        ("_element", InternalTraversal.dp_clauseelement),
    ]

    _cache_key_traversal = [
        ("name", InternalTraversal.dp_anon_name),
        ("_element", InternalTraversal.dp_clauseelement),
    ]

    _element: ColumnElement[_T]
    name: str

    def __init__(
        self,
        name: Optional[str],
        element: _ColumnExpressionArgument[_T],
        type_: Optional[_TypeEngineArgument[_T]] = None,
    ):
        orig_element = element
        element = coercions.expect(
            roles.ExpressionElementRole,
            element,
            apply_propagate_attrs=self,
        )
        while isinstance(element, Label):
            
            
            element = element.element

        if name:
            self.name = name
        else:
            self.name = _anonymous_label.safe_construct(
                id(self), getattr(element, "name", "anon")
            )
            if isinstance(orig_element, Label):
                
                
                self._resolve_label = orig_element._label

        self.key = self._tq_label = self._tq_key_label = self.name
        self._element = element

        self.type = (
            type_api.to_instance(type_)
            if type_ is not None
            else self._element.type
        )

        self._proxies = [element]

    def __reduce__(self):
        return self.__class__, (self.name, self._element, self.type)

    @HasMemoized.memoized_attribute
    def _render_label_in_columns_clause(self):
        return True

    def _bind_param(self, operator, obj, type_=None, expanding=False):
        return BindParameter(
            None,
            obj,
            _compared_to_operator=operator,
            type_=type_,
            _compared_to_type=self.type,
            unique=True,
            expanding=expanding,
        )

    @util.memoized_property
    def _is_implicitly_boolean(self):
        return self.element._is_implicitly_boolean

    @HasMemoized.memoized_attribute
    def _allow_label_resolve(self):
        return self.element._allow_label_resolve

    @property
    def _order_by_label_element(self):
        return self

    @HasMemoized.memoized_attribute
    def element(self) -> ColumnElement[_T]:
        return self._element.self_group(against=operators.as_)

    def self_group(self, against: Optional[OperatorType] = None) -> Label[_T]:
        return self._apply_to_inner(self._element.self_group, against=against)

    def _negate(self):
        return self._apply_to_inner(self._element._negate)

    def _apply_to_inner(
        self,
        fn: Callable[_PS, ColumnElement[_T]],
        *arg: _PS.args,
        **kw: _PS.kwargs,
    ) -> Label[_T]:
        sub_element = fn(*arg, **kw)
        if sub_element is not self._element:
            return Label(self.name, sub_element, type_=self.type)
        else:
            return self

    @property
    def primary_key(self):  
        return self.element.primary_key

    @property
    def foreign_keys(self):  
        return self.element.foreign_keys

    def _copy_internals(
        self,
        *,
        clone: _CloneCallableType = _clone,
        anonymize_labels: bool = False,
        **kw: Any,
    ) -> None:
        self._reset_memoizations()
        self._element = clone(self._element, **kw)
        if anonymize_labels:
            self.name = _anonymous_label.safe_construct(
                id(self), getattr(self.element, "name", "anon")
            )
            self.key = self._tq_label = self._tq_key_label = self.name

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return self.element._from_objects

    def _make_proxy(
        self,
        selectable: FromClause,
        *,
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
        name: Optional[str] = None,
        compound_select_cols: Optional[Sequence[ColumnElement[Any]]] = None,
        **kw: Any,
    ) -> typing_Tuple[str, ColumnClause[_T]]:
        name = self.name if not name else name

        key, e = self.element._make_proxy(
            selectable,
            name=name,
            disallow_is_literal=True,
            name_is_truncatable=isinstance(name, _truncated_label),
            compound_select_cols=compound_select_cols,
            primary_key=primary_key,
            foreign_keys=foreign_keys,
        )

        
        
        
        
        
        
        
        if key != self.name and not isinstance(self.name, _anonymous_label):
            raise exc.InvalidRequestError(
                "Label name %s is being renamed to an anonymous label due "
                "to disambiguation "
                "which is not supported right now.  Please use unique names "
                "for explicit labels." % (self.name)
            )

        e._propagate_attrs = selectable._propagate_attrs
        e._proxies.append(self)
        if self.type is not None:
            e.type = self.type

        return self.key, e


class ColumnClause(
    roles.DDLReferredColumnRole,
    roles.LabeledColumnExprRole[_T],
    roles.StrAsPlainColumnRole,
    Immutable,
    NamedColumn[_T],
):
    

    table: Optional[FromClause]
    is_literal: bool

    __visit_name__ = "column"

    _traverse_internals: _TraverseInternalsType = [
        ("name", InternalTraversal.dp_anon_name),
        ("type", InternalTraversal.dp_type),
        ("table", InternalTraversal.dp_clauseelement),
        ("is_literal", InternalTraversal.dp_boolean),
    ]

    onupdate: Optional[DefaultGenerator] = None
    default: Optional[DefaultGenerator] = None
    server_default: Optional[FetchedValue] = None
    server_onupdate: Optional[FetchedValue] = None

    _is_multiparam_column = False

    @property
    def _is_star(self):  
        return self.is_literal and self.name == "*"

    def __init__(
        self,
        text: str,
        type_: Optional[_TypeEngineArgument[_T]] = None,
        is_literal: bool = False,
        _selectable: Optional[FromClause] = None,
    ):
        self.key = self.name = text
        self.table = _selectable

        
        
        self.type = type_api.to_instance(type_)  

        self.is_literal = is_literal

    def get_children(self, *, column_tables=False, **kw):
        
        
        
        return []

    @property
    def entity_namespace(self):
        if self.table is not None:
            return self.table.entity_namespace
        else:
            return super().entity_namespace

    def _clone(self, detect_subquery_cols=False, **kw):
        if (
            detect_subquery_cols
            and self.table is not None
            and self.table._is_subquery
        ):
            clone = kw.pop("clone")
            table = clone(self.table, **kw)
            new = table.c.corresponding_column(self)
            return new

        return super()._clone(**kw)

    @HasMemoized_ro_memoized_attribute
    def _from_objects(self) -> List[FromClause]:
        t = self.table
        if t is not None:
            return [t]
        else:
            return []

    @HasMemoized.memoized_attribute
    def _render_label_in_columns_clause(self):
        return self.table is not None

    @property
    def _ddl_label(self):
        return self._gen_tq_label(self.name, dedupe_on_key=False)

    def _compare_name_for_result(self, other):
        if (
            self.is_literal
            or self.table is None
            or self.table._is_textual
            or not hasattr(other, "proxy_set")
            or (
                isinstance(other, ColumnClause)
                and (
                    other.is_literal
                    or other.table is None
                    or other.table._is_textual
                )
            )
        ):
            return (hasattr(other, "name") and self.name == other.name) or (
                hasattr(other, "_tq_label")
                and self._tq_label == other._tq_label
            )
        else:
            return other.proxy_set.intersection(self.proxy_set)

    def _gen_tq_label(
        self, name: str, dedupe_on_key: bool = True
    ) -> Optional[str]:
        
        label: str
        t = self.table
        if self.is_literal:
            return None
        elif t is not None and is_named_from_clause(t):
            if has_schema_attr(t) and t.schema:
                label = t.schema.replace(".", "_") + "_" + t.name + "_" + name
            else:
                assert not TYPE_CHECKING or isinstance(t, NamedFromClause)
                label = t.name + "_" + name

            
            if is_quoted_name(name) and name.quote is not None:
                if is_quoted_name(label):
                    label.quote = name.quote
                else:
                    label = quoted_name(label, name.quote)
            elif is_quoted_name(t.name) and t.name.quote is not None:
                
                
                assert not isinstance(label, quoted_name)
                label = quoted_name(label, t.name.quote)

            if dedupe_on_key:
                
                
                
                
                
                
                
                
                if label in t.c:
                    _label = label
                    counter = 1
                    while _label in t.c:
                        _label = label + "_" + str(counter)
                        counter += 1
                    label = _label

            return coercions.expect(roles.TruncatedLabelRole, label)

        else:
            return name

    def _make_proxy(
        self,
        selectable: FromClause,
        *,
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
        name: Optional[str] = None,
        key: Optional[str] = None,
        name_is_truncatable: bool = False,
        compound_select_cols: Optional[Sequence[ColumnElement[Any]]] = None,
        disallow_is_literal: bool = False,
        **kw: Any,
    ) -> typing_Tuple[str, ColumnClause[_T]]:
        
        
        
        
        
        
        is_literal = (
            not disallow_is_literal
            and self.is_literal
            and (
                
                
                name is None
                or name == self.name
            )
        )
        c = self._constructor(
            (
                coercions.expect(roles.TruncatedLabelRole, name or self.name)
                if name_is_truncatable
                else (name or self.name)
            ),
            type_=self.type,
            _selectable=selectable,
            is_literal=is_literal,
        )
        c._propagate_attrs = selectable._propagate_attrs
        if name is None:
            c.key = self.key
        if compound_select_cols:
            c._proxies = list(compound_select_cols)
        else:
            c._proxies = [self]

        if selectable._is_clone_of is not None:
            c._is_clone_of = selectable._is_clone_of.columns.get(c.key)
        return c.key, c


class TableValuedColumn(NamedColumn[_T]):
    __visit_name__ = "table_valued_column"

    _traverse_internals: _TraverseInternalsType = [
        ("name", InternalTraversal.dp_anon_name),
        ("type", InternalTraversal.dp_type),
        ("scalar_alias", InternalTraversal.dp_clauseelement),
    ]

    def __init__(self, scalar_alias: NamedFromClause, type_: TypeEngine[_T]):
        self.scalar_alias = scalar_alias
        self.key = self.name = scalar_alias.name
        self.type = type_

    def _copy_internals(
        self, clone: _CloneCallableType = _clone, **kw: Any
    ) -> None:
        self.scalar_alias = clone(self.scalar_alias, **kw)
        self.key = self.name = self.scalar_alias.name

    @util.ro_non_memoized_property
    def _from_objects(self) -> List[FromClause]:
        return [self.scalar_alias]


class CollationClause(ColumnElement[str]):
    __visit_name__ = "collation"

    _traverse_internals: _TraverseInternalsType = [
        ("collation", InternalTraversal.dp_string)
    ]

    @classmethod
    @util.preload_module("sqlalchemy.sql.sqltypes")
    def _create_collation_expression(
        cls, expression: _ColumnExpressionArgument[str], collation: str
    ) -> BinaryExpression[str]:

        sqltypes = util.preloaded.sql_sqltypes

        expr = coercions.expect(roles.ExpressionElementRole[str], expression)

        if expr.type._type_affinity is sqltypes.String:
            collate_type = expr.type._with_collation(collation)
        else:
            collate_type = expr.type

        return BinaryExpression(
            expr,
            CollationClause(collation),
            operators.collate,
            type_=collate_type,
        )

    def __init__(self, collation):
        self.collation = collation


class _IdentifiedClause(Executable, ClauseElement):
    __visit_name__ = "identified"

    def __init__(self, ident):
        self.ident = ident


class SavepointClause(_IdentifiedClause):
    __visit_name__ = "savepoint"
    inherit_cache = False


class RollbackToSavepointClause(_IdentifiedClause):
    __visit_name__ = "rollback_to_savepoint"
    inherit_cache = False


class ReleaseSavepointClause(_IdentifiedClause):
    __visit_name__ = "release_savepoint"
    inherit_cache = False


class quoted_name(util.MemoizedSlots, str):
    

    __slots__ = "quote", "lower", "upper"

    quote: Optional[bool]

    @overload
    @classmethod
    def construct(cls, value: str, quote: Optional[bool]) -> quoted_name: ...

    @overload
    @classmethod
    def construct(cls, value: None, quote: Optional[bool]) -> None: ...

    @classmethod
    def construct(
        cls, value: Optional[str], quote: Optional[bool]
    ) -> Optional[quoted_name]:
        if value is None:
            return None
        else:
            return quoted_name(value, quote)

    def __new__(cls, value: str, quote: Optional[bool]) -> quoted_name:
        assert (
            value is not None
        ), "use quoted_name.construct() for None passthrough"
        if isinstance(value, cls) and (quote is None or value.quote == quote):
            return value
        self = super().__new__(cls, value)

        self.quote = quote
        return self

    def __reduce__(self):
        return quoted_name, (str(self), self.quote)

    def _memoized_method_lower(self):
        if self.quote:
            return self
        else:
            return str(self).lower()

    def _memoized_method_upper(self):
        if self.quote:
            return self
        else:
            return str(self).upper()


def _find_columns(clause: ClauseElement) -> Set[ColumnClause[Any]]:
    

    cols: Set[ColumnClause[Any]] = set()
    traverse(clause, {}, {"column": cols.add})
    return cols


def _type_from_args(args: Sequence[ColumnElement[_T]]) -> TypeEngine[_T]:
    for a in args:
        if not a.type._isnull:
            return a.type
    else:
        return type_api.NULLTYPE  


def _corresponding_column_or_error(fromclause, column, require_embedded=False):
    c = fromclause.corresponding_column(
        column, require_embedded=require_embedded
    )
    if c is None:
        raise exc.InvalidRequestError(
            "Given column '%s', attached to table '%s', "
            "failed to locate a corresponding column from table '%s'"
            % (column, getattr(column, "table", None), fromclause.description)
        )
    return c


class _memoized_property_but_not_nulltype(
    util.memoized_property["TypeEngine[_T]"]
):
    

    def __get__(self, obj, cls):
        if obj is None:
            return self
        result = self.fget(obj)
        if not result._isnull:
            obj.__dict__[self.__name__] = result
        return result


class AnnotatedColumnElement(Annotated):
    _Annotated__element: ColumnElement[Any]

    def __init__(self, element, values):
        Annotated.__init__(self, element, values)
        for attr in (
            "comparator",
            "_proxy_key",
            "_tq_key_label",
            "_tq_label",
            "_non_anon_label",
            "type",
        ):
            self.__dict__.pop(attr, None)
        for attr in ("name", "key", "table"):
            if self.__dict__.get(attr, False) is None:
                self.__dict__.pop(attr)

    def _with_annotations(self, values):
        clone = super()._with_annotations(values)
        for attr in (
            "comparator",
            "_proxy_key",
            "_tq_key_label",
            "_tq_label",
            "_non_anon_label",
        ):
            clone.__dict__.pop(attr, None)
        return clone

    @util.memoized_property
    def name(self):
        
        return self._Annotated__element.name

    @_memoized_property_but_not_nulltype
    def type(self):
        
        return self._Annotated__element.type

    @util.memoized_property
    def table(self):
        
        return self._Annotated__element.table

    @util.memoized_property
    def key(self):
        
        return self._Annotated__element.key

    @util.memoized_property
    def info(self) -> _InfoType:
        if TYPE_CHECKING:
            assert isinstance(self._Annotated__element, Column)
        return self._Annotated__element.info

    @util.memoized_property
    def _anon_name_label(self) -> str:
        return self._Annotated__element._anon_name_label


class _truncated_label(quoted_name):
    

    __slots__ = ()

    def __new__(cls, value: str, quote: Optional[bool] = None) -> Any:
        quote = getattr(value, "quote", quote)
        
        return super().__new__(cls, value, quote)

    def __reduce__(self) -> Any:
        return self.__class__, (str(self), self.quote)

    def apply_map(self, map_: Mapping[str, Any]) -> str:
        return self


class conv(_truncated_label):
    

    __slots__ = ()






_generated_label = _truncated_label


class _anonymous_label(_truncated_label):
    

    __slots__ = ()

    @classmethod
    def safe_construct(
        cls,
        seed: int,
        body: str,
        enclosing_label: Optional[str] = None,
        sanitize_key: bool = False,
    ) -> _anonymous_label:
        
        
        body = re.sub(r"[%\(\) \$]+", "_", body)

        if sanitize_key:
            
            body = body.strip("_")

        label = "%%(%d %s)s" % (seed, body.replace("%", "%%"))
        if enclosing_label:
            label = "%s%s" % (enclosing_label, label)

        return _anonymous_label(label)

    def __add__(self, other):
        if "%" in other and not isinstance(other, _anonymous_label):
            other = str(other).replace("%", "%%")
        else:
            other = str(other)

        return _anonymous_label(
            quoted_name(
                str.__add__(self, other),
                self.quote,
            )
        )

    def __radd__(self, other):
        if "%" in other and not isinstance(other, _anonymous_label):
            other = str(other).replace("%", "%%")
        else:
            other = str(other)

        return _anonymous_label(
            quoted_name(
                str.__add__(other, self),
                self.quote,
            )
        )

    def apply_map(self, map_):
        if self.quote is not None:
            
            return quoted_name(self % map_, self.quote)
        else:
            
            return self % map_
