







from __future__ import annotations

from abc import ABC
import collections
from enum import Enum
import operator
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence as _typing_Sequence
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from . import coercions
from . import ddl
from . import roles
from . import type_api
from . import visitors
from .base import _DefaultDescriptionTuple
from .base import _NoArg
from .base import _NoneName
from .base import _SentinelColumnCharacterization
from .base import _SentinelDefaultCharacterization
from .base import DedupeColumnCollection
from .base import DialectKWArgs
from .base import Executable
from .base import SchemaEventTarget as SchemaEventTarget
from .base import SchemaVisitable as SchemaVisitable
from .coercions import _document_text_coercion
from .elements import ClauseElement
from .elements import ColumnClause
from .elements import ColumnElement
from .elements import quoted_name
from .elements import TextClause
from .selectable import TableClause
from .type_api import to_instance
from .visitors import ExternallyTraversible
from .. import event
from .. import exc
from .. import inspection
from .. import util
from ..util import HasMemoized
from ..util.typing import Final
from ..util.typing import Literal
from ..util.typing import Protocol
from ..util.typing import Self
from ..util.typing import TypedDict
from ..util.typing import TypeGuard

if typing.TYPE_CHECKING:
    from ._typing import _AutoIncrementType
    from ._typing import _CreateDropBind
    from ._typing import _DDLColumnArgument
    from ._typing import _InfoType
    from ._typing import _TextCoercedExpressionArgument
    from ._typing import _TypeEngineArgument
    from .base import ColumnSet
    from .base import ReadOnlyColumnCollection
    from .compiler import DDLCompiler
    from .elements import BindParameter
    from .elements import KeyedColumnElement
    from .functions import Function
    from .type_api import TypeEngine
    from .visitors import anon_map
    from ..engine import Connection
    from ..engine import Engine
    from ..engine.interfaces import _CoreMultiExecuteParams
    from ..engine.interfaces import CoreExecuteOptionsParameter
    from ..engine.interfaces import ExecutionContext
    from ..engine.reflection import _ReflectionInfo
    from ..sql.selectable import FromClause

_T = TypeVar("_T", bound="Any")
_SI = TypeVar("_SI", bound="SchemaItem")
_TAB = TypeVar("_TAB", bound="Table")


_ConstraintNameArgument = Optional[Union[str, _NoneName]]

_ServerDefaultArgument = Union[
    "FetchedValue", str, TextClause, ColumnElement[Any]
]

_ServerOnUpdateArgument = _ServerDefaultArgument


class SchemaConst(Enum):
    RETAIN_SCHEMA = 1
    

    BLANK_SCHEMA = 2
    

    NULL_UNSPECIFIED = 3
    


RETAIN_SCHEMA: Final[Literal[SchemaConst.RETAIN_SCHEMA]] = (
    SchemaConst.RETAIN_SCHEMA
)
BLANK_SCHEMA: Final[Literal[SchemaConst.BLANK_SCHEMA]] = (
    SchemaConst.BLANK_SCHEMA
)
NULL_UNSPECIFIED: Final[Literal[SchemaConst.NULL_UNSPECIFIED]] = (
    SchemaConst.NULL_UNSPECIFIED
)


def _get_table_key(name: str, schema: Optional[str]) -> str:
    if schema is None:
        return name
    else:
        return schema + "." + name




def _copy_expression(
    expression: ColumnElement[Any],
    source_table: Optional[Table],
    target_table: Optional[Table],
) -> ColumnElement[Any]:
    if source_table is None or target_table is None:
        return expression

    fixed_source_table = source_table
    fixed_target_table = target_table

    def replace(
        element: ExternallyTraversible, **kw: Any
    ) -> Optional[ExternallyTraversible]:
        if (
            isinstance(element, Column)
            and element.table is fixed_source_table
            and element.key in fixed_source_table.c
        ):
            return fixed_target_table.c[element.key]
        else:
            return None

    return cast(
        ColumnElement[Any],
        visitors.replacement_traverse(expression, {}, replace),
    )


@inspection._self_inspects
class SchemaItem(SchemaVisitable):
    

    __visit_name__ = "schema_item"

    create_drop_stringify_dialect = "default"

    def _init_items(self, *args: SchemaItem, **kw: Any) -> None:
        
        for item in args:
            if item is not None:
                try:
                    spwd = item._set_parent_with_dispatch
                except AttributeError as err:
                    raise exc.ArgumentError(
                        "'SchemaItem' object, such as a 'Column' or a "
                        f"'Constraint' expected, got {item!r}"
                    ) from err
                else:
                    spwd(self, **kw)

    def __repr__(self) -> str:
        return util.generic_repr(self, omit_kwarg=["info"])

    @util.memoized_property
    def info(self) -> _InfoType:
        
        return {}

    def _schema_item_copy(self, schema_item: _SI) -> _SI:
        if "info" in self.__dict__:
            schema_item.info = self.info.copy()
        schema_item.dispatch._update(self.dispatch)
        return schema_item

    _use_schema_map = True


class HasConditionalDDL:
    

    _ddl_if: Optional[ddl.DDLIf] = None

    def ddl_if(
        self,
        dialect: Optional[str] = None,
        callable_: Optional[ddl.DDLIfCallable] = None,
        state: Optional[Any] = None,
    ) -> Self:
        r
        self._ddl_if = ddl.DDLIf(dialect, callable_, state)
        return self


class HasSchemaAttr(SchemaItem):
    

    schema: Optional[str]


class Table(
    DialectKWArgs, HasSchemaAttr, TableClause, inspection.Inspectable["Table"]
):
    r

    __visit_name__ = "table"

    if TYPE_CHECKING:

        @util.ro_non_memoized_property
        def primary_key(self) -> PrimaryKeyConstraint: ...

        @util.ro_non_memoized_property
        def foreign_keys(self) -> Set[ForeignKey]: ...

    _columns: DedupeColumnCollection[Column[Any]]

    _sentinel_column: Optional[Column[Any]]

    constraints: Set[Constraint]
    

    indexes: Set[Index]
    

    if TYPE_CHECKING:

        @util.ro_non_memoized_property
        def columns(self) -> ReadOnlyColumnCollection[str, Column[Any]]: ...

        @util.ro_non_memoized_property
        def exported_columns(
            self,
        ) -> ReadOnlyColumnCollection[str, Column[Any]]: ...

        @util.ro_non_memoized_property
        def c(self) -> ReadOnlyColumnCollection[str, Column[Any]]: ...

    def _gen_cache_key(
        self, anon_map: anon_map, bindparams: List[BindParameter[Any]]
    ) -> Tuple[Any, ...]:
        if self._annotations:
            return (self,) + self._annotations_cache_key
        else:
            return (self,)

    if not typing.TYPE_CHECKING:
        
        
        
        @util.deprecated_params(
            mustexist=(
                "1.4",
                "Deprecated alias of :paramref:`_schema.Table.must_exist`",
            ),
        )
        def __new__(cls, *args: Any, **kw: Any) -> Any:
            return cls._new(*args, **kw)

    @classmethod
    def _new(cls, *args: Any, **kw: Any) -> Any:
        if not args and not kw:
            
            return object.__new__(cls)

        try:
            name, metadata, args = args[0], args[1], args[2:]
        except IndexError:
            raise TypeError(
                "Table() takes at least two positional-only "
                "arguments 'name' and 'metadata'"
            )

        schema = kw.get("schema", None)
        if schema is None:
            schema = metadata.schema
        elif schema is BLANK_SCHEMA:
            schema = None
        keep_existing = kw.get("keep_existing", False)
        extend_existing = kw.get("extend_existing", False)

        if keep_existing and extend_existing:
            msg = "keep_existing and extend_existing are mutually exclusive."
            raise exc.ArgumentError(msg)

        must_exist = kw.pop("must_exist", kw.pop("mustexist", False))
        key = _get_table_key(name, schema)
        if key in metadata.tables:
            if not keep_existing and not extend_existing and bool(args):
                raise exc.InvalidRequestError(
                    f"Table '{key}' is already defined for this MetaData "
                    "instance.  Specify 'extend_existing=True' "
                    "to redefine "
                    "options and columns on an "
                    "existing Table object."
                )
            table = metadata.tables[key]
            if extend_existing:
                table._init_existing(*args, **kw)
            return table
        else:
            if must_exist:
                raise exc.InvalidRequestError(f"Table '{key}' not defined")
            table = object.__new__(cls)
            table.dispatch.before_parent_attach(table, metadata)
            metadata._add_table(name, schema, table)
            try:
                table.__init__(name, metadata, *args, _no_init=False, **kw)  
                table.dispatch.after_parent_attach(table, metadata)
                return table
            except Exception:
                with util.safe_reraise():
                    metadata._remove_table(name, schema)

    def __init__(
        self,
        name: str,
        metadata: MetaData,
        *args: SchemaItem,
        schema: Optional[Union[str, Literal[SchemaConst.BLANK_SCHEMA]]] = None,
        quote: Optional[bool] = None,
        quote_schema: Optional[bool] = None,
        autoload_with: Optional[Union[Engine, Connection]] = None,
        autoload_replace: bool = True,
        keep_existing: bool = False,
        extend_existing: bool = False,
        resolve_fks: bool = True,
        include_columns: Optional[Collection[str]] = None,
        implicit_returning: bool = True,
        comment: Optional[str] = None,
        info: Optional[Dict[Any, Any]] = None,
        listeners: Optional[
            _typing_Sequence[Tuple[str, Callable[..., Any]]]
        ] = None,
        prefixes: Optional[_typing_Sequence[str]] = None,
        
        _extend_on: Optional[Set[Table]] = None,
        
        _no_init: bool = True,
        
        **kw: Any,
    ) -> None:
        r  
        if _no_init:
            
            
            return

        super().__init__(quoted_name(name, quote))
        self.metadata = metadata

        if schema is None:
            self.schema = metadata.schema
        elif schema is BLANK_SCHEMA:
            self.schema = None
        else:
            quote_schema = quote_schema
            assert isinstance(schema, str)
            self.schema = quoted_name(schema, quote_schema)

        self._sentinel_column = None

        self.indexes = set()
        self.constraints = set()
        PrimaryKeyConstraint(
            _implicit_generated=True
        )._set_parent_with_dispatch(self)
        self.foreign_keys = set()  
        self._extra_dependencies: Set[Table] = set()
        if self.schema is not None:
            self.fullname = "%s.%s" % (self.schema, self.name)
        else:
            self.fullname = self.name

        self.implicit_returning = implicit_returning
        _reflect_info = kw.pop("_reflect_info", None)

        self.comment = comment

        if info is not None:
            self.info = info

        if listeners is not None:
            for evt, fn in listeners:
                event.listen(self, evt, fn)

        self._prefixes = prefixes if prefixes else []

        self._extra_kwargs(**kw)

        
        
        
        if autoload_with is not None:
            self._autoload(
                metadata,
                autoload_with,
                include_columns,
                _extend_on=_extend_on,
                _reflect_info=_reflect_info,
                resolve_fks=resolve_fks,
            )

        
        

        self._init_items(
            *args,
            allow_replacements=extend_existing
            or keep_existing
            or autoload_with,
            all_names={},
        )

    def _autoload(
        self,
        metadata: MetaData,
        autoload_with: Union[Engine, Connection],
        include_columns: Optional[Collection[str]],
        exclude_columns: Collection[str] = (),
        resolve_fks: bool = True,
        _extend_on: Optional[Set[Table]] = None,
        _reflect_info: _ReflectionInfo | None = None,
    ) -> None:
        insp = inspection.inspect(autoload_with)
        with insp._inspection_context() as conn_insp:
            conn_insp.reflect_table(
                self,
                include_columns,
                exclude_columns,
                resolve_fks,
                _extend_on=_extend_on,
                _reflect_info=_reflect_info,
            )

    @property
    def _sorted_constraints(self) -> List[Constraint]:
        

        return sorted(self.constraints, key=lambda c: c._creation_order)

    @property
    def foreign_key_constraints(self) -> Set[ForeignKeyConstraint]:
        
        return {
            fkc.constraint
            for fkc in self.foreign_keys
            if fkc.constraint is not None
        }

    def _init_existing(self, *args: Any, **kwargs: Any) -> None:
        autoload_with = kwargs.pop("autoload_with", None)
        autoload = kwargs.pop("autoload", autoload_with is not None)
        autoload_replace = kwargs.pop("autoload_replace", True)
        schema = kwargs.pop("schema", None)
        _extend_on = kwargs.pop("_extend_on", None)
        _reflect_info = kwargs.pop("_reflect_info", None)

        
        extend_existing = kwargs.pop("extend_existing", False)
        keep_existing = kwargs.pop("keep_existing", False)

        assert extend_existing
        assert not keep_existing

        if schema and schema != self.schema:
            raise exc.ArgumentError(
                f"Can't change schema of existing table "
                f"from '{self.schema}' to '{schema}'",
            )

        include_columns = kwargs.pop("include_columns", None)
        if include_columns is not None:
            for c in self.c:
                if c.name not in include_columns:
                    self._columns.remove(c)

        resolve_fks = kwargs.pop("resolve_fks", True)

        for key in ("quote", "quote_schema"):
            if key in kwargs:
                raise exc.ArgumentError(
                    "Can't redefine 'quote' or 'quote_schema' arguments"
                )

        
        self.comment = kwargs.pop("comment", self.comment)
        self.implicit_returning = kwargs.pop(
            "implicit_returning", self.implicit_returning
        )
        self.info = kwargs.pop("info", self.info)

        exclude_columns: _typing_Sequence[str]

        if autoload:
            if not autoload_replace:
                
                
                
                exclude_columns = [c.name for c in self.c]
            else:
                exclude_columns = ()
            self._autoload(
                self.metadata,
                autoload_with,
                include_columns,
                exclude_columns,
                resolve_fks,
                _extend_on=_extend_on,
                _reflect_info=_reflect_info,
            )

        all_names = {c.name: c for c in self.c}
        self._extra_kwargs(**kwargs)
        self._init_items(*args, allow_replacements=True, all_names=all_names)

    def _extra_kwargs(self, **kwargs: Any) -> None:
        self._validate_dialect_kwargs(kwargs)

    def _init_collections(self) -> None:
        pass

    def _reset_exported(self) -> None:
        pass

    @util.ro_non_memoized_property
    def _autoincrement_column(self) -> Optional[Column[int]]:
        return self.primary_key._autoincrement_column

    @util.ro_memoized_property
    def _sentinel_column_characteristics(
        self,
    ) -> _SentinelColumnCharacterization:
        

        sentinel_is_explicit = False
        sentinel_is_autoinc = False
        the_sentinel: Optional[_typing_Sequence[Column[Any]]] = None

        
        explicit_sentinel_col = self._sentinel_column

        if explicit_sentinel_col is not None:
            the_sentinel = (explicit_sentinel_col,)
            sentinel_is_explicit = True

        autoinc_col = self._autoincrement_column
        if sentinel_is_explicit and explicit_sentinel_col is autoinc_col:
            assert autoinc_col is not None
            sentinel_is_autoinc = True
        elif explicit_sentinel_col is None and autoinc_col is not None:
            the_sentinel = (autoinc_col,)
            sentinel_is_autoinc = True

        default_characterization = _SentinelDefaultCharacterization.UNKNOWN

        if the_sentinel:
            the_sentinel_zero = the_sentinel[0]
            if the_sentinel_zero.identity:
                if the_sentinel_zero.identity._increment_is_negative:
                    if sentinel_is_explicit:
                        raise exc.InvalidRequestError(
                            "Can't use IDENTITY default with negative "
                            "increment as an explicit sentinel column"
                        )
                    else:
                        if sentinel_is_autoinc:
                            autoinc_col = None
                            sentinel_is_autoinc = False
                        the_sentinel = None
                else:
                    default_characterization = (
                        _SentinelDefaultCharacterization.IDENTITY
                    )
            elif (
                the_sentinel_zero.default is None
                and the_sentinel_zero.server_default is None
            ):
                if the_sentinel_zero.nullable:
                    raise exc.InvalidRequestError(
                        f"Column {the_sentinel_zero} has been marked as a "
                        "sentinel "
                        "column with no default generation function; it "
                        "at least needs to be marked nullable=False assuming "
                        "user-populated sentinel values will be used."
                    )
                default_characterization = (
                    _SentinelDefaultCharacterization.NONE
                )
            elif the_sentinel_zero.default is not None:
                if the_sentinel_zero.default.is_sentinel:
                    default_characterization = (
                        _SentinelDefaultCharacterization.SENTINEL_DEFAULT
                    )
                elif default_is_sequence(the_sentinel_zero.default):
                    if the_sentinel_zero.default._increment_is_negative:
                        if sentinel_is_explicit:
                            raise exc.InvalidRequestError(
                                "Can't use SEQUENCE default with negative "
                                "increment as an explicit sentinel column"
                            )
                        else:
                            if sentinel_is_autoinc:
                                autoinc_col = None
                                sentinel_is_autoinc = False
                            the_sentinel = None

                    default_characterization = (
                        _SentinelDefaultCharacterization.SEQUENCE
                    )
                elif the_sentinel_zero.default.is_callable:
                    default_characterization = (
                        _SentinelDefaultCharacterization.CLIENTSIDE
                    )
            elif the_sentinel_zero.server_default is not None:
                if sentinel_is_explicit:
                    raise exc.InvalidRequestError(
                        f"Column {the_sentinel[0]} can't be a sentinel column "
                        "because it uses an explicit server side default "
                        "that's not the Identity() default."
                    )

                default_characterization = (
                    _SentinelDefaultCharacterization.SERVERSIDE
                )

        if the_sentinel is None and self.primary_key:
            assert autoinc_col is None

            
            
            for _pkc in self.primary_key:
                if _pkc.server_default is not None or (
                    _pkc.default and not _pkc.default.is_callable
                ):
                    break
            else:
                the_sentinel = tuple(self.primary_key)
                default_characterization = (
                    _SentinelDefaultCharacterization.CLIENTSIDE
                )

        return _SentinelColumnCharacterization(
            the_sentinel,
            sentinel_is_explicit,
            sentinel_is_autoinc,
            default_characterization,
        )

    @property
    def autoincrement_column(self) -> Optional[Column[int]]:
        
        return self._autoincrement_column

    @property
    def key(self) -> str:
        
        return _get_table_key(self.name, self.schema)

    def __repr__(self) -> str:
        return "Table(%s)" % ", ".join(
            [repr(self.name)]
            + [repr(self.metadata)]
            + [repr(x) for x in self.columns]
            + ["%s=%s" % (k, repr(getattr(self, k))) for k in ["schema"]]
        )

    def __str__(self) -> str:
        return _get_table_key(self.description, self.schema)

    def add_is_dependent_on(self, table: Table) -> None:
        
        self._extra_dependencies.add(table)

    def append_column(
        self, column: ColumnClause[Any], replace_existing: bool = False
    ) -> None:
        

        try:
            column._set_parent_with_dispatch(
                self,
                allow_replacements=replace_existing,
                all_names={c.name: c for c in self.c},
            )
        except exc.DuplicateColumnError as de:
            raise exc.DuplicateColumnError(
                f"{de.args[0]} Specify replace_existing=True to "
                "Table.append_column() to replace an "
                "existing column."
            ) from de

    def append_constraint(self, constraint: Union[Index, Constraint]) -> None:
        

        constraint._set_parent_with_dispatch(self)

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        metadata = parent
        assert isinstance(metadata, MetaData)
        metadata._add_table(self.name, self.schema, self)
        self.metadata = metadata

    def create(self, bind: _CreateDropBind, checkfirst: bool = False) -> None:
        

        bind._run_ddl_visitor(ddl.SchemaGenerator, self, checkfirst=checkfirst)

    def drop(self, bind: _CreateDropBind, checkfirst: bool = False) -> None:
        
        bind._run_ddl_visitor(ddl.SchemaDropper, self, checkfirst=checkfirst)

    @util.deprecated(
        "1.4",
        ":meth:`_schema.Table.tometadata` is renamed to "
        ":meth:`_schema.Table.to_metadata`",
    )
    def tometadata(
        self,
        metadata: MetaData,
        schema: Union[str, Literal[SchemaConst.RETAIN_SCHEMA]] = RETAIN_SCHEMA,
        referred_schema_fn: Optional[
            Callable[
                [Table, Optional[str], ForeignKeyConstraint, Optional[str]],
                Optional[str],
            ]
        ] = None,
        name: Optional[str] = None,
    ) -> Table:
        
        return self.to_metadata(
            metadata,
            schema=schema,
            referred_schema_fn=referred_schema_fn,
            name=name,
        )

    def to_metadata(
        self,
        metadata: MetaData,
        schema: Union[str, Literal[SchemaConst.RETAIN_SCHEMA]] = RETAIN_SCHEMA,
        referred_schema_fn: Optional[
            Callable[
                [Table, Optional[str], ForeignKeyConstraint, Optional[str]],
                Optional[str],
            ]
        ] = None,
        name: Optional[str] = None,
    ) -> Table:
          
        if name is None:
            name = self.name

        actual_schema: Optional[str]

        if schema is RETAIN_SCHEMA:
            actual_schema = self.schema
        elif schema is None:
            actual_schema = metadata.schema
        else:
            actual_schema = schema
        key = _get_table_key(name, actual_schema)
        if key in metadata.tables:
            util.warn(
                f"Table '{self.description}' already exists within the given "
                "MetaData - not copying."
            )
            return metadata.tables[key]

        args = []
        for col in self.columns:
            args.append(col._copy(schema=actual_schema, _to_metadata=metadata))
        table = Table(
            name,
            metadata,
            schema=actual_schema,
            comment=self.comment,
            *args,
            **self.kwargs,
        )
        for const in self.constraints:
            if isinstance(const, ForeignKeyConstraint):
                referred_schema = const._referred_schema
                if referred_schema_fn:
                    fk_constraint_schema = referred_schema_fn(
                        self, actual_schema, const, referred_schema
                    )
                else:
                    fk_constraint_schema = (
                        actual_schema
                        if referred_schema == self.schema
                        else None
                    )
                table.append_constraint(
                    const._copy(
                        schema=fk_constraint_schema, target_table=table
                    )
                )
            elif not const._type_bound:
                
                
                if const._column_flag:
                    continue

                table.append_constraint(
                    const._copy(schema=actual_schema, target_table=table)
                )
        for index in self.indexes:
            
            
            if index._column_flag:
                continue
            Index(
                index.name,
                unique=index.unique,
                *[
                    _copy_expression(expr, self, table)
                    for expr in index._table_bound_expressions
                ],
                _table=table,
                **index.kwargs,
            )
        return self._schema_item_copy(table)


class Column(DialectKWArgs, SchemaItem, ColumnClause[_T]):
    

    __visit_name__ = "column"

    inherit_cache = True
    key: str

    server_default: Optional[FetchedValue]

    def __init__(
        self,
        __name_pos: Optional[
            Union[str, _TypeEngineArgument[_T], SchemaEventTarget]
        ] = None,
        __type_pos: Optional[
            Union[_TypeEngineArgument[_T], SchemaEventTarget]
        ] = None,
        *args: SchemaEventTarget,
        name: Optional[str] = None,
        type_: Optional[_TypeEngineArgument[_T]] = None,
        autoincrement: _AutoIncrementType = "auto",
        default: Optional[Any] = _NoArg.NO_ARG,
        insert_default: Optional[Any] = _NoArg.NO_ARG,
        doc: Optional[str] = None,
        key: Optional[str] = None,
        index: Optional[bool] = None,
        unique: Optional[bool] = None,
        info: Optional[_InfoType] = None,
        nullable: Optional[
            Union[bool, Literal[SchemaConst.NULL_UNSPECIFIED]]
        ] = SchemaConst.NULL_UNSPECIFIED,
        onupdate: Optional[Any] = None,
        primary_key: bool = False,
        server_default: Optional[_ServerDefaultArgument] = None,
        server_onupdate: Optional[_ServerOnUpdateArgument] = None,
        quote: Optional[bool] = None,
        system: bool = False,
        comment: Optional[str] = None,
        insert_sentinel: bool = False,
        _omit_from_statements: bool = False,
        _proxies: Optional[Any] = None,
        **dialect_kwargs: Any,
    ):
        r  

        l_args = [__name_pos, __type_pos] + list(args)
        del args

        if l_args:
            if isinstance(l_args[0], str):
                if name is not None:
                    raise exc.ArgumentError(
                        "May not pass name positionally and as a keyword."
                    )
                name = l_args.pop(0)  
            elif l_args[0] is None:
                l_args.pop(0)
        if l_args:
            coltype = l_args[0]

            if hasattr(coltype, "_sqla_type"):
                if type_ is not None:
                    raise exc.ArgumentError(
                        "May not pass type_ positionally and as a keyword."
                    )
                type_ = l_args.pop(0)  
            elif l_args[0] is None:
                l_args.pop(0)

        if name is not None:
            name = quoted_name(name, quote)
        elif quote is not None:
            raise exc.ArgumentError(
                "Explicit 'name' is required when sending 'quote' argument"
            )

        
        
        
        super().__init__(name, type_)  

        self.key = key if key is not None else name  
        self.primary_key = primary_key
        self._insert_sentinel = insert_sentinel
        self._omit_from_statements = _omit_from_statements
        self._user_defined_nullable = udn = nullable
        if udn is not NULL_UNSPECIFIED:
            self.nullable = udn
        else:
            self.nullable = not primary_key

        
        
        
        self.index = index
        self.unique = unique

        self.system = system
        self.doc = doc
        self.autoincrement: _AutoIncrementType = autoincrement
        self.constraints = set()
        self.foreign_keys = set()
        self.comment = comment
        self.computed = None
        self.identity = None

        

        if _proxies is not None:
            self._proxies = _proxies
        else:
            
            self._set_type(self.type)

        if insert_default is not _NoArg.NO_ARG:
            resolved_default = insert_default
        elif default is not _NoArg.NO_ARG:
            resolved_default = default
        else:
            resolved_default = None

        if resolved_default is not None:
            if not isinstance(resolved_default, (ColumnDefault, Sequence)):
                resolved_default = ColumnDefault(resolved_default)

            self.default = resolved_default
            l_args.append(resolved_default)
        else:
            self.default = None

        if onupdate is not None:
            if not isinstance(onupdate, (ColumnDefault, Sequence)):
                onupdate = ColumnDefault(onupdate, for_update=True)

            self.onupdate = onupdate
            l_args.append(onupdate)
        else:
            self.onupdate = None

        if server_default is not None:
            if isinstance(server_default, FetchedValue):
                server_default = server_default._as_for_update(False)
                l_args.append(server_default)
            else:
                server_default = DefaultClause(server_default)
                l_args.append(server_default)
        self.server_default = server_default

        if server_onupdate is not None:
            if isinstance(server_onupdate, FetchedValue):
                server_onupdate = server_onupdate._as_for_update(True)
                l_args.append(server_onupdate)
            else:
                server_onupdate = DefaultClause(
                    server_onupdate, for_update=True
                )
                l_args.append(server_onupdate)
        self.server_onupdate = server_onupdate

        self._init_items(*cast(_typing_Sequence[SchemaItem], l_args))

        util.set_creation_order(self)

        if info is not None:
            self.info = info

        self._extra_kwargs(**dialect_kwargs)

    table: Table

    constraints: Set[Constraint]

    foreign_keys: Set[ForeignKey]
    

    index: Optional[bool]
    

    unique: Optional[bool]
    

    computed: Optional[Computed]

    identity: Optional[Identity]

    def _set_type(self, type_: TypeEngine[Any]) -> None:
        assert self.type._isnull or type_ is self.type

        self.type = type_
        if isinstance(self.type, SchemaEventTarget):
            self.type._set_parent_with_dispatch(self)
        for impl in self.type._variant_mapping.values():
            if isinstance(impl, SchemaEventTarget):
                impl._set_parent_with_dispatch(self)

    @HasMemoized.memoized_attribute
    def _default_description_tuple(self) -> _DefaultDescriptionTuple:
        

        return _DefaultDescriptionTuple._from_column_default(self.default)

    @HasMemoized.memoized_attribute
    def _onupdate_description_tuple(self) -> _DefaultDescriptionTuple:
        
        return _DefaultDescriptionTuple._from_column_default(self.onupdate)

    @util.memoized_property
    def _gen_static_annotations_cache_key(self) -> bool:
        
        return self.table is not None and self.table._is_table

    def _extra_kwargs(self, **kwargs: Any) -> None:
        self._validate_dialect_kwargs(kwargs)

    def __str__(self) -> str:
        if self.name is None:
            return "(no name)"
        elif self.table is not None:
            if self.table.named_with_column:
                return self.table.description + "." + self.description
            else:
                return self.description
        else:
            return self.description

    def references(self, column: Column[Any]) -> bool:
        

        for fk in self.foreign_keys:
            if fk.column.proxy_set.intersection(column.proxy_set):
                return True
        else:
            return False

    def append_foreign_key(self, fk: ForeignKey) -> None:
        fk._set_parent_with_dispatch(self)

    def __repr__(self) -> str:
        kwarg = []
        if self.key != self.name:
            kwarg.append("key")
        if self.primary_key:
            kwarg.append("primary_key")
        if not self.nullable:
            kwarg.append("nullable")
        if self.onupdate:
            kwarg.append("onupdate")
        if self.default:
            kwarg.append("default")
        if self.server_default:
            kwarg.append("server_default")
        if self.comment:
            kwarg.append("comment")
        return "Column(%s)" % ", ".join(
            [repr(self.name)]
            + [repr(self.type)]
            + [repr(x) for x in self.foreign_keys if x is not None]
            + [repr(x) for x in self.constraints]
            + [
                (
                    self.table is not None
                    and "table=<%s>" % self.table.description
                    or "table=None"
                )
            ]
            + ["%s=%s" % (k, repr(getattr(self, k))) for k in kwarg]
        )

    def _set_parent(  
        self,
        parent: SchemaEventTarget,
        *,
        all_names: Dict[str, Column[Any]],
        allow_replacements: bool,
        **kw: Any,
    ) -> None:
        table = parent
        assert isinstance(table, Table)
        if not self.name:
            raise exc.ArgumentError(
                "Column must be constructed with a non-blank name or "
                "assign a non-blank .name before adding to a Table."
            )

        self._reset_memoizations()

        if self.key is None:
            self.key = self.name

        existing = getattr(self, "table", None)
        if existing is not None and existing is not table:
            raise exc.ArgumentError(
                f"Column object '{self.key}' already "
                f"assigned to Table '{existing.description}'"
            )

        extra_remove = None
        existing_col = None
        conflicts_on = ""

        if self.key in table._columns:
            existing_col = table._columns[self.key]
            if self.key == self.name:
                conflicts_on = "name"
            else:
                conflicts_on = "key"
        elif self.name in all_names:
            existing_col = all_names[self.name]
            extra_remove = {existing_col}
            conflicts_on = "name"

        if existing_col is not None:
            if existing_col is not self:
                if not allow_replacements:
                    raise exc.DuplicateColumnError(
                        f"A column with {conflicts_on} "
                        f
                        f"is already present in table '{table.name}'."
                    )
                for fk in existing_col.foreign_keys:
                    table.foreign_keys.remove(fk)
                    if fk.constraint in table.constraints:
                        
                        
                        
                        table.constraints.remove(fk.constraint)

        if extra_remove and existing_col is not None and self.key == self.name:
            util.warn(
                f'Column with user-specified key "{existing_col.key}" is '
                "being replaced with "
                f'plain named column "{self.name}", '
                f'key "{existing_col.key}" is being removed.  If this is a '
                "reflection operation, specify autoload_replace=False to "
                "prevent this replacement."
            )
        table._columns.replace(self, extra_remove=extra_remove)
        all_names[self.name] = self
        self.table = table

        if self._insert_sentinel:
            if self.table._sentinel_column is not None:
                raise exc.ArgumentError(
                    "a Table may have only one explicit sentinel column"
                )
            self.table._sentinel_column = self

        if self.primary_key:
            table.primary_key._replace(self)
        elif self.key in table.primary_key:
            raise exc.ArgumentError(
                f"Trying to redefine primary-key column '{self.key}' as a "
                f"non-primary-key column on table '{table.fullname}'"
            )

        if self.index:
            if isinstance(self.index, str):
                raise exc.ArgumentError(
                    "The 'index' keyword argument on Column is boolean only. "
                    "To create indexes with a specific name, create an "
                    "explicit Index object external to the Table."
                )
            table.append_constraint(
                Index(
                    None, self.key, unique=bool(self.unique), _column_flag=True
                )
            )

        elif self.unique:
            if isinstance(self.unique, str):
                raise exc.ArgumentError(
                    "The 'unique' keyword argument on Column is boolean "
                    "only. To create unique constraints or indexes with a "
                    "specific name, append an explicit UniqueConstraint to "
                    "the Table's list of elements, or create an explicit "
                    "Index object external to the Table."
                )
            table.append_constraint(
                UniqueConstraint(self.key, _column_flag=True)
            )

        self._setup_on_memoized_fks(lambda fk: fk._set_remote_table(table))

        if self.identity and (
            isinstance(self.default, Sequence)
            or isinstance(self.onupdate, Sequence)
        ):
            raise exc.ArgumentError(
                "An column cannot specify both Identity and Sequence."
            )

    def _setup_on_memoized_fks(self, fn: Callable[..., Any]) -> None:
        fk_keys = [
            ((self.table.key, self.key), False),
            ((self.table.key, self.name), True),
        ]
        for fk_key, link_to_name in fk_keys:
            if fk_key in self.table.metadata._fk_memos:
                for fk in self.table.metadata._fk_memos[fk_key]:
                    if fk.link_to_name is link_to_name:
                        fn(fk)

    def _on_table_attach(self, fn: Callable[..., Any]) -> None:
        if self.table is not None:
            fn(self, self.table)
        else:
            event.listen(self, "after_parent_attach", fn)

    @util.deprecated(
        "1.4",
        "The :meth:`_schema.Column.copy` method is deprecated "
        "and will be removed in a future release.",
    )
    def copy(self, **kw: Any) -> Column[Any]:
        return self._copy(**kw)

    def _copy(self, **kw: Any) -> Column[Any]:
        

        
        args: List[SchemaItem] = [
            c._copy(**kw) for c in self.constraints if not c._type_bound
        ] + [c._copy(**kw) for c in self.foreign_keys if not c.constraint]

        
        column_kwargs = {}
        for dialect_name in self.dialect_options:
            dialect_options = self.dialect_options[dialect_name]._non_defaults
            for (
                dialect_option_key,
                dialect_option_value,
            ) in dialect_options.items():
                column_kwargs[dialect_name + "_" + dialect_option_key] = (
                    dialect_option_value
                )

        server_default = self.server_default
        server_onupdate = self.server_onupdate
        if isinstance(server_default, (Computed, Identity)):
            
            
            
            args.append(server_default._copy(**kw))
            server_default = server_onupdate = None

        type_ = self.type
        if isinstance(type_, SchemaEventTarget):
            type_ = type_.copy(**kw)

        
        
        

        c = self._constructor(
            name=self.name,
            type_=type_,
            key=self.key,
            primary_key=self.primary_key,
            unique=self.unique,
            system=self.system,
            
            index=self.index,
            autoincrement=self.autoincrement,
            default=self.default,
            server_default=server_default,
            onupdate=self.onupdate,
            server_onupdate=server_onupdate,
            doc=self.doc,
            comment=self.comment,
            _omit_from_statements=self._omit_from_statements,
            insert_sentinel=self._insert_sentinel,
            *args,
            **column_kwargs,
        )

        
        
        c.nullable = self.nullable
        c._user_defined_nullable = self._user_defined_nullable

        return self._schema_item_copy(c)

    def _merge(self, other: Column[Any]) -> None:
        

        if self.primary_key:
            other.primary_key = True

        if self.autoincrement != "auto" and other.autoincrement == "auto":
            other.autoincrement = self.autoincrement

        if self.system:
            other.system = self.system

        if self.info:
            other.info.update(self.info)

        type_ = self.type
        if not type_._isnull and other.type._isnull:
            if isinstance(type_, SchemaEventTarget):
                type_ = type_.copy()

            other.type = type_

            if isinstance(type_, SchemaEventTarget):
                type_._set_parent_with_dispatch(other)

            for impl in type_._variant_mapping.values():
                if isinstance(impl, SchemaEventTarget):
                    impl._set_parent_with_dispatch(other)

        if (
            self._user_defined_nullable is not NULL_UNSPECIFIED
            and other._user_defined_nullable is NULL_UNSPECIFIED
        ):
            other.nullable = self.nullable
            other._user_defined_nullable = self._user_defined_nullable

        if self.default is not None and other.default is None:
            new_default = self.default._copy()
            new_default._set_parent(other)

        if self.server_default and other.server_default is None:
            new_server_default = self.server_default
            if isinstance(new_server_default, FetchedValue):
                new_server_default = new_server_default._copy()
                new_server_default._set_parent(other)
            else:
                other.server_default = new_server_default

        if self.server_onupdate and other.server_onupdate is None:
            new_server_onupdate = self.server_onupdate
            new_server_onupdate = new_server_onupdate._copy()
            new_server_onupdate._set_parent(other)

        if self.onupdate and other.onupdate is None:
            new_onupdate = self.onupdate._copy()
            new_onupdate._set_parent(other)

        if self.index in (True, False) and other.index is None:
            other.index = self.index

        if self.unique in (True, False) and other.unique is None:
            other.unique = self.unique

        if self.doc and other.doc is None:
            other.doc = self.doc

        if self.comment and other.comment is None:
            other.comment = self.comment

        for const in self.constraints:
            if not const._type_bound:
                new_const = const._copy()
                new_const._set_parent(other)

        for fk in self.foreign_keys:
            if not fk.constraint:
                new_fk = fk._copy()
                new_fk._set_parent(other)

    def _make_proxy(
        self,
        selectable: FromClause,
        primary_key: ColumnSet,
        foreign_keys: Set[KeyedColumnElement[Any]],
        name: Optional[str] = None,
        key: Optional[str] = None,
        name_is_truncatable: bool = False,
        compound_select_cols: Optional[
            _typing_Sequence[ColumnElement[Any]]
        ] = None,
        **kw: Any,
    ) -> Tuple[str, ColumnClause[_T]]:
        

        fk = [
            ForeignKey(
                col if col is not None else f._colspec,
                _unresolvable=col is None,
                _constraint=f.constraint,
            )
            for f, col in [
                (fk, fk._resolve_column(raiseerr=False))
                for fk in self.foreign_keys
            ]
        ]

        if name is None and self.name is None:
            raise exc.InvalidRequestError(
                "Cannot initialize a sub-selectable"
                " with this Column object until its 'name' has "
                "been assigned."
            )
        try:
            c = self._constructor(
                (
                    coercions.expect(
                        roles.TruncatedLabelRole, name if name else self.name
                    )
                    if name_is_truncatable
                    else (name or self.name)
                ),
                self.type,
                
                key=key if key else name if name else self.key,
                primary_key=self.primary_key,
                nullable=self.nullable,
                _proxies=(
                    list(compound_select_cols)
                    if compound_select_cols
                    else [self]
                ),
                *fk,
            )
        except TypeError as err:
            raise TypeError(
                "Could not create a copy of this %r object.  "
                "Ensure the class includes a _constructor() "
                "attribute or method which accepts the "
                "standard Column constructor arguments, or "
                "references the Column class itself." % self.__class__
            ) from err

        c.table = selectable
        c._propagate_attrs = selectable._propagate_attrs
        if selectable._is_clone_of is not None:
            c._is_clone_of = selectable._is_clone_of.columns.get(c.key)

        if self.primary_key:
            primary_key.add(c)

        if fk:
            foreign_keys.update(fk)  

        return c.key, c


def insert_sentinel(
    name: Optional[str] = None,
    type_: Optional[_TypeEngineArgument[_T]] = None,
    *,
    default: Optional[Any] = None,
    omit_from_statements: bool = True,
) -> Column[Any]:
    
    return Column(
        name=name,
        type_=type_api.INTEGERTYPE if type_ is None else type_,
        default=(
            default if default is not None else _InsertSentinelColumnDefault()
        ),
        _omit_from_statements=omit_from_statements,
        insert_sentinel=True,
    )


class ForeignKey(DialectKWArgs, SchemaItem):
    

    __visit_name__ = "foreign_key"

    parent: Column[Any]

    _table_column: Optional[Column[Any]]

    def __init__(
        self,
        column: _DDLColumnArgument,
        _constraint: Optional[ForeignKeyConstraint] = None,
        use_alter: bool = False,
        name: _ConstraintNameArgument = None,
        onupdate: Optional[str] = None,
        ondelete: Optional[str] = None,
        deferrable: Optional[bool] = None,
        initially: Optional[str] = None,
        link_to_name: bool = False,
        match: Optional[str] = None,
        info: Optional[_InfoType] = None,
        comment: Optional[str] = None,
        _unresolvable: bool = False,
        **dialect_kw: Any,
    ):
        r

        self._colspec = coercions.expect(roles.DDLReferredColumnRole, column)
        self._unresolvable = _unresolvable

        if isinstance(self._colspec, str):
            self._table_column = None
        else:
            self._table_column = self._colspec

            if not isinstance(
                self._table_column.table, (type(None), TableClause)
            ):
                raise exc.ArgumentError(
                    "ForeignKey received Column not bound "
                    "to a Table, got: %r" % self._table_column.table
                )

        
        
        
        
        
        self.constraint = _constraint

        
        self.parent = None  

        self.use_alter = use_alter
        self.name = name
        self.onupdate = onupdate
        self.ondelete = ondelete
        self.deferrable = deferrable
        self.initially = initially
        self.link_to_name = link_to_name
        self.match = match
        self.comment = comment
        if info:
            self.info = info
        self._unvalidated_dialect_kw = dialect_kw

    def __repr__(self) -> str:
        return "ForeignKey(%r)" % self._get_colspec()

    @util.deprecated(
        "1.4",
        "The :meth:`_schema.ForeignKey.copy` method is deprecated "
        "and will be removed in a future release.",
    )
    def copy(self, *, schema: Optional[str] = None, **kw: Any) -> ForeignKey:
        return self._copy(schema=schema, **kw)

    def _copy(self, *, schema: Optional[str] = None, **kw: Any) -> ForeignKey:
        
        fk = ForeignKey(
            self._get_colspec(schema=schema),
            use_alter=self.use_alter,
            name=self.name,
            onupdate=self.onupdate,
            ondelete=self.ondelete,
            deferrable=self.deferrable,
            initially=self.initially,
            link_to_name=self.link_to_name,
            match=self.match,
            comment=self.comment,
            **self._unvalidated_dialect_kw,
        )
        return self._schema_item_copy(fk)

    def _get_colspec(
        self,
        schema: Optional[
            Union[
                str,
                Literal[SchemaConst.RETAIN_SCHEMA, SchemaConst.BLANK_SCHEMA],
            ]
        ] = None,
        table_name: Optional[str] = None,
        _is_copy: bool = False,
    ) -> str:
        
        if schema not in (None, RETAIN_SCHEMA):
            _schema, tname, colname = self._column_tokens
            if table_name is not None:
                tname = table_name
            if schema is BLANK_SCHEMA:
                return "%s.%s" % (tname, colname)
            else:
                return "%s.%s.%s" % (schema, tname, colname)
        elif table_name:
            schema, tname, colname = self._column_tokens
            if schema:
                return "%s.%s.%s" % (schema, table_name, colname)
            else:
                return "%s.%s" % (table_name, colname)
        elif self._table_column is not None:
            if self._table_column.table is None:
                if _is_copy:
                    raise exc.InvalidRequestError(
                        f"Can't copy ForeignKey object which refers to "
                        f"non-table bound Column {self._table_column!r}"
                    )
                else:
                    return self._table_column.key
            return "%s.%s" % (
                self._table_column.table.fullname,
                self._table_column.key,
            )
        else:
            assert isinstance(self._colspec, str)
            return self._colspec

    @property
    def _referred_schema(self) -> Optional[str]:
        return self._column_tokens[0]

    def _table_key(self) -> Any:
        if self._table_column is not None:
            if self._table_column.table is None:
                return None
            else:
                return self._table_column.table.key
        else:
            schema, tname, colname = self._column_tokens
            return _get_table_key(tname, schema)

    target_fullname = property(_get_colspec)

    def references(self, table: Table) -> bool:
        

        return table.corresponding_column(self.column) is not None

    def get_referent(self, table: FromClause) -> Optional[Column[Any]]:
        
        
        
        
        return table.columns.corresponding_column(self.column)  

    @util.memoized_property
    def _column_tokens(self) -> Tuple[Optional[str], str, Optional[str]]:
        

        m = self._get_colspec().split(".")
        if m is None:
            raise exc.ArgumentError(
                f"Invalid foreign key column specification: {self._colspec}"
            )
        if len(m) == 1:
            tname = m.pop()
            colname = None
        else:
            colname = m.pop()
            tname = m.pop()

        
        
        
        
        
        
        
        

        if len(m) > 0:
            schema = ".".join(m)
        else:
            schema = None
        return schema, tname, colname

    def _resolve_col_tokens(self) -> Tuple[Table, str, Optional[str]]:
        if self.parent is None:
            raise exc.InvalidRequestError(
                "this ForeignKey object does not yet have a "
                "parent Column associated with it."
            )

        elif self.parent.table is None:
            raise exc.InvalidRequestError(
                "this ForeignKey's parent column is not yet associated "
                "with a Table."
            )

        parenttable = self.parent.table

        if self._unresolvable:
            schema, tname, colname = self._column_tokens
            tablekey = _get_table_key(tname, schema)
            return parenttable, tablekey, colname

        
        
        
        
        for c in self.parent.base_columns:
            if isinstance(c, Column):
                assert c.table is parenttable
                break
        else:
            assert False
        

        schema, tname, colname = self._column_tokens

        if schema is None and parenttable.metadata.schema is not None:
            schema = parenttable.metadata.schema

        tablekey = _get_table_key(tname, schema)
        return parenttable, tablekey, colname

    def _link_to_col_by_colstring(
        self, parenttable: Table, table: Table, colname: Optional[str]
    ) -> Column[Any]:
        _column = None
        if colname is None:
            
            
            
            
            
            
            parent = self.parent
            assert parent is not None
            key = parent.key
            _column = table.c.get(key, None)
        elif self.link_to_name:
            key = colname
            for c in table.c:
                if c.name == colname:
                    _column = c
        else:
            key = colname
            _column = table.c.get(colname, None)

        if _column is None:
            raise exc.NoReferencedColumnError(
                "Could not initialize target column "
                f"for ForeignKey '{self._colspec}' "
                f"on table '{parenttable.name}': "
                f"table '{table.name}' has no column named '{key}'",
                table.name,
                key,
            )

        return _column

    def _set_target_column(self, column: Column[Any]) -> None:
        assert self.parent is not None

        
        if self.parent.type._isnull:
            self.parent.type = column.type

        
        

        def set_type(fk: ForeignKey) -> None:
            if fk.parent.type._isnull:
                fk.parent.type = column.type

        self.parent._setup_on_memoized_fks(set_type)

        self.column = column  

    @util.ro_memoized_property
    def column(self) -> Column[Any]:
        

        return self._resolve_column()

    @overload
    def _resolve_column(
        self, *, raiseerr: Literal[True] = ...
    ) -> Column[Any]: ...

    @overload
    def _resolve_column(
        self, *, raiseerr: bool = ...
    ) -> Optional[Column[Any]]: ...

    def _resolve_column(
        self, *, raiseerr: bool = True
    ) -> Optional[Column[Any]]:
        _column: Column[Any]

        if isinstance(self._colspec, str):
            parenttable, tablekey, colname = self._resolve_col_tokens()

            if self._unresolvable or tablekey not in parenttable.metadata:
                if not raiseerr:
                    return None
                raise exc.NoReferencedTableError(
                    f"Foreign key associated with column "
                    f"'{self.parent}' could not find "
                    f"table '{tablekey}' with which to generate a "
                    f"foreign key to target column '{colname}'",
                    tablekey,
                )
            elif parenttable.key not in parenttable.metadata:
                if not raiseerr:
                    return None
                raise exc.InvalidRequestError(
                    f"Table {parenttable} is no longer associated with its "
                    "parent MetaData"
                )
            else:
                table = parenttable.metadata.tables[tablekey]
                return self._link_to_col_by_colstring(
                    parenttable, table, colname
                )

        elif hasattr(self._colspec, "__clause_element__"):
            _column = self._colspec.__clause_element__()
            return _column
        else:
            _column = self._colspec
            return _column

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        assert isinstance(parent, Column)

        if self.parent is not None and self.parent is not parent:
            raise exc.InvalidRequestError(
                "This ForeignKey already has a parent !"
            )
        self.parent = parent
        self.parent.foreign_keys.add(self)
        self.parent._on_table_attach(self._set_table)

    def _set_remote_table(self, table: Table) -> None:
        parenttable, _, colname = self._resolve_col_tokens()
        _column = self._link_to_col_by_colstring(parenttable, table, colname)
        self._set_target_column(_column)
        assert self.constraint is not None
        self.constraint._validate_dest_table(table)

    def _remove_from_metadata(self, metadata: MetaData) -> None:
        parenttable, table_key, colname = self._resolve_col_tokens()
        fk_key = (table_key, colname)

        if self in metadata._fk_memos[fk_key]:
            
            metadata._fk_memos[fk_key].remove(self)

    def _set_table(self, column: Column[Any], table: Table) -> None:
        
        
        assert isinstance(table, Table)
        if self.constraint is None:
            self.constraint = ForeignKeyConstraint(
                [],
                [],
                use_alter=self.use_alter,
                name=self.name,
                onupdate=self.onupdate,
                ondelete=self.ondelete,
                deferrable=self.deferrable,
                initially=self.initially,
                match=self.match,
                comment=self.comment,
                **self._unvalidated_dialect_kw,
            )
            self.constraint._append_element(column, self)
            self.constraint._set_parent_with_dispatch(table)
        table.foreign_keys.add(self)
        
        
        if isinstance(self._colspec, str):
            parenttable, table_key, colname = self._resolve_col_tokens()
            fk_key = (table_key, colname)
            if table_key in parenttable.metadata.tables:
                table = parenttable.metadata.tables[table_key]
                try:
                    _column = self._link_to_col_by_colstring(
                        parenttable, table, colname
                    )
                except exc.NoReferencedColumnError:
                    
                    pass
                else:
                    self._set_target_column(_column)

            parenttable.metadata._fk_memos[fk_key].append(self)
        elif hasattr(self._colspec, "__clause_element__"):
            _column = self._colspec.__clause_element__()
            self._set_target_column(_column)
        else:
            _column = self._colspec
            self._set_target_column(_column)


if TYPE_CHECKING:

    def default_is_sequence(
        obj: Optional[DefaultGenerator],
    ) -> TypeGuard[Sequence]: ...

    def default_is_clause_element(
        obj: Optional[DefaultGenerator],
    ) -> TypeGuard[ColumnElementColumnDefault]: ...

    def default_is_scalar(
        obj: Optional[DefaultGenerator],
    ) -> TypeGuard[ScalarElementColumnDefault]: ...

else:
    default_is_sequence = operator.attrgetter("is_sequence")

    default_is_clause_element = operator.attrgetter("is_clause_element")

    default_is_scalar = operator.attrgetter("is_scalar")


class DefaultGenerator(Executable, SchemaItem):
    

    __visit_name__ = "default_generator"

    _is_default_generator = True
    is_sequence = False
    is_identity = False
    is_server_default = False
    is_clause_element = False
    is_callable = False
    is_scalar = False
    has_arg = False
    is_sentinel = False
    column: Optional[Column[Any]]

    def __init__(self, for_update: bool = False) -> None:
        self.for_update = for_update

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        if TYPE_CHECKING:
            assert isinstance(parent, Column)
        self.column = parent
        if self.for_update:
            self.column.onupdate = self
        else:
            self.column.default = self

    def _copy(self) -> DefaultGenerator:
        raise NotImplementedError()

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Any:
        util.warn_deprecated(
            "Using the .execute() method to invoke a "
            "DefaultGenerator object is deprecated; please use "
            "the .scalar() method.",
            "2.0",
        )
        return self._execute_on_scalar(
            connection, distilled_params, execution_options
        )

    def _execute_on_scalar(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Any:
        return connection._execute_default(
            self, distilled_params, execution_options
        )


class ColumnDefault(DefaultGenerator, ABC):
    

    arg: Any

    @overload
    def __new__(
        cls, arg: Callable[..., Any], for_update: bool = ...
    ) -> CallableColumnDefault: ...

    @overload
    def __new__(
        cls, arg: ColumnElement[Any], for_update: bool = ...
    ) -> ColumnElementColumnDefault: ...

    
    
    
    @overload
    def __new__(cls, arg: object, for_update: bool = ...) -> ColumnDefault: ...

    def __new__(
        cls, arg: Any = None, for_update: bool = False
    ) -> ColumnDefault:
        

        if isinstance(arg, FetchedValue):
            raise exc.ArgumentError(
                "ColumnDefault may not be a server-side default type."
            )
        elif callable(arg):
            cls = CallableColumnDefault
        elif isinstance(arg, ClauseElement):
            cls = ColumnElementColumnDefault
        elif arg is not None:
            cls = ScalarElementColumnDefault

        return object.__new__(cls)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self.arg!r})"


class ScalarElementColumnDefault(ColumnDefault):
    

    is_scalar = True
    has_arg = True

    def __init__(self, arg: Any, for_update: bool = False) -> None:
        self.for_update = for_update
        self.arg = arg

    def _copy(self) -> ScalarElementColumnDefault:
        return ScalarElementColumnDefault(
            arg=self.arg, for_update=self.for_update
        )


class _InsertSentinelColumnDefault(ColumnDefault):
    

    is_sentinel = True
    for_update = False
    arg = None

    def __new__(cls) -> _InsertSentinelColumnDefault:
        return object.__new__(cls)

    def __init__(self) -> None:
        pass

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        col = cast("Column[Any]", parent)
        if not col._insert_sentinel:
            raise exc.ArgumentError(
                "The _InsertSentinelColumnDefault may only be applied to a "
                "Column marked as insert_sentinel=True"
            )
        elif not col.nullable:
            raise exc.ArgumentError(
                "The _InsertSentinelColumnDefault may only be applied to a "
                "Column that is nullable"
            )

        super()._set_parent(parent, **kw)

    def _copy(self) -> _InsertSentinelColumnDefault:
        return _InsertSentinelColumnDefault()


_SQLExprDefault = Union["ColumnElement[Any]", "TextClause"]


class ColumnElementColumnDefault(ColumnDefault):
    

    is_clause_element = True
    has_arg = True
    arg: _SQLExprDefault

    def __init__(
        self,
        arg: _SQLExprDefault,
        for_update: bool = False,
    ) -> None:
        self.for_update = for_update
        self.arg = arg

    def _copy(self) -> ColumnElementColumnDefault:
        return ColumnElementColumnDefault(
            arg=self.arg, for_update=self.for_update
        )

    @util.memoized_property
    @util.preload_module("sqlalchemy.sql.sqltypes")
    def _arg_is_typed(self) -> bool:
        sqltypes = util.preloaded.sql_sqltypes

        return not isinstance(self.arg.type, sqltypes.NullType)


class _CallableColumnDefaultProtocol(Protocol):
    def __call__(self, context: ExecutionContext) -> Any: ...


class CallableColumnDefault(ColumnDefault):
    

    is_callable = True
    arg: _CallableColumnDefaultProtocol
    has_arg = True

    def __init__(
        self,
        arg: Union[_CallableColumnDefaultProtocol, Callable[[], Any]],
        for_update: bool = False,
    ) -> None:
        self.for_update = for_update
        self.arg = self._maybe_wrap_callable(arg)

    def _copy(self) -> CallableColumnDefault:
        return CallableColumnDefault(arg=self.arg, for_update=self.for_update)

    def _maybe_wrap_callable(
        self, fn: Union[_CallableColumnDefaultProtocol, Callable[[], Any]]
    ) -> _CallableColumnDefaultProtocol:
        

        try:
            argspec = util.get_callable_argspec(fn, no_self=True)
        except TypeError:
            return util.wrap_callable(lambda ctx: fn(), fn)  

        defaulted = argspec[3] is not None and len(argspec[3]) or 0
        positionals = len(argspec[0]) - defaulted

        if positionals == 0:
            return util.wrap_callable(lambda ctx: fn(), fn)  

        elif positionals == 1:
            return fn  
        else:
            raise exc.ArgumentError(
                "ColumnDefault Python function takes zero or one "
                "positional arguments"
            )


class IdentityOptions:
    

    def __init__(
        self,
        start: Optional[int] = None,
        increment: Optional[int] = None,
        minvalue: Optional[int] = None,
        maxvalue: Optional[int] = None,
        nominvalue: Optional[bool] = None,
        nomaxvalue: Optional[bool] = None,
        cycle: Optional[bool] = None,
        cache: Optional[int] = None,
        order: Optional[bool] = None,
    ) -> None:
        
        self.start = start
        self.increment = increment
        self.minvalue = minvalue
        self.maxvalue = maxvalue
        self.nominvalue = nominvalue
        self.nomaxvalue = nomaxvalue
        self.cycle = cycle
        self.cache = cache
        self.order = order

    @property
    def _increment_is_negative(self) -> bool:
        return self.increment is not None and self.increment < 0


class Sequence(HasSchemaAttr, IdentityOptions, DefaultGenerator):
    

    __visit_name__ = "sequence"

    is_sequence = True

    column: Optional[Column[Any]]
    data_type: Optional[TypeEngine[int]]

    def __init__(
        self,
        name: str,
        start: Optional[int] = None,
        increment: Optional[int] = None,
        minvalue: Optional[int] = None,
        maxvalue: Optional[int] = None,
        nominvalue: Optional[bool] = None,
        nomaxvalue: Optional[bool] = None,
        cycle: Optional[bool] = None,
        schema: Optional[Union[str, Literal[SchemaConst.BLANK_SCHEMA]]] = None,
        cache: Optional[int] = None,
        order: Optional[bool] = None,
        data_type: Optional[_TypeEngineArgument[int]] = None,
        optional: bool = False,
        quote: Optional[bool] = None,
        metadata: Optional[MetaData] = None,
        quote_schema: Optional[bool] = None,
        for_update: bool = False,
    ) -> None:
        
        DefaultGenerator.__init__(self, for_update=for_update)
        IdentityOptions.__init__(
            self,
            start=start,
            increment=increment,
            minvalue=minvalue,
            maxvalue=maxvalue,
            nominvalue=nominvalue,
            nomaxvalue=nomaxvalue,
            cycle=cycle,
            cache=cache,
            order=order,
        )
        self.column = None
        self.name = quoted_name(name, quote)
        self.optional = optional
        if schema is BLANK_SCHEMA:
            self.schema = schema = None
        elif metadata is not None and schema is None and metadata.schema:
            self.schema = schema = metadata.schema
        else:
            self.schema = quoted_name.construct(schema, quote_schema)
        self.metadata = metadata
        self._key = _get_table_key(name, schema)
        if metadata:
            self._set_metadata(metadata)
        if data_type is not None:
            self.data_type = to_instance(data_type)
        else:
            self.data_type = None

    @util.preload_module("sqlalchemy.sql.functions")
    def next_value(self) -> Function[int]:
        
        return util.preloaded.sql_functions.func.next_value(self)

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        column = parent
        assert isinstance(column, Column)
        super()._set_parent(column)
        column._on_table_attach(self._set_table)

    def _copy(self) -> Sequence:
        return Sequence(
            name=self.name,
            start=self.start,
            increment=self.increment,
            minvalue=self.minvalue,
            maxvalue=self.maxvalue,
            nominvalue=self.nominvalue,
            nomaxvalue=self.nomaxvalue,
            cycle=self.cycle,
            schema=self.schema,
            cache=self.cache,
            order=self.order,
            data_type=self.data_type,
            optional=self.optional,
            metadata=self.metadata,
            for_update=self.for_update,
        )

    def _set_table(self, column: Column[Any], table: Table) -> None:
        self._set_metadata(table.metadata)

    def _set_metadata(self, metadata: MetaData) -> None:
        self.metadata = metadata
        self.metadata._sequences[self._key] = self

    def create(self, bind: _CreateDropBind, checkfirst: bool = True) -> None:
        

        bind._run_ddl_visitor(ddl.SchemaGenerator, self, checkfirst=checkfirst)

    def drop(self, bind: _CreateDropBind, checkfirst: bool = True) -> None:
        

        bind._run_ddl_visitor(ddl.SchemaDropper, self, checkfirst=checkfirst)

    def _not_a_column_expr(self) -> NoReturn:
        raise exc.InvalidRequestError(
            f"This {self.__class__.__name__} cannot be used directly "
            "as a column expression.  Use func.next_value(sequence) "
            "to produce a 'next value' function that's usable "
            "as a column element."
        )


@inspection._self_inspects
class FetchedValue(SchemaEventTarget):
    

    is_server_default = True
    reflected = False
    has_argument = False
    is_clause_element = False
    is_identity = False

    column: Optional[Column[Any]]

    def __init__(self, for_update: bool = False) -> None:
        self.for_update = for_update

    def _as_for_update(self, for_update: bool) -> FetchedValue:
        if for_update == self.for_update:
            return self
        else:
            return self._clone(for_update)

    def _copy(self) -> FetchedValue:
        return FetchedValue(self.for_update)

    def _clone(self, for_update: bool) -> Self:
        n = self.__class__.__new__(self.__class__)
        n.__dict__.update(self.__dict__)
        n.__dict__.pop("column", None)
        n.for_update = for_update
        return n

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        column = parent
        assert isinstance(column, Column)
        self.column = column
        if self.for_update:
            self.column.server_onupdate = self
        else:
            self.column.server_default = self

    def __repr__(self) -> str:
        return util.generic_repr(self)


class DefaultClause(FetchedValue):
    

    has_argument = True

    def __init__(
        self,
        arg: Union[str, ClauseElement, TextClause],
        for_update: bool = False,
        _reflected: bool = False,
    ) -> None:
        util.assert_arg_type(arg, (str, ClauseElement, TextClause), "arg")
        super().__init__(for_update)
        self.arg = arg
        self.reflected = _reflected

    def _copy(self) -> DefaultClause:
        return DefaultClause(
            arg=self.arg, for_update=self.for_update, _reflected=self.reflected
        )

    def __repr__(self) -> str:
        return "DefaultClause(%r, for_update=%r)" % (self.arg, self.for_update)


class Constraint(DialectKWArgs, HasConditionalDDL, SchemaItem):
    

    __visit_name__ = "constraint"

    _creation_order: int
    _column_flag: bool

    def __init__(
        self,
        name: _ConstraintNameArgument = None,
        deferrable: Optional[bool] = None,
        initially: Optional[str] = None,
        info: Optional[_InfoType] = None,
        comment: Optional[str] = None,
        _create_rule: Optional[Any] = None,
        _type_bound: bool = False,
        **dialect_kw: Any,
    ) -> None:
        r

        self.name = name
        self.deferrable = deferrable
        self.initially = initially
        if info:
            self.info = info
        self._create_rule = _create_rule
        self._type_bound = _type_bound
        util.set_creation_order(self)
        self._validate_dialect_kwargs(dialect_kw)
        self.comment = comment

    def _should_create_for_compiler(
        self, compiler: DDLCompiler, **kw: Any
    ) -> bool:
        if self._create_rule is not None and not self._create_rule(compiler):
            return False
        elif self._ddl_if is not None:
            return self._ddl_if._should_execute(
                ddl.CreateConstraint(self), self, None, compiler=compiler, **kw
            )
        else:
            return True

    @property
    def table(self) -> Table:
        try:
            if isinstance(self.parent, Table):
                return self.parent
        except AttributeError:
            pass
        raise exc.InvalidRequestError(
            "This constraint is not bound to a table.  Did you "
            "mean to call table.append_constraint(constraint) ?"
        )

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        assert isinstance(parent, (Table, Column))
        self.parent = parent
        parent.constraints.add(self)

    @util.deprecated(
        "1.4",
        "The :meth:`_schema.Constraint.copy` method is deprecated "
        "and will be removed in a future release.",
    )
    def copy(self, **kw: Any) -> Self:
        return self._copy(**kw)

    def _copy(self, **kw: Any) -> Self:
        raise NotImplementedError()


class ColumnCollectionMixin:
    

    _columns: DedupeColumnCollection[Column[Any]]

    _allow_multiple_tables = False

    _pending_colargs: List[Optional[Union[str, Column[Any]]]]

    if TYPE_CHECKING:

        def _set_parent_with_dispatch(
            self, parent: SchemaEventTarget, **kw: Any
        ) -> None: ...

    def __init__(
        self,
        *columns: _DDLColumnArgument,
        _autoattach: bool = True,
        _column_flag: bool = False,
        _gather_expressions: Optional[
            List[Union[str, ColumnElement[Any]]]
        ] = None,
    ) -> None:
        self._column_flag = _column_flag
        self._columns = DedupeColumnCollection()

        processed_expressions: Optional[
            List[Union[ColumnElement[Any], str]]
        ] = _gather_expressions

        if processed_expressions is not None:

            
            assert not processed_expressions

            self._pending_colargs = []
            for (
                expr,
                _,
                _,
                add_element,
            ) in coercions.expect_col_expression_collection(
                roles.DDLConstraintColumnRole, columns
            ):
                self._pending_colargs.append(add_element)
                processed_expressions.append(expr)
        else:
            self._pending_colargs = [
                coercions.expect(roles.DDLConstraintColumnRole, column)
                for column in columns
            ]

        if _autoattach and self._pending_colargs:
            self._check_attach()

    def _check_attach(self, evt: bool = False) -> None:
        col_objs = [c for c in self._pending_colargs if isinstance(c, Column)]

        cols_w_table = [c for c in col_objs if isinstance(c.table, Table)]

        cols_wo_table = set(col_objs).difference(cols_w_table)
        if cols_wo_table:
            
            
            assert not evt, "Should not reach here on event call"

            
            
            has_string_cols = {
                c for c in self._pending_colargs if c is not None
            }.difference(col_objs)
            if not has_string_cols:

                def _col_attached(column: Column[Any], table: Table) -> None:
                    
                    
                    
                    if isinstance(table, Table):
                        cols_wo_table.discard(column)
                        if not cols_wo_table:
                            self._check_attach(evt=True)

                self._cols_wo_table = cols_wo_table
                for col in cols_wo_table:
                    col._on_table_attach(_col_attached)
                return

        columns = cols_w_table

        tables = {c.table for c in columns}
        if len(tables) == 1:
            self._set_parent_with_dispatch(tables.pop())
        elif len(tables) > 1 and not self._allow_multiple_tables:
            table = columns[0].table
            others = [c for c in columns[1:] if c.table is not table]
            if others:
                
                other_str = ", ".join("'%s'" % c for c in others)
                raise exc.ArgumentError(
                    f"Column(s) {other_str} "
                    f"are not part of table '{table.description}'."
                )

    @util.ro_memoized_property
    def columns(self) -> ReadOnlyColumnCollection[str, Column[Any]]:
        return self._columns.as_readonly()

    @util.ro_memoized_property
    def c(self) -> ReadOnlyColumnCollection[str, Column[Any]]:
        return self._columns.as_readonly()

    def _col_expressions(
        self, parent: Union[Table, Column[Any]]
    ) -> List[Optional[Column[Any]]]:
        if isinstance(parent, Column):
            result: List[Optional[Column[Any]]] = [
                c for c in self._pending_colargs if isinstance(c, Column)
            ]
            assert len(result) == len(self._pending_colargs)
            return result
        else:
            try:
                return [
                    parent.c[col] if isinstance(col, str) else col
                    for col in self._pending_colargs
                ]
            except KeyError as ke:
                raise exc.ConstraintColumnNotFoundError(
                    f"Can't create {self.__class__.__name__} "
                    f"on table '{parent.description}': no column "
                    f"named '{ke.args[0]}' is present."
                ) from ke

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        assert isinstance(parent, (Table, Column))

        for col in self._col_expressions(parent):
            if col is not None:
                self._columns.add(col)


class ColumnCollectionConstraint(ColumnCollectionMixin, Constraint):
    

    def __init__(
        self,
        *columns: _DDLColumnArgument,
        name: _ConstraintNameArgument = None,
        deferrable: Optional[bool] = None,
        initially: Optional[str] = None,
        info: Optional[_InfoType] = None,
        _autoattach: bool = True,
        _column_flag: bool = False,
        _gather_expressions: Optional[List[_DDLColumnArgument]] = None,
        **dialect_kw: Any,
    ) -> None:
        r
        Constraint.__init__(
            self,
            name=name,
            deferrable=deferrable,
            initially=initially,
            info=info,
            **dialect_kw,
        )
        ColumnCollectionMixin.__init__(
            self, *columns, _autoattach=_autoattach, _column_flag=_column_flag
        )

    columns: ReadOnlyColumnCollection[str, Column[Any]]
    

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        assert isinstance(parent, (Column, Table))
        Constraint._set_parent(self, parent)
        ColumnCollectionMixin._set_parent(self, parent)

    def __contains__(self, x: Any) -> bool:
        return x in self._columns

    @util.deprecated(
        "1.4",
        "The :meth:`_schema.ColumnCollectionConstraint.copy` method "
        "is deprecated and will be removed in a future release.",
    )
    def copy(
        self,
        *,
        target_table: Optional[Table] = None,
        **kw: Any,
    ) -> ColumnCollectionConstraint:
        return self._copy(target_table=target_table, **kw)

    def _copy(
        self,
        *,
        target_table: Optional[Table] = None,
        **kw: Any,
    ) -> ColumnCollectionConstraint:
        
        constraint_kwargs = {}
        for dialect_name in self.dialect_options:
            dialect_options = self.dialect_options[dialect_name]._non_defaults
            for (
                dialect_option_key,
                dialect_option_value,
            ) in dialect_options.items():
                constraint_kwargs[dialect_name + "_" + dialect_option_key] = (
                    dialect_option_value
                )

        assert isinstance(self.parent, Table)
        c = self.__class__(
            name=self.name,
            deferrable=self.deferrable,
            initially=self.initially,
            *[
                _copy_expression(expr, self.parent, target_table)
                for expr in self._columns
            ],
            comment=self.comment,
            **constraint_kwargs,
        )
        return self._schema_item_copy(c)

    def contains_column(self, col: Column[Any]) -> bool:
        

        return self._columns.contains_column(col)

    def __iter__(self) -> Iterator[Column[Any]]:
        return iter(self._columns)

    def __len__(self) -> int:
        return len(self._columns)


class CheckConstraint(ColumnCollectionConstraint):
    

    _allow_multiple_tables = True

    __visit_name__ = "table_or_column_check_constraint"

    @_document_text_coercion(
        "sqltext",
        ":class:`.CheckConstraint`",
        ":paramref:`.CheckConstraint.sqltext`",
    )
    def __init__(
        self,
        sqltext: _TextCoercedExpressionArgument[Any],
        name: _ConstraintNameArgument = None,
        deferrable: Optional[bool] = None,
        initially: Optional[str] = None,
        table: Optional[Table] = None,
        info: Optional[_InfoType] = None,
        _create_rule: Optional[Any] = None,
        _autoattach: bool = True,
        _type_bound: bool = False,
        **dialect_kw: Any,
    ) -> None:
        r

        self.sqltext = coercions.expect(roles.DDLExpressionRole, sqltext)
        columns: List[Column[Any]] = []
        visitors.traverse(self.sqltext, {}, {"column": columns.append})

        super().__init__(
            name=name,
            deferrable=deferrable,
            initially=initially,
            _create_rule=_create_rule,
            info=info,
            _type_bound=_type_bound,
            _autoattach=_autoattach,
            *columns,
            **dialect_kw,
        )
        if table is not None:
            self._set_parent_with_dispatch(table)

    @property
    def is_column_level(self) -> bool:
        return not isinstance(self.parent, Table)

    @util.deprecated(
        "1.4",
        "The :meth:`_schema.CheckConstraint.copy` method is deprecated "
        "and will be removed in a future release.",
    )
    def copy(
        self, *, target_table: Optional[Table] = None, **kw: Any
    ) -> CheckConstraint:
        return self._copy(target_table=target_table, **kw)

    def _copy(
        self, *, target_table: Optional[Table] = None, **kw: Any
    ) -> CheckConstraint:
        if target_table is not None:
            
            
            
            sqltext = _copy_expression(self.sqltext, self.table, target_table)
        else:
            sqltext = self.sqltext
        c = CheckConstraint(
            sqltext,
            name=self.name,
            initially=self.initially,
            deferrable=self.deferrable,
            _create_rule=self._create_rule,
            table=target_table,
            comment=self.comment,
            _autoattach=False,
            _type_bound=self._type_bound,
        )
        return self._schema_item_copy(c)


class ForeignKeyConstraint(ColumnCollectionConstraint):
    

    __visit_name__ = "foreign_key_constraint"

    def __init__(
        self,
        columns: _typing_Sequence[_DDLColumnArgument],
        refcolumns: _typing_Sequence[_DDLColumnArgument],
        name: _ConstraintNameArgument = None,
        onupdate: Optional[str] = None,
        ondelete: Optional[str] = None,
        deferrable: Optional[bool] = None,
        initially: Optional[str] = None,
        use_alter: bool = False,
        link_to_name: bool = False,
        match: Optional[str] = None,
        table: Optional[Table] = None,
        info: Optional[_InfoType] = None,
        comment: Optional[str] = None,
        **dialect_kw: Any,
    ) -> None:
        r

        Constraint.__init__(
            self,
            name=name,
            deferrable=deferrable,
            initially=initially,
            info=info,
            comment=comment,
            **dialect_kw,
        )
        self.onupdate = onupdate
        self.ondelete = ondelete
        self.link_to_name = link_to_name
        self.use_alter = use_alter
        self.match = match

        if len(set(columns)) != len(refcolumns):
            if len(set(columns)) != len(columns):
                
                raise exc.ArgumentError(
                    "ForeignKeyConstraint with duplicate source column "
                    "references are not supported."
                )
            else:
                
                
                
                raise exc.ArgumentError(
                    "ForeignKeyConstraint number "
                    "of constrained columns must match the number of "
                    "referenced columns."
                )

        
        
        
        
        self.elements = [
            ForeignKey(
                refcol,
                _constraint=self,
                name=self.name,
                onupdate=self.onupdate,
                ondelete=self.ondelete,
                use_alter=self.use_alter,
                link_to_name=self.link_to_name,
                match=self.match,
                deferrable=self.deferrable,
                initially=self.initially,
                **self.dialect_kwargs,
            )
            for refcol in refcolumns
        ]

        ColumnCollectionMixin.__init__(self, *columns)
        if table is not None:
            if hasattr(self, "parent"):
                assert table is self.parent
            self._set_parent_with_dispatch(table)

    def _append_element(self, column: Column[Any], fk: ForeignKey) -> None:
        self._columns.add(column)
        self.elements.append(fk)

    columns: ReadOnlyColumnCollection[str, Column[Any]]
    

    elements: List[ForeignKey]
    

    @property
    def _elements(self) -> util.OrderedDict[str, ForeignKey]:
        
        return util.OrderedDict(zip(self.column_keys, self.elements))

    @property
    def _referred_schema(self) -> Optional[str]:
        for elem in self.elements:
            return elem._referred_schema
        else:
            return None

    @property
    def referred_table(self) -> Table:
        
        return self.elements[0].column.table

    def _validate_dest_table(self, table: Table) -> None:
        table_keys = {elem._table_key() for elem in self.elements}
        if None not in table_keys and len(table_keys) > 1:
            elem0, elem1 = sorted(table_keys)[0:2]
            raise exc.ArgumentError(
                f"ForeignKeyConstraint on "
                f"{table.fullname}({self._col_description}) refers to "
                f"multiple remote tables: {elem0} and {elem1}"
            )

    @property
    def column_keys(self) -> _typing_Sequence[str]:
        
        if hasattr(self, "parent"):
            return self._columns.keys()
        else:
            return [
                col.key if isinstance(col, ColumnElement) else str(col)
                for col in self._pending_colargs
            ]

    @property
    def _col_description(self) -> str:
        return ", ".join(self.column_keys)

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        table = parent
        assert isinstance(table, Table)
        Constraint._set_parent(self, table)

        ColumnCollectionConstraint._set_parent(self, table)

        for col, fk in zip(self._columns, self.elements):
            if not hasattr(fk, "parent") or fk.parent is not col:
                fk._set_parent_with_dispatch(col)

        self._validate_dest_table(table)

    @util.deprecated(
        "1.4",
        "The :meth:`_schema.ForeignKeyConstraint.copy` method is deprecated "
        "and will be removed in a future release.",
    )
    def copy(
        self,
        *,
        schema: Optional[str] = None,
        target_table: Optional[Table] = None,
        **kw: Any,
    ) -> ForeignKeyConstraint:
        return self._copy(schema=schema, target_table=target_table, **kw)

    def _copy(
        self,
        *,
        schema: Optional[str] = None,
        target_table: Optional[Table] = None,
        **kw: Any,
    ) -> ForeignKeyConstraint:
        fkc = ForeignKeyConstraint(
            [x.parent.key for x in self.elements],
            [
                x._get_colspec(
                    schema=schema,
                    table_name=(
                        target_table.name
                        if target_table is not None
                        and x._table_key() == x.parent.table.key
                        else None
                    ),
                    _is_copy=True,
                )
                for x in self.elements
            ],
            name=self.name,
            onupdate=self.onupdate,
            ondelete=self.ondelete,
            use_alter=self.use_alter,
            deferrable=self.deferrable,
            initially=self.initially,
            link_to_name=self.link_to_name,
            match=self.match,
            comment=self.comment,
        )
        for self_fk, other_fk in zip(self.elements, fkc.elements):
            self_fk._schema_item_copy(other_fk)
        return self._schema_item_copy(fkc)


class PrimaryKeyConstraint(ColumnCollectionConstraint):
    

    __visit_name__ = "primary_key_constraint"

    def __init__(
        self,
        *columns: _DDLColumnArgument,
        name: Optional[str] = None,
        deferrable: Optional[bool] = None,
        initially: Optional[str] = None,
        info: Optional[_InfoType] = None,
        _implicit_generated: bool = False,
        **dialect_kw: Any,
    ) -> None:
        self._implicit_generated = _implicit_generated
        super().__init__(
            *columns,
            name=name,
            deferrable=deferrable,
            initially=initially,
            info=info,
            **dialect_kw,
        )

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        table = parent
        assert isinstance(table, Table)
        super()._set_parent(table)

        if table.primary_key is not self:
            table.constraints.discard(table.primary_key)
            table.primary_key = self  
            table.constraints.add(self)

        table_pks = [c for c in table.c if c.primary_key]
        if (
            self._columns
            and table_pks
            and set(table_pks) != set(self._columns)
        ):
            
            table_pk_str = ", ".join("'%s'" % c.name for c in table_pks)
            col_str = ", ".join("'%s'" % c.name for c in self._columns)

            util.warn(
                f"Table '{table.name}' specifies columns "
                f"{table_pk_str} as "
                f"primary_key=True, "
                f"not matching locally specified columns {col_str}; "
                f"setting the "
                f"current primary key columns to "
                f"{col_str}. "
                f"This warning "
                f"may become an exception in a future release"
            )
            table_pks[:] = []

        for c in self._columns:
            c.primary_key = True
            if c._user_defined_nullable is NULL_UNSPECIFIED:
                c.nullable = False
        if table_pks:
            self._columns.extend(table_pks)

    def _reload(self, columns: Iterable[Column[Any]]) -> None:
        
        
        
        
        for col in columns:
            col.primary_key = True

        self._columns.extend(columns)

        PrimaryKeyConstraint._autoincrement_column._reset(self)  
        self._set_parent_with_dispatch(self.table)

    def _replace(self, col: Column[Any]) -> None:
        PrimaryKeyConstraint._autoincrement_column._reset(self)  
        self._columns.replace(col)

        self.dispatch._sa_event_column_added_to_pk_constraint(self, col)

    @property
    def columns_autoinc_first(self) -> List[Column[Any]]:
        autoinc = self._autoincrement_column

        if autoinc is not None:
            return [autoinc] + [c for c in self._columns if c is not autoinc]
        else:
            return list(self._columns)

    @util.ro_memoized_property
    def _autoincrement_column(self) -> Optional[Column[int]]:
        def _validate_autoinc(col: Column[Any], autoinc_true: bool) -> bool:
            if col.type._type_affinity is None or not issubclass(
                col.type._type_affinity,
                (
                    type_api.INTEGERTYPE._type_affinity,
                    type_api.NUMERICTYPE._type_affinity,
                ),
            ):
                if autoinc_true:
                    raise exc.ArgumentError(
                        f"Column type {col.type} on column '{col}' is not "
                        f"compatible with autoincrement=True"
                    )
                else:
                    return False
            elif (
                not isinstance(col.default, (type(None), Sequence))
                and not autoinc_true
            ):
                return False
            elif (
                col.server_default is not None
                and not isinstance(col.server_default, Identity)
                and not autoinc_true
            ):
                return False
            elif col.foreign_keys and col.autoincrement not in (
                True,
                "ignore_fk",
            ):
                return False
            return True

        if len(self._columns) == 1:
            col = list(self._columns)[0]

            if col.autoincrement is True:
                _validate_autoinc(col, True)
                return col
            elif col.autoincrement in (
                "auto",
                "ignore_fk",
            ) and _validate_autoinc(col, False):
                return col
            else:
                return None

        else:
            autoinc = None
            for col in self._columns:
                if col.autoincrement is True:
                    _validate_autoinc(col, True)
                    if autoinc is not None:
                        raise exc.ArgumentError(
                            f"Only one Column may be marked "
                            f"autoincrement=True, found both "
                            f"{col.name} and {autoinc.name}."
                        )
                    else:
                        autoinc = col

            return autoinc


class UniqueConstraint(ColumnCollectionConstraint):
    

    __visit_name__ = "unique_constraint"


class Index(
    DialectKWArgs, ColumnCollectionMixin, HasConditionalDDL, SchemaItem
):
    

    __visit_name__ = "index"

    table: Optional[Table]
    expressions: _typing_Sequence[Union[str, ColumnElement[Any]]]
    _table_bound_expressions: _typing_Sequence[ColumnElement[Any]]

    def __init__(
        self,
        name: Optional[str],
        *expressions: _DDLColumnArgument,
        unique: bool = False,
        quote: Optional[bool] = None,
        info: Optional[_InfoType] = None,
        _table: Optional[Table] = None,
        _column_flag: bool = False,
        **dialect_kw: Any,
    ) -> None:
        r
        self.table = table = None

        self.name = quoted_name.construct(name, quote)
        self.unique = unique
        if info is not None:
            self.info = info

        
        
        if _table is not None:
            table = _table

        self._validate_dialect_kwargs(dialect_kw)

        self.expressions = []
        
        
        ColumnCollectionMixin.__init__(
            self,
            *expressions,
            _column_flag=_column_flag,
            _gather_expressions=self.expressions,
        )
        if table is not None:
            self._set_parent(table)

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        table = parent
        assert isinstance(table, Table)
        ColumnCollectionMixin._set_parent(self, table)

        if self.table is not None and table is not self.table:
            raise exc.ArgumentError(
                f"Index '{self.name}' is against table "
                f"'{self.table.description}', and "
                f"cannot be associated with table '{table.description}'."
            )
        self.table = table
        table.indexes.add(self)

        expressions = self.expressions
        col_expressions = self._col_expressions(table)
        assert len(expressions) == len(col_expressions)

        exprs = []
        for expr, colexpr in zip(expressions, col_expressions):
            if isinstance(expr, ClauseElement):
                exprs.append(expr)
            elif colexpr is not None:
                exprs.append(colexpr)
            else:
                assert False
        self.expressions = self._table_bound_expressions = exprs

    def create(self, bind: _CreateDropBind, checkfirst: bool = False) -> None:
        
        bind._run_ddl_visitor(ddl.SchemaGenerator, self, checkfirst=checkfirst)

    def drop(self, bind: _CreateDropBind, checkfirst: bool = False) -> None:
        
        bind._run_ddl_visitor(ddl.SchemaDropper, self, checkfirst=checkfirst)

    def __repr__(self) -> str:
        exprs: _typing_Sequence[Any]  

        return "Index(%s)" % (
            ", ".join(
                [repr(self.name)]
                + [repr(e) for e in self.expressions]
                + (self.unique and ["unique=True"] or [])
            )
        )


_NamingSchemaCallable = Callable[[Constraint, Table], str]
_NamingSchemaDirective = Union[str, _NamingSchemaCallable]


class _NamingSchemaTD(TypedDict, total=False):
    fk: _NamingSchemaDirective
    pk: _NamingSchemaDirective
    ix: _NamingSchemaDirective
    ck: _NamingSchemaDirective
    uq: _NamingSchemaDirective


_NamingSchemaParameter = Union[
    
    
    _NamingSchemaTD,
    
    
    
    Mapping[Any, _NamingSchemaDirective],
]


DEFAULT_NAMING_CONVENTION: _NamingSchemaParameter = util.immutabledict(
    {"ix": "ix_%(column_0_label)s"}
)


class MetaData(HasSchemaAttr):
    

    __visit_name__ = "metadata"

    def __init__(
        self,
        schema: Optional[str] = None,
        quote_schema: Optional[bool] = None,
        naming_convention: Optional[_NamingSchemaParameter] = None,
        info: Optional[_InfoType] = None,
    ) -> None:
        
        if schema is not None and not isinstance(schema, str):
            raise exc.ArgumentError(
                "expected schema argument to be a string, "
                f"got {type(schema)}."
            )
        self.tables = util.FacadeDict()
        self.schema = quoted_name.construct(schema, quote_schema)
        self.naming_convention = (
            naming_convention
            if naming_convention
            else DEFAULT_NAMING_CONVENTION
        )
        if info:
            self.info = info
        self._schemas: Set[str] = set()
        self._sequences: Dict[str, Sequence] = {}
        self._fk_memos: Dict[Tuple[str, Optional[str]], List[ForeignKey]] = (
            collections.defaultdict(list)
        )

    tables: util.FacadeDict[str, Table]
    

    def __repr__(self) -> str:
        return "MetaData()"

    def __contains__(self, table_or_key: Union[str, Table]) -> bool:
        if not isinstance(table_or_key, str):
            table_or_key = table_or_key.key
        return table_or_key in self.tables

    def _add_table(
        self, name: str, schema: Optional[str], table: Table
    ) -> None:
        key = _get_table_key(name, schema)
        self.tables._insert_item(key, table)
        if schema:
            self._schemas.add(schema)

    def _remove_table(self, name: str, schema: Optional[str]) -> None:
        key = _get_table_key(name, schema)
        removed = dict.pop(self.tables, key, None)
        if removed is not None:
            for fk in removed.foreign_keys:
                fk._remove_from_metadata(self)
        if self._schemas:
            self._schemas = {
                t.schema for t in self.tables.values() if t.schema is not None
            }

    def __getstate__(self) -> Dict[str, Any]:
        return {
            "tables": self.tables,
            "schema": self.schema,
            "schemas": self._schemas,
            "sequences": self._sequences,
            "fk_memos": self._fk_memos,
            "naming_convention": self.naming_convention,
        }

    def __setstate__(self, state: Dict[str, Any]) -> None:
        self.tables = state["tables"]
        self.schema = state["schema"]
        self.naming_convention = state["naming_convention"]
        self._sequences = state["sequences"]
        self._schemas = state["schemas"]
        self._fk_memos = state["fk_memos"]

    def clear(self) -> None:
        

        dict.clear(self.tables)
        self._schemas.clear()
        self._fk_memos.clear()

    def remove(self, table: Table) -> None:
        

        self._remove_table(table.name, table.schema)

    @property
    def sorted_tables(self) -> List[Table]:
        
        return ddl.sort_tables(
            sorted(self.tables.values(), key=lambda t: t.key)  
        )

    
    
    @overload
    def reflect(
        self,
        bind: Engine,
        schema: Optional[str] = ...,
        views: bool = ...,
        only: Union[
            _typing_Sequence[str], Callable[[str, MetaData], bool], None
        ] = ...,
        extend_existing: bool = ...,
        autoload_replace: bool = ...,
        resolve_fks: bool = ...,
        **dialect_kwargs: Any,
    ) -> None: ...

    @overload
    def reflect(
        self,
        bind: Connection,
        schema: Optional[str] = ...,
        views: bool = ...,
        only: Union[
            _typing_Sequence[str], Callable[[str, MetaData], bool], None
        ] = ...,
        extend_existing: bool = ...,
        autoload_replace: bool = ...,
        resolve_fks: bool = ...,
        **dialect_kwargs: Any,
    ) -> None: ...

    @util.preload_module("sqlalchemy.engine.reflection")
    def reflect(
        self,
        bind: Union[Engine, Connection],
        schema: Optional[str] = None,
        views: bool = False,
        only: Union[
            _typing_Sequence[str], Callable[[str, MetaData], bool], None
        ] = None,
        extend_existing: bool = False,
        autoload_replace: bool = True,
        resolve_fks: bool = True,
        **dialect_kwargs: Any,
    ) -> None:
        r

        with inspection.inspect(bind)._inspection_context() as insp:
            reflect_opts: Any = {
                "autoload_with": insp,
                "extend_existing": extend_existing,
                "autoload_replace": autoload_replace,
                "resolve_fks": resolve_fks,
                "_extend_on": set(),
            }

            reflect_opts.update(dialect_kwargs)

            if schema is None:
                schema = self.schema

            if schema is not None:
                reflect_opts["schema"] = schema

            kind = util.preloaded.engine_reflection.ObjectKind.TABLE
            available: util.OrderedSet[str] = util.OrderedSet(
                insp.get_table_names(schema)
            )
            if views:
                kind = util.preloaded.engine_reflection.ObjectKind.ANY
                available.update(insp.get_view_names(schema))
                try:
                    available.update(insp.get_materialized_view_names(schema))
                except NotImplementedError:
                    pass

            if schema is not None:
                available_w_schema: util.OrderedSet[str] = util.OrderedSet(
                    [f"{schema}.{name}" for name in available]
                )
            else:
                available_w_schema = available

            current = set(self.tables)

            if only is None:
                load = [
                    name
                    for name, schname in zip(available, available_w_schema)
                    if extend_existing or schname not in current
                ]
            elif callable(only):
                load = [
                    name
                    for name, schname in zip(available, available_w_schema)
                    if (extend_existing or schname not in current)
                    and only(name, self)
                ]
            else:
                missing = [name for name in only if name not in available]
                if missing:
                    s = schema and (" schema '%s'" % schema) or ""
                    missing_str = ", ".join(missing)
                    raise exc.InvalidRequestError(
                        f"Could not reflect: requested table(s) not available "
                        f"in {bind.engine!r}{s}: ({missing_str})"
                    )
                load = [
                    name
                    for name in only
                    if extend_existing or name not in current
                ]
            
            
            _reflect_info = insp._get_reflection_info(
                schema=schema,
                filter_names=load,
                available=available,
                kind=kind,
                scope=util.preloaded.engine_reflection.ObjectScope.ANY,
                **dialect_kwargs,
            )
            reflect_opts["_reflect_info"] = _reflect_info

            for name in load:
                try:
                    Table(name, self, **reflect_opts)
                except exc.UnreflectableTableError as uerr:
                    util.warn(f"Skipping table {name}: {uerr}")

    def create_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        
        bind._run_ddl_visitor(
            ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
        )

    def drop_all(
        self,
        bind: _CreateDropBind,
        tables: Optional[_typing_Sequence[Table]] = None,
        checkfirst: bool = True,
    ) -> None:
        
        bind._run_ddl_visitor(
            ddl.SchemaDropper, self, checkfirst=checkfirst, tables=tables
        )


class Computed(FetchedValue, SchemaItem):
    

    __visit_name__ = "computed_column"

    column: Optional[Column[Any]]

    @_document_text_coercion(
        "sqltext", ":class:`.Computed`", ":paramref:`.Computed.sqltext`"
    )
    def __init__(
        self, sqltext: _DDLColumnArgument, persisted: Optional[bool] = None
    ) -> None:
        
        self.sqltext = coercions.expect(roles.DDLExpressionRole, sqltext)
        self.persisted = persisted
        self.column = None

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        assert isinstance(parent, Column)

        if not isinstance(
            parent.server_default, (type(None), Computed)
        ) or not isinstance(parent.server_onupdate, (type(None), Computed)):
            raise exc.ArgumentError(
                "A generated column cannot specify a server_default or a "
                "server_onupdate argument"
            )
        self.column = parent
        parent.computed = self
        self.column.server_onupdate = self
        self.column.server_default = self

    def _as_for_update(self, for_update: bool) -> FetchedValue:
        return self

    @util.deprecated(
        "1.4",
        "The :meth:`_schema.Computed.copy` method is deprecated "
        "and will be removed in a future release.",
    )
    def copy(
        self, *, target_table: Optional[Table] = None, **kw: Any
    ) -> Computed:
        return self._copy(target_table=target_table, **kw)

    def _copy(
        self, *, target_table: Optional[Table] = None, **kw: Any
    ) -> Computed:
        sqltext = _copy_expression(
            self.sqltext,
            self.column.table if self.column is not None else None,
            target_table,
        )
        g = Computed(sqltext, persisted=self.persisted)

        return self._schema_item_copy(g)


class Identity(IdentityOptions, FetchedValue, SchemaItem):
    

    __visit_name__ = "identity_column"

    is_identity = True

    def __init__(
        self,
        always: bool = False,
        on_null: Optional[bool] = None,
        start: Optional[int] = None,
        increment: Optional[int] = None,
        minvalue: Optional[int] = None,
        maxvalue: Optional[int] = None,
        nominvalue: Optional[bool] = None,
        nomaxvalue: Optional[bool] = None,
        cycle: Optional[bool] = None,
        cache: Optional[int] = None,
        order: Optional[bool] = None,
    ) -> None:
        
        IdentityOptions.__init__(
            self,
            start=start,
            increment=increment,
            minvalue=minvalue,
            maxvalue=maxvalue,
            nominvalue=nominvalue,
            nomaxvalue=nomaxvalue,
            cycle=cycle,
            cache=cache,
            order=order,
        )
        self.always = always
        self.on_null = on_null
        self.column = None

    def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
        assert isinstance(parent, Column)
        if not isinstance(
            parent.server_default, (type(None), Identity)
        ) or not isinstance(parent.server_onupdate, type(None)):
            raise exc.ArgumentError(
                "A column with an Identity object cannot specify a "
                "server_default or a server_onupdate argument"
            )
        if parent.autoincrement is False:
            raise exc.ArgumentError(
                "A column with an Identity object cannot specify "
                "autoincrement=False"
            )
        self.column = parent

        parent.identity = self
        if parent._user_defined_nullable is NULL_UNSPECIFIED:
            parent.nullable = False

        parent.server_default = self

    def _as_for_update(self, for_update: bool) -> FetchedValue:
        return self

    @util.deprecated(
        "1.4",
        "The :meth:`_schema.Identity.copy` method is deprecated "
        "and will be removed in a future release.",
    )
    def copy(self, **kw: Any) -> Identity:
        return self._copy(**kw)

    def _copy(self, **kw: Any) -> Identity:
        i = Identity(
            always=self.always,
            on_null=self.on_null,
            start=self.start,
            increment=self.increment,
            minvalue=self.minvalue,
            maxvalue=self.maxvalue,
            nominvalue=self.nominvalue,
            nomaxvalue=self.nomaxvalue,
            cycle=self.cycle,
            cache=self.cache,
            order=self.order,
        )

        return self._schema_item_copy(i)
