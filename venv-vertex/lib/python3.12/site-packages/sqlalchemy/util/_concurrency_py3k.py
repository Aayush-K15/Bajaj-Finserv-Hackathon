







from __future__ import annotations

import asyncio
from contextvars import Context
import sys
import typing
from typing import Any
from typing import Awaitable
from typing import Callable
from typing import Coroutine
from typing import Optional
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from .langhelpers import memoized_property
from .. import exc
from ..util import py311
from ..util.typing import Literal
from ..util.typing import Protocol
from ..util.typing import Self
from ..util.typing import TypeGuard

_T = TypeVar("_T")

if typing.TYPE_CHECKING:

    class greenlet(Protocol):
        dead: bool
        gr_context: Optional[Context]

        def __init__(self, fn: Callable[..., Any], driver: greenlet): ...

        def throw(self, *arg: Any) -> Any:
            return None

        def switch(self, value: Any) -> Any:
            return None

    def getcurrent() -> greenlet: ...

else:
    from greenlet import getcurrent
    from greenlet import greenlet





_has_gr_context = hasattr(getcurrent(), "gr_context")


def is_exit_exception(e: BaseException) -> bool:
    
    
    return not isinstance(e, Exception) or isinstance(
        e, (asyncio.TimeoutError, asyncio.CancelledError)
    )







class _AsyncIoGreenlet(greenlet):
    dead: bool

    __sqlalchemy_greenlet_provider__ = True

    def __init__(self, fn: Callable[..., Any], driver: greenlet):
        greenlet.__init__(self, fn, driver)
        if _has_gr_context:
            self.gr_context = driver.gr_context


_T_co = TypeVar("_T_co", covariant=True)

if TYPE_CHECKING:

    def iscoroutine(
        awaitable: Awaitable[_T_co],
    ) -> TypeGuard[Coroutine[Any, Any, _T_co]]: ...

else:
    iscoroutine = asyncio.iscoroutine


def _safe_cancel_awaitable(awaitable: Awaitable[Any]) -> None:
    

    if iscoroutine(awaitable):
        awaitable.close()


def in_greenlet() -> bool:
    current = getcurrent()
    return getattr(current, "__sqlalchemy_greenlet_provider__", False)


def await_only(awaitable: Awaitable[_T]) -> _T:
    
    
    current = getcurrent()
    if not getattr(current, "__sqlalchemy_greenlet_provider__", False):
        _safe_cancel_awaitable(awaitable)

        raise exc.MissingGreenlet(
            "greenlet_spawn has not been called; can't call await_only() "
            "here. Was IO attempted in an unexpected place?"
        )

    
    
    
    
    return current.parent.switch(awaitable)  


def await_fallback(awaitable: Awaitable[_T]) -> _T:
    

    
    current = getcurrent()
    if not getattr(current, "__sqlalchemy_greenlet_provider__", False):
        loop = get_event_loop()
        if loop.is_running():
            _safe_cancel_awaitable(awaitable)

            raise exc.MissingGreenlet(
                "greenlet_spawn has not been called and asyncio event "
                "loop is already running; can't call await_fallback() here. "
                "Was IO attempted in an unexpected place?"
            )
        return loop.run_until_complete(awaitable)

    return current.parent.switch(awaitable)  


async def greenlet_spawn(
    fn: Callable[..., _T],
    *args: Any,
    _require_await: bool = False,
    **kwargs: Any,
) -> _T:
    

    result: Any
    context = _AsyncIoGreenlet(fn, getcurrent())
    
    
    
    
    switch_occurred = False
    result = context.switch(*args, **kwargs)
    while not context.dead:
        switch_occurred = True
        try:
            
            
            value = await result
        except BaseException:
            
            
            
            result = context.throw(*sys.exc_info())
        else:
            result = context.switch(value)

    if _require_await and not switch_occurred:
        raise exc.AwaitRequired(
            "The current operation required an async execution but none was "
            "detected. This will usually happen when using a non compatible "
            "DBAPI driver. Please ensure that an async DBAPI is used."
        )
    return result  


class AsyncAdaptedLock:
    @memoized_property
    def mutex(self) -> asyncio.Lock:
        
        
        return asyncio.Lock()

    def __enter__(self) -> bool:
        
        
        return await_fallback(self.mutex.acquire())

    def __exit__(self, *arg: Any, **kw: Any) -> None:
        self.mutex.release()


def get_event_loop() -> asyncio.AbstractEventLoop:
    
    try:
        return asyncio.get_running_loop()
    except RuntimeError:
        
        pass
    return asyncio.get_event_loop_policy().get_event_loop()


if not TYPE_CHECKING and py311:
    _Runner = asyncio.Runner
else:

    class _Runner:
        

        _loop: Union[None, asyncio.AbstractEventLoop, Literal[False]]

        def __init__(self) -> None:
            self._loop = None

        def __enter__(self) -> Self:
            self._lazy_init()
            return self

        def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
            self.close()

        def close(self) -> None:
            if self._loop:
                try:
                    self._loop.run_until_complete(
                        self._loop.shutdown_asyncgens()
                    )
                finally:
                    self._loop.close()
                    self._loop = False

        def get_loop(self) -> asyncio.AbstractEventLoop:
            
            self._lazy_init()
            assert self._loop
            return self._loop

        def run(self, coro: Coroutine[Any, Any, _T]) -> _T:
            self._lazy_init()
            assert self._loop
            return self._loop.run_until_complete(coro)

        def _lazy_init(self) -> None:
            if self._loop is False:
                raise RuntimeError("Runner is closed")
            if self._loop is None:
                self._loop = asyncio.new_event_loop()
