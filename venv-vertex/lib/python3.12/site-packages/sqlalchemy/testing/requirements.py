










from __future__ import annotations

import os
import platform

from . import asyncio as _test_asyncio
from . import exclusions
from .exclusions import only_on
from .. import create_engine
from .. import util
from ..pool import QueuePool


class Requirements:
    pass


class SuiteRequirements(Requirements):
    @property
    def create_table(self):
        

        return exclusions.open()

    @property
    def drop_table(self):
        

        return exclusions.open()

    @property
    def table_ddl_if_exists(self):
        

        return exclusions.closed()

    @property
    def index_ddl_if_exists(self):
        

        return exclusions.closed()

    @property
    def uuid_data_type(self):
        

        return exclusions.closed()

    @property
    def foreign_keys(self):
        

        return exclusions.open()

    @property
    def foreign_keys_reflect_as_index(self):
        

        return exclusions.closed()

    @property
    def unique_index_reflect_as_unique_constraints(self):
        

        return exclusions.closed()

    @property
    def unique_constraints_reflect_as_index(self):
        

        return exclusions.closed()

    @property
    def table_value_constructor(self):
        
        return exclusions.closed()

    @property
    def standard_cursor_sql(self):
        

        return exclusions.open()

    @property
    def on_update_cascade(self):
        

        return exclusions.open()

    @property
    def non_updating_cascade(self):
        
        return exclusions.closed()

    @property
    def deferrable_fks(self):
        return exclusions.closed()

    @property
    def on_update_or_deferrable_fks(self):
        
        
        
        return exclusions.only_if(
            lambda: self.on_update_cascade.enabled
            or self.deferrable_fks.enabled
        )

    @property
    def queue_pool(self):
        

        def go(config):
            return isinstance(config.db.pool, QueuePool)

        return exclusions.only_if(go)

    @property
    def self_referential_foreign_keys(self):
        

        return exclusions.open()

    @property
    def foreign_key_ddl(self):
        

        return exclusions.open()

    @property
    def named_constraints(self):
        

        return exclusions.open()

    @property
    def implicitly_named_constraints(self):
        

        return exclusions.open()

    @property
    def unusual_column_name_characters(self):
        
        return exclusions.open()

    @property
    def subqueries(self):
        

        return exclusions.open()

    @property
    def offset(self):
        

        return exclusions.open()

    @property
    def bound_limit_offset(self):
        

        return exclusions.open()

    @property
    def sql_expression_limit_offset(self):
        

        return exclusions.open()

    @property
    def parens_in_union_contained_select_w_limit_offset(self):
        
        return exclusions.open()

    @property
    def parens_in_union_contained_select_wo_limit_offset(self):
        
        return exclusions.open()

    @property
    def boolean_col_expressions(self):
        

        return exclusions.closed()

    @property
    def nullable_booleans(self):
        

        return exclusions.open()

    @property
    def nullsordering(self):
        

        return exclusions.closed()

    @property
    def standalone_binds(self):
        
        return exclusions.open()

    @property
    def standalone_null_binds_whereclause(self):
        
        return exclusions.open()

    @property
    def intersect(self):
        
        return exclusions.closed()

    @property
    def except_(self):
        
        return exclusions.closed()

    @property
    def window_functions(self):
        
        return exclusions.closed()

    @property
    def ctes(self):
        

        return exclusions.closed()

    @property
    def ctes_with_update_delete(self):
        

        return exclusions.closed()

    @property
    def ctes_with_values(self):
        

        return exclusions.closed()

    @property
    def ctes_on_dml(self):
        

        return exclusions.closed()

    @property
    def autoincrement_insert(self):
        

        return exclusions.open()

    @property
    def fetch_rows_post_commit(self):
        

        return exclusions.open()

    @property
    def group_by_complex_expression(self):
        

        return exclusions.open()

    @property
    def sane_rowcount(self):
        return exclusions.skip_if(
            lambda config: not config.db.dialect.supports_sane_rowcount,
            "driver doesn't support 'sane' rowcount",
        )

    @property
    def sane_multi_rowcount(self):
        return exclusions.fails_if(
            lambda config: not config.db.dialect.supports_sane_multi_rowcount,
            "driver %(driver)s %(doesnt_support)s 'sane' multi row count",
        )

    @property
    def sane_rowcount_w_returning(self):
        return exclusions.fails_if(
            lambda config: not (
                config.db.dialect.supports_sane_rowcount_returning
            ),
            "driver doesn't support 'sane' rowcount when returning is on",
        )

    @property
    def empty_inserts(self):
        

        return exclusions.only_if(
            lambda config: config.db.dialect.supports_empty_insert
            or config.db.dialect.supports_default_values
            or config.db.dialect.supports_default_metavalue,
            "empty inserts not supported",
        )

    @property
    def empty_inserts_executemany(self):
        

        return self.empty_inserts

    @property
    def insert_from_select(self):
        

        return exclusions.open()

    @property
    def delete_returning(self):
        

        return exclusions.only_if(
            lambda config: config.db.dialect.delete_returning,
            "%(database)s %(does_support)s 'DELETE ... RETURNING'",
        )

    @property
    def insert_returning(self):
        

        return exclusions.only_if(
            lambda config: config.db.dialect.insert_returning,
            "%(database)s %(does_support)s 'INSERT ... RETURNING'",
        )

    @property
    def update_returning(self):
        

        return exclusions.only_if(
            lambda config: config.db.dialect.update_returning,
            "%(database)s %(does_support)s 'UPDATE ... RETURNING'",
        )

    @property
    def insert_executemany_returning(self):
        

        return exclusions.only_if(
            lambda config: config.db.dialect.insert_executemany_returning,
            "%(database)s %(does_support)s 'RETURNING of "
            "multiple rows with INSERT executemany'",
        )

    @property
    def insertmanyvalues(self):
        return exclusions.only_if(
            lambda config: config.db.dialect.supports_multivalues_insert
            and config.db.dialect.insert_returning
            and config.db.dialect.use_insertmanyvalues,
            "%(database)s %(does_support)s 'insertmanyvalues functionality",
        )

    @property
    def tuple_in(self):
        

        return exclusions.closed()

    @property
    def tuple_in_w_empty(self):
        
        return self.tuple_in

    @property
    def duplicate_names_in_cursor_description(self):
        

        return exclusions.open()

    @property
    def denormalized_names(self):
        

        return exclusions.skip_if(
            lambda config: not config.db.dialect.requires_name_normalize,
            "Backend does not require denormalized names.",
        )

    @property
    def multivalues_inserts(self):
        

        return exclusions.skip_if(
            lambda config: not config.db.dialect.supports_multivalues_insert,
            "Backend does not support multirow inserts.",
        )

    @property
    def implements_get_lastrowid(self):
        
        return exclusions.open()

    @property
    def arraysize(self):
        

        return exclusions.open()

    @property
    def emulated_lastrowid(self):
        
        return exclusions.closed()

    @property
    def emulated_lastrowid_even_with_sequences(self):
        
        return exclusions.closed()

    @property
    def dbapi_lastrowid(self):
        
        return exclusions.closed()

    @property
    def views(self):
        

        return exclusions.closed()

    @property
    def schemas(self):
        

        return only_on(lambda config: config.db.dialect.supports_schemas)

    @property
    def cross_schema_fk_reflection(self):
        
        return exclusions.closed()

    @property
    def foreign_key_constraint_name_reflection(self):
        
        return exclusions.closed()

    @property
    def implicit_default_schema(self):
        
        return exclusions.closed()

    @property
    def default_schema_name_switch(self):
        

        return exclusions.closed()

    @property
    def server_side_cursors(self):
        

        return exclusions.only_if(
            [lambda config: config.db.dialect.supports_server_side_cursors],
            "no server side cursors support",
        )

    @property
    def sequences(self):
        

        return exclusions.only_if(
            [lambda config: config.db.dialect.supports_sequences],
            "no sequence support",
        )

    @property
    def no_sequences(self):
        

        return exclusions.NotPredicate(self.sequences)

    @property
    def sequences_optional(self):
        

        return exclusions.only_if(
            [
                lambda config: config.db.dialect.supports_sequences
                and config.db.dialect.sequences_optional
            ],
            "no sequence support, or sequences not optional",
        )

    @property
    def supports_lastrowid(self):
        
        return exclusions.only_if(
            [lambda config: config.db.dialect.postfetch_lastrowid]
        )

    @property
    def no_lastrowid_support(self):
        
        return exclusions.only_if(
            [lambda config: not config.db.dialect.postfetch_lastrowid]
        )

    @property
    def reflects_pk_names(self):
        return exclusions.closed()

    @property
    def table_reflection(self):
        
        return exclusions.open()

    @property
    def reflect_tables_no_columns(self):
        

        return exclusions.closed()

    @property
    def temp_table_comment_reflection(self):
        
        return exclusions.closed()

    @property
    def comment_reflection(self):
        
        return exclusions.closed()

    @property
    def comment_reflection_full_unicode(self):
        
        return exclusions.closed()

    @property
    def constraint_comment_reflection(self):
        
        return exclusions.closed()

    @property
    def view_column_reflection(self):
        
        return self.views

    @property
    def view_reflection(self):
        
        return self.views

    @property
    def schema_reflection(self):
        return self.schemas

    @property
    def schema_create_delete(self):
        
        return exclusions.closed()

    @property
    def primary_key_constraint_reflection(self):
        return exclusions.open()

    @property
    def foreign_key_constraint_reflection(self):
        return exclusions.open()

    @property
    def foreign_key_constraint_option_reflection_ondelete(self):
        return exclusions.closed()

    @property
    def fk_constraint_option_reflection_ondelete_restrict(self):
        return exclusions.closed()

    @property
    def fk_constraint_option_reflection_ondelete_noaction(self):
        return exclusions.closed()

    @property
    def foreign_key_constraint_option_reflection_onupdate(self):
        return exclusions.closed()

    @property
    def fk_constraint_option_reflection_onupdate_restrict(self):
        return exclusions.closed()

    @property
    def temp_table_reflection(self):
        return exclusions.open()

    @property
    def temp_table_reflect_indexes(self):
        return self.temp_table_reflection

    @property
    def temp_table_names(self):
        
        return exclusions.closed()

    @property
    def has_temp_table(self):
        
        return exclusions.closed()

    @property
    def temporary_tables(self):
        
        return exclusions.open()

    @property
    def temporary_views(self):
        
        return exclusions.closed()

    @property
    def index_reflection(self):
        return exclusions.open()

    @property
    def index_reflects_included_columns(self):
        return exclusions.closed()

    @property
    def indexes_with_ascdesc(self):
        
        return exclusions.open()

    @property
    def reflect_indexes_with_ascdesc(self):
        
        return exclusions.open()

    @property
    def reflect_indexes_with_ascdesc_as_expression(self):
        
        return exclusions.closed()

    @property
    def indexes_with_expressions(self):
        
        return exclusions.closed()

    @property
    def reflect_indexes_with_expressions(self):
        
        return exclusions.closed()

    @property
    def unique_constraint_reflection(self):
        
        return exclusions.open()

    @property
    def inline_check_constraint_reflection(self):
        
        return exclusions.closed()

    @property
    def check_constraint_reflection(self):
        
        return exclusions.closed()

    @property
    def duplicate_key_raises_integrity_error(self):
        
        return exclusions.open()

    @property
    def unbounded_varchar(self):
        

        return exclusions.open()

    @property
    def nvarchar_types(self):
        
        return exclusions.closed()

    @property
    def unicode_data_no_special_types(self):
        
        return exclusions.open()

    @property
    def unicode_data(self):
        
        return exclusions.open()

    @property
    def unicode_ddl(self):
        
        return exclusions.closed()

    @property
    def symbol_names_w_double_quote(self):
        
        return exclusions.open()

    @property
    def datetime_interval(self):
        
        return exclusions.closed()

    @property
    def datetime_literals(self):
        

        return exclusions.closed()

    @property
    def datetime(self):
        

        return exclusions.open()

    @property
    def datetime_timezone(self):
        

        return exclusions.closed()

    @property
    def time_timezone(self):
        

        return exclusions.closed()

    @property
    def date_implicit_bound(self):
        
        return exclusions.open()

    @property
    def time_implicit_bound(self):
        
        return exclusions.open()

    @property
    def datetime_implicit_bound(self):
        
        return exclusions.open()

    @property
    def datetime_microseconds(self):
        

        return exclusions.open()

    @property
    def timestamp_microseconds(self):
        
        return exclusions.closed()

    @property
    def timestamp_microseconds_implicit_bound(self):
        
        return self.timestamp_microseconds

    @property
    def datetime_historic(self):
        

        return exclusions.closed()

    @property
    def date(self):
        

        return exclusions.open()

    @property
    def date_coerces_from_datetime(self):
        

        return exclusions.open()

    @property
    def date_historic(self):
        

        return exclusions.closed()

    @property
    def time(self):
        

        return exclusions.open()

    @property
    def time_microseconds(self):
        

        return exclusions.open()

    @property
    def binary_comparisons(self):
        

        return exclusions.open()

    @property
    def binary_literals(self):
        

        return exclusions.open()

    @property
    def autocommit(self):
        
        return exclusions.closed()

    @property
    def isolation_level(self):
        
        return exclusions.closed()

    def get_isolation_levels(self, config):
        
        with config.db.connect() as conn:
            try:
                supported = conn.dialect.get_isolation_level_values(
                    conn.connection.dbapi_connection
                )
            except NotImplementedError:
                return None
            else:
                return {
                    "default": conn.dialect.default_isolation_level,
                    "supported": supported,
                }

    @property
    def get_isolation_level_values(self):
        

        def go(config):
            with config.db.connect() as conn:
                try:
                    conn.dialect.get_isolation_level_values(
                        conn.connection.dbapi_connection
                    )
                except NotImplementedError:
                    return False
                else:
                    return True

        return exclusions.only_if(go)

    @property
    def dialect_level_isolation_level_param(self):
        

        def go(config):
            try:
                e = create_engine(
                    config.db.url, isolation_level="READ COMMITTED"
                )
            except:
                return False
            else:
                return (
                    e.dialect._on_connect_isolation_level == "READ COMMITTED"
                )

        return exclusions.only_if(go)

    @property
    def array_type(self):
        
        return exclusions.closed()

    @property
    def json_type(self):
        

        return exclusions.closed()

    @property
    def json_array_indexes(self):
        

        return self.json_type

    @property
    def json_index_supplementary_unicode_element(self):
        return exclusions.open()

    @property
    def legacy_unconditional_json_extract(self):
        
        return exclusions.closed()

    @property
    def precision_numerics_general(self):
        
        return exclusions.open()

    @property
    def precision_numerics_enotation_small(self):
        
        return exclusions.closed()

    @property
    def precision_numerics_enotation_large(self):
        
        return exclusions.open()

    @property
    def precision_numerics_many_significant_digits(self):
        
        return exclusions.closed()

    @property
    def cast_precision_numerics_many_significant_digits(self):
        
        return self.precision_numerics_many_significant_digits

    @property
    def server_defaults(self):
        

        return exclusions.closed()

    @property
    def expression_server_defaults(self):
        

        return exclusions.closed()

    @property
    def implicit_decimal_binds(self):
        

        return exclusions.open()

    @property
    def numeric_received_as_decimal_untyped(self):
        
        return exclusions.open()

    @property
    def nested_aggregates(self):
        
        return exclusions.open()

    @property
    def recursive_fk_cascade(self):
        
        return exclusions.open()

    @property
    def precision_numerics_retains_significant_digits(self):
        

        return exclusions.closed()

    @property
    def infinity_floats(self):
        

        return exclusions.closed()

    @property
    def float_or_double_precision_behaves_generically(self):
        return exclusions.closed()

    @property
    def precision_generic_float_type(self):
        
        return exclusions.open()

    @property
    def literal_float_coercion(self):
        
        return exclusions.open()

    @property
    def floats_to_four_decimals(self):
        
        return exclusions.open()

    @property
    def fetch_null_from_numeric(self):
        

        return exclusions.open()

    @property
    def float_is_numeric(self):
        

        return exclusions.open()

    @property
    def text_type(self):
        

        return exclusions.open()

    @property
    def empty_strings_varchar(self):
        
        return exclusions.open()

    @property
    def empty_strings_text(self):
        

        return exclusions.open()

    @property
    def expressions_against_unbounded_text(self):
        

        return exclusions.open()

    @property
    def selectone(self):
        
        return exclusions.open()

    @property
    def savepoints(self):
        

        return exclusions.closed()

    @property
    def two_phase_transactions(self):
        

        return exclusions.closed()

    @property
    def update_from(self):
        
        return exclusions.closed()

    @property
    def delete_from(self):
        
        return exclusions.closed()

    @property
    def update_where_target_in_subquery(self):
        
        return exclusions.open()

    @property
    def mod_operator_as_percent_sign(self):
        
        return exclusions.closed()

    @property
    def percent_schema_names(self):
        
        return exclusions.closed()

    @property
    def order_by_col_from_union(self):
        
        return exclusions.open()

    @property
    def order_by_label_with_expression(self):
        
        return exclusions.closed()

    @property
    def order_by_collation(self):
        def check(config):
            try:
                self.get_order_by_collation(config)
                return False
            except NotImplementedError:
                return True

        return exclusions.skip_if(check)

    def get_order_by_collation(self, config):
        raise NotImplementedError()

    @property
    def unicode_connections(self):
        
        return exclusions.open()

    @property
    def graceful_disconnects(self):
        
        return exclusions.open()

    @property
    def independent_connections(self):
        
        return exclusions.open()

    @property
    def independent_readonly_connections(self):
        
        return exclusions.open()

    @property
    def skip_mysql_on_windows(self):
        
        return exclusions.open()

    @property
    def ad_hoc_engines(self):
        
        return exclusions.skip_if(
            lambda config: config.options.low_connections
        )

    @property
    def no_windows(self):
        return exclusions.skip_if(self._running_on_windows())

    def _running_on_windows(self):
        return exclusions.LambdaPredicate(
            lambda: platform.system() == "Windows",
            description="running on Windows",
        )

    @property
    def timing_intensive(self):
        from . import config

        return config.add_to_marker.timing_intensive

    @property
    def posix(self):
        return exclusions.skip_if(lambda: os.name != "posix")

    @property
    def memory_intensive(self):
        from . import config

        return config.add_to_marker.memory_intensive

    @property
    def threading_with_mock(self):
        
        return exclusions.skip_if(
            lambda config: config.options.has_coverage,
            "Stability issues with coverage",
        )

    @property
    def sqlalchemy2_stubs(self):
        def check(config):
            try:
                __import__("sqlalchemy-stubs.ext.mypy")
            except ImportError:
                return False
            else:
                return True

        return exclusions.only_if(check)

    @property
    def no_sqlalchemy2_stubs(self):
        def check(config):
            try:
                __import__("sqlalchemy-stubs.ext.mypy")
            except ImportError:
                return False
            else:
                return True

        return exclusions.skip_if(check)

    @property
    def up_to_date_typealias_type(self):
        
        
        
        
        def check(config):
            import typing
            import typing_extensions

            TypeAliasType = getattr(
                typing, "TypeAliasType", typing_extensions.TypeAliasType
            )
            TV = typing.TypeVar("TV")
            TA_generic = TypeAliasType(  
                "TA_generic", typing.List[TV], type_params=(TV,)
            )
            return hasattr(TA_generic[int], "__value__")

        return exclusions.only_if(check)

    @property
    def python38(self):
        return exclusions.only_if(
            lambda: util.py38, "Python 3.8 or above required"
        )

    @property
    def python39(self):
        return exclusions.only_if(
            lambda: util.py39, "Python 3.9 or above required"
        )

    @property
    def python310(self):
        return exclusions.only_if(
            lambda: util.py310, "Python 3.10 or above required"
        )

    @property
    def python311(self):
        return exclusions.only_if(
            lambda: util.py311, "Python 3.11 or above required"
        )

    @property
    def python312(self):
        return exclusions.only_if(
            lambda: util.py312, "Python 3.12 or above required"
        )

    @property
    def fail_python314b1(self):
        return exclusions.fails_if(
            lambda: util.compat.py314b1, "Fails as of python 3.14.0b1"
        )

    @property
    def not_python314(self):
        
        return exclusions.skip_if(
            lambda: util.py314, "Python 3.14 or above not supported"
        )

    @property
    def cpython(self):
        return exclusions.only_if(
            lambda: util.cpython, "cPython interpreter needed"
        )

    @property
    def is64bit(self):
        return exclusions.only_if(lambda: util.is64bit, "64bit required")

    @property
    def patch_library(self):
        def check_lib():
            try:
                __import__("patch")
            except ImportError:
                return False
            else:
                return True

        return exclusions.only_if(check_lib, "patch library needed")

    @property
    def predictable_gc(self):
        
        return self.cpython

    @property
    def no_coverage(self):
        
        return exclusions.skip_if(
            lambda config: config.options.has_coverage,
            "Issues observed when coverage is enabled",
        )

    def _has_mysql_on_windows(self, config):
        return False

    def _has_mysql_fully_case_sensitive(self, config):
        return False

    @property
    def sqlite(self):
        return exclusions.skip_if(lambda: not self._has_sqlite())

    @property
    def cextensions(self):
        return exclusions.skip_if(
            lambda: not util.has_compiled_ext(),
            "Cython extensions not installed",
        )

    def _has_sqlite(self):
        from sqlalchemy import create_engine

        try:
            create_engine("sqlite://")
            return True
        except ImportError:
            return False

    @property
    def async_dialect(self):
        

        return exclusions.closed()

    @property
    def asyncio(self):
        return self.greenlet

    @property
    def no_greenlet(self):
        def go(config):
            try:
                import greenlet  
            except ImportError:
                return True
            else:
                return False

        return exclusions.only_if(go)

    @property
    def greenlet(self):
        def go(config):
            if not _test_asyncio.ENABLE_ASYNCIO:
                return False

            try:
                import greenlet  
            except ImportError:
                return False
            else:
                return True

        return exclusions.only_if(go)

    @property
    def computed_columns(self):
        "Supports computed columns"
        return exclusions.closed()

    @property
    def computed_columns_stored(self):
        "Supports computed columns with `persisted=True`"
        return exclusions.closed()

    @property
    def computed_columns_virtual(self):
        "Supports computed columns with `persisted=False`"
        return exclusions.closed()

    @property
    def computed_columns_default_persisted(self):
        
        return exclusions.closed()

    @property
    def computed_columns_reflect_persisted(self):
        
        return exclusions.closed()

    @property
    def supports_distinct_on(self):
        
        return exclusions.closed()

    @property
    def supports_is_distinct_from(self):
        
        return exclusions.skip_if(
            lambda config: not config.db.dialect.supports_is_distinct_from,
            "driver doesn't support an IS DISTINCT FROM construct",
        )

    @property
    def identity_columns(self):
        
        return exclusions.closed()

    @property
    def identity_columns_standard(self):
        
        return exclusions.closed()

    @property
    def regexp_match(self):
        
        return exclusions.closed()

    @property
    def regexp_replace(self):
        
        return exclusions.closed()

    @property
    def fetch_first(self):
        
        return exclusions.closed()

    @property
    def fetch_percent(self):
        
        return exclusions.closed()

    @property
    def fetch_ties(self):
        
        return exclusions.closed()

    @property
    def fetch_no_order_by(self):
        
        return exclusions.closed()

    @property
    def fetch_offset_with_options(self):
        
        return exclusions.closed()

    @property
    def fetch_expression(self):
        
        return exclusions.closed()

    @property
    def autoincrement_without_sequence(self):
        
        return exclusions.open()

    @property
    def generic_classes(self):
        "If X[Y] can be implemented with ``__class_getitem__``. py3.7+"
        return exclusions.open()

    @property
    def json_deserializer_binary(self):
        "indicates if the json_deserializer function is called with bytes"
        return exclusions.closed()

    @property
    def reflect_table_options(self):
        
        return exclusions.closed()

    @property
    def materialized_views(self):
        
        return exclusions.closed()

    @property
    def materialized_views_reflect_pk(self):
        
        return exclusions.closed()

    @property
    def supports_bitwise_or(self):
        
        return exclusions.closed()

    @property
    def supports_bitwise_and(self):
        
        return exclusions.closed()

    @property
    def supports_bitwise_not(self):
        
        return exclusions.closed()

    @property
    def supports_bitwise_xor(self):
        
        return exclusions.closed()

    @property
    def supports_bitwise_shift(self):
        
        return exclusions.closed()

    @property
    def like_escapes(self):
        
        return exclusions.open()
