



















from __future__ import annotations

from functools import wraps
import inspect

from . import config
from ..util.concurrency import _AsyncUtil



ENABLE_ASYNCIO = True
_async_util = _AsyncUtil()  


def _shutdown():
    
    _async_util.close()


def _run_coroutine_function(fn, *args, **kwargs):
    return _async_util.run(fn, *args, **kwargs)


def _assume_async(fn, *args, **kwargs):
    

    if not ENABLE_ASYNCIO:
        return fn(*args, **kwargs)

    return _async_util.run_in_greenlet(fn, *args, **kwargs)


def _maybe_async_provisioning(fn, *args, **kwargs):
    
    if not ENABLE_ASYNCIO:
        return fn(*args, **kwargs)

    if config.any_async:
        return _async_util.run_in_greenlet(fn, *args, **kwargs)
    else:
        return fn(*args, **kwargs)


def _maybe_async(fn, *args, **kwargs):
    
    if not ENABLE_ASYNCIO:
        return fn(*args, **kwargs)

    is_async = config._current.is_async

    if is_async:
        return _async_util.run_in_greenlet(fn, *args, **kwargs)
    else:
        return fn(*args, **kwargs)


def _maybe_async_wrapper(fn):
    

    if inspect.isgeneratorfunction(fn):
        _stop = object()

        def call_next(gen):
            try:
                return next(gen)
                
            except StopIteration:
                return _stop

        @wraps(fn)
        def wrap_fixture(*args, **kwargs):
            gen = fn(*args, **kwargs)
            while True:
                value = _maybe_async(call_next, gen)
                if value is _stop:
                    break
                yield value

    else:

        @wraps(fn)
        def wrap_fixture(*args, **kwargs):
            return _maybe_async(fn, *args, **kwargs)

    return wrap_fixture
