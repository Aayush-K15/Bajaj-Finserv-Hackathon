





from __future__ import annotations

import typing
from typing import Any
from typing import Optional
from typing import Type
from typing import Union

from .base import ConnectionPoolEntry
from .base import Pool
from .base import PoolProxiedConnection
from .base import PoolResetState
from .. import event
from .. import util

if typing.TYPE_CHECKING:
    from ..engine import Engine
    from ..engine.interfaces import DBAPIConnection


class PoolEvents(event.Events[Pool]):
      

    _target_class_doc = "SomeEngineOrPool"
    _dispatch_target = Pool

    @util.preload_module("sqlalchemy.engine")
    @classmethod
    def _accept_with(
        cls,
        target: Union[Pool, Type[Pool], Engine, Type[Engine]],
        identifier: str,
    ) -> Optional[Union[Pool, Type[Pool]]]:
        if not typing.TYPE_CHECKING:
            Engine = util.preloaded.engine.Engine

        if isinstance(target, type):
            if issubclass(target, Engine):
                return Pool
            else:
                assert issubclass(target, Pool)
                return target
        elif isinstance(target, Engine):
            return target.pool
        elif isinstance(target, Pool):
            return target
        elif hasattr(target, "_no_async_engine_events"):
            target._no_async_engine_events()
        else:
            return None

    @classmethod
    def _listen(
        cls,
        event_key: event._EventKey[Pool],
        **kw: Any,
    ) -> None:
        target = event_key.dispatch_target

        kw.setdefault("asyncio", target._is_asyncio)

        event_key.base_listen(**kw)

    def connect(
        self,
        dbapi_connection: DBAPIConnection,
        connection_record: ConnectionPoolEntry,
    ) -> None:
        

    def first_connect(
        self,
        dbapi_connection: DBAPIConnection,
        connection_record: ConnectionPoolEntry,
    ) -> None:
        

    def checkout(
        self,
        dbapi_connection: DBAPIConnection,
        connection_record: ConnectionPoolEntry,
        connection_proxy: PoolProxiedConnection,
    ) -> None:
        

    def checkin(
        self,
        dbapi_connection: Optional[DBAPIConnection],
        connection_record: ConnectionPoolEntry,
    ) -> None:
        

    @event._legacy_signature(
        "2.0",
        ["dbapi_connection", "connection_record"],
        lambda dbapi_connection, connection_record, reset_state: (
            dbapi_connection,
            connection_record,
        ),
    )
    def reset(
        self,
        dbapi_connection: DBAPIConnection,
        connection_record: ConnectionPoolEntry,
        reset_state: PoolResetState,
    ) -> None:
        

    def invalidate(
        self,
        dbapi_connection: DBAPIConnection,
        connection_record: ConnectionPoolEntry,
        exception: Optional[BaseException],
    ) -> None:
        

    def soft_invalidate(
        self,
        dbapi_connection: DBAPIConnection,
        connection_record: ConnectionPoolEntry,
        exception: Optional[BaseException],
    ) -> None:
        

    def close(
        self,
        dbapi_connection: DBAPIConnection,
        connection_record: ConnectionPoolEntry,
    ) -> None:
        

    def detach(
        self,
        dbapi_connection: DBAPIConnection,
        connection_record: ConnectionPoolEntry,
    ) -> None:
        

    def close_detached(self, dbapi_connection: DBAPIConnection) -> None:
        
