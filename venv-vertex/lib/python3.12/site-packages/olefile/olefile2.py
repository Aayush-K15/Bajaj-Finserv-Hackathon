



__author__  = "Philippe Lagadec"
__date__    = "2014-10-01"
__version__ = '0.40py2'




















































































































































































import string, StringIO, struct, array, os.path, sys, datetime


__all__ = ['OleFileIO', 'isOleFile']


if array.array('L').itemsize == 4:
    
    UINT32 = 'L'
elif array.array('I').itemsize == 4:
    
    UINT32 = 'I'
else:
    raise ValueError, 'Need to fix a bug with 32 bit arrays, please contact author...'







try:
    True, False
except NameError:
    True, False = 1, 0


try:
    basestring
except NameError:
    try:
        
        basestring = (str, unicode)
    except NameError:
        basestring = str



KEEP_UNICODE_NAMES = False



DEBUG_MODE = False
def debug_print(msg):
    print msg
def debug_pass(msg):
    pass
debug = debug_pass

def set_debug_mode(debug_mode):
    
    global DEBUG_MODE, debug
    DEBUG_MODE = debug_mode
    if debug_mode:
        debug = debug_print
    else:
        debug = debug_pass


MAGIC = '\320\317\021\340\241\261\032\341'


MAXREGSECT = 0xFFFFFFFAL; 
DIFSECT    = 0xFFFFFFFCL; 
FATSECT    = 0xFFFFFFFDL; 
ENDOFCHAIN = 0xFFFFFFFEL; 
FREESECT   = 0xFFFFFFFFL; 


MAXREGSID  = 0xFFFFFFFAL; 
NOSTREAM   = 0xFFFFFFFFL; 


STGTY_EMPTY     = 0 
STGTY_STORAGE   = 1 
STGTY_STREAM    = 2 
STGTY_LOCKBYTES = 3 
STGTY_PROPERTY  = 4 
STGTY_ROOT      = 5 






VT_EMPTY=0; VT_NULL=1; VT_I2=2; VT_I4=3; VT_R4=4; VT_R8=5; VT_CY=6;
VT_DATE=7; VT_BSTR=8; VT_DISPATCH=9; VT_ERROR=10; VT_BOOL=11;
VT_VARIANT=12; VT_UNKNOWN=13; VT_DECIMAL=14; VT_I1=16; VT_UI1=17;
VT_UI2=18; VT_UI4=19; VT_I8=20; VT_UI8=21; VT_INT=22; VT_UINT=23;
VT_VOID=24; VT_HRESULT=25; VT_PTR=26; VT_SAFEARRAY=27; VT_CARRAY=28;
VT_USERDEFINED=29; VT_LPSTR=30; VT_LPWSTR=31; VT_FILETIME=64;
VT_BLOB=65; VT_STREAM=66; VT_STORAGE=67; VT_STREAMED_OBJECT=68;
VT_STORED_OBJECT=69; VT_BLOB_OBJECT=70; VT_CF=71; VT_CLSID=72;
VT_VECTOR=0x1000;



VT = {}
for keyword, var in vars().items():
    if keyword[:3] == "VT_":
        VT[var] = keyword





WORD_CLSID = "00020900-0000-0000-C000-000000000046"



DEFECT_UNSURE =    10    
DEFECT_POTENTIAL = 20    
DEFECT_INCORRECT = 30    
                         
DEFECT_FATAL =     40    
                         


for key in vars().keys():
    if key.startswith('STGTY_') or key.startswith('DEFECT_'):
        __all__.append(key)




def isOleFile (filename):
    
    f = open(filename, 'rb')
    header = f.read(len(MAGIC))
    if header == MAGIC:
        return True
    else:
        return False



def i16(c, o = 0):
    
    return ord(c[o])+(ord(c[o+1])<<8)


def i32(c, o = 0):
    
    return int(ord(c[o])+(ord(c[o+1])<<8)+(ord(c[o+2])<<16)+(ord(c[o+3])<<24))
    


def _clsid(clsid):
    
    assert len(clsid) == 16
    if clsid == "\0" * len(clsid):
        return ""
    return (("%08X-%04X-%04X-%02X%02X-" + "%02X" * 6) %
            ((i32(clsid, 0), i16(clsid, 4), i16(clsid, 6)) +
            tuple(map(ord, clsid[8:16]))))






try:
    
    unicode

    def _unicode(s, errors='replace'):
        
        
        
        try:
            
            
            u = s.decode('UTF-16LE', errors)
            if KEEP_UNICODE_NAMES:
                return u
            else:
                
                return u.encode('latin_1', errors)
        except:
            
            raise IOError, 'incorrect Unicode name'

except NameError:
    def _unicode(s, errors='replace'):
        
        
        
        
        
        return filter(ord, s)


def filetime2datetime(filetime):
        
        
        
        _FILETIME_null_date = datetime.datetime(1601, 1, 1, 0, 0, 0)
        
        return _FILETIME_null_date + datetime.timedelta(microseconds=filetime/10)





class OleMetadata:
    

    
    
    SUMMARY_ATTRIBS = ['codepage', 'title', 'subject', 'author', 'keywords', 'comments',
        'template', 'last_saved_by', 'revision_number', 'total_edit_time',
        'last_printed', 'create_time', 'last_saved_time', 'num_pages',
        'num_words', 'num_chars', 'thumbnail', 'creating_application',
        'security']

    
    
    DOCSUM_ATTRIBS = ['codepage_doc', 'category', 'presentation_target', 'bytes', 'lines', 'paragraphs',
        'slides', 'notes', 'hidden_slides', 'mm_clips',
        'scale_crop', 'heading_pairs', 'titles_of_parts', 'manager',
        'company', 'links_dirty', 'chars_with_spaces', 'unused', 'shared_doc',
        'link_base', 'hlinks', 'hlinks_changed', 'version', 'dig_sig',
        'content_type', 'content_status', 'language', 'doc_version']

    def __init__(self):
        
        
        self.codepage = None
        self.title = None
        self.subject = None
        self.author = None
        self.keywords = None
        self.comments = None
        self.template = None
        self.last_saved_by = None
        self.revision_number = None
        self.total_edit_time = None
        self.last_printed = None
        self.create_time = None
        self.last_saved_time = None
        self.num_pages = None
        self.num_words = None
        self.num_chars = None
        self.thumbnail = None
        self.creating_application = None
        self.security = None
        
        self.codepage_doc = None
        self.category = None
        self.presentation_target = None
        self.bytes = None
        self.lines = None
        self.paragraphs = None
        self.slides = None
        self.notes = None
        self.hidden_slides = None
        self.mm_clips = None
        self.scale_crop = None
        self.heading_pairs = None
        self.titles_of_parts = None
        self.manager = None
        self.company = None
        self.links_dirty = None
        self.chars_with_spaces = None
        self.unused = None
        self.shared_doc = None
        self.link_base = None
        self.hlinks = None
        self.hlinks_changed = None
        self.version = None
        self.dig_sig = None
        self.content_type = None
        self.content_status = None
        self.language = None
        self.doc_version = None


    def parse_properties(self, olefile):
        
        
        for attrib in (self.SUMMARY_ATTRIBS + self.DOCSUM_ATTRIBS):
            setattr(self, attrib, None)
        if olefile.exists("\x05SummaryInformation"):
            
            
            
            props = olefile.getproperties("\x05SummaryInformation",
                convert_time=True, no_conversion=[10])
            
            for i in range(len(self.SUMMARY_ATTRIBS)):
                
                value = props.get(i+1, None)
                setattr(self, self.SUMMARY_ATTRIBS[i], value)
        if olefile.exists("\x05DocumentSummaryInformation"):
            
            props = olefile.getproperties("\x05DocumentSummaryInformation",
                convert_time=True)
            
            for i in range(len(self.DOCSUM_ATTRIBS)):
                
                value = props.get(i+1, None)
                setattr(self, self.DOCSUM_ATTRIBS[i], value)

    def dump(self):
        
        print 'Properties from SummaryInformation stream:'
        for prop in self.SUMMARY_ATTRIBS:
            value = getattr(self, prop)
            print '- %s: %s' % (prop, repr(value))
        print 'Properties from DocumentSummaryInformation stream:'
        for prop in self.DOCSUM_ATTRIBS:
            value = getattr(self, prop)
            print '- %s: %s' % (prop, repr(value))




class _OleStream(StringIO.StringIO):
    

    
    
    

    def __init__(self, fp, sect, size, offset, sectorsize, fat, filesize):
        
        debug('_OleStream.__init__:')
        debug('  sect=%d (%X), size=%d, offset=%d, sectorsize=%d, len(fat)=%d, fp=%s'
            %(sect,sect,size,offset,sectorsize,len(fat), repr(fp)))
        
        
        unknown_size = False
        if size==0x7FFFFFFF:
            
            
            
            size = len(fat)*sectorsize
            
            unknown_size = True
            debug('  stream with UNKNOWN SIZE')
        nb_sectors = (size + (sectorsize-1)) / sectorsize
        debug('nb_sectors = %d' % nb_sectors)
        
        
        if nb_sectors > len(fat):
            raise IOError, 'malformed OLE document, stream too large'
        
        
        
        data = []
        
        if size == 0 and sect != ENDOFCHAIN:
            debug('size == 0 and sect != ENDOFCHAIN:')
            raise IOError, 'incorrect OLE sector index for empty stream'
        
        
        for i in xrange(nb_sectors):
            
            if sect == ENDOFCHAIN:
                if unknown_size:
                    break
                else:
                    
                    debug('sect=ENDOFCHAIN before expected size')
                    raise IOError, 'incomplete OLE stream'
            
            if sect<0 or sect>=len(fat):
                debug('sect=%d (%X) / len(fat)=%d' % (sect, sect, len(fat)))
                debug('i=%d / nb_sectors=%d' %(i, nb_sectors))





                raise IOError, 'incorrect OLE FAT, sector index out of range'
            
            
            try:
                fp.seek(offset + sectorsize * sect)
            except:
                debug('sect=%d, seek=%d, filesize=%d' %
                    (sect, offset+sectorsize*sect, filesize))
                raise IOError, 'OLE sector index out of range'
            sector_data = fp.read(sectorsize)
            
            
            
            
            if len(sector_data)!=sectorsize and sect!=(len(fat)-1):
                debug('sect=%d / len(fat)=%d, seek=%d / filesize=%d, len read=%d' %
                    (sect, len(fat), offset+sectorsize*sect, filesize, len(sector_data)))
                debug('seek+len(read)=%d' % (offset+sectorsize*sect+len(sector_data)))
                raise IOError, 'incomplete OLE sector'
            data.append(sector_data)
            
            try:
                sect = fat[sect]
            except IndexError:
                
                raise IOError, 'incorrect OLE FAT, sector index out of range'
        
        if sect != ENDOFCHAIN:
            raise IOError, 'incorrect last sector index in OLE stream'
        data = string.join(data, "")
        
        if len(data) >= size:
            data = data[:size]
            
            self.size = size
        elif unknown_size:
            
            
            self.size = len(data)
        else:
            
            debug('len(data)=%d, size=%d' % (len(data), size))
            raise IOError, 'OLE stream size is less than declared'
        
        StringIO.StringIO.__init__(self, data)
        




class _OleDirectoryEntry:

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    STRUCT_DIRENTRY = '<64sHBBIII16sIQQIII'
    
    DIRENTRY_SIZE = 128
    assert struct.calcsize(STRUCT_DIRENTRY) == DIRENTRY_SIZE


    def __init__(self, entry, sid, olefile):
        
        self.sid = sid
        
        self.olefile = olefile
        
        
        self.kids = []
        
        
        
        self.kids_dict = {}
        
        
        self.used = False
        
        (
            name,
            namelength,
            self.entry_type,
            self.color,
            self.sid_left,
            self.sid_right,
            self.sid_child,
            clsid,
            self.dwUserFlags,
            self.createTime,
            self.modifyTime,
            self.isectStart,
            sizeLow,
            sizeHigh
        ) = struct.unpack(_OleDirectoryEntry.STRUCT_DIRENTRY, entry)
        if self.entry_type not in [STGTY_ROOT, STGTY_STORAGE, STGTY_STREAM, STGTY_EMPTY]:
            olefile._raise_defect(DEFECT_INCORRECT, 'unhandled OLE storage type')
        
        if self.entry_type == STGTY_ROOT and sid != 0:
            olefile._raise_defect(DEFECT_INCORRECT, 'duplicate OLE root entry')
        if sid == 0 and self.entry_type != STGTY_ROOT:
            olefile._raise_defect(DEFECT_INCORRECT, 'incorrect OLE root entry')
        
        
        
        if namelength>64:
            olefile._raise_defect(DEFECT_INCORRECT, 'incorrect DirEntry name length')
            
            namelength = 64
        
        name = name[:(namelength-2)]
        
        self.name = _unicode(name)

        debug('DirEntry SID=%d: %s' % (self.sid, repr(self.name)))
        debug(' - type: %d' % self.entry_type)
        debug(' - sect: %d' % self.isectStart)
        debug(' - SID left: %d, right: %d, child: %d' % (self.sid_left,
            self.sid_right, self.sid_child))

        
        
        
        if olefile.sectorsize == 512:
            if sizeHigh != 0 and sizeHigh != 0xFFFFFFFFL:
                debug('sectorsize=%d, sizeLow=%d, sizeHigh=%d (%X)' %
                    (olefile.sectorsize, sizeLow, sizeHigh, sizeHigh))
                olefile._raise_defect(DEFECT_UNSURE, 'incorrect OLE stream size')
            self.size = sizeLow
        else:
            self.size = sizeLow + (long(sizeHigh)<<32)
        debug(' - size: %d (sizeLow=%d, sizeHigh=%d)' % (self.size, sizeLow, sizeHigh))

        self.clsid = _clsid(clsid)
        
        
        if self.entry_type == STGTY_STORAGE and self.size != 0:
            olefile._raise_defect(DEFECT_POTENTIAL, 'OLE storage with size>0')
        
        if self.entry_type in (STGTY_ROOT, STGTY_STREAM) and self.size>0:
            if self.size < olefile.minisectorcutoff \
            and self.entry_type==STGTY_STREAM: 
                
                minifat = True
            else:
                minifat = False
            olefile._check_duplicate_stream(self.isectStart, minifat)



    def build_storage_tree(self):
        
        debug('build_storage_tree: SID=%d - %s - sid_child=%d'
            % (self.sid, repr(self.name), self.sid_child))
        if self.sid_child != NOSTREAM:
            
            
            self.append_kids(self.sid_child)

            
            
            

            
            
            
            self.kids.sort()


    def append_kids(self, child_sid):
        
        
        
        
        if child_sid == NOSTREAM:
            return
        
        if child_sid<0 or child_sid>=len(self.olefile.direntries):
            self.olefile._raise_defect(DEFECT_FATAL, 'OLE DirEntry index out of range')
        
        child = self.olefile._load_direntry(child_sid) 
        debug('append_kids: child_sid=%d - %s - sid_left=%d, sid_right=%d, sid_child=%d'
            % (child.sid, repr(child.name), child.sid_left, child.sid_right, child.sid_child))
        
        
        
        self.append_kids(child.sid_left)
        
        name_lower = child.name.lower()
        if self.kids_dict.has_key(name_lower):
            self.olefile._raise_defect(DEFECT_INCORRECT,
                "Duplicate filename in OLE storage")
        
        
        self.kids.append(child)
        self.kids_dict[name_lower] = child
        
        if child.used:
            self.olefile._raise_defect(DEFECT_INCORRECT,
                'OLE Entry referenced more than once')
        child.used = True
        
        self.append_kids(child.sid_right)
        
        child.build_storage_tree()


    def __cmp__(self, other):
        "Compare entries by name"
        return cmp(self.name, other.name)
        
        


    def dump(self, tab = 0):
        "Dump this entry, and all its subentries (for debug purposes only)"
        TYPES = ["(invalid)", "(storage)", "(stream)", "(lockbytes)",
                 "(property)", "(root)"]
        print " "*tab + repr(self.name), TYPES[self.entry_type],
        if self.entry_type in (STGTY_STREAM, STGTY_ROOT):
            print self.size, "bytes",
        print
        if self.entry_type in (STGTY_STORAGE, STGTY_ROOT) and self.clsid:
            print " "*tab + "{%s}" % self.clsid

        for kid in self.kids:
            kid.dump(tab + 2)


    def getmtime(self):
        
        if self.modifyTime == 0:
            return None
        return filetime2datetime(self.modifyTime)


    def getctime(self):
        
        if self.createTime == 0:
            return None
        return filetime2datetime(self.createTime)




class OleFileIO:
    

    def __init__(self, filename = None, raise_defects=DEFECT_FATAL):
        
        
        self._raise_defects_level = raise_defects
        
        
        self.parsing_issues = []
        if filename:
            self.open(filename)


    def _raise_defect(self, defect_level, message, exception_type=IOError):
        
        
        if defect_level >= self._raise_defects_level:
            raise exception_type, message
        else:
            
            self.parsing_issues.append((exception_type, message))


    def open(self, filename):
        
        
        
        if hasattr(filename, 'read'):
            
            self.fp = filename
        else:
            
            
            self.fp = open(filename, "rb")
        
        
        
        
        
        
        
        
        
        self.fp.seek(0, os.SEEK_END)
        try:
            filesize = self.fp.tell()
        finally:
            self.fp.seek(0)
        self._filesize = filesize

        
        
        self._used_streams_fat = []
        self._used_streams_minifat = []

        header = self.fp.read(512)

        if len(header) != 512 or header[:8] != MAGIC:
            self._raise_defect(DEFECT_FATAL, "not an OLE2 structured storage file")

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

        
        
        fmt_header = '<8s16sHHHHHHLLLLLLLLLL'
        header_size = struct.calcsize(fmt_header)
        debug( "fmt_header size = %d, +FAT = %d" % (header_size, header_size + 109*4) )
        header1 = header[:header_size]
        (
            self.Sig,
            self.clsid,
            self.MinorVersion,
            self.DllVersion,
            self.ByteOrder,
            self.SectorShift,
            self.MiniSectorShift,
            self.Reserved, self.Reserved1,
            self.csectDir,
            self.csectFat,
            self.sectDirStart,
            self.signature,
            self.MiniSectorCutoff,
            self.MiniFatStart,
            self.csectMiniFat,
            self.sectDifStart,
            self.csectDif
        ) = struct.unpack(fmt_header, header1)
        debug( struct.unpack(fmt_header,    header1))

        if self.Sig != '\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1':
            
            self._raise_defect(DEFECT_FATAL, "incorrect OLE signature")
        if self.clsid != '\x00'*16:
            
            self._raise_defect(DEFECT_INCORRECT, "incorrect CLSID in OLE header")
        debug( "MinorVersion = %d" % self.MinorVersion )
        debug( "DllVersion   = %d" % self.DllVersion )
        if self.DllVersion not in [3, 4]:
            
            
            self._raise_defect(DEFECT_INCORRECT, "incorrect DllVersion in OLE header")
        debug( "ByteOrder    = %X" % self.ByteOrder )
        if self.ByteOrder != 0xFFFE:
            
            self._raise_defect(DEFECT_FATAL, "incorrect ByteOrder in OLE header")
            
        self.SectorSize = 2**self.SectorShift
        debug( "SectorSize   = %d" % self.SectorSize )
        if self.SectorSize not in [512, 4096]:
            self._raise_defect(DEFECT_INCORRECT, "incorrect SectorSize in OLE header")
        if (self.DllVersion==3 and self.SectorSize!=512) \
        or (self.DllVersion==4 and self.SectorSize!=4096):
            self._raise_defect(DEFECT_INCORRECT, "SectorSize does not match DllVersion in OLE header")
        self.MiniSectorSize = 2**self.MiniSectorShift
        debug( "MiniSectorSize   = %d" % self.MiniSectorSize )
        if self.MiniSectorSize not in [64]:
            self._raise_defect(DEFECT_INCORRECT, "incorrect MiniSectorSize in OLE header")
        if self.Reserved != 0 or self.Reserved1 != 0:
            self._raise_defect(DEFECT_INCORRECT, "incorrect OLE header (non-null reserved bytes)")
        debug( "csectDir     = %d" % self.csectDir )
        if self.SectorSize==512 and self.csectDir!=0:
            self._raise_defect(DEFECT_INCORRECT, "incorrect csectDir in OLE header")
        debug( "numFatSectors     = %d" % self.csectFat )
        debug( "sectDirStart = %X" % self.sectDirStart )
        debug( "signature    = %d" % self.signature )
        
        
        if self.signature != 0:
            self._raise_defect(DEFECT_POTENTIAL, "incorrect OLE header (signature>0)")
        debug( "MiniSectorCutoff = %d" % self.MiniSectorCutoff )
        debug( "MiniFatStart     = %X" % self.MiniFatStart )
        debug( "csectMiniFat     = %d" % self.csectMiniFat )
        debug( "sectDifStart     = %X" % self.sectDifStart )
        debug( "csectDif         = %d" % self.csectDif )

        
        
        self.nb_sect = ( (filesize + self.SectorSize-1) / self.SectorSize) - 1
        debug( "Number of sectors in the file: %d" % self.nb_sect )

        
        clsid = _clsid(header[8:24])
        self.sectorsize = self.SectorSize 
        self.minisectorsize = self.MiniSectorSize  
        self.minisectorcutoff = self.MiniSectorCutoff 

        
        
        self._check_duplicate_stream(self.sectDirStart)
        
        if self.csectMiniFat:
            self._check_duplicate_stream(self.MiniFatStart)
        
        if self.csectDif:
            self._check_duplicate_stream(self.sectDifStart)

        
        self.loadfat(header)
        
        
        self.loaddirectory(self.sectDirStart)
        self.ministream = None
        self.minifatsect = self.MiniFatStart 


    def close(self):
        
        self.fp.close()


    def _check_duplicate_stream(self, first_sect, minifat=False):
        
        if minifat:
            debug('_check_duplicate_stream: sect=%d in MiniFAT' % first_sect)
            used_streams = self._used_streams_minifat
        else:
            debug('_check_duplicate_stream: sect=%d in FAT' % first_sect)
            
            if first_sect in (DIFSECT,FATSECT,ENDOFCHAIN,FREESECT):
                return
            used_streams = self._used_streams_fat
        
        
        if first_sect in used_streams:
            self._raise_defect(DEFECT_INCORRECT, 'Stream referenced twice')
        else:
            used_streams.append(first_sect)


    def dumpfat(self, fat, firstindex=0):
        "Displays a part of FAT in human-readable form for debugging purpose"
        
        if not DEBUG_MODE:
            return
        
        VPL=8 
        fatnames = {
            FREESECT:   "..free..",
            ENDOFCHAIN: "[ END. ]",
            FATSECT:    "FATSECT ",
            DIFSECT:    "DIFSECT "
            }
        nbsect = len(fat)
        nlines = (nbsect+VPL-1)/VPL
        print "index",
        for i in range(VPL):
            print ("%8X" % i),
        print ""
        for l in range(nlines):
            index = l*VPL
            print ("%8X:" % (firstindex+index)),
            for i in range(index, index+VPL):
                if i>=nbsect:
                    break
                sect = fat[i]
                if sect in fatnames:
                    nom = fatnames[sect]
                else:
                    if sect == i+1:
                        nom = "    --->"
                    else:
                        nom = "%8X" % sect
                print nom,
            print ""


    def dumpsect(self, sector, firstindex=0):
        "Displays a sector in a human-readable form, for debugging purpose."
        if not DEBUG_MODE:
            return
        VPL=8 
        tab = array.array(UINT32, sector)
        nbsect = len(tab)
        nlines = (nbsect+VPL-1)/VPL
        print "index",
        for i in range(VPL):
            print ("%8X" % i),
        print ""
        for l in range(nlines):
            index = l*VPL
            print ("%8X:" % (firstindex+index)),
            for i in range(index, index+VPL):
                if i>=nbsect:
                    break
                sect = tab[i]
                nom = "%8X" % sect
                print nom,
            print ""

    def sect2array(self, sect):
        
        a = array.array(UINT32, sect)
        
        if sys.byteorder == 'big':
            a.byteswap()
        return a


    def loadfat_sect(self, sect):
        
        
        if isinstance(sect, array.array):
            
            fat1 = sect
        else:
            
            fat1 = self.sect2array(sect)
            self.dumpsect(sect)
        
        for isect in fat1:
            
            if isect == ENDOFCHAIN or isect == FREESECT:
                
                break
            
            s = self.getsect(isect)
            
            
            nextfat = self.sect2array(s)
            self.fat = self.fat + nextfat
        return isect


    def loadfat(self, header):
        
        
        
        

        sect = header[76:512]
        debug( "len(sect)=%d, so %d integers" % (len(sect), len(sect)/4) )
        
        
        
        
        self.fat = array.array(UINT32)
        self.loadfat_sect(sect)
        








        if self.csectDif != 0:
            
            
            if self.csectFat <= 109:
                
                
                self._raise_defect(DEFECT_INCORRECT, 'incorrect DIFAT, not enough sectors')
            if self.sectDifStart >= self.nb_sect:
                
                self._raise_defect(DEFECT_FATAL, 'incorrect DIFAT, first index out of range')
            debug( "DIFAT analysis..." )
            
            
            nb_difat = (self.csectFat-109 + 126)/127
            debug( "nb_difat = %d" % nb_difat )
            if self.csectDif != nb_difat:
                raise IOError, 'incorrect DIFAT'
            isect_difat = self.sectDifStart
            for i in xrange(nb_difat):
                debug( "DIFAT block %d, sector %X" % (i, isect_difat) )
                
                sector_difat = self.getsect(isect_difat)
                difat = self.sect2array(sector_difat)
                self.dumpsect(sector_difat)
                self.loadfat_sect(difat[:127])
                
                isect_difat = difat[127]
                debug( "next DIFAT sector: %X" % isect_difat )
            
            if isect_difat not in [ENDOFCHAIN, FREESECT]:
                
                raise IOError, 'incorrect end of DIFAT'




        
        
        
        if len(self.fat) > self.nb_sect:
            debug('len(fat)=%d, shrunk to nb_sect=%d' % (len(self.fat), self.nb_sect))
            self.fat = self.fat[:self.nb_sect]
        debug('\nFAT:')
        self.dumpfat(self.fat)


    def loadminifat(self):
        
        
        
        
        
        
        
        
        stream_size = self.csectMiniFat * self.SectorSize
        
        
        
        nb_minisectors = (self.root.size + self.MiniSectorSize-1) / self.MiniSectorSize
        used_size = nb_minisectors * 4
        debug('loadminifat(): minifatsect=%d, nb FAT sectors=%d, used_size=%d, stream_size=%d, nb MiniSectors=%d' %
            (self.minifatsect, self.csectMiniFat, used_size, stream_size, nb_minisectors))
        if used_size > stream_size:
            
            self._raise_defect(DEFECT_INCORRECT, 'OLE MiniStream is larger than MiniFAT')
        
        s = self._open(self.minifatsect, stream_size, force_FAT=True).read()
        
        
        self.minifat = self.sect2array(s)
        
        debug('MiniFAT shrunk from %d to %d sectors' % (len(self.minifat), nb_minisectors))
        self.minifat = self.minifat[:nb_minisectors]
        debug('loadminifat(): len=%d' % len(self.minifat))
        debug('\nMiniFAT:')
        self.dumpfat(self.minifat)

    def getsect(self, sect):
        
        
        
        
        
        
        try:
            self.fp.seek(self.sectorsize * (sect+1))
        except:
            debug('getsect(): sect=%X, seek=%d, filesize=%d' %
                (sect, self.sectorsize*(sect+1), self._filesize))
            self._raise_defect(DEFECT_FATAL, 'OLE sector index out of range')
        sector = self.fp.read(self.sectorsize)
        if len(sector) != self.sectorsize:
            debug('getsect(): sect=%X, read=%d, sectorsize=%d' %
                (sect, len(sector), self.sectorsize))
            self._raise_defect(DEFECT_FATAL, 'incomplete OLE sector')
        return sector


    def loaddirectory(self, sect):
        
        
        

        
        
        self.directory_fp = self._open(sect)

        
        
        max_entries = self.directory_fp.size / 128
        debug('loaddirectory: size=%d, max_entries=%d' %
            (self.directory_fp.size, max_entries))

        
        
        
        self.direntries = [None] * max_entries





        
        root_entry = self._load_direntry(0)
        
        self.root = self.direntries[0]
        
        self.root.build_storage_tree()


    def _load_direntry (self, sid):
        
        
        if sid<0 or sid>=len(self.direntries):
            self._raise_defect(DEFECT_FATAL, "OLE directory index out of range")
        
        if self.direntries[sid] is not None:
            self._raise_defect(DEFECT_INCORRECT,
                "double reference for OLE stream/storage")
            
            return self.direntries[sid]
        self.directory_fp.seek(sid * 128)
        entry = self.directory_fp.read(128)
        self.direntries[sid] = _OleDirectoryEntry(entry, sid, self)
        return self.direntries[sid]


    def dumpdirectory(self):
        
        self.root.dump()


    def _open(self, start, size = 0x7FFFFFFF, force_FAT=False):
        
        debug('OleFileIO.open(): sect=%d, size=%d, force_FAT=%s' %
            (start, size, str(force_FAT)))
        
        if size < self.minisectorcutoff and not force_FAT:
            
            if not self.ministream:
                
                self.loadminifat()
                
                
                size_ministream = self.root.size
                debug('Opening MiniStream: sect=%d, size=%d' %
                    (self.root.isectStart, size_ministream))
                self.ministream = self._open(self.root.isectStart,
                    size_ministream, force_FAT=True)
            return _OleStream(fp=self.ministream, sect=start, size=size,
                              offset=0, sectorsize=self.minisectorsize,
                              fat=self.minifat, filesize=self.ministream.size)
        else:
            
            return _OleStream(fp=self.fp, sect=start, size=size,
                              offset=self.sectorsize,
                              sectorsize=self.sectorsize, fat=self.fat,
                              filesize=self._filesize)


    def _list(self, files, prefix, node, streams=True, storages=False):
        
        prefix = prefix + [node.name]
        for entry in node.kids:
            if entry.kids:
                
                if storages:
                    
                    files.append(prefix[1:] + [entry.name])
                
                self._list(files, prefix, entry, streams, storages)
            else:
                
                if streams:
                    
                    files.append(prefix[1:] + [entry.name])


    def listdir(self, streams=True, storages=False):
        
        files = []
        self._list(files, [], self.root, streams, storages)
        return files


    def _find(self, filename):
        

        
        
        if isinstance(filename, basestring):
            filename = filename.split('/')
        
        node = self.root
        for name in filename:
            for kid in node.kids:
                if kid.name.lower() == name.lower():
                    break
            else:
                raise IOError, "file not found"
            node = kid
        return node.sid


    def openstream(self, filename):
        
        sid = self._find(filename)
        entry = self.direntries[sid]
        if entry.entry_type != STGTY_STREAM:
            raise IOError, "this file is not a stream"
        return self._open(entry.isectStart, entry.size)


    def get_type(self, filename):
        
        try:
            sid = self._find(filename)
            entry = self.direntries[sid]
            return entry.entry_type
        except:
            return False


    def getmtime(self, filename):
        
        sid = self._find(filename)
        entry = self.direntries[sid]
        return entry.getmtime()


    def getctime(self, filename):
        
        sid = self._find(filename)
        entry = self.direntries[sid]
        return entry.getctime()


    def exists(self, filename):
        
        try:
            sid = self._find(filename)
            return True
        except:
            return False


    def get_size(self, filename):
        
        sid = self._find(filename)
        entry = self.direntries[sid]
        if entry.entry_type != STGTY_STREAM:
            
            raise TypeError, 'object is not an OLE stream'
        return entry.size


    def get_rootentry_name(self):
        
        return self.root.name


    def getproperties(self, filename, convert_time=False, no_conversion=None):
        
        
        if no_conversion == None:
            no_conversion = []
        
        streampath = filename
        if not isinstance(streampath, str):
            streampath = '/'.join(streampath)

        fp = self.openstream(filename)

        data = {}

        try:
            
            s = fp.read(28)
            clsid = _clsid(s[8:24])

            
            s = fp.read(20)
            fmtid = _clsid(s[:16])
            fp.seek(i32(s, 16))

            
            s = "****" + fp.read(i32(fp.read(4))-4)
            
            num_props = i32(s, 4)
        except:
            
            
            
            exctype, excvalue = sys.exc_info()[:2]
            msg = 'Error while parsing properties header in stream %s: %s' % (
                repr(streampath), excvalue)
            self._raise_defect(DEFECT_INCORRECT, msg, exctype)
            return data

        for i in range(num_props):
            try:
                id = 0 
                id = i32(s, 8+i*8)
                offset = i32(s, 12+i*8)
                type = i32(s, offset)

                debug ('property id=%d: type=%d offset=%X' % (id, type, offset))

                
                

                if type == VT_I2: 
                    value = i16(s, offset+4)
                    if value >= 32768:
                        value = value - 65536
                elif type == VT_UI2: 
                    value = i16(s, offset+4)
                elif type in (VT_I4, VT_INT, VT_ERROR):
                    
                    
                    
                    value = i32(s, offset+4)
                elif type in (VT_UI4, VT_UINT): 
                    value = i32(s, offset+4) 
                elif type in (VT_BSTR, VT_LPSTR):
                    
                    
                    
                    
                    count = i32(s, offset+4)
                    value = s[offset+8:offset+8+count-1]
                    
                    value = value.replace('\x00', '')
                elif type == VT_BLOB:
                    
                    
                    count = i32(s, offset+4)
                    value = s[offset+8:offset+8+count]
                elif type == VT_LPWSTR:
                    
                    
                    
                    
                    count = i32(s, offset+4)
                    value = _unicode(s[offset+8:offset+8+count*2])
                elif type == VT_FILETIME:
                    value = long(i32(s, offset+4)) + (long(i32(s, offset+8))<<32)
                    
                    
                    if convert_time and id not in no_conversion:
                        debug('Converting property 
                                %(id, value, float(value)/10000000L))
                        
                        
                        _FILETIME_null_date = datetime.datetime(1601, 1, 1, 0, 0, 0)
                        debug('timedelta days=%d' % (value/(10*1000000*3600*24)))
                        value = _FILETIME_null_date + datetime.timedelta(microseconds=value/10)
                    else:
                        
                        
                        value = value / 10000000L 
                elif type == VT_UI1: 
                    value = ord(s[offset+4])
                elif type == VT_CLSID:
                    value = _clsid(s[offset+4:offset+20])
                elif type == VT_CF:
                    
                    
                    count = i32(s, offset+4)
                    value = s[offset+8:offset+8+count]
                elif type == VT_BOOL:
                    
                    
                    value = bool(i16(s, offset+4))
                else:
                    value = None 
                    debug ('property id=%d: type=%d not implemented in parser yet' % (id, type))

                
                
                

                
                
                
                
                

                
                

                data[id] = value
            except:
                
                
                exctype, excvalue = sys.exc_info()[:2]
                msg = 'Error while parsing property id %d in stream %s: %s' % (
                    id, repr(streampath), excvalue)
                self._raise_defect(DEFECT_INCORRECT, msg, exctype)

        return data

    def get_metadata(self):
        
        self.metadata = OleMetadata()
        self.metadata.parse_properties(self)
        return self.metadata






if __name__ == "__main__":

    import sys

    
    if len(sys.argv) <= 1:
        print __doc__
        print 
        sys.exit()

    check_streams = False
    for filename in sys.argv[1:]:

            
            if filename == '-d':
                
                set_debug_mode(True)
                continue
            if filename == '-c':
                
                check_streams = True
                continue

            ole = OleFileIO(filename)
            print "-" * 68
            print filename
            print "-" * 68
            ole.dumpdirectory()
            for streamname in ole.listdir():
                if streamname[-1][0] == "\005":
                    print streamname, ": properties"
                    props = ole.getproperties(streamname, convert_time=True)
                    props = props.items()
                    props.sort()
                    for k, v in props:
                        
                        if isinstance(v, basestring):
                            if len(v) > 50:
                                v = v[:50]
                            
                            for c in (1,2,3,4,5,6,7,11,12,14,15,16,17,18,19,20,
                                21,22,23,24,25,26,27,28,29,30,31):
                                if chr(c) in v:
                                    v = '(binary data)'
                                    break
                        print "   ", k, v

            if check_streams:
                
                print '\nChecking streams...'
                for streamname in ole.listdir():
                    
                    print '-', repr('/'.join(streamname)),'-',
                    st_type = ole.get_type(streamname)
                    if st_type == STGTY_STREAM:
                        print 'size %d' % ole.get_size(streamname)
                        
                        ole.openstream(streamname)
                    else:
                        print 'NOT a stream : type=%d' % st_type
                print ''







            print 'Modification/Creation times of all directory entries:'
            for entry in ole.direntries:
                if entry is not None:
                    print '- %s: mtime=%s ctime=%s' % (entry.name,
                        entry.getmtime(), entry.getctime())
            print ''

            
            meta = ole.get_metadata()
            meta.dump()
            print ''
            
            root = ole.get_rootentry_name()
            print 'Root entry name: "%s"' % root
            if ole.exists('worddocument'):
                print "This is a Word document."
                print "type of stream 'WordDocument':", ole.get_type('worddocument')
                print "size :", ole.get_size('worddocument')
                if ole.exists('macros/vba'):
                    print "This document may contain VBA macros."

            
            print '\nNon-fatal issues raised during parsing:'
            if ole.parsing_issues:
                for exctype, msg in ole.parsing_issues:
                    print '- %s: %s' % (exctype.__name__, msg)
            else:
                print 'None'




