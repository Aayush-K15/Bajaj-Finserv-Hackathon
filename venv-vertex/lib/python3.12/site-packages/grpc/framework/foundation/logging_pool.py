














from concurrent import futures
import logging

_LOGGER = logging.getLogger(__name__)


def _wrap(behavior):
    

    def _wrapping(*args, **kwargs):
        try:
            return behavior(*args, **kwargs)
        except Exception:
            _LOGGER.exception(
                "Unexpected exception from %s executed in logging pool!",
                behavior,
            )
            raise

    return _wrapping


class _LoggingPool(object):
    

    def __init__(self, backing_pool):
        self._backing_pool = backing_pool

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._backing_pool.shutdown(wait=True)

    def submit(self, fn, *args, **kwargs):
        return self._backing_pool.submit(_wrap(fn), *args, **kwargs)

    def map(self, func, *iterables, **kwargs):
        return self._backing_pool.map(
            _wrap(func), *iterables, timeout=kwargs.get("timeout", None)
        )

    def shutdown(self, wait=True):
        self._backing_pool.shutdown(wait=wait)


def pool(max_workers):
    
    return _LoggingPool(futures.ThreadPoolExecutor(max_workers))
