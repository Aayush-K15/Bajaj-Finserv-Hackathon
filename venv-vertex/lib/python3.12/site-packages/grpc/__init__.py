














import abc
import contextlib
import enum
import logging
import sys

from grpc import _compression
from grpc._cython import cygrpc as _cygrpc
from grpc._runtime_protos import protos
from grpc._runtime_protos import protos_and_services
from grpc._runtime_protos import services

logging.getLogger(__name__).addHandler(logging.NullHandler())

try:
    
    from grpc._grpcio_metadata import __version__
except ImportError:
    __version__ = "dev0"




class FutureTimeoutError(Exception):
    


class FutureCancelledError(Exception):
    


class Future(abc.ABC):
    

    @abc.abstractmethod
    def cancel(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def cancelled(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def running(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def done(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def result(self, timeout=None):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def exception(self, timeout=None):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def traceback(self, timeout=None):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def add_done_callback(self, fn):
        
        raise NotImplementedError()





@enum.unique
class ChannelConnectivity(enum.Enum):
    

    IDLE = (_cygrpc.ConnectivityState.idle, "idle")
    CONNECTING = (_cygrpc.ConnectivityState.connecting, "connecting")
    READY = (_cygrpc.ConnectivityState.ready, "ready")
    TRANSIENT_FAILURE = (
        _cygrpc.ConnectivityState.transient_failure,
        "transient failure",
    )
    SHUTDOWN = (_cygrpc.ConnectivityState.shutdown, "shutdown")


@enum.unique
class StatusCode(enum.Enum):
    

    OK = (_cygrpc.StatusCode.ok, "ok")
    CANCELLED = (_cygrpc.StatusCode.cancelled, "cancelled")
    UNKNOWN = (_cygrpc.StatusCode.unknown, "unknown")
    INVALID_ARGUMENT = (_cygrpc.StatusCode.invalid_argument, "invalid argument")
    DEADLINE_EXCEEDED = (
        _cygrpc.StatusCode.deadline_exceeded,
        "deadline exceeded",
    )
    NOT_FOUND = (_cygrpc.StatusCode.not_found, "not found")
    ALREADY_EXISTS = (_cygrpc.StatusCode.already_exists, "already exists")
    PERMISSION_DENIED = (
        _cygrpc.StatusCode.permission_denied,
        "permission denied",
    )
    RESOURCE_EXHAUSTED = (
        _cygrpc.StatusCode.resource_exhausted,
        "resource exhausted",
    )
    FAILED_PRECONDITION = (
        _cygrpc.StatusCode.failed_precondition,
        "failed precondition",
    )
    ABORTED = (_cygrpc.StatusCode.aborted, "aborted")
    OUT_OF_RANGE = (_cygrpc.StatusCode.out_of_range, "out of range")
    UNIMPLEMENTED = (_cygrpc.StatusCode.unimplemented, "unimplemented")
    INTERNAL = (_cygrpc.StatusCode.internal, "internal")
    UNAVAILABLE = (_cygrpc.StatusCode.unavailable, "unavailable")
    DATA_LOSS = (_cygrpc.StatusCode.data_loss, "data loss")
    UNAUTHENTICATED = (_cygrpc.StatusCode.unauthenticated, "unauthenticated")





class Status(abc.ABC):
    





class RpcError(Exception):
    





class RpcContext(abc.ABC):
    

    @abc.abstractmethod
    def is_active(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def time_remaining(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def cancel(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def add_callback(self, callback):
        
        raise NotImplementedError()





class Call(RpcContext, metaclass=abc.ABCMeta):
    

    @abc.abstractmethod
    def initial_metadata(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def trailing_metadata(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def code(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def details(self):
        
        raise NotImplementedError()





class ClientCallDetails(abc.ABC):
    


class UnaryUnaryClientInterceptor(abc.ABC):
    

    @abc.abstractmethod
    def intercept_unary_unary(self, continuation, client_call_details, request):
        
        raise NotImplementedError()


class UnaryStreamClientInterceptor(abc.ABC):
    

    @abc.abstractmethod
    def intercept_unary_stream(
        self, continuation, client_call_details, request
    ):
        
        raise NotImplementedError()


class StreamUnaryClientInterceptor(abc.ABC):
    

    @abc.abstractmethod
    def intercept_stream_unary(
        self, continuation, client_call_details, request_iterator
    ):
        
        raise NotImplementedError()


class StreamStreamClientInterceptor(abc.ABC):
    

    @abc.abstractmethod
    def intercept_stream_stream(
        self, continuation, client_call_details, request_iterator
    ):
        
        raise NotImplementedError()





class ChannelCredentials(object):
    

    def __init__(self, credentials):
        self._credentials = credentials


class CallCredentials(object):
    

    def __init__(self, credentials):
        self._credentials = credentials


class AuthMetadataContext(abc.ABC):
    


class AuthMetadataPluginCallback(abc.ABC):
    

    def __call__(self, metadata, error):
        
        raise NotImplementedError()


class AuthMetadataPlugin(abc.ABC):
    

    def __call__(self, context, callback):
        
        raise NotImplementedError()


class ServerCredentials(object):
    

    def __init__(self, credentials):
        self._credentials = credentials


class ServerCertificateConfiguration(object):
    

    def __init__(self, certificate_configuration):
        self._certificate_configuration = certificate_configuration





class UnaryUnaryMultiCallable(abc.ABC):
    

    @abc.abstractmethod
    def __call__(
        self,
        request,
        timeout=None,
        metadata=None,
        credentials=None,
        wait_for_ready=None,
        compression=None,
    ):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def with_call(
        self,
        request,
        timeout=None,
        metadata=None,
        credentials=None,
        wait_for_ready=None,
        compression=None,
    ):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def future(
        self,
        request,
        timeout=None,
        metadata=None,
        credentials=None,
        wait_for_ready=None,
        compression=None,
    ):
        
        raise NotImplementedError()


class UnaryStreamMultiCallable(abc.ABC):
    

    @abc.abstractmethod
    def __call__(
        self,
        request,
        timeout=None,
        metadata=None,
        credentials=None,
        wait_for_ready=None,
        compression=None,
    ):
        
        raise NotImplementedError()


class StreamUnaryMultiCallable(abc.ABC):
    

    @abc.abstractmethod
    def __call__(
        self,
        request_iterator,
        timeout=None,
        metadata=None,
        credentials=None,
        wait_for_ready=None,
        compression=None,
    ):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def with_call(
        self,
        request_iterator,
        timeout=None,
        metadata=None,
        credentials=None,
        wait_for_ready=None,
        compression=None,
    ):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def future(
        self,
        request_iterator,
        timeout=None,
        metadata=None,
        credentials=None,
        wait_for_ready=None,
        compression=None,
    ):
        
        raise NotImplementedError()


class StreamStreamMultiCallable(abc.ABC):
    

    @abc.abstractmethod
    def __call__(
        self,
        request_iterator,
        timeout=None,
        metadata=None,
        credentials=None,
        wait_for_ready=None,
        compression=None,
    ):
        
        raise NotImplementedError()





class Channel(abc.ABC):
    

    @abc.abstractmethod
    def subscribe(self, callback, try_to_connect=False):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def unsubscribe(self, callback):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def unary_unary(
        self,
        method,
        request_serializer=None,
        response_deserializer=None,
        _registered_method=False,
    ):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def unary_stream(
        self,
        method,
        request_serializer=None,
        response_deserializer=None,
        _registered_method=False,
    ):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def stream_unary(
        self,
        method,
        request_serializer=None,
        response_deserializer=None,
        _registered_method=False,
    ):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def stream_stream(
        self,
        method,
        request_serializer=None,
        response_deserializer=None,
        _registered_method=False,
    ):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self):
        
        raise NotImplementedError()

    def __enter__(self):
        
        raise NotImplementedError()

    def __exit__(self, exc_type, exc_val, exc_tb):
        
        raise NotImplementedError()





class ServicerContext(RpcContext, metaclass=abc.ABCMeta):
    

    @abc.abstractmethod
    def invocation_metadata(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def peer(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def peer_identities(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def peer_identity_key(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def auth_context(self):
        
        raise NotImplementedError()

    def set_compression(self, compression):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def send_initial_metadata(self, initial_metadata):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def set_trailing_metadata(self, trailing_metadata):
        
        raise NotImplementedError()

    def trailing_metadata(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def abort(self, code, details):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def abort_with_status(self, status):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def set_code(self, code):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def set_details(self, details):
        
        raise NotImplementedError()

    def code(self):
        
        raise NotImplementedError()

    def details(self):
        
        raise NotImplementedError()

    def disable_next_message_compression(self):
        
        raise NotImplementedError()





class RpcMethodHandler(abc.ABC):
    


class HandlerCallDetails(abc.ABC):
    


class GenericRpcHandler(abc.ABC):
    

    @abc.abstractmethod
    def service(self, handler_call_details):
        
        raise NotImplementedError()


class ServiceRpcHandler(GenericRpcHandler, metaclass=abc.ABCMeta):
    

    @abc.abstractmethod
    def service_name(self):
        
        raise NotImplementedError()





class ServerInterceptor(abc.ABC):
    

    @abc.abstractmethod
    def intercept_service(self, continuation, handler_call_details):
        
        raise NotImplementedError()





class Server(abc.ABC):
    

    @abc.abstractmethod
    def add_generic_rpc_handlers(self, generic_rpc_handlers):
        
        raise NotImplementedError()

    def add_registered_method_handlers(self, service_name, method_handlers):
        

    @abc.abstractmethod
    def add_insecure_port(self, address):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def add_secure_port(self, address, server_credentials):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def start(self):
        
        raise NotImplementedError()

    @abc.abstractmethod
    def stop(self, grace):
        
        raise NotImplementedError()

    def wait_for_termination(self, timeout=None):
        
        raise NotImplementedError()





def unary_unary_rpc_method_handler(
    behavior, request_deserializer=None, response_serializer=None
):
    
    from grpc import _utilities  

    return _utilities.RpcMethodHandler(
        False,
        False,
        request_deserializer,
        response_serializer,
        behavior,
        None,
        None,
        None,
    )


def unary_stream_rpc_method_handler(
    behavior, request_deserializer=None, response_serializer=None
):
    
    from grpc import _utilities  

    return _utilities.RpcMethodHandler(
        False,
        True,
        request_deserializer,
        response_serializer,
        None,
        behavior,
        None,
        None,
    )


def stream_unary_rpc_method_handler(
    behavior, request_deserializer=None, response_serializer=None
):
    
    from grpc import _utilities  

    return _utilities.RpcMethodHandler(
        True,
        False,
        request_deserializer,
        response_serializer,
        None,
        None,
        behavior,
        None,
    )


def stream_stream_rpc_method_handler(
    behavior, request_deserializer=None, response_serializer=None
):
    
    from grpc import _utilities  

    return _utilities.RpcMethodHandler(
        True,
        True,
        request_deserializer,
        response_serializer,
        None,
        None,
        None,
        behavior,
    )


def method_handlers_generic_handler(service, method_handlers):
    
    from grpc import _utilities  

    return _utilities.DictionaryGenericHandler(service, method_handlers)


def ssl_channel_credentials(
    root_certificates=None, private_key=None, certificate_chain=None
):
    
    return ChannelCredentials(
        _cygrpc.SSLChannelCredentials(
            root_certificates, private_key, certificate_chain
        )
    )


def xds_channel_credentials(fallback_credentials=None):
    
    fallback_credentials = (
        ssl_channel_credentials()
        if fallback_credentials is None
        else fallback_credentials
    )
    return ChannelCredentials(
        _cygrpc.XDSChannelCredentials(fallback_credentials._credentials)
    )


def metadata_call_credentials(metadata_plugin, name=None):
    
    from grpc import _plugin_wrapping  

    return _plugin_wrapping.metadata_plugin_call_credentials(
        metadata_plugin, name
    )


def access_token_call_credentials(access_token):
    
    from grpc import _auth  
    from grpc import _plugin_wrapping  

    return _plugin_wrapping.metadata_plugin_call_credentials(
        _auth.AccessTokenAuthMetadataPlugin(access_token), None
    )


def composite_call_credentials(*call_credentials):
    
    return CallCredentials(
        _cygrpc.CompositeCallCredentials(
            tuple(
                single_call_credentials._credentials
                for single_call_credentials in call_credentials
            )
        )
    )


def composite_channel_credentials(channel_credentials, *call_credentials):
    
    return ChannelCredentials(
        _cygrpc.CompositeChannelCredentials(
            tuple(
                single_call_credentials._credentials
                for single_call_credentials in call_credentials
            ),
            channel_credentials._credentials,
        )
    )


def ssl_server_credentials(
    private_key_certificate_chain_pairs,
    root_certificates=None,
    require_client_auth=False,
):
    
    if not private_key_certificate_chain_pairs:
        raise ValueError(
            "At least one private key-certificate chain pair is required!"
        )
    elif require_client_auth and root_certificates is None:
        raise ValueError(
            "Illegal to require client auth without providing root"
            " certificates!"
        )
    else:
        return ServerCredentials(
            _cygrpc.server_credentials_ssl(
                root_certificates,
                [
                    _cygrpc.SslPemKeyCertPair(key, pem)
                    for key, pem in private_key_certificate_chain_pairs
                ],
                require_client_auth,
            )
        )


def xds_server_credentials(fallback_credentials):
    
    return ServerCredentials(
        _cygrpc.xds_server_credentials(fallback_credentials._credentials)
    )


def insecure_server_credentials():
    
    return ServerCredentials(_cygrpc.insecure_server_credentials())


def ssl_server_certificate_configuration(
    private_key_certificate_chain_pairs, root_certificates=None
):
    
    if private_key_certificate_chain_pairs:
        return ServerCertificateConfiguration(
            _cygrpc.server_certificate_config_ssl(
                root_certificates,
                [
                    _cygrpc.SslPemKeyCertPair(key, pem)
                    for key, pem in private_key_certificate_chain_pairs
                ],
            )
        )
    else:
        raise ValueError(
            "At least one private key-certificate chain pair is required!"
        )


def dynamic_ssl_server_credentials(
    initial_certificate_configuration,
    certificate_configuration_fetcher,
    require_client_authentication=False,
):
    
    return ServerCredentials(
        _cygrpc.server_credentials_ssl_dynamic_cert_config(
            initial_certificate_configuration,
            certificate_configuration_fetcher,
            require_client_authentication,
        )
    )


@enum.unique
class LocalConnectionType(enum.Enum):
    

    UDS = _cygrpc.LocalConnectionType.uds
    LOCAL_TCP = _cygrpc.LocalConnectionType.local_tcp


def local_channel_credentials(local_connect_type=LocalConnectionType.LOCAL_TCP):
    
    return ChannelCredentials(
        _cygrpc.channel_credentials_local(local_connect_type.value)
    )


def local_server_credentials(local_connect_type=LocalConnectionType.LOCAL_TCP):
    
    return ServerCredentials(
        _cygrpc.server_credentials_local(local_connect_type.value)
    )


def alts_channel_credentials(service_accounts=None):
    
    return ChannelCredentials(
        _cygrpc.channel_credentials_alts(service_accounts or [])
    )


def alts_server_credentials():
    
    return ServerCredentials(_cygrpc.server_credentials_alts())


def compute_engine_channel_credentials(call_credentials):
    
    return ChannelCredentials(
        _cygrpc.channel_credentials_compute_engine(
            call_credentials._credentials
        )
    )


def channel_ready_future(channel):
    
    from grpc import _utilities  

    return _utilities.channel_ready_future(channel)


def insecure_channel(target, options=None, compression=None):
    
    from grpc import _channel  

    return _channel.Channel(
        target, () if options is None else options, None, compression
    )


def secure_channel(target, credentials, options=None, compression=None):
    
    from grpc import _channel  
    from grpc.experimental import _insecure_channel_credentials

    if credentials._credentials is _insecure_channel_credentials:
        raise ValueError(
            "secure_channel cannot be called with insecure credentials."
            + " Call insecure_channel instead."
        )
    return _channel.Channel(
        target,
        () if options is None else options,
        credentials._credentials,
        compression,
    )


def intercept_channel(channel, *interceptors):
    
    from grpc import _interceptor  

    return _interceptor.intercept_channel(channel, *interceptors)


def server(
    thread_pool,
    handlers=None,
    interceptors=None,
    options=None,
    maximum_concurrent_rpcs=None,
    compression=None,
    xds=False,
):
    
    from grpc import _server  

    return _server.create_server(
        thread_pool,
        () if handlers is None else handlers,
        () if interceptors is None else interceptors,
        () if options is None else options,
        maximum_concurrent_rpcs,
        compression,
        xds,
    )


@contextlib.contextmanager
def _create_servicer_context(rpc_event, state, request_deserializer):
    from grpc import _server  

    context = _server._Context(rpc_event, state, request_deserializer)
    yield context
    context._finalize_state()  


@enum.unique
class Compression(enum.IntEnum):
    

    NoCompression = _compression.NoCompression
    Deflate = _compression.Deflate
    Gzip = _compression.Gzip




__all__ = (
    "FutureTimeoutError",
    "FutureCancelledError",
    "Future",
    "ChannelConnectivity",
    "StatusCode",
    "Status",
    "RpcError",
    "RpcContext",
    "Call",
    "ChannelCredentials",
    "CallCredentials",
    "AuthMetadataContext",
    "AuthMetadataPluginCallback",
    "AuthMetadataPlugin",
    "Compression",
    "ClientCallDetails",
    "ServerCertificateConfiguration",
    "ServerCredentials",
    "LocalConnectionType",
    "UnaryUnaryMultiCallable",
    "UnaryStreamMultiCallable",
    "StreamUnaryMultiCallable",
    "StreamStreamMultiCallable",
    "UnaryUnaryClientInterceptor",
    "UnaryStreamClientInterceptor",
    "StreamUnaryClientInterceptor",
    "StreamStreamClientInterceptor",
    "Channel",
    "ServicerContext",
    "RpcMethodHandler",
    "HandlerCallDetails",
    "GenericRpcHandler",
    "ServiceRpcHandler",
    "Server",
    "ServerInterceptor",
    "unary_unary_rpc_method_handler",
    "unary_stream_rpc_method_handler",
    "stream_unary_rpc_method_handler",
    "stream_stream_rpc_method_handler",
    "method_handlers_generic_handler",
    "ssl_channel_credentials",
    "metadata_call_credentials",
    "access_token_call_credentials",
    "composite_call_credentials",
    "composite_channel_credentials",
    "compute_engine_channel_credentials",
    "local_channel_credentials",
    "local_server_credentials",
    "alts_channel_credentials",
    "alts_server_credentials",
    "ssl_server_credentials",
    "ssl_server_certificate_configuration",
    "dynamic_ssl_server_credentials",
    "channel_ready_future",
    "insecure_channel",
    "secure_channel",
    "intercept_channel",
    "server",
    "protos",
    "services",
    "protos_and_services",
    "xds_channel_credentials",
    "xds_server_credentials",
    "insecure_server_credentials",
)




try:
    import grpc_tools

    sys.modules.update({"grpc.tools": grpc_tools})
except ImportError:
    pass
try:
    import grpc_health

    sys.modules.update({"grpc.health": grpc_health})
except ImportError:
    pass
try:
    import grpc_reflection

    sys.modules.update({"grpc.reflection": grpc_reflection})
except ImportError:
    pass


if sys.version_info >= (3, 6) and __name__ == "grpc":
    from grpc import aio  

    sys.modules.update({"grpc.aio": aio})
