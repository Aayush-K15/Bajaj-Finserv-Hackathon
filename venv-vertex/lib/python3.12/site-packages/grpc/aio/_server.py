














from concurrent.futures import Executor
from typing import Any, Dict, Optional, Sequence

import grpc
from grpc import _common
from grpc import _compression
from grpc._cython import cygrpc

from . import _base_server
from ._interceptor import ServerInterceptor
from ._typing import ChannelArgumentType


def _augment_channel_arguments(
    base_options: ChannelArgumentType, compression: Optional[grpc.Compression]
):
    compression_option = _compression.create_channel_option(compression)
    return tuple(base_options) + compression_option


class Server(_base_server.Server):
    

    def __init__(
        self,
        thread_pool: Optional[Executor],
        generic_handlers: Optional[Sequence[grpc.GenericRpcHandler]],
        interceptors: Optional[Sequence[Any]],
        options: ChannelArgumentType,
        maximum_concurrent_rpcs: Optional[int],
        compression: Optional[grpc.Compression],
    ):
        self._loop = cygrpc.get_working_loop()
        if interceptors:
            invalid_interceptors = [
                interceptor
                for interceptor in interceptors
                if not isinstance(interceptor, ServerInterceptor)
            ]
            if invalid_interceptors:
                raise ValueError(
                    "Interceptor must be ServerInterceptor, the "
                    f"following are invalid: {invalid_interceptors}"
                )
        self._server = cygrpc.AioServer(
            self._loop,
            thread_pool,
            generic_handlers,
            interceptors,
            _augment_channel_arguments(options, compression),
            maximum_concurrent_rpcs,
        )

    def add_generic_rpc_handlers(
        self, generic_rpc_handlers: Sequence[grpc.GenericRpcHandler]
    ) -> None:
        
        self._server.add_generic_rpc_handlers(generic_rpc_handlers)

    def add_registered_method_handlers(
        self,
        service_name: str,
        method_handlers: Dict[str, grpc.RpcMethodHandler],
    ) -> None:
        
        pass

    def add_insecure_port(self, address: str) -> int:
        
        return _common.validate_port_binding_result(
            address, self._server.add_insecure_port(_common.encode(address))
        )

    def add_secure_port(
        self, address: str, server_credentials: grpc.ServerCredentials
    ) -> int:
        
        return _common.validate_port_binding_result(
            address,
            self._server.add_secure_port(
                _common.encode(address), server_credentials
            ),
        )

    async def start(self) -> None:
        
        await self._server.start()

    async def stop(self, grace: Optional[float]) -> None:
        
        await self._server.shutdown(grace)

    async def wait_for_termination(
        self, timeout: Optional[float] = None
    ) -> bool:
        
        return await self._server.wait_for_termination(timeout)

    def __del__(self):
        
        if hasattr(self, "_server"):
            if self._server.is_running():
                cygrpc.schedule_coro_threadsafe(
                    self._server.shutdown(None),
                    self._loop,
                )


def server(
    migration_thread_pool: Optional[Executor] = None,
    handlers: Optional[Sequence[grpc.GenericRpcHandler]] = None,
    interceptors: Optional[Sequence[Any]] = None,
    options: Optional[ChannelArgumentType] = None,
    maximum_concurrent_rpcs: Optional[int] = None,
    compression: Optional[grpc.Compression] = None,
):
    
    return Server(
        migration_thread_pool,
        () if handlers is None else handlers,
        () if interceptors is None else interceptors,
        () if options is None else options,
        maximum_concurrent_rpcs,
        compression,
    )
