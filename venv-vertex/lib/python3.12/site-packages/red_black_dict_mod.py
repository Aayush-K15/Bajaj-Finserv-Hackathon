











































from __future__ import division

import sys
import math
import random
import itertools

if hasattr(itertools, 'izip_longest'):
    MY_ZIP_LONGEST = getattr(itertools, 'izip_longest')
else:
    MY_ZIP_LONGEST = getattr(itertools, 'zip_longest')

try:
    next
except NameError:
    def next(iterator):
        
        
        return iterator.next()





def center(string, field_use_width, field_avail_width):
    
    field_use = (string + '_' * (field_use_width - 1))[:field_use_width - 1]
    pad_width = (field_avail_width - len(field_use)) / 2.0
    result = ' ' * int(pad_width) + field_use + ' ' * int(math.ceil(pad_width))
    return result

class BinaryTree(object):
    
    

    __slots__ = ('key', 'value', 'left', 'right', 'parent')

    def __init__(self, key=None, value=None, left=None, right=None, parent=None):
        
        self.key = key
        self.value = value
        self.left = left
        self.right = right
        self.parent = parent

    def __repr__(self):
        
        if self:
            return '%s %s' % (self.key, self.value)
        else:
            return "sent"

    def _depth_and_field_width(self):
        
        class maxer(object):
            
            def __init__(self, maximum=-1):
                self.depth_max = maximum
                self.field_width_max = -1

            def feed(self, node, key, value, depth, from_left):
                
                
                
                dummy = key
                dummy = value
                dummy = from_left
                if depth > self.depth_max:
                    self.depth_max = depth
                repr_node = repr(node)
                len_node = len(repr_node)
                if len_node > self.field_width_max:
                    self.field_width_max = len_node

            def result(self):
                
                return (self.depth_max + 1, self.field_width_max)

        max_obj = maxer()
        self.detailed_inorder_traversal(max_obj.feed)
        return max_obj.result()

    def to_dot(self, initial=True, file_=sys.stdout, visited=None):
        

        if visited is None:
            visited = set()
        if initial:
            file_.write('digraph G {\n')
        this_node = '%s %s' % (id(self), repr(self))
        if this_node in visited:
            return
        visited.add(this_node)
        if self.left is not None:
            file_.write('   "%s" -> "%s %s" [ label="left" ]\n' % (this_node, id(self.left), repr(self.left)))
            self.left.to_dot(initial=False, file_=file_, visited=visited)
        if self.right is not None:
            file_.write('   "%s" -> "%s %s" [ label="right" ]\n' % (this_node, id(self.right), repr(self.right)))
            self.right.to_dot(initial=False, file_=file_, visited=visited)
        if initial:
            file_.write('}\n')

    def __str__(self):
        
        class Desc(object):
            
            
            
            def __init__(self, pretree):
                self.tree = pretree

            def update(self, node, key, value, depth, from_left):
                
                
                
                dummy = key
                dummy = value
                self.tree[depth][from_left] = repr(node)

        pretree = []
        depth, field_use_width = self._depth_and_field_width()
        field_use_width += 1
        for level in range(depth):
            string = '_' * (field_use_width - 1)
            pretree.append([string] * 2 ** level)
        desc = Desc(pretree)
        self.detailed_inorder_traversal(desc.update)
        result = []
        widest = 2 ** (depth - 1) * field_use_width
        for level in range(depth):
            two_level = 2 ** level
            field_avail_width = widest / two_level
            string = ''.join([center(x, field_use_width, field_avail_width) for x in desc.tree[level]])
            
            result.append(('%2d ' % level) + string)
        return '\n'.join(result)

    def __nonzero__(self):
        
        return not (self.left is None and self.right is None)

    __bool__ = __nonzero__

    @property
    def is_root(self):
        
        return self.parent is None

    @property
    def sibling(self):
        
        
        if self.is_root:
            return None
        elif self is self.parent.left:
            return self.parent.right
        else:
            return self.parent.left

    @property
    def size(self):
        
        if self:
            return self.left.size + self.right.size + 1
        return 0

    @property
    def num_levels(self):
        
        if self:
            return max(self.left.num_levels, self.right.num_levels) + 1
        return 0

    @property
    def height(self):
        
        return self.num_levels - 1

    def copy(self, parent=None):
        
        if self:
            copy = self.__class__(key=self.key, value=self.value, parent=parent)
            copy.left = self.left.copy(copy)
            copy.right = self.right.copy(copy)
        else:
            copy = self.__class__(parent=parent)
        return copy

    def del_node(self):
        
        if self.left:
            if self.right:
                
                
                if random.random() < 0.5:
                    node = self.left.maximum
                    self.key = node.key
                    self.value = node.value
                    node.del_node()
                else:
                    node = self.right.minimum
                    self.key = node.key
                    self.value = node.value
                    node.del_node()
            else:
                node = self.left
                self.key, self.left, self.right = node.key, node.left, node.right
                self.value = node.value
                self.left.parent = self
                self.right.parent = self
        elif self.right:
            node = self.right
            self.key, self.left, self.right = node.key, node.left, node.right
            self.value = node.value
            self.left.parent = self
            self.right.parent = self
        else:
            
            self.key = self.left = self.right = None
            self.value = None

    def add(self, key, value):
        
        node = self.find(key)
        if not node:
            node.key = key
            node.value = value
            node.left, node.right = self.__class__(parent=node), self.__class__(parent=node)
            return (False, node)
        elif node.key == key:
            node.key = key
            node.value = value
            return (True, node)
        else:
            if random.random() < 0.5:
                return BinaryTree.add(node.left, key=key, value=value)
            else:
                return BinaryTree.add(node.right, key=key, value=value)

    def remove(self, key):
        
        node = self.find(key)
        if node:
            node.del_node()
        else:
            raise ValueError('tree.remove(x): x not in tree')

    def remove_min(self):
        
        node = self.minimum
        if node:
            
            
            result = (node.key, node.value)
            node.del_node()
            return result
        else:
            raise ValueError('tree.remove(x): x not in tree')

    def remove_max(self):
        
        node = self.maximum
        if node:
            
            
            result = (node.key, node.value)
            node.del_node()
            return result
        else:
            raise ValueError('tree.remove(x): x not in tree')

    def discard(self, key):
        
        try:
            self.remove(key)
        except ValueError:
            pass

    def count(self, key):
        
        if self:
            node = self.find(key)
            if node:
                return node.left.count(key) + node.right.count(key) + 1
        return 0

    def __add__(self, iterable):
        
        items = list(self) + list(iterable)
        random.shuffle(items)  
        tree = self.__class__()
        for item in items:
            tree.add(item)
        return tree

    def __iadd__(self, iterable):
        
        items = list(iterable)
        random.shuffle(items)  
        for item in items:
            self.add(item)

    def find(self, key):
        
        if self:
            if self.key == key:
                return self
            elif key < self.key:
                return self.left.find(key)
            else:
                return self.right.find(key)
        return self

    @property
    def predecessor(self):
        
        if self.left:
            return self.left.maximum
        else:
            if not self.parent:
                return None
            if self is self.parent.right:
                return self.parent
            else:
                current, parent = self, self.parent
                while parent and parent.left is current:
                    current, parent = parent, parent.parent
                return parent

    @property
    def successor(self):
        
        if self.right:
            return self.right.minimum
        else:
            if not self.parent:
                return None
            if self is self.parent.left:
                return self.parent
            else:
                current, parent = self, self.parent
                while parent and parent.right is current:
                    current, parent = parent, parent.parent
                return parent

    def in_order(self):
        
        if self:
            if self.left:
                for node in self.left.in_order():
                    yield node
            yield self
            if self.right:
                for node in self.right.in_order():
                    yield node

    def detailed_inorder_traversal(self, visit, depth=0, from_left=0):
        
        if self.left:
            self.left.detailed_inorder_traversal(visit, depth + 1, from_left * 2)
        visit(self, self.key, self.value, depth, from_left)
        if self.right:
            self.right.detailed_inorder_traversal(visit, depth + 1, from_left * 2 + 1)

    def __iter__(self):
        
        return (n.key for n in self.in_order())

    def in_reverse(self):
        
        if self:
            for node in self.right.in_reverse():
                yield node
            yield self
            for node in self.left.in_reverse():
                yield node

    def pre_order(self):
        
        if self:
            yield self
            if self.left:
                for node in self.left.pre_order():
                    yield node
            if self.right:
                for node in self.right.pre_order():
                    yield node

    def post_order(self):
        
        if self:
            if self.left:
                for node in self.left.post_order():
                    yield node
            if self.right:
                for node in self.right.post_order():
                    yield node
            yield self

    @property
    def minimum(self):
        
        node = self
        while node.left:
            node = node.left
        return node

    @property
    def maximum(self):
        
        node = self
        while node.right:
            node = node.right
        return node

    def find_min(self):
        
        node = self.minimum
        return node.key

    def find_max(self):
        
        node = self.maximum
        return node.key

    def is_similar(self, other):
        
        if not self and not other:
            return True
        if self and other:
            return self.left.is_similar(other.left) and self.right.is_similar(other.right)
        return False

    def is_equivalent(self, other):
        
        if not self and not other:
            return True
        if self and other:
            return (
                self.key == other.key and
                self.value == other.value and
                self.left.is_equivalent(other.left) and
                self.right.is_equivalent(other.right)
            )
        return False































    def __cmp__(self, other):
        
        
        for self_node, other_node in MY_ZIP_LONGEST(self.in_order(), other.in_order()):
            if self_node is None:
                return -1
            elif other_node is None:
                return 1
            elif self_node.key < other_node.key:
                return -1
            elif self_node.key > other_node.key:
                return 1
        return 0

    cmp = __cmp__

    def __eq__(self, other):
        
        return self.cmp(other) == 0

    def __neq__(self, other):
        
        return self.cmp(other) != 0

    def __lt__(self, other):
        
        return self.cmp(other) < 0

    def __gt__(self, other):
        return other.cmp(self) < 0

    def __le__(self, other):
        return self.cmp(other) <= 0

    def __ge__(self, other):
        return self.cmp(other) >= 0

    def __contains__(self, key):
        
        return bool(self.find(key))


class RedBlackTree(BinaryTree):
    
    

    __slots__ = BinaryTree.__slots__ + ('is_red', )

    def __init__(self, key=None, value=None, left=None, right=None, parent=None):
        
        super(RedBlackTree, self).__init__(key, value, left, right, parent)
        self.is_red = False  

    @property
    def is_black(self):
        
        return not self.is_red

    @is_black.setter
    def is_black(self, val):
        
        self.is_red = not val

    @property
    def black_height(self):
        
        if self.left:
            if self.left.is_black:
                return self.left.black_height + 1
            else:
                return self.left.black_height
        elif self.right:
            if self.right.is_black:
                return self.right.black_height + 1
            else:
                return self.right.black_height
        else:
            return 0

    def __repr__(self):
        
        if self:
            if self.is_red:
                color_string = 'red'
            else:
                color_string = 'blk'
            return '%s %s %s' % (self.key, self.value, color_string)
        else:
            return "sent"

    def copy(self, parent=None):
        
        copy = super(RedBlackTree, self).copy(parent)
        copy.is_red = self.is_red
        return copy

    def add(self, key, value):
        
        (replaced, node) = super(RedBlackTree, self).add(key=key, value=value)
        if not replaced:
            node.is_red = True
            node = node.fix_insert()
        return node

    def fix_insert(self):
        
        
        if self.parent is None:
            self.is_black = True
            return self
        
        if self.parent.is_black:
            return self
        
        sib = self.parent.sibling
        if sib.is_red:
            self.parent.is_black = True
            sib.is_black = True
            par = self.parent.parent
            par.is_red = True
            par.fix_insert()
            return self
        
        par = self.parent.parent
        if not (self.parent.left is self) == (par.left is self.parent):
            self.rotate()
            self.parent.rotate()
            return par
        else:
            self.parent.rotate()
            return self

    def rotate(self):
        
        
        
        if self is self.parent.left:
            self.key, self.parent.key = self.parent.key, self.key
            self.value, self.parent.value = self.parent.value, self.value
            self.parent.left = self.left
            self.parent.left.parent = self.parent
            self.left = self.right
            self.right = self.parent.right
            self.left.parent = self.right.parent = self
            self.parent.right = self
        else:
            self.key, self.parent.key = self.parent.key, self.key
            self.value, self.parent.value = self.parent.value, self.value
            self.parent.right = self.right
            self.parent.right.parent = self.parent
            self.right = self.left
            self.left = self.parent.left
            self.left.parent = self.right.parent = self
            self.parent.left = self

    def del_node(self):
        
        
        if self.left:
            if self.right:
                
                
                if random.random() < 0.5:
                    node = self.left.maximum
                else:
                    node = self.right.minimum
                self.key, node.key = node.key, self.key
                self.value, node.value = node.value, self.value
                node.del_node()  
            else:
                node = self.left
                self.key, self.left, self.right = node.key, node.left, node.right
                self.value = node.value
                self.left.parent = self  
                self.right.parent = self
                self.is_black = True
        elif self.right:
            node = self.right
            self.key, self.left, self.right = node.key, node.left, node.right
            self.value = node.value
            self.left.parent = self
            self.right.parent = self
            self.is_black = True
        else:
            
            self.key = self.left = self.right = None
            self.value = None
            if self.is_red:
                self.is_black = True
            else:
                self.is_black = True
                
                self.fix_del()

    def fix_del(self):
        
        
        if self.parent is None:
            return
        sib = self.sibling
        
        if sib.is_red:
            sib.rotate()
            sib = self.sibling
        
        if (
                self.parent.is_black and 
                sib.is_black and
                sib.left.is_black and 
                sib.right.is_black
        ):
            sib.is_red = True
            self.parent.fix_del()
            return
        
        if (
                self.parent.is_red and
                sib.is_black and
                sib.left.is_black and
                sib.right.is_black
        ):
            sib.is_red = True
            self.parent.is_black = True
            return
        
        if sib.is_black:
            if self is self.parent.left and sib.right.is_black and sib.left.is_red:
                sib.left.rotate()
            elif self is self.parent.right and sib.left.is_black and sib.right.is_red:
                sib.right.rotate()
            sib = self.sibling
        
        sib.rotate()
        self.parent.sibling.is_black = True

    def check(self):
        
        leaf_nodes = []
        for node in self.in_order():
            if not node.left and not node.right:
                leaf_nodes.append(node)
            if node.is_red:
                if not (node.left.is_black and node.right.is_black):
                    return False
        black_height = 0
        if leaf_nodes:
            node = leaf_nodes[0]
            while node.parent:
                if node.is_black:
                    black_height += 1
                node = node.parent
            for node in leaf_nodes[1:]:
                height = 0
                while node.parent:
                    if node.is_black:
                        height += 1
                    node = node.parent
                if not height == black_height:
                    return False
        return True

    def __getitem__(self, key):
        

        node = self.find(key)
        if node:
            return node.value
        else:
            raise KeyError

    def __setitem__(self, key, value):
        

        self.add(key, value)

    def __delitem__(self, key):
        

        node = self.find(key)
        if node:
            node.del_node()
        else:
            raise KeyError

    def iteritems(self):
        

        return ((node.key, node.value) for node in self.in_order())

    items = iteritems

    def itervalues(self):
        

        return (node.value for node in self.in_order())

    values = itervalues

    def __len__(self):
        

        return self.size

    def _slow_len(self):
        

        count = 0

        for element in self:
            dummy = element
            count += 1

        return count
