















from __future__ import absolute_import

import http.client
import logging

from google.auth import exceptions
from google.auth import transport
import httplib2


_LOGGER = logging.getLogger(__name__)

_STREAM_PROPERTIES = ("read", "seek", "tell")


class _Response(transport.Response):
    

    def __init__(self, response, data):
        self._response = response
        self._data = data

    @property
    def status(self):
        
        return self._response.status

    @property
    def headers(self):
        
        return dict(self._response)

    @property
    def data(self):
        
        return self._data


class Request(transport.Request):
    

    def __init__(self, http):
        self.http = http

    def __call__(
        self, url, method="GET", body=None, headers=None, timeout=None, **kwargs
    ):
        
        if timeout is not None:
            _LOGGER.warning(
                "httplib2 transport does not support per-request timeout. "
                "Set the timeout when constructing the httplib2.Http instance."
            )

        try:
            _LOGGER.debug("Making request: %s %s", method, url)
            response, data = self.http.request(
                url, method=method, body=body, headers=headers, **kwargs
            )
            return _Response(response, data)
        
        
        except (httplib2.HttpLib2Error, http.client.HTTPException) as exc:
            raise exceptions.TransportError(exc)


def _make_default_http():
    
    return httplib2.Http()


class AuthorizedHttp(object):
    

    def __init__(
        self,
        credentials,
        http=None,
        refresh_status_codes=transport.DEFAULT_REFRESH_STATUS_CODES,
        max_refresh_attempts=transport.DEFAULT_MAX_REFRESH_ATTEMPTS,
    ):
        

        if http is None:
            http = _make_default_http()

        self.http = http
        self.credentials = credentials
        self._refresh_status_codes = refresh_status_codes
        self._max_refresh_attempts = max_refresh_attempts
        
        
        self._request = Request(self.http)

    def close(self):
        
        self.http.close()

    def request(
        self,
        uri,
        method="GET",
        body=None,
        headers=None,
        redirections=httplib2.DEFAULT_MAX_REDIRECTS,
        connection_type=None,
        **kwargs
    ):
        

        _credential_refresh_attempt = kwargs.pop("_credential_refresh_attempt", 0)

        
        
        request_headers = headers.copy() if headers is not None else {}

        self.credentials.before_request(self._request, method, uri, request_headers)

        
        
        body_stream_position = None
        if all(getattr(body, stream_prop, None) for stream_prop in _STREAM_PROPERTIES):
            body_stream_position = body.tell()

        
        response, content = self.http.request(
            uri,
            method,
            body=body,
            headers=request_headers,
            redirections=redirections,
            connection_type=connection_type,
            **kwargs
        )

        
        
        
        
        
        if (
            response.status in self._refresh_status_codes
            and _credential_refresh_attempt < self._max_refresh_attempts
        ):

            _LOGGER.info(
                "Refreshing credentials due to a %s response. Attempt %s/%s.",
                response.status,
                _credential_refresh_attempt + 1,
                self._max_refresh_attempts,
            )

            self.credentials.refresh(self._request)

            
            if body_stream_position is not None:
                body.seek(body_stream_position)

            
            return self.request(
                uri,
                method,
                body=body,
                headers=headers,
                redirections=redirections,
                connection_type=connection_type,
                _credential_refresh_attempt=_credential_refresh_attempt + 1,
                **kwargs
            )

        return response, content

    def add_certificate(self, key, cert, domain, password=None):
        
        self.http.add_certificate(key, cert, domain, password=password)

    @property
    def connections(self):
        
        return self.http.connections

    @connections.setter
    def connections(self, value):
        
        self.http.connections = value

    @property
    def follow_redirects(self):
        
        return self.http.follow_redirects

    @follow_redirects.setter
    def follow_redirects(self, value):
        
        self.http.follow_redirects = value

    @property
    def timeout(self):
        
        return self.http.timeout

    @timeout.setter
    def timeout(self, value):
        
        self.http.timeout = value

    @property
    def redirect_codes(self):
        
        return self.http.redirect_codes

    @redirect_codes.setter
    def redirect_codes(self, value):
        
        self.http.redirect_codes = value
