from __future__ import annotations

import sys
import threading
import warnings
from typing import TYPE_CHECKING, Literal

if sys.version_info >= (3, 13):
    from warnings import deprecated as _deprecated
else:
    from typing_extensions import deprecated as _deprecated


if TYPE_CHECKING:
    if sys.version_info >= (3, 11):
        from typing import LiteralString
    else:
        from typing_extensions import LiteralString

__all__ = [
    "AltairDeprecationWarning",
    "deprecated",
    "deprecated_static_only",
    "deprecated_warn",
]


class AltairDeprecationWarning(DeprecationWarning): ...


def _format_message(
    version: LiteralString,
    alternative: LiteralString | None,
    message: LiteralString | None,
    /,
) -> LiteralString:
    output = f"\nDeprecated since `altair={version}`."
    if alternative:
        output = f"{output} Use {alternative} instead."
    return f"{output}\n{message}" if message else output




def deprecated(
    *,
    version: LiteralString,
    alternative: LiteralString | None = None,
    message: LiteralString | None = None,
    category: type[AltairDeprecationWarning] | None = AltairDeprecationWarning,
    stacklevel: int = 1,
):  
    
    msg = _format_message(version, alternative, message)
    return _deprecated(msg, category=category, stacklevel=stacklevel)


def deprecated_warn(
    message: LiteralString,
    *,
    version: LiteralString,
    alternative: LiteralString | None = None,
    category: type[AltairDeprecationWarning] = AltairDeprecationWarning,
    stacklevel: int = 2,
    action: Literal["once"] | None = None,
) -> None:
    
    msg = _format_message(version, alternative, message)
    if action is None:
        warnings.warn(msg, category=category, stacklevel=stacklevel)
    elif action == "once":
        _warn_once(msg, category=category, stacklevel=stacklevel)
    else:
        raise NotImplementedError(action)


deprecated_static_only = _deprecated



class _WarningsMonitor:
    def __init__(self) -> None:
        self._warned: dict[LiteralString, Literal[True]] = {}
        self._lock = threading.Lock()

    def __contains__(self, key: LiteralString, /) -> bool:
        with self._lock:
            return key in self._warned

    def hit(self, key: LiteralString, /) -> None:
        with self._lock:
            self._warned[key] = True

    def clear(self) -> None:
        with self._lock:
            self._warned.clear()


_warnings_monitor = _WarningsMonitor()


def _warn_once(
    msg: LiteralString, /, *, category: type[AltairDeprecationWarning], stacklevel: int
) -> None:
    global _warnings_monitor
    if msg in _warnings_monitor:
        return
    else:
        _warnings_monitor.hit(msg)
        warnings.warn(msg, category=category, stacklevel=stacklevel + 1)
