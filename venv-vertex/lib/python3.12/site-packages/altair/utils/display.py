from __future__ import annotations

import json
import pkgutil
import textwrap
import uuid
from typing import TYPE_CHECKING, Any, Callable, Union

from ._vegafusion_data import compile_with_vegafusion, using_vegafusion
from .mimebundle import spec_to_mimebundle
from .plugin_registry import PluginEnabler, PluginRegistry
from .schemapi import validate_jsonschema

if TYPE_CHECKING:
    import sys

    if sys.version_info >= (3, 10):
        from typing import TypeAlias
    else:
        from typing_extensions import TypeAlias







MimeBundleDataType: TypeAlias = dict[str, Any]
MimeBundleMetaDataType: TypeAlias = dict[str, Any]
MimeBundleType: TypeAlias = Union[
    MimeBundleDataType, tuple[MimeBundleDataType, MimeBundleMetaDataType]
]
RendererType: TypeAlias = Callable[..., MimeBundleType]


DefaultRendererReturnType: TypeAlias = tuple[
    dict[str, Union[str, dict[str, Any]]], dict[str, dict[str, Any]]
]


class RendererRegistry(PluginRegistry[RendererType, MimeBundleType]):
    entrypoint_err_messages = {
        "notebook": textwrap.dedent(
            
        ),
    }

    def set_embed_options(
        self,
        defaultStyle: bool | str | None = None,
        renderer: str | None = None,
        width: int | None = None,
        height: int | None = None,
        padding: int | None = None,
        scaleFactor: float | None = None,
        actions: bool | dict[str, bool] | None = None,
        format_locale: str | dict | None = None,
        time_format_locale: str | dict | None = None,
        **kwargs,
    ) -> PluginEnabler:
        
        options: dict[str, bool | str | float | dict[str, bool] | None] = {
            "defaultStyle": defaultStyle,
            "renderer": renderer,
            "width": width,
            "height": height,
            "padding": padding,
            "scaleFactor": scaleFactor,
            "actions": actions,
            "formatLocale": format_locale,
            "timeFormatLocale": time_format_locale,
        }
        kwargs.update({key: val for key, val in options.items() if val is not None})
        return self.enable(None, embed_options=kwargs)







class Displayable:
    

    renderers: RendererRegistry | None = None
    schema_path = ("altair", "")

    def __init__(self, spec: dict[str, Any], validate: bool = False) -> None:
        self.spec = spec
        self.validate = validate
        self._validate()

    def _validate(self) -> None:
        
        data = pkgutil.get_data(*self.schema_path)
        assert data is not None
        schema_dict: dict[str, Any] = json.loads(data.decode("utf-8"))
        validate_jsonschema(
            self.spec,
            schema_dict,
        )

    def _repr_mimebundle_(
        self, include: Any = None, exclude: Any = None
    ) -> MimeBundleType:
        
        if self.renderers is not None:
            renderer_func = self.renderers.get()
            assert renderer_func is not None
            return renderer_func(self.spec)
        else:
            return {}


def default_renderer_base(
    spec: dict[str, Any], mime_type: str, str_repr: str, **options
) -> DefaultRendererReturnType:
    
    
    from altair.vegalite.v5.display import VEGA_MIME_TYPE, VEGALITE_MIME_TYPE

    assert isinstance(spec, dict)
    bundle: dict[str, str | dict] = {}
    metadata: dict[str, dict[str, Any]] = {}

    if using_vegafusion():
        spec = compile_with_vegafusion(spec)

        
        
        if mime_type == VEGALITE_MIME_TYPE:
            mime_type = VEGA_MIME_TYPE

    bundle[mime_type] = spec
    bundle["text/plain"] = str_repr
    if options:
        metadata[mime_type] = options
    return bundle, metadata


def json_renderer_base(
    spec: dict[str, Any], str_repr: str, **options
) -> DefaultRendererReturnType:
    
    return default_renderer_base(
        spec, mime_type="application/json", str_repr=str_repr, **options
    )


class HTMLRenderer:
    

    def __init__(self, output_div: str = "altair-viz-{}", **kwargs) -> None:
        self._output_div = output_div
        self.kwargs = kwargs

    @property
    def output_div(self) -> str:
        return self._output_div.format(uuid.uuid4().hex)

    def __call__(self, spec: dict[str, Any], **metadata) -> dict[str, str]:
        kwargs = self.kwargs.copy()
        kwargs.update(**metadata, output_div=self.output_div)
        return spec_to_mimebundle(spec, format="html", **kwargs)
