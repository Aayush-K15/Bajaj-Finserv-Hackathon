from __future__ import annotations

import functools
import hashlib
import io
import itertools
import json
import operator
import sys
import typing as t
import warnings
from collections.abc import Mapping, Sequence
from copy import deepcopy as _deepcopy
from typing import TYPE_CHECKING, Any, Literal, TypeVar, Union, overload

import jsonschema
import narwhals.stable.v1 as nw

from altair import theme, utils
from altair.expr import core as _expr_core
from altair.utils import Optional, SchemaBase, Undefined
from altair.utils._vegafusion_data import (
    compile_with_vegafusion as _compile_with_vegafusion,
)
from altair.utils._vegafusion_data import using_vegafusion as _using_vegafusion
from altair.utils.data import DataType
from altair.utils.data import is_data_type as _is_data_type
from altair.utils.schemapi import ConditionLike, _TypeMap

from .compiler import vegalite_compilers
from .data import data_transformers
from .display import VEGA_VERSION, VEGAEMBED_VERSION, VEGALITE_VERSION, renderers
from .schema import SCHEMA_URL, channels, core, mixins
from .schema._typing import Map, PrimitiveValue_T, SingleDefUnitChannel_T, Temporal

if sys.version_info >= (3, 14):
    from typing import TypedDict
else:
    from typing_extensions import TypedDict
if sys.version_info >= (3, 12):
    from typing import Protocol, TypeAliasType, runtime_checkable
else:
    from typing_extensions import (  
        Protocol,
        TypeAliasType,
        runtime_checkable,
    )
if sys.version_info >= (3, 11):
    from typing import LiteralString
else:
    from typing_extensions import LiteralString
if sys.version_info >= (3, 10):
    from typing import TypeAlias
else:
    from typing_extensions import TypeAlias

if TYPE_CHECKING:
    from collections.abc import Iterable, Iterator
    from pathlib import Path
    from typing import IO

    from altair.utils.core import DataFrameLike

    if sys.version_info >= (3, 13):
        from typing import Required, TypeIs
    else:
        from typing_extensions import Required, TypeIs
    if sys.version_info >= (3, 11):
        from typing import Never, Self
    else:
        from typing_extensions import Never, Self

    from altair.expr.core import (
        BinaryExpression,
        Expression,
        GetAttrExpression,
        GetItemExpression,
        IntoExpression,
    )
    from altair.utils.display import MimeBundleType

    from .schema._config import BrushConfigKwds, DerivedStreamKwds, MergedStreamKwds
    from .schema._typing import (
        AggregateOp_T,
        AutosizeType_T,
        ColorName_T,
        CompositeMark_T,
        ImputeMethod_T,
        LayoutAlign_T,
        Mark_T,
        MultiTimeUnit_T,
        OneOrSeq,
        ProjectionType_T,
        ResolveMode_T,
        SelectionResolution_T,
        SelectionType_T,
        SingleTimeUnit_T,
        StackOffset_T,
    )
    from .schema.channels import Column, Facet, Row
    from .schema.core import (
        AggregatedFieldDef,
        AggregateOp,
        AnyMark,
        BindCheckbox,
        Binding,
        BindInput,
        BindRadioSelect,
        BindRange,
        BinParams,
        BrushConfig,
        DateTime,
        Expr,
        ExprRef,
        FacetedEncoding,
        FacetFieldDef,
        FieldName,
        GraticuleGenerator,
        ImputeMethod,
        ImputeSequence,
        InlineData,
        InlineDataset,
        IntervalSelectionConfig,
        JoinAggregateFieldDef,
        LayerRepeatMapping,
        LookupSelection,
        NamedData,
        ParameterName,
        PointSelectionConfig,
        PredicateComposition,
        ProjectionType,
        RepeatMapping,
        RepeatRef,
        SelectionParameter,
        SequenceGenerator,
        SortField,
        SphereGenerator,
        Step,
        TimeUnit,
        TopLevelSelectionParameter,
        Transform,
        UrlData,
        VariableParameter,
        Vector2number,
        Vector2Vector2number,
        Vector3number,
        WindowFieldDef,
    )

__all__ = [
    "TOPLEVEL_ONLY_KEYS",
    "Bin",
    "ChainedWhen",
    "Chart",
    "ChartDataType",
    "ConcatChart",
    "DataType",
    "FacetChart",
    "FacetMapping",
    "HConcatChart",
    "Impute",
    "LayerChart",
    "LookupData",
    "Parameter",
    "ParameterExpression",
    "RepeatChart",
    "SelectionExpression",
    "SelectionPredicateComposition",
    "Then",
    "Title",
    "TopLevelMixin",
    "VConcatChart",
    "When",
    "binding",
    "binding_checkbox",
    "binding_radio",
    "binding_range",
    "binding_select",
    "check_fields_and_encodings",
    "concat",
    "condition",
    "graticule",
    "hconcat",
    "layer",
    "mixins",
    "param",
    "repeat",
    "selection",
    "selection_interval",
    "selection_multi",
    "selection_point",
    "selection_single",
    "sequence",
    "sphere",
    "topo_feature",
    "value",
    "vconcat",
    "when",
]

ChartDataType: TypeAlias = Optional[Union[DataType, core.Data, str, core.Generator]]
_TSchemaBase = TypeVar("_TSchemaBase", bound=SchemaBase)




def _dataset_name(values: dict[str, Any] | list | InlineDataset) -> str:
    
    if isinstance(values, core.InlineDataset):
        values = values.to_dict()
    if values == [{}]:
        return "empty"
    values_json = json.dumps(values, sort_keys=True, default=str)
    hsh = hashlib.sha256(values_json.encode()).hexdigest()[:32]
    return "data-" + hsh


def _consolidate_data(
    data: ChartDataType | UrlData, context: dict[str, Any]
) -> ChartDataType | NamedData | InlineData | UrlData:
    
    values: Any = Undefined
    kwds = {}

    if isinstance(data, core.InlineData):
        if utils.is_undefined(data.name) and not utils.is_undefined(data.values):
            if isinstance(data.values, core.InlineDataset):
                values = data.to_dict()["values"]
            else:
                values = data.values
            kwds = {"format": data.format}

    elif isinstance(data, dict) and "name" not in data and "values" in data:
        values = data["values"]
        kwds = {k: v for k, v in data.items() if k != "values"}

    if not utils.is_undefined(values):
        name = _dataset_name(values)
        data = core.NamedData(name=name, **kwds)
        context.setdefault("datasets", {})[name] = values

    return data


def _prepare_data(
    data: ChartDataType, context: dict[str, Any] | None = None
) -> ChartDataType | NamedData | InlineData | UrlData | Any:
    
    if data is Undefined:
        return data

    
    elif not isinstance(data, dict) and _is_data_type(data):
        if func := data_transformers.get():
            data = func(nw.to_native(data, pass_through=True))

    
    elif isinstance(data, str):
        data = core.UrlData(data)

    
    if context is not None and data_transformers.consolidate_datasets:
        data = _consolidate_data(data, context)

    
    if not isinstance(data, (dict, core.Data)):
        warnings.warn(f"data of type {type(data)} not recognized", stacklevel=1)

    return data




Bin = core.BinParams
Impute = core.ImputeParams
Title = core.TitleParams


class LookupData(core.LookupData):
    @utils.use_signature(core.LookupData)
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)

    def to_dict(self, *args: Any, **kwargs: Any) -> dict[str, Any]:
        
        copy = self.copy(deep=False)
        copy.data = _prepare_data(copy.data, kwargs.get("context"))
        return super(LookupData, copy).to_dict(*args, **kwargs)


class FacetMapping(core.FacetMapping):
    

    _class_is_valid_at_instantiation = False

    def __init__(
        self,
        column: Optional[str | FacetFieldDef | Column] = Undefined,
        row: Optional[str | FacetFieldDef | Row] = Undefined,
        **kwargs: Any,
    ) -> None:
        super().__init__(column=column, row=row, **kwargs)  

    def to_dict(self, *args: Any, **kwargs: Any) -> dict[str, Any]:
        copy = self.copy(deep=False)
        context = kwargs.get("context", {})
        data = context.get("data", None)
        if isinstance(self.row, str):
            copy.row = core.FacetFieldDef(**utils.parse_shorthand(self.row, data))
        if isinstance(self.column, str):
            copy.column = core.FacetFieldDef(**utils.parse_shorthand(self.column, data))
        return super(FacetMapping, copy).to_dict(*args, **kwargs)




core.FacetedEncoding._class_is_valid_at_instantiation = False





TOPLEVEL_ONLY_KEYS = {"background", "config", "autosize", "padding", "$schema"}




class Parameter(_expr_core.OperatorMixin):
    

    _schema: t.ClassVar[_TypeMap[Literal["object"]]] = {"type": "object"}
    _counter: int = 0

    @classmethod
    def _get_name(cls) -> str:
        cls._counter += 1
        return f"param_{cls._counter}"

    def __init__(
        self,
        name: str | None = None,
        empty: Optional[bool] = Undefined,
        param: Optional[
            VariableParameter | TopLevelSelectionParameter | SelectionParameter
        ] = Undefined,
        param_type: Optional[Literal["variable", "selection"]] = Undefined,
    ) -> None:
        if name is None:
            name = self._get_name()
        self.name = name
        self.empty = empty
        self.param = param
        self.param_type = param_type

    @utils.deprecated(
        version="5.0.0",
        alternative="to_dict",
        message="No need to call '.ref()' anymore.",
    )
    def ref(self) -> dict[str, Any]:
        
        return self.to_dict()

    def to_dict(self) -> dict[str, str | dict[str, Any]]:
        if self.param_type == "variable":
            return {"expr": self.name}
        elif self.param_type == "selection":
            nm: Any = self.name
            return {"param": nm.to_dict() if hasattr(nm, "to_dict") else nm}
        else:
            msg = f"Unrecognized parameter type: {self.param_type}"
            raise ValueError(msg)

    def __invert__(self) -> PredicateComposition | Any:
        if self.param_type == "selection":
            return core.PredicateComposition({"not": {"param": self.name}})
        else:
            return _expr_core.OperatorMixin.__invert__(self)

    def __and__(self, other: Any) -> PredicateComposition | Any:
        if self.param_type == "selection":
            if isinstance(other, Parameter):
                other = {"param": other.name}
            return core.PredicateComposition({"and": [{"param": self.name}, other]})
        else:
            return _expr_core.OperatorMixin.__and__(self, other)

    def __or__(self, other: Any) -> PredicateComposition | Any:
        if self.param_type == "selection":
            if isinstance(other, Parameter):
                other = {"param": other.name}
            return core.PredicateComposition({"or": [{"param": self.name}, other]})
        else:
            return _expr_core.OperatorMixin.__or__(self, other)

    def __repr__(self) -> str:
        return f"Parameter({self.name!r}, {self.param})"

    def _to_expr(self) -> str:
        return self.name

    def _from_expr(self, expr: IntoExpression) -> ParameterExpression:
        return ParameterExpression(expr=expr)

    def __getattr__(self, field_name: str) -> GetAttrExpression | SelectionExpression:
        if field_name.startswith("__") and field_name.endswith("__"):
            raise AttributeError(field_name)
        _attrexpr = _expr_core.GetAttrExpression(self.name, field_name)
        
        
        if check_fields_and_encodings(self, field_name):
            return SelectionExpression(_attrexpr)
        return _expr_core.GetAttrExpression(self.name, field_name)

    
    
    def __getitem__(self, field_name: str) -> GetItemExpression:
        return _expr_core.GetItemExpression(self.name, field_name)



SelectionPredicateComposition = core.PredicateComposition


class ParameterExpression(_expr_core.OperatorMixin):
    _schema: t.ClassVar[_TypeMap[Literal["object"]]] = {"type": "object"}

    def __init__(self, expr: IntoExpression) -> None:
        self.expr = expr

    def to_dict(self) -> dict[str, str]:
        return {"expr": repr(self.expr)}

    def _to_expr(self) -> str:
        return repr(self.expr)

    def _from_expr(self, expr: IntoExpression) -> ParameterExpression:
        return ParameterExpression(expr=expr)


class SelectionExpression(_expr_core.OperatorMixin):
    _schema: t.ClassVar[_TypeMap[Literal["object"]]] = {"type": "object"}

    def __init__(self, expr: IntoExpression) -> None:
        self.expr = expr

    def to_dict(self) -> dict[str, str]:
        return {"expr": repr(self.expr)}

    def _to_expr(self) -> str:
        return repr(self.expr)

    def _from_expr(self, expr: IntoExpression) -> SelectionExpression:
        return SelectionExpression(expr=expr)


def check_fields_and_encodings(parameter: Parameter, field_name: str) -> bool:
    param = parameter.param
    if utils.is_undefined(param) or isinstance(param, core.VariableParameter):
        return False
    for prop in ["fields", "encodings"]:
        try:
            if field_name in getattr(param.select, prop):
                return True
        except (AttributeError, TypeError):
            pass

    return False




_TestPredicateType: TypeAlias = Union[
    str, _expr_core.Expression, core.PredicateComposition
]


_PredicateType: TypeAlias = Union[
    Parameter,
    core.Expr,
    "_ConditionExtra",
    _TestPredicateType,
    _expr_core.OperatorMixin,
]


_ComposablePredicateType: TypeAlias = Union[
    _expr_core.OperatorMixin, core.PredicateComposition
]


_StatementType: TypeAlias = Union[SchemaBase, Map, str]



_FieldEqualType: TypeAlias = Union["IntoExpression", Parameter, SchemaBase]



def _is_test_predicate(obj: Any) -> TypeIs[_TestPredicateType]:
    return isinstance(obj, (str, _expr_core.Expression, core.PredicateComposition))


def _get_predicate_expr(p: Parameter) -> Optional[_TestPredicateType]:
    
    return getattr(p.param, "expr", Undefined)


def _predicate_to_condition(
    predicate: _PredicateType, *, empty: Optional[bool] = Undefined
) -> _Condition:
    condition: _Condition
    if isinstance(predicate, Parameter):
        predicate_expr = _get_predicate_expr(predicate)
        if predicate.param_type == "selection" or utils.is_undefined(predicate_expr):
            condition = {"param": predicate.name}
            if isinstance(empty, bool):
                condition["empty"] = empty
            elif isinstance(predicate.empty, bool):
                condition["empty"] = predicate.empty
        else:
            condition = {"test": predicate_expr}
    elif _is_test_predicate(predicate):
        condition = {"test": predicate}
    elif isinstance(predicate, dict):
        condition = predicate
    elif isinstance(predicate, _expr_core.OperatorMixin):
        condition = {"test": predicate._to_expr()}
    else:
        msg = (
            f"Expected a predicate, but got: {type(predicate).__name__!r}\n\n"
            f"From `predicate={predicate!r}`."
        )
        raise TypeError(msg)
    return condition


def _condition_to_selection(
    condition: _Condition,
    if_true: _StatementType,
    if_false: _StatementType,
    **kwargs: Any,
) -> SchemaBase | _Conditional[_Condition]:
    selection: SchemaBase | _Conditional[_Condition]
    if isinstance(if_true, SchemaBase):
        if_true = if_true.to_dict()
    elif isinstance(if_true, str):
        if isinstance(if_false, str):
            msg = (
                "A field cannot be used for both the `if_true` and `if_false` "
                "values of a condition. "
                "One of them has to specify a `value` or `datum` definition."
            )
            raise ValueError(msg)
        else:
            if_true = utils.parse_shorthand(if_true)
            if_true.update(kwargs)
    cond_mutable: Any = dict(condition)
    cond_mutable.update(if_true)
    if isinstance(if_false, SchemaBase):
        
        
        selection = if_false.copy()
        selection.condition = cond_mutable
    elif isinstance(if_false, (str, dict)):
        if isinstance(if_false, str):
            if_false = utils.parse_shorthand(if_false)
            if_false.update(kwargs)
        selection = _Conditional(condition=cond_mutable, **if_false)  
    else:
        raise TypeError(if_false)
    return selection


class _ConditionExtra(TypedDict, closed=True, total=False):  
    
    
    empty: Optional[bool]
    param: Parameter | str
    test: _TestPredicateType
    value: Any
    __extra_items__: _StatementType | OneOrSeq[PrimitiveValue_T]


_Condition: TypeAlias = _ConditionExtra



class _ConditionClosed(TypedDict, closed=True, total=False):  
    
    
    
    empty: Optional[bool]
    param: Parameter | str
    test: _TestPredicateType
    value: Any


_Conditions: TypeAlias = list[_ConditionClosed]


_C = TypeVar("_C", _Conditions, _Condition)


class _Conditional(TypedDict, t.Generic[_C], total=False):
    

    condition: Required[_C]
    value: Any


IntoCondition: TypeAlias = Union[ConditionLike, _Conditional[Any]]



class _Value(TypedDict, closed=True, total=False):  
    
    value: Required[Any]
    __extra_items__: Any


def _reveal_parsed_shorthand(obj: Map, /) -> dict[str, Any]:
    
    return {k: v for k, v in obj.items() if k in utils.SHORTHAND_KEYS}


def _is_extra(*objs: Any, kwds: Map) -> Iterator[bool]:
    for el in objs:
        if isinstance(el, (SchemaBase, t.Mapping)):
            item = el.to_dict(validate=False) if isinstance(el, SchemaBase) else el
            yield not (item.keys() - kwds.keys()).isdisjoint(utils.SHORTHAND_KEYS)
        else:
            continue


def _is_condition_extra(obj: Any, *objs: Any, kwds: Map) -> TypeIs[_Condition]:
    
    
    
    return isinstance(obj, str) or any(_is_extra(obj, *objs, kwds=kwds))


def _is_condition_closed(obj: Map) -> TypeIs[_ConditionClosed]:
    
    return {"empty", "param", "test", "value"} >= obj.keys()


def _parse_when_constraints(
    constraints: dict[str, _FieldEqualType], /
) -> Iterator[BinaryExpression]:
    
    for name, value in constraints.items():
        yield _expr_core.GetAttrExpression("datum", name) == value


def _validate_composables(
    predicates: Iterable[Any], /
) -> Iterator[_ComposablePredicateType]:
    for p in predicates:
        if isinstance(p, (_expr_core.OperatorMixin, core.PredicateComposition)):
            yield p
        else:
            msg = (
                f"Predicate composition is not permitted for "
                f"{type(p).__name__!r}.\n"
                f"Try wrapping {p!r} in a `Parameter` first."
            )
            raise TypeError(msg)


def _parse_when_compose(
    predicates: tuple[Any, ...],
    constraints: dict[str, _FieldEqualType],
    /,
) -> BinaryExpression:
    
    iters = []
    if predicates:
        iters.append(_validate_composables(predicates))
    if constraints:
        iters.append(_parse_when_constraints(constraints))
    r = functools.reduce(operator.and_, itertools.chain.from_iterable(iters))
    return t.cast(_expr_core.BinaryExpression, r)


def _parse_when(
    predicate: Optional[_PredicateType],
    *more_predicates: _ComposablePredicateType,
    empty: Optional[bool],
    **constraints: _FieldEqualType,
) -> _Condition:
    composed: _PredicateType
    if utils.is_undefined(predicate):
        if more_predicates or constraints:
            composed = _parse_when_compose(more_predicates, constraints)
        else:
            msg = (
                f"At least one predicate or constraint must be provided, "
                f"but got: {predicate=}"
            )
            raise TypeError(msg)
    elif more_predicates or constraints:
        predicates = predicate, *more_predicates
        composed = _parse_when_compose(predicates, constraints)
    else:
        composed = predicate
    return _predicate_to_condition(composed, empty=empty)


def _parse_literal(val: Any, /) -> dict[str, Any]:
    if isinstance(val, str):
        return utils.parse_shorthand(val)
    else:
        msg = (
            f"Expected a shorthand `str`, but got: {type(val).__name__!r}\n\n"
            f"From `statement={val!r}`."
        )
        raise TypeError(msg)


def _parse_then(statement: _StatementType, kwds: dict[str, Any], /) -> dict[str, Any]:
    if isinstance(statement, SchemaBase):
        statement = statement.to_dict()
    elif not isinstance(statement, dict):
        statement = _parse_literal(statement)
    statement.update(kwds)
    return statement


def _parse_otherwise(
    statement: _StatementType, conditions: _Conditional[Any], kwds: dict[str, Any], /
) -> SchemaBase | _Conditional[Any]:
    selection: SchemaBase | _Conditional[Any]
    if isinstance(statement, SchemaBase):
        selection = statement.copy()
        conditions.update(**kwds)  
        selection.condition = conditions["condition"]
    else:
        if not isinstance(statement, t.Mapping):
            statement = _parse_literal(statement)
        selection = conditions
        selection.update(**statement, **kwds)  
    return selection


class _BaseWhen(Protocol):
    
    _condition: _Condition

    def _when_then(
        self, statement: _StatementType, kwds: dict[str, Any], /
    ) -> _ConditionClosed | _Condition:
        condition: Any = _deepcopy(self._condition)
        then = _parse_then(statement, kwds)
        condition.update(then)
        return condition


class When(_BaseWhen):
    

    def __init__(self, condition: _Condition, /) -> None:
        self._condition = condition

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self._condition!r})"

    @overload
    def then(self, statement: str, /, **kwds: Any) -> Then[_Condition]: ...
    @overload
    def then(self, statement: _Value, /, **kwds: Any) -> Then[_Conditions]: ...
    @overload
    def then(
        self, statement: dict[str, Any] | SchemaBase, /, **kwds: Any
    ) -> Then[Any]: ...
    def then(self, statement: _StatementType, /, **kwds: Any) -> Then[Any]:
        
        condition = self._when_then(statement, kwds)
        if _is_condition_extra(condition, statement, kwds=kwds):
            return Then(_Conditional(condition=condition))
        else:
            return Then(_Conditional(condition=[condition]))


class Then(ConditionLike, t.Generic[_C]):
    

    def __init__(self, conditions: _Conditional[_C], /) -> None:
        self.condition: _C = conditions["condition"]

    @overload
    def otherwise(self, statement: _TSchemaBase, /, **kwds: Any) -> _TSchemaBase: ...
    @overload
    def otherwise(self, statement: str, /, **kwds: Any) -> _Conditional[_Condition]: ...
    @overload
    def otherwise(
        self, statement: _Value, /, **kwds: Any
    ) -> _Conditional[_Conditions]: ...
    @overload
    def otherwise(
        self, statement: dict[str, Any], /, **kwds: Any
    ) -> _Conditional[Any]: ...
    def otherwise(
        self, statement: _StatementType, /, **kwds: Any
    ) -> SchemaBase | _Conditional[Any]:
        
        conditions: _Conditional[Any]
        is_extra = functools.partial(_is_condition_extra, kwds=kwds)
        if is_extra(self.condition, statement):
            current = self.condition
            if isinstance(current, list) and len(current) == 1:
                
                
                conditions = _Conditional(condition=current[0])  
            elif isinstance(current, dict):
                if not is_extra(statement):
                    conditions = self.to_dict()
                else:
                    cond = _reveal_parsed_shorthand(current)
                    msg = (
                        f"Only one field may be used within a condition.\n"
                        f"Shorthand {statement!r} would conflict with {cond!r}\n\n"
                        f"Use `alt.value({statement!r})` if this is not a shorthand string."
                    )
                    raise TypeError(msg)
            else:
                
                msg = (
                    f"Chained conditions cannot be mixed with field conditions.\n"
                    f"{self!r}\n\n{statement!r}"
                )
                raise TypeError(msg)
        else:
            conditions = self.to_dict()
        return _parse_otherwise(statement, conditions, kwds)

    def when(
        self,
        predicate: Optional[_PredicateType] = Undefined,
        *more_predicates: _ComposablePredicateType,
        empty: Optional[bool] = Undefined,
        **constraints: _FieldEqualType,
    ) -> ChainedWhen:
        
        condition = _parse_when(predicate, *more_predicates, empty=empty, **constraints)
        conditions = self.to_dict()
        current = conditions["condition"]
        if isinstance(current, list):
            conditions = t.cast(_Conditional[_Conditions], conditions)
            return ChainedWhen(condition, conditions)
        elif isinstance(current, dict):
            cond = _reveal_parsed_shorthand(current)
            msg = (
                f"Chained conditions cannot be mixed with field conditions.\n"
                f"Additional conditions would conflict with {cond!r}\n\n"
                f"Must finalize by calling `.otherwise()`."
            )
            raise TypeError(msg)
        else:
            msg = (
                f"The internal structure has been modified.\n"
                f"{type(current).__name__!r} found, but only `dict | list` are valid."
            )
            raise NotImplementedError(msg)

    def to_dict(self, *args: Any, **kwds: Any) -> _Conditional[_C]:
        return _Conditional(condition=self.condition.copy())

    def __deepcopy__(self, memo: Any) -> Self:
        return type(self)(_Conditional(condition=_deepcopy(self.condition, memo)))

    def __repr__(self) -> str:
        name = type(self).__name__
        COND = "condition: "
        LB, RB = "{", "}"
        if len(self.condition) == 1:
            args = f"{COND}{self.condition!r}".replace("\n", "\n  ")
        else:
            conds = "\n    ".join(f"{c!r}" for c in self.condition)
            args = f"{COND}[\n    " f"{conds}\n  ]"
        return f"{name}({LB}\n  {args}\n{RB})"


class ChainedWhen(_BaseWhen):
    

    def __init__(
        self,
        condition: _Condition,
        conditions: _Conditional[_Conditions],
        /,
    ) -> None:
        self._condition = condition
        self._conditions = conditions

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}(\n"
            f"  {self._conditions!r},\n  {self._condition!r}\n"
            ")"
        )

    def then(self, statement: _StatementType, /, **kwds: Any) -> Then[_Conditions]:
        
        condition = self._when_then(statement, kwds)
        if _is_condition_closed(condition):
            conditions = self._conditions.copy()
            conditions["condition"].append(condition)
            return Then(conditions)
        else:
            cond = _reveal_parsed_shorthand(condition)
            msg = (
                f"Chained conditions cannot be mixed with field conditions.\n"
                f"Shorthand {statement!r} expanded to {cond!r}\n\n"
                f"Use `alt.value({statement!r})` if this is not a shorthand string."
            )
            raise TypeError(msg)


def when(
    predicate: Optional[_PredicateType] = Undefined,
    *more_predicates: _ComposablePredicateType,
    empty: Optional[bool] = Undefined,
    **constraints: _FieldEqualType,
) -> When:
    
    condition = _parse_when(predicate, *more_predicates, empty=empty, **constraints)
    return When(condition)






def value(value: Any, **kwargs: Any) -> _Value:
    
    return _Value(value=value, **kwargs)  


def param(
    name: str | None = None,
    value: Optional[Any] = Undefined,
    bind: Optional[Binding] = Undefined,
    empty: Optional[bool] = Undefined,
    expr: Optional[str | Expr | Expression] = Undefined,
    **kwds: Any,
) -> Parameter:
    
    warn_msg = "The value of `empty` should be True or False."
    empty_remap = {"none": False, "all": True}
    parameter = Parameter(name)

    if not utils.is_undefined(empty):
        if isinstance(empty, bool) and not isinstance(empty, str):
            parameter.empty = empty
        elif empty in empty_remap:
            utils.deprecated_warn(warn_msg, version="5.0.0")
            parameter.empty = empty_remap[t.cast(str, empty)]
        else:
            raise ValueError(warn_msg)

    if _init := kwds.pop("init", None):
        utils.deprecated_warn("Use `value` instead of `init`.", version="5.0.0")
        
        if value is Undefined:
            kwds["value"] = _init

    
    if "select" not in kwds:
        parameter.param = core.VariableParameter(
            name=parameter.name,
            bind=bind,
            value=value,
            expr=expr,
            **kwds,
        )
        parameter.param_type = "variable"
    elif "views" in kwds:
        parameter.param = core.TopLevelSelectionParameter(
            name=parameter.name, bind=bind, value=value, expr=expr, **kwds
        )
        parameter.param_type = "selection"
    else:
        parameter.param = core.SelectionParameter(
            name=parameter.name, bind=bind, value=value, expr=expr, **kwds
        )
        parameter.param_type = "selection"

    return parameter


def _selection(type: Optional[SelectionType_T] = Undefined, **kwds: Any) -> Parameter:
    

    select_kwds = {"name", "bind", "value", "empty", "init", "views"}
    param_kwds = {key: kwds.pop(key) for key in select_kwds & kwds.keys()}

    select: IntervalSelectionConfig | PointSelectionConfig
    if type == "interval":
        select = core.IntervalSelectionConfig(type=type, **kwds)
    elif type == "point":
        select = core.PointSelectionConfig(type=type, **kwds)
    elif type in {"single", "multi"}:
        select = core.PointSelectionConfig(type="point", **kwds)
        utils.deprecated_warn(
            "The types `single` and `multi` are now combined.",
            version="5.0.0",
            alternative="selection_point()",
        )
    else:
        msg = 
        raise ValueError(msg)

    return param(select=select, **param_kwds)


@utils.deprecated(
    version="5.0.0",
    alternative="'selection_point()' or 'selection_interval()'",
    message="These functions also include more helpful docstrings.",
)
def selection(type: Optional[SelectionType_T] = Undefined, **kwds: Any) -> Parameter:
    
    return _selection(type=type, **kwds)


_SelectionPointValue: TypeAlias = "PrimitiveValue_T | Temporal | DateTime | Sequence[Mapping[SingleDefUnitChannel_T | LiteralString, PrimitiveValue_T | Temporal | DateTime]]"


_SelectionIntervalValueMap: TypeAlias = Mapping[
    SingleDefUnitChannel_T,
    Union[
        tuple[bool, bool],
        tuple[float, float],
        tuple[str, str],
        tuple["Temporal | DateTime", "Temporal | DateTime"],
        Sequence[bool],
        Sequence[float],
        Sequence[str],
        Sequence["Temporal | DateTime"],
    ],
]



def selection_interval(
    name: str | None = None,
    value: Optional[_SelectionIntervalValueMap] = Undefined,
    bind: Optional[Binding | str] = Undefined,
    empty: Optional[bool] = Undefined,
    expr: Optional[str | Expr | Expression] = Undefined,
    encodings: Optional[Sequence[SingleDefUnitChannel_T]] = Undefined,
    on: Optional[str | MergedStreamKwds | DerivedStreamKwds] = Undefined,
    clear: Optional[str | bool | MergedStreamKwds | DerivedStreamKwds] = Undefined,
    resolve: Optional[SelectionResolution_T] = Undefined,
    mark: Optional[BrushConfig | BrushConfigKwds] = Undefined,
    translate: Optional[str | bool] = Undefined,
    zoom: Optional[str | bool] = Undefined,
    **kwds: Any,
) -> Parameter:
    
    return _selection(
        type="interval",
        name=name,
        value=value,
        bind=bind,
        empty=empty,
        expr=expr,
        encodings=encodings,
        on=on,
        clear=clear,
        resolve=resolve,
        mark=mark,
        translate=translate,
        zoom=zoom,
        **kwds,
    )


def selection_point(
    name: str | None = None,
    value: Optional[_SelectionPointValue] = Undefined,
    bind: Optional[Binding | str] = Undefined,
    empty: Optional[bool] = Undefined,
    expr: Optional[str | Expr | Expression] = Undefined,
    encodings: Optional[Sequence[SingleDefUnitChannel_T]] = Undefined,
    fields: Optional[Sequence[str]] = Undefined,
    on: Optional[str | MergedStreamKwds | DerivedStreamKwds] = Undefined,
    clear: Optional[str | bool | MergedStreamKwds | DerivedStreamKwds] = Undefined,
    resolve: Optional[SelectionResolution_T] = Undefined,
    toggle: Optional[str | bool] = Undefined,
    nearest: Optional[bool] = Undefined,
    **kwds: Any,
) -> Parameter:
    
    return _selection(
        type="point",
        name=name,
        value=value,
        bind=bind,
        empty=empty,
        expr=expr,
        encodings=encodings,
        fields=fields,
        on=on,
        clear=clear,
        resolve=resolve,
        toggle=toggle,
        nearest=nearest,
        **kwds,
    )


@utils.deprecated(version="5.0.0", alternative="selection_point")
def selection_multi(**kwargs: Any) -> Parameter:
    
    return _selection(type="point", **kwargs)


@utils.deprecated(version="5.0.0", alternative="selection_point")
def selection_single(**kwargs: Any) -> Parameter:
    
    return _selection(type="point", **kwargs)


def binding(
    input: str,
    *,
    autocomplete: Optional[str] = Undefined,
    debounce: Optional[float] = Undefined,
    element: Optional[str] = Undefined,
    name: Optional[str] = Undefined,
    placeholder: Optional[str] = Undefined,
) -> BindInput:
    
    return core.BindInput(
        autocomplete=autocomplete,
        debounce=debounce,
        element=element,
        input=input,
        name=name,
        placeholder=placeholder,
    )


@utils.use_signature(core.BindCheckbox)
def binding_checkbox(**kwargs: Any) -> BindCheckbox:
    
    return core.BindCheckbox(input="checkbox", **kwargs)


@utils.use_signature(core.BindRadioSelect)
def binding_radio(**kwargs: Any) -> BindRadioSelect:
    
    return core.BindRadioSelect(input="radio", **kwargs)


@utils.use_signature(core.BindRadioSelect)
def binding_select(**kwargs: Any) -> BindRadioSelect:
    
    return core.BindRadioSelect(input="select", **kwargs)


@utils.use_signature(core.BindRange)
def binding_range(**kwargs: Any) -> BindRange:
    
    return core.BindRange(input="range", **kwargs)


@overload
def condition(
    predicate: _PredicateType,
    if_true: _StatementType,
    if_false: _TSchemaBase,
    *,
    empty: Optional[bool] = ...,
    **kwargs: Any,
) -> _TSchemaBase: ...
@overload
def condition(
    predicate: _PredicateType,
    if_true: Map | SchemaBase,
    if_false: Map | str,
    *,
    empty: Optional[bool] = ...,
    **kwargs: Any,
) -> _Conditional[_Condition]: ...
@overload
def condition(
    predicate: _PredicateType,
    if_true: Map | str,
    if_false: Map,
    *,
    empty: Optional[bool] = ...,
    **kwargs: Any,
) -> _Conditional[_Condition]: ...
@overload
def condition(
    predicate: _PredicateType, if_true: str, if_false: str, **kwargs: Any
) -> Never: ...

def condition(
    predicate: _PredicateType,
    if_true: _StatementType,
    if_false: _StatementType,
    *,
    empty: Optional[bool] = Undefined,
    **kwargs: Any,
) -> SchemaBase | _Conditional[_Condition]:
    
    condition = _predicate_to_condition(predicate, empty=empty)
    return _condition_to_selection(condition, if_true, if_false, **kwargs)






def _top_schema_base(  
    obj: Any, /
):  
    
    if (isinstance(obj, SchemaBase) and isinstance(obj, TopLevelMixin)) or (
        not TYPE_CHECKING
        and (
            isinstance(obj, super)
            and issubclass(obj.__self_class__, SchemaBase)
            and obj.__thisclass__ is TopLevelMixin
        )
    ):
        return obj
    else:
        msg = f"{type(obj).__name__!r} does not derive from {SchemaBase.__name__!r}"
        raise TypeError(msg)


class TopLevelMixin(mixins.ConfigMethodMixin):
    

    _class_is_valid_at_instantiation: bool = False
    data: Any

    def to_dict(  
        self,
        validate: bool = True,
        *,
        format: Literal["vega-lite", "vega"] = "vega-lite",
        ignore: list[str] | None = None,
        context: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        
        
        if format not in {"vega-lite", "vega"}:
            msg = f'The format argument must be either "vega-lite" or "vega". Received {format!r}'
            raise ValueError(msg)

        
        
        
        
        
        
        
        
        
        

        
        
        context = context.copy() if context else {}
        context.setdefault("datasets", {})
        is_top_level = context.get("top_level", True)

        copy = _top_schema_base(self).copy(deep=False)
        original_data = getattr(copy, "data", Undefined)
        if not utils.is_undefined(original_data):
            try:
                data = nw.from_native(original_data, eager_or_interchange_only=True)
            except TypeError:
                
                data = original_data
            copy.data = _prepare_data(data, context)
            context["data"] = data

        
        context["top_level"] = False

        vegalite_spec: Any = _top_schema_base(super(TopLevelMixin, copy)).to_dict(
            validate=validate, ignore=ignore, context=dict(context, pre_transform=False)
        )

        
        if is_top_level:
            
            if "$schema" not in vegalite_spec:
                vegalite_spec["$schema"] = SCHEMA_URL

            if func := theme.get():
                vegalite_spec = utils.update_nested(func(), vegalite_spec, copy=True)
            else:
                msg = (
                    f"Expected a theme to be set but got {None!r}.\n"
                    f"Call `themes.enable('default')` to reset the `ThemeRegistry`."
                )
                raise TypeError(msg)

            
            if context["datasets"]:
                vegalite_spec.setdefault("datasets", {}).update(context["datasets"])

        if context.get("pre_transform", True) and _using_vegafusion():
            if format == "vega-lite":
                msg = (
                    'When the "vegafusion" data transformer is enabled, the \n'
                    "to_dict() and to_json() chart methods must be called with "
                    'format="vega". \n'
                    "For example: \n"
                    '    >>> chart.to_dict(format="vega")\n'
                    '    >>> chart.to_json(format="vega")'
                )
                raise ValueError(msg)
            else:
                return _compile_with_vegafusion(vegalite_spec)
        elif format == "vega":
            plugin = vegalite_compilers.get()
            if plugin is None:
                msg = "No active vega-lite compiler plugin found"
                raise ValueError(msg)
            return plugin(vegalite_spec)
        else:
            return vegalite_spec

    def to_json(
        self,
        validate: bool = True,
        indent: int | str | None = 2,
        sort_keys: bool = True,
        *,
        format: Literal["vega-lite", "vega"] = "vega-lite",
        ignore: list[str] | None = None,
        context: dict[str, Any] | None = None,
        **kwargs: Any,
    ) -> str:
        
        if ignore is None:
            ignore = []
        if context is None:
            context = {}
        spec = self.to_dict(
            validate=validate, format=format, ignore=ignore, context=context
        )
        return json.dumps(spec, indent=indent, sort_keys=sort_keys, **kwargs)

    def to_html(
        self,
        base_url: str = "https://cdn.jsdelivr.net/npm",
        output_div: str = "vis",
        embed_options: dict | None = None,
        json_kwds: dict | None = None,
        fullhtml: bool = True,
        requirejs: bool = False,
        inline: bool = False,
        **kwargs: Any,
    ) -> str:
        
        if inline:
            kwargs["template"] = "inline"
        return utils.spec_to_html(
            self.to_dict(),
            mode="vega-lite",
            vegalite_version=VEGALITE_VERSION,
            vegaembed_version=VEGAEMBED_VERSION,
            vega_version=VEGA_VERSION,
            base_url=base_url,
            output_div=output_div,
            embed_options=embed_options,
            json_kwds=json_kwds,
            fullhtml=fullhtml,
            requirejs=requirejs,
            **kwargs,
        )

    def to_url(self, *, fullscreen: bool = False) -> str:
        
        from altair.utils._importers import import_vl_convert

        vlc = import_vl_convert()
        if _using_vegafusion():
            return vlc.vega_to_url(self.to_dict(format="vega"), fullscreen=fullscreen)
        else:
            return vlc.vegalite_to_url(self.to_dict(), fullscreen=fullscreen)

    def open_editor(self, *, fullscreen: bool = False) -> None:
        
        import webbrowser

        webbrowser.open(self.to_url(fullscreen=fullscreen))

    def save(
        self,
        fp: str | Path | IO,
        format: Literal["json", "html", "png", "svg", "pdf"] | None = None,
        override_data_transformer: bool = True,
        scale_factor: float = 1.0,
        mode: str | None = None,
        vegalite_version: str = VEGALITE_VERSION,
        vega_version: str = VEGA_VERSION,
        vegaembed_version: str = VEGAEMBED_VERSION,
        embed_options: dict | None = None,
        json_kwds: dict | None = None,
        engine: str | None = None,
        inline: bool = False,
        **kwargs: Any,
    ) -> None:
        
        if _ := kwargs.pop("webdriver", None):
            utils.deprecated_warn(
                "The webdriver argument is not relevant for the new vl-convert engine which replaced altair_saver. "
                "The argument will be removed in a future release.",
                version="5.0.0",
            )

        from altair.utils.save import save

        kwds: dict[str, Any] = dict(
            chart=self,
            fp=fp,
            format=format,
            scale_factor=scale_factor,
            mode=mode,
            vegalite_version=vegalite_version,
            vega_version=vega_version,
            vegaembed_version=vegaembed_version,
            embed_options=embed_options,
            json_kwds=json_kwds,
            engine=engine,
            inline=inline,
            **kwargs,
        )

        
        
        
        if override_data_transformer:
            with data_transformers.disable_max_rows():
                save(**kwds)
        else:
            save(**kwds)

    
    
    def __repr__(self) -> str:
        return f"alt.{self.__class__.__name__}(...)"

    
    def __add__(self, other: ChartType) -> LayerChart:
        if not is_chart_type(other):
            msg = "Only Chart objects can be layered."
            raise ValueError(msg)
        return layer(t.cast("ChartType", self), other)

    def __and__(self, other: ChartType) -> VConcatChart:
        if not is_chart_type(other):
            msg = "Only Chart objects can be concatenated."
            raise ValueError(msg)
        
        return vconcat(t.cast("ChartType", self), other)

    def __or__(self, other: ChartType) -> HConcatChart | ConcatChart:
        if not is_chart_type(other):
            msg = "Only Chart objects can be concatenated."
            raise ValueError(msg)
        elif isinstance(self, ConcatChart):
            return concat(self, other)
        else:
            return hconcat(t.cast("ChartType", self), other)

    def repeat(
        self,
        repeat: Optional[list[str]] = Undefined,
        row: Optional[list[str]] = Undefined,
        column: Optional[list[str]] = Undefined,
        layer: Optional[list[str]] = Undefined,
        columns: Optional[int] = Undefined,
        **kwargs: Any,
    ) -> RepeatChart:
        
        repeat_specified = repeat is not Undefined
        rowcol_specified = row is not Undefined or column is not Undefined
        layer_specified = layer is not Undefined

        if repeat_specified and rowcol_specified:
            msg = "repeat argument cannot be combined with row/column argument."
            raise ValueError(msg)
        elif repeat_specified and layer_specified:
            msg = "repeat argument cannot be combined with layer argument."
            raise ValueError(msg)

        repeat_arg: list[str] | LayerRepeatMapping | RepeatMapping
        if repeat_specified:
            assert isinstance(repeat, list)
            repeat_arg = repeat
        elif layer_specified:
            repeat_arg = core.LayerRepeatMapping(layer=layer, row=row, column=column)
        else:
            repeat_arg = core.RepeatMapping(row=row, column=column)

        return RepeatChart(
            spec=t.cast("ChartType", self), repeat=repeat_arg, columns=columns, **kwargs
        )

    def properties(self, **kwargs: Any) -> Self:
        
        copy = _top_schema_base(self).copy(deep=False)
        for key, val in kwargs.items():
            if key == "selection" and isinstance(val, Parameter):
                
                
                setattr(copy, key, {val.name: val.selection})
            else:
                
                if key != "data":
                    _top_schema_base(self).validate_property(key, val)
                setattr(copy, key, val)
        return t.cast("Self", copy)

    def project(
        self,
        type: Optional[
            ProjectionType_T | ProjectionType | ExprRef | Parameter
        ] = Undefined,
        center: Optional[list[float] | Vector2number | ExprRef | Parameter] = Undefined,
        clipAngle: Optional[float | ExprRef | Parameter] = Undefined,
        clipExtent: Optional[
            list[list[float]] | Vector2Vector2number | ExprRef | Parameter
        ] = Undefined,
        coefficient: Optional[float | ExprRef | Parameter] = Undefined,
        distance: Optional[float | ExprRef | Parameter] = Undefined,
        fraction: Optional[float | ExprRef | Parameter] = Undefined,
        lobes: Optional[float | ExprRef | Parameter] = Undefined,
        parallel: Optional[float | ExprRef | Parameter] = Undefined,
        precision: Optional[float | ExprRef | Parameter] = Undefined,
        radius: Optional[float | ExprRef | Parameter] = Undefined,
        ratio: Optional[float | ExprRef | Parameter] = Undefined,
        reflectX: Optional[bool | ExprRef | Parameter] = Undefined,
        reflectY: Optional[bool | ExprRef | Parameter] = Undefined,
        rotate: Optional[
            list[float] | Vector2number | Vector3number | ExprRef | Parameter
        ] = Undefined,
        scale: Optional[float | ExprRef | Parameter] = Undefined,
        spacing: Optional[float | Vector2number | ExprRef | Parameter] = Undefined,
        tilt: Optional[float | ExprRef | Parameter] = Undefined,
        translate: Optional[
            list[float] | Vector2number | ExprRef | Parameter
        ] = Undefined,
        **kwds: Any,
    ) -> Self:
        
        projection = core.Projection(
            center=center,
            clipAngle=clipAngle,
            clipExtent=clipExtent,
            coefficient=coefficient,
            distance=distance,
            fraction=fraction,
            lobes=lobes,
            parallel=parallel,
            precision=precision,
            radius=radius,
            ratio=ratio,
            reflectX=reflectX,
            reflectY=reflectY,
            rotate=rotate,
            scale=scale,
            spacing=spacing,
            tilt=tilt,
            translate=translate,
            type=type,
            **kwds,
        )
        return self.properties(projection=projection)

    def _add_transform(self, *transforms: Transform) -> Self:
        
        copy = _top_schema_base(self).copy(deep=["transform"])
        if copy.transform is Undefined:
            copy.transform = []
        copy.transform.extend(transforms)
        return t.cast("Self", copy)

    def transform_aggregate(
        self,
        aggregate: Optional[list[AggregatedFieldDef]] = Undefined,
        groupby: Optional[list[str | FieldName]] = Undefined,
        **kwds: dict[str, Any] | str,
    ) -> Self:
        
        if aggregate is Undefined:
            aggregate = []
        for key, val in kwds.items():
            parsed = utils.parse_shorthand(val)
            dct = {
                "as": key,
                "field": parsed.get("field", Undefined),
                "op": parsed.get("aggregate", Undefined),
            }
            assert isinstance(aggregate, list)
            aggregate.append(core.AggregatedFieldDef(**dct))
        return self._add_transform(
            core.AggregateTransform(aggregate=aggregate, groupby=groupby)
        )

    def transform_bin(
        self,
        as_: Optional[str | FieldName | list[str | FieldName]] = Undefined,
        field: Optional[str | FieldName] = Undefined,
        bin: Literal[True] | BinParams = True,
        **kwargs: Any,
    ) -> Self:
        
        if as_ is not Undefined:
            if "as" in kwargs:
                msg = "transform_bin: both 'as_' and 'as' passed as arguments."
                raise ValueError(msg)
            kwargs["as"] = as_
        kwargs["bin"] = bin
        kwargs["field"] = field
        return self._add_transform(core.BinTransform(**kwargs))

    def transform_calculate(
        self,
        as_: Optional[str | FieldName] = Undefined,
        calculate: Optional[str | Expr | Expression] = Undefined,
        **kwargs: str | Expr | Expression,
    ) -> Self:
        
        calc_as: Optional[str | FieldName | Expr | Expression]
        if as_ is Undefined:
            calc_as = kwargs.pop("as", Undefined)
        elif "as" in kwargs:
            msg = "transform_calculate: both 'as_' and 'as' passed as arguments."
            raise ValueError(msg)
        else:
            calc_as = as_
        if calc_as is not Undefined or calculate is not Undefined:
            dct: dict[str, Any] = {"as": calc_as, "calculate": calculate}
            self = self._add_transform(core.CalculateTransform(**dct))
        for a, calculate in kwargs.items():
            dct = {"as": a, "calculate": calculate}
            self = self._add_transform(core.CalculateTransform(**dct))
        return self

    def transform_density(
        self,
        density: str | FieldName,
        as_: Optional[list[str | FieldName]] = Undefined,
        bandwidth: Optional[float] = Undefined,
        counts: Optional[bool] = Undefined,
        cumulative: Optional[bool] = Undefined,
        extent: Optional[list[float]] = Undefined,
        groupby: Optional[list[str | FieldName]] = Undefined,
        maxsteps: Optional[int] = Undefined,
        minsteps: Optional[int] = Undefined,
        steps: Optional[int] = Undefined,
        resolve: Optional[ResolveMode_T] = Undefined,
    ) -> Self:
        
        return self._add_transform(
            core.DensityTransform(
                density=density,
                bandwidth=bandwidth,
                counts=counts,
                cumulative=cumulative,
                extent=extent,
                groupby=groupby,
                maxsteps=maxsteps,
                minsteps=minsteps,
                steps=steps,
                resolve=resolve,
                **{"as": as_},
            )
        )

    def transform_impute(
        self,
        impute: str | FieldName,
        key: str | FieldName,
        frame: Optional[list[int | None]] = Undefined,
        groupby: Optional[list[str | FieldName]] = Undefined,
        keyvals: Optional[list[Any] | ImputeSequence] = Undefined,
        method: Optional[ImputeMethod_T | ImputeMethod] = Undefined,
        value: Optional[Any] = Undefined,
    ) -> Self:
        
        return self._add_transform(
            core.ImputeTransform(
                impute=impute,
                key=key,
                frame=frame,
                groupby=groupby,
                keyvals=keyvals,
                method=method,
                value=value,
            )
        )

    def transform_joinaggregate(
        self,
        joinaggregate: Optional[list[JoinAggregateFieldDef]] = Undefined,
        groupby: Optional[list[str | FieldName]] = Undefined,
        **kwargs: str,
    ) -> Self:
        
        if joinaggregate is Undefined:
            joinaggregate = []
        for key, val in kwargs.items():
            parsed = utils.parse_shorthand(val)
            dct = {
                "as": key,
                "field": parsed.get("field", Undefined),
                "op": parsed.get("aggregate", Undefined),
            }
            assert isinstance(joinaggregate, list)
            joinaggregate.append(core.JoinAggregateFieldDef(**dct))
        return self._add_transform(
            core.JoinAggregateTransform(joinaggregate=joinaggregate, groupby=groupby)
        )

    def transform_extent(
        self, extent: str | FieldName, param: str | ParameterName
    ) -> Self:
        
        return self._add_transform(core.ExtentTransform(extent=extent, param=param))

    def transform_filter(
        self,
        predicate: Optional[_PredicateType] = Undefined,
        *more_predicates: _ComposablePredicateType,
        empty: Optional[bool] = Undefined,
        **constraints: _FieldEqualType,
    ) -> Self:
        
        if depr_filter := t.cast(Any, constraints.pop("filter", None)):
            utils.deprecated_warn(
                "Passing `filter` as a keyword is ambiguous.\n\n"
                "Use a positional argument for `<5.5.0` behavior.\n"
                "Or, `alt.datum['filter'] == ...` if referring to a column named 'filter'.",
                version="5.5.0",
            )
            if utils.is_undefined(predicate):
                predicate = depr_filter
            else:
                more_predicates = *more_predicates, depr_filter
        cond = _parse_when(predicate, *more_predicates, empty=empty, **constraints)
        return self._add_transform(core.FilterTransform(filter=cond.get("test", cond)))

    def transform_flatten(
        self,
        flatten: list[str | FieldName],
        as_: Optional[list[str | FieldName]] = Undefined,
    ) -> Self:
        
        return self._add_transform(
            core.FlattenTransform(flatten=flatten, **{"as": as_})
        )

    def transform_fold(
        self,
        fold: list[str | FieldName],
        as_: Optional[list[str | FieldName]] = Undefined,
    ) -> Self:
        
        return self._add_transform(core.FoldTransform(fold=fold, **{"as": as_}))

    def transform_loess(
        self,
        on: str | FieldName,
        loess: str | FieldName,
        as_: Optional[list[str | FieldName]] = Undefined,
        bandwidth: Optional[float] = Undefined,
        groupby: Optional[list[str | FieldName]] = Undefined,
    ) -> Self:
        
        return self._add_transform(
            core.LoessTransform(
                loess=loess, on=on, bandwidth=bandwidth, groupby=groupby, **{"as": as_}
            )
        )

    def transform_lookup(
        self,
        lookup: Optional[str] = Undefined,
        from_: Optional[LookupData | LookupSelection] = Undefined,
        as_: Optional[str | FieldName | list[str | FieldName]] = Undefined,
        default: Optional[str] = Undefined,
        **kwargs: Any,
    ) -> Self:
        
        if as_ is not Undefined:
            if "as" in kwargs:
                msg = "transform_lookup: both 'as_' and 'as' passed as arguments."
                raise ValueError(msg)
            kwargs["as"] = as_
        if from_ is not Undefined:
            if "from" in kwargs:
                msg = "transform_lookup: both 'from_' and 'from' passed as arguments."
                raise ValueError(msg)
            kwargs["from"] = from_
        kwargs["lookup"] = lookup
        kwargs["default"] = default
        return self._add_transform(core.LookupTransform(**kwargs))

    def transform_pivot(
        self,
        pivot: str | FieldName,
        value: str | FieldName,
        groupby: Optional[list[str | FieldName]] = Undefined,
        limit: Optional[int] = Undefined,
        op: Optional[AggregateOp_T | AggregateOp] = Undefined,
    ) -> Self:
        
        return self._add_transform(
            core.PivotTransform(
                pivot=pivot, value=value, groupby=groupby, limit=limit, op=op
            )
        )

    def transform_quantile(
        self,
        quantile: str | FieldName,
        as_: Optional[list[str | FieldName]] = Undefined,
        groupby: Optional[list[str | FieldName]] = Undefined,
        probs: Optional[list[float]] = Undefined,
        step: Optional[float] = Undefined,
    ) -> Self:
        
        return self._add_transform(
            core.QuantileTransform(
                quantile=quantile,
                groupby=groupby,
                probs=probs,
                step=step,
                **{"as": as_},
            )
        )

    def transform_regression(
        self,
        on: str | FieldName,
        regression: str | FieldName,
        as_: Optional[list[str | FieldName]] = Undefined,
        extent: Optional[list[float]] = Undefined,
        groupby: Optional[list[str | FieldName]] = Undefined,
        method: Optional[
            Literal["linear", "log", "exp", "pow", "quad", "poly"]
        ] = Undefined,
        order: Optional[int] = Undefined,
        params: Optional[bool] = Undefined,
    ) -> Self:
        
        return self._add_transform(
            core.RegressionTransform(
                regression=regression,
                on=on,
                extent=extent,
                groupby=groupby,
                method=method,
                order=order,
                params=params,
                **{"as": as_},
            )
        )

    def transform_sample(self, sample: int = 1000) -> Self:
        
        return self._add_transform(core.SampleTransform(sample))

    def transform_stack(
        self,
        as_: str | FieldName | list[str],
        stack: str | FieldName,
        groupby: list[str | FieldName],
        offset: Optional[StackOffset_T] = Undefined,
        sort: Optional[list[SortField]] = Undefined,
    ) -> Self:
        
        return self._add_transform(
            core.StackTransform(
                stack=stack, groupby=groupby, offset=offset, sort=sort, **{"as": as_}
            )
        )

    def transform_timeunit(
        self,
        as_: Optional[str | FieldName] = Undefined,
        field: Optional[str | FieldName] = Undefined,
        timeUnit: Optional[MultiTimeUnit_T | SingleTimeUnit_T | TimeUnit] = Undefined,
        **kwargs: str,
    ) -> Self:
        
        if as_ is Undefined:
            as_ = kwargs.pop("as", Undefined)
        elif "as" in kwargs:
            msg = "transform_timeunit: both 'as_' and 'as' passed as arguments."
            raise ValueError(msg)
        if as_ is not Undefined:
            dct: dict[str, Any] = {"as": as_, "timeUnit": timeUnit, "field": field}
            self = self._add_transform(core.TimeUnitTransform(**dct))
        for as_, shorthand in kwargs.items():
            dct = utils.parse_shorthand(
                shorthand,
                parse_timeunits=True,
                parse_aggregates=False,
                parse_types=False,
            )
            dct.pop("type", None)
            dct["as"] = as_
            if "timeUnit" not in dct:
                msg = f"'{shorthand}' must include a valid timeUnit"
                raise ValueError(msg)
            self = self._add_transform(core.TimeUnitTransform(**dct))
        return self

    def transform_window(
        self,
        window: Optional[list[WindowFieldDef]] = Undefined,
        frame: Optional[list[int | None]] = Undefined,
        groupby: Optional[list[str]] = Undefined,
        ignorePeers: Optional[bool] = Undefined,
        sort: Optional[list[SortField | dict[str, str]]] = Undefined,
        **kwargs: str,
    ) -> Self:
        
        w = window if isinstance(window, list) else []
        if kwargs:
            for as_, shorthand in kwargs.items():
                kwds: dict[str, Any] = {"as": as_}
                kwds.update(
                    utils.parse_shorthand(
                        shorthand,
                        parse_aggregates=False,
                        parse_window_ops=True,
                        parse_timeunits=False,
                        parse_types=False,
                    )
                )
                w.append(core.WindowFieldDef(**kwds))

        return self._add_transform(
            core.WindowTransform(
                window=w or Undefined,
                frame=frame,
                groupby=groupby,
                ignorePeers=ignorePeers,
                sort=sort,
            )
        )

    

    def _repr_mimebundle_(self, *args, **kwds) -> MimeBundleType | None:  
        
        
        
        try:
            dct = self.to_dict(context={"pre_transform": False})
        except Exception:
            utils.display_traceback(in_ipython=True)
            return {}
        else:
            if renderer := renderers.get():
                return renderer(dct)

    def display(
        self,
        renderer: Optional[Literal["canvas", "svg"]] = Undefined,
        theme: Optional[str] = Undefined,
        actions: Optional[bool | dict] = Undefined,
        **kwargs: Any,
    ) -> None:
        
        from IPython.display import display

        if renderer is not Undefined:
            kwargs["renderer"] = renderer
        if theme is not Undefined:
            kwargs["theme"] = theme
        if actions is not Undefined:
            kwargs["actions"] = actions

        if kwargs:
            options = renderers.options.copy()
            options["embed_options"] = options.get("embed_options", {}).copy()
            options["embed_options"].update(kwargs)
            with renderers.enable(**options):
                display(self)
        else:
            display(self)

    @utils.deprecated(version="4.1.0", alternative="show")
    def serve(
        self,
        ip="127.0.0.1",  
        port=8888,  
        n_retries=50,  
        files=None,  
        jupyter_warning=True,  
        open_browser=True,  
        http_server=None,  
        **kwargs,  
    ) -> None:
        
        from altair.utils.server import serve

        html = io.StringIO()
        self.save(html, format="html", **kwargs)
        html.seek(0)

        serve(
            html.read(),
            ip=ip,
            port=port,
            n_retries=n_retries,
            files=files,
            jupyter_warning=jupyter_warning,
            open_browser=open_browser,
            http_server=http_server,
        )

    def show(self) -> None:
        
        if renderers.active == "browser":
            
            
            self._repr_mimebundle_()
        else:
            
            from IPython.display import display

            display(self)

    @utils.use_signature(core.Resolve)
    def _set_resolve(self, **kwargs: Any):  
        
        if not hasattr(self, "resolve"):
            msg = f"{self.__class__} object has no attribute " "'resolve'"
            raise ValueError(msg)
        copy = _top_schema_base(self).copy(deep=["resolve"])
        if copy.resolve is Undefined:
            copy.resolve = core.Resolve()
        for key, val in kwargs.items():
            copy.resolve[key] = val
        return copy

    @utils.use_signature(core.AxisResolveMap)
    def resolve_axis(self, *args: Any, **kwargs: Any) -> Self:
        check = _top_schema_base(self)
        r = check._set_resolve(axis=core.AxisResolveMap(*args, **kwargs))
        return t.cast("Self", r)

    @utils.use_signature(core.LegendResolveMap)
    def resolve_legend(self, *args: Any, **kwargs: Any) -> Self:
        check = _top_schema_base(self)
        r = check._set_resolve(legend=core.LegendResolveMap(*args, **kwargs))
        return t.cast("Self", r)

    @utils.use_signature(core.ScaleResolveMap)
    def resolve_scale(self, *args: Any, **kwargs: Any) -> Self:
        check = _top_schema_base(self)
        r = check._set_resolve(scale=core.ScaleResolveMap(*args, **kwargs))
        return t.cast("Self", r)


class _EncodingMixin(channels._EncodingMixin):
    data: Any

    def facet(
        self,
        facet: Optional[str | Facet] = Undefined,
        row: Optional[str | FacetFieldDef | Row] = Undefined,
        column: Optional[str | FacetFieldDef | Column] = Undefined,
        data: Optional[ChartDataType] = Undefined,
        columns: Optional[int] = Undefined,
        **kwargs: Any,
    ) -> FacetChart:
        
        facet_specified = facet is not Undefined
        rowcol_specified = row is not Undefined or column is not Undefined

        if facet_specified and rowcol_specified:
            msg = "facet argument cannot be combined with row/column argument."
            raise ValueError(msg)
        self = _top_schema_base(self)

        if data is Undefined:
            if self.data is Undefined:
                msg = (
                    "Facet charts require data to be specified at the top level. "
                    "If you are trying to facet layered or concatenated charts, "
                    "ensure that the same data variable is passed to each chart "
                    "or specify the data inside the facet method instead."
                )
                raise ValueError(msg)
            self = _top_schema_base(self).copy(deep=False)
            data, self.data = self.data, Undefined

        f: Facet | FacetMapping
        if not utils.is_undefined(facet):
            f = channels.Facet(facet) if isinstance(facet, str) else facet
        else:
            r: Any = row
            f = FacetMapping(row=r, column=column)

        return FacetChart(spec=self, facet=f, data=data, columns=columns, **kwargs)  


class Chart(
    TopLevelMixin, _EncodingMixin, mixins.MarkMethodMixin, core.TopLevelUnitSpec
):
    

    def __init__(
        self,
        data: Optional[ChartDataType] = Undefined,
        encoding: Optional[FacetedEncoding] = Undefined,
        mark: Optional[AnyMark | Mark_T | CompositeMark_T] = Undefined,
        width: Optional[int | dict | Step | Literal["container"]] = Undefined,
        height: Optional[int | dict | Step | Literal["container"]] = Undefined,
        **kwargs: Any,
    ) -> None:
        
        
        
        super().__init__(
            data=data,  
            encoding=encoding,
            mark=mark,
            width=width,
            height=height,
            **kwargs,
        )

    _counter: int = 0

    @classmethod
    def _get_name(cls) -> str:
        cls._counter += 1
        return f"view_{cls._counter}"

    @classmethod
    def from_dict(
        cls: type[_TSchemaBase], dct: dict[str, Any], validate: bool = True
    ) -> _TSchemaBase:
        
        _tp: Any
        for tp in TopLevelMixin.__subclasses__():
            _tp = super() if tp is Chart else tp
            try:
                return _tp.from_dict(dct, validate=validate)
            except jsonschema.ValidationError:
                pass

        
        return t.cast(_TSchemaBase, core.Root.from_dict(dct, validate))

    def to_dict(
        self,
        validate: bool = True,
        *,
        format: Literal["vega-lite", "vega"] = "vega-lite",
        ignore: list[str] | None = None,
        context: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        
        context = context or {}
        kwds: Map = {"validate": validate, "format": format, "ignore": ignore, "context": context}  
        if self.data is Undefined and "data" not in context:
            
            
            copy = self.copy(deep=False)
            copy.data = core.InlineData(values=[{}])
            return super(Chart, copy).to_dict(**kwds)
        return super().to_dict(**kwds)

    def transformed_data(
        self, row_limit: int | None = None, exclude: Iterable[str] | None = None
    ) -> DataFrameLike | None:
        
        from altair.utils._transformed_data import transformed_data

        return transformed_data(self, row_limit=row_limit, exclude=exclude)

    def add_params(self, *params: Parameter) -> Self:
        
        if not params:
            return self
        copy = self.copy(deep=["params"])
        if copy.params is Undefined:
            copy.params = []

        for s in params:
            copy.params.append(s.param)
        return copy

    @utils.deprecated(version="5.0.0", alternative="add_params")
    def add_selection(self, *params) -> Self:  
        
        return self.add_params(*params)

    def interactive(
        self, name: str | None = None, bind_x: bool = True, bind_y: bool = True
    ) -> Self:
        
        encodings: list[SingleDefUnitChannel_T] = []
        if bind_x:
            encodings.append("x")
        if bind_y:
            encodings.append("y")
        return self.add_params(selection_interval(bind="scales", encodings=encodings))


def _check_if_valid_subspec(
    spec: ConcatType | LayerType,
    classname: Literal[
        "ConcatChart",
        "FacetChart",
        "HConcatChart",
        "LayerChart",
        "RepeatChart",
        "VConcatChart",
    ],
) -> None:
    
    if not isinstance(spec, SchemaBase):
        msg = f"Only chart objects can be used in {classname}."
        raise TypeError(msg)
    for attr in TOPLEVEL_ONLY_KEYS:
        if spec._get(attr) is not Undefined:
            msg = (
                f"Objects with {attr!r} attribute cannot be used within {classname}. "
                f"Consider defining the {attr} attribute in the {classname} object instead."
            )
            raise TypeError(msg)


def _check_if_can_be_layered(spec: LayerType) -> None:
    

    def _get_any(spec: LayerType, *attrs: str) -> bool:
        return any(spec._get(attr) is not Undefined for attr in attrs)

    base_msg = "charts cannot be layered. Instead, layer the charts before"

    encoding: Any = spec._get("encoding")
    if not utils.is_undefined(encoding):
        for channel in ["row", "column", "facet"]:
            if encoding._get(channel) is not Undefined:
                msg = f"Faceted {base_msg} faceting."
                raise TypeError(msg)
    if isinstance(spec, (Chart, LayerChart)):
        return
    elif is_chart_type(spec) or _get_any(
        spec, "facet", "repeat", "concat", "hconcat", "vconcat"
    ):
        if isinstance(spec, FacetChart) or spec._get("facet") is not Undefined:
            msg = f"Faceted {base_msg} faceting."
        elif isinstance(spec, RepeatChart) or spec._get("repeat") is not Undefined:
            msg = f"Repeat {base_msg} repeating."
        elif isinstance(spec, (ConcatChart, HConcatChart, VConcatChart)) or _get_any(
            spec, "concat", "hconcat", "vconcat"
        ):
            msg = f"Concatenated {base_msg} concatenating."
        else:
            msg = "Should be unreachable"
            raise NotImplementedError(msg)
        raise TypeError(msg)


class RepeatChart(TopLevelMixin, core.TopLevelRepeatSpec):
    

    def __init__(
        self,
        repeat: Optional[list[str] | LayerRepeatMapping | RepeatMapping] = Undefined,
        spec: Optional[ChartType] = Undefined,
        align: Optional[dict | SchemaBase | LayoutAlign_T] = Undefined,
        autosize: Optional[dict | SchemaBase | AutosizeType_T] = Undefined,
        background: Optional[
            str | dict | Parameter | SchemaBase | ColorName_T
        ] = Undefined,
        bounds: Optional[Literal["full", "flush"]] = Undefined,
        center: Optional[bool | dict | SchemaBase] = Undefined,
        columns: Optional[int] = Undefined,
        config: Optional[dict | SchemaBase] = Undefined,
        data: Optional[ChartDataType] = Undefined,
        datasets: Optional[dict | SchemaBase] = Undefined,
        description: Optional[str] = Undefined,
        name: Optional[str] = Undefined,
        padding: Optional[dict | float | Parameter | SchemaBase] = Undefined,
        params: Optional[Sequence[_Parameter]] = Undefined,
        resolve: Optional[dict | SchemaBase] = Undefined,
        spacing: Optional[dict | float | SchemaBase] = Undefined,
        title: Optional[str | dict | SchemaBase | Sequence[str]] = Undefined,
        transform: Optional[Sequence[dict | SchemaBase]] = Undefined,
        usermeta: Optional[dict | SchemaBase] = Undefined,
        **kwds: Any,
    ) -> None:
        tp_name = type(self).__name__
        if utils.is_undefined(spec):
            msg = f"{tp_name!r} requires a `spec`, but got: {spec!r}"
            raise TypeError(msg)
        _check_if_valid_subspec(spec, "RepeatChart")
        _spec_as_list = [spec]
        params, _spec_as_list = _combine_subchart_params(params, _spec_as_list)
        spec = _spec_as_list[0]
        if isinstance(spec, (Chart, LayerChart)):
            if utils.is_undefined(repeat):
                msg = f"{tp_name!r} requires a `repeat`, but got: {repeat!r}"
                raise TypeError(msg)
            params = _repeat_names(params, repeat, spec)
        super().__init__(
            repeat=repeat,
            spec=spec,
            align=align,
            autosize=autosize,
            background=background,
            bounds=bounds,
            center=center,
            columns=columns,
            config=config,
            data=data,
            datasets=datasets,
            description=description,
            name=name,
            padding=padding,
            params=params,
            resolve=resolve,
            spacing=spacing,
            title=title,
            transform=transform,
            usermeta=usermeta,
            **kwds,
        )

    def transformed_data(
        self, row_limit: int | None = None, exclude: Iterable[str] | None = None
    ) -> DataFrameLike | None:
        
        msg = "transformed_data is not yet implemented for RepeatChart"
        raise NotImplementedError(msg)

    def interactive(
        self, name: str | None = None, bind_x: bool = True, bind_y: bool = True
    ) -> Self:
        
        copy = self.copy(deep=False)
        copy.spec = copy.spec.interactive(name=name, bind_x=bind_x, bind_y=bind_y)
        return copy

    def add_params(self, *params: Parameter) -> Self:
        
        if not params or self.spec is Undefined:
            return self
        copy = self.copy()
        copy.spec = copy.spec.add_params(*params)
        return copy.copy()

    @utils.deprecated(version="5.0.0", alternative="add_params")
    def add_selection(self, *selections) -> Self:  
        
        return self.add_params(*selections)


def repeat(
    repeater: Literal["row", "column", "repeat", "layer"] = "repeat",
) -> RepeatRef:
    
    if repeater not in {"row", "column", "repeat", "layer"}:
        msg = "repeater must be one of ['row', 'column', 'repeat', 'layer']"
        raise ValueError(msg)
    return core.RepeatRef(repeat=repeater)


class ConcatChart(TopLevelMixin, core.TopLevelConcatSpec):
    

    @utils.use_signature(core.TopLevelConcatSpec)
    def __init__(
        self,
        data: Optional[ChartDataType] = Undefined,
        concat: Sequence[ConcatType] = (),
        columns: Optional[float] = Undefined,
        **kwargs: Any,
    ) -> None:
        for spec in concat:
            _check_if_valid_subspec(spec, "ConcatChart")
        super().__init__(data=data, concat=list(concat), columns=columns, **kwargs)  
        self.concat: list[ChartType]
        self.params: Optional[Sequence[_Parameter]]
        self.data: Optional[ChartDataType]
        self.data, self.concat = _combine_subchart_data(self.data, self.concat)
        self.params, self.concat = _combine_subchart_params(self.params, self.concat)

    def __ior__(self, other: ChartType) -> Self:
        _check_if_valid_subspec(other, "ConcatChart")
        self.concat.append(other)
        self.data, self.concat = _combine_subchart_data(self.data, self.concat)
        self.params, self.concat = _combine_subchart_params(self.params, self.concat)
        return self

    def __or__(self, other: ChartType) -> Self:
        copy = self.copy(deep=["concat"])
        copy |= other
        return copy

    def transformed_data(
        self, row_limit: int | None = None, exclude: Iterable[str] | None = None
    ) -> list[DataFrameLike]:
        
        from altair.utils._transformed_data import transformed_data

        return transformed_data(self, row_limit=row_limit, exclude=exclude)

    def interactive(
        self, name: str | None = None, bind_x: bool = True, bind_y: bool = True
    ) -> Self:
        
        encodings: list[SingleDefUnitChannel_T] = []
        if bind_x:
            encodings.append("x")
        if bind_y:
            encodings.append("y")
        return self.add_params(selection_interval(bind="scales", encodings=encodings))

    def add_params(self, *params: Parameter) -> Self:
        
        if not params or not self.concat:
            return self
        copy = self.copy()
        copy.concat = [chart.add_params(*params) for chart in copy.concat]
        return copy

    @utils.deprecated(version="5.0.0", alternative="add_params")
    def add_selection(self, *selections) -> Self:  
        
        return self.add_params(*selections)


def concat(*charts: ConcatType, **kwargs: Any) -> ConcatChart:
    
    return ConcatChart(concat=charts, **kwargs)


class HConcatChart(TopLevelMixin, core.TopLevelHConcatSpec):
    

    @utils.use_signature(core.TopLevelHConcatSpec)
    def __init__(
        self,
        data: Optional[ChartDataType] = Undefined,
        hconcat: Sequence[ConcatType] = (),
        **kwargs: Any,
    ) -> None:
        for spec in hconcat:
            _check_if_valid_subspec(spec, "HConcatChart")
        super().__init__(data=data, hconcat=list(hconcat), **kwargs)  
        self.hconcat: list[ChartType]
        self.params: Optional[Sequence[_Parameter]]
        self.data: Optional[ChartDataType]
        self.data, self.hconcat = _combine_subchart_data(self.data, self.hconcat)
        self.params, self.hconcat = _combine_subchart_params(self.params, self.hconcat)

    def __ior__(self, other: ChartType) -> Self:
        _check_if_valid_subspec(other, "HConcatChart")
        self.hconcat.append(other)
        self.data, self.hconcat = _combine_subchart_data(self.data, self.hconcat)
        self.params, self.hconcat = _combine_subchart_params(self.params, self.hconcat)
        return self

    def __or__(self, other: ChartType) -> Self:
        copy = self.copy(deep=["hconcat"])
        copy |= other
        return copy

    def transformed_data(
        self, row_limit: int | None = None, exclude: Iterable[str] | None = None
    ) -> list[DataFrameLike]:
        
        from altair.utils._transformed_data import transformed_data

        return transformed_data(self, row_limit=row_limit, exclude=exclude)

    def interactive(
        self, name: str | None = None, bind_x: bool = True, bind_y: bool = True
    ) -> Self:
        
        encodings: list[SingleDefUnitChannel_T] = []
        if bind_x:
            encodings.append("x")
        if bind_y:
            encodings.append("y")
        return self.add_params(selection_interval(bind="scales", encodings=encodings))

    def add_params(self, *params: Parameter) -> Self:
        
        if not params or not self.hconcat:
            return self
        copy = self.copy()
        copy.hconcat = [chart.add_params(*params) for chart in copy.hconcat]
        return copy

    @utils.deprecated(version="5.0.0", alternative="add_params")
    def add_selection(self, *selections) -> Self:  
        
        return self.add_params(*selections)


def hconcat(*charts: ConcatType, **kwargs: Any) -> HConcatChart:
    
    return HConcatChart(hconcat=charts, **kwargs)


class VConcatChart(TopLevelMixin, core.TopLevelVConcatSpec):
    

    @utils.use_signature(core.TopLevelVConcatSpec)
    def __init__(
        self,
        data: Optional[ChartDataType] = Undefined,
        vconcat: Sequence[ConcatType] = (),
        **kwargs: Any,
    ) -> None:
        for spec in vconcat:
            _check_if_valid_subspec(spec, "VConcatChart")
        super().__init__(data=data, vconcat=list(vconcat), **kwargs)  
        self.vconcat: list[ChartType]
        self.params: Optional[Sequence[_Parameter]]
        self.data: Optional[ChartDataType]
        self.data, self.vconcat = _combine_subchart_data(self.data, self.vconcat)
        self.params, self.vconcat = _combine_subchart_params(self.params, self.vconcat)

    def __iand__(self, other: ChartType) -> Self:
        _check_if_valid_subspec(other, "VConcatChart")
        self.vconcat.append(other)
        self.data, self.vconcat = _combine_subchart_data(self.data, self.vconcat)
        self.params, self.vconcat = _combine_subchart_params(self.params, self.vconcat)
        return self

    def __and__(self, other: ChartType) -> Self:
        copy = self.copy(deep=["vconcat"])
        copy &= other
        return copy

    def transformed_data(
        self,
        row_limit: int | None = None,
        exclude: Iterable[str] | None = None,
    ) -> list[DataFrameLike]:
        
        from altair.utils._transformed_data import transformed_data

        return transformed_data(self, row_limit=row_limit, exclude=exclude)

    def interactive(
        self, name: str | None = None, bind_x: bool = True, bind_y: bool = True
    ) -> Self:
        
        encodings: list[SingleDefUnitChannel_T] = []
        if bind_x:
            encodings.append("x")
        if bind_y:
            encodings.append("y")
        return self.add_params(selection_interval(bind="scales", encodings=encodings))

    def add_params(self, *params: Parameter) -> Self:
        
        if not params or not self.vconcat:
            return self
        copy = self.copy()
        copy.vconcat = [chart.add_params(*params) for chart in copy.vconcat]
        return copy

    @utils.deprecated(version="5.0.0", alternative="add_params")
    def add_selection(self, *selections) -> Self:  
        
        return self.add_params(*selections)


def vconcat(*charts: ConcatType, **kwargs: Any) -> VConcatChart:
    
    return VConcatChart(vconcat=charts, **kwargs)


class LayerChart(TopLevelMixin, _EncodingMixin, core.TopLevelLayerSpec):
    

    @utils.use_signature(core.TopLevelLayerSpec)
    def __init__(
        self,
        data: Optional[ChartDataType] = Undefined,
        layer: Sequence[LayerType] = (),
        **kwargs: Any,
    ) -> None:
        
        for spec in layer:
            _check_if_valid_subspec(spec, "LayerChart")
            _check_if_can_be_layered(spec)
        super().__init__(data=data, layer=list(layer), **kwargs)  
        self.layer: list[ChartType]
        self.params: Optional[Sequence[_Parameter]]
        self.data: Optional[ChartDataType]
        self.data, self.layer = _combine_subchart_data(self.data, self.layer)
        
        self.layer = _remove_duplicate_params(self.layer)
        self.params, self.layer = _combine_subchart_params(self.params, self.layer)

        
        layer_props = ("height", "width", "view")
        combined_dict, self.layer = _remove_layer_props(self, self.layer, layer_props)

        for prop in combined_dict:
            self[prop] = combined_dict[prop]

    def transformed_data(
        self,
        row_limit: int | None = None,
        exclude: Iterable[str] | None = None,
    ) -> list[DataFrameLike]:
        
        from altair.utils._transformed_data import transformed_data

        return transformed_data(self, row_limit=row_limit, exclude=exclude)

    def __iadd__(self, other: ChartType) -> Self:
        _check_if_valid_subspec(other, "LayerChart")
        _check_if_can_be_layered(other)
        self.layer.append(other)
        self.data, self.layer = _combine_subchart_data(self.data, self.layer)
        self.params, self.layer = _combine_subchart_params(self.params, self.layer)
        return self

    def __add__(self, other: ChartType) -> Self:
        copy = self.copy(deep=["layer"])
        copy += other
        return copy

    def add_layers(self, *layers: LayerChart | Chart) -> Self:
        copy = self.copy(deep=["layer"])
        for layer in layers:
            copy += layer
        return copy

    def interactive(
        self, name: str | None = None, bind_x: bool = True, bind_y: bool = True
    ) -> Self:
        
        if not self.layer:
            msg = "LayerChart: cannot call interactive() until a " "layer is defined"
            raise ValueError(msg)
        copy = self.copy(deep=["layer"])
        copy.layer[0] = copy.layer[0].interactive(
            name=name, bind_x=bind_x, bind_y=bind_y
        )
        return copy

    def add_params(self, *params: Parameter) -> Self:
        
        if not params or not self.layer:
            return self
        copy = self.copy()
        copy.layer[0] = copy.layer[0].add_params(*params)
        return copy.copy()

    @utils.deprecated(version="5.0.0", alternative="add_params")
    def add_selection(self, *selections) -> Self:  
        
        return self.add_params(*selections)


def layer(*charts: LayerType, **kwargs: Any) -> LayerChart:
    
    return LayerChart(layer=charts, **kwargs)


class FacetChart(TopLevelMixin, core.TopLevelFacetSpec):
    

    @utils.use_signature(core.TopLevelFacetSpec)
    def __init__(
        self,
        data: Optional[ChartDataType] = Undefined,
        spec: Optional[ChartType] = Undefined,
        facet: Optional[dict | SchemaBase] = Undefined,
        params: Optional[Sequence[_Parameter]] = Undefined,
        **kwargs: Any,
    ) -> None:
        if utils.is_undefined(spec):
            msg = f"{type(self).__name__!r} requires a `spec`, but got: {spec!r}"
            raise TypeError(msg)
        _check_if_valid_subspec(spec, "FacetChart")
        _spec_as_list = [spec]
        params, _spec_as_list = _combine_subchart_params(params, _spec_as_list)
        spec = _spec_as_list[0]
        super().__init__(data=data, spec=spec, facet=facet, params=params, **kwargs)  
        self.data: Optional[ChartDataType]
        self.spec: ChartType
        self.params: Optional[Sequence[_Parameter]]

    def transformed_data(
        self, row_limit: int | None = None, exclude: Iterable[str] | None = None
    ) -> DataFrameLike | None:
        
        from altair.utils._transformed_data import transformed_data

        return transformed_data(self, row_limit=row_limit, exclude=exclude)

    def interactive(
        self, name: str | None = None, bind_x: bool = True, bind_y: bool = True
    ) -> Self:
        
        copy = self.copy(deep=False)
        copy.spec = copy.spec.interactive(name=name, bind_x=bind_x, bind_y=bind_y)
        return copy

    def add_params(self, *params: Parameter) -> Self:
        
        if not params or self.spec is Undefined:
            return self
        copy = self.copy()
        copy.spec = copy.spec.add_params(*params)
        return copy.copy()

    @utils.deprecated(version="5.0.0", alternative="add_params")
    def add_selection(self, *selections) -> Self:  
        
        return self.add_params(*selections)


def topo_feature(url: str, feature: str, **kwargs: Any) -> UrlData:
    
    return core.UrlData(
        url=url, format=core.TopoDataFormat(type="topojson", feature=feature, **kwargs)
    )


def _combine_subchart_data(
    data: Optional[ChartDataType], subcharts: list[ChartType]
) -> tuple[Optional[ChartDataType], list[ChartType]]:
    def remove_data(subchart: _TSchemaBase) -> _TSchemaBase:
        if subchart.data is not Undefined:
            subchart = subchart.copy()
            subchart.data = Undefined
        return subchart

    if not subcharts:
        
        pass
    elif data is Undefined:
        
        
        subdata = subcharts[0].data
        if subdata is not Undefined and all(c.data is subdata for c in subcharts):
            data = subdata
            subcharts = [remove_data(c) for c in subcharts]
    elif all(c.data is Undefined or c.data is data for c in subcharts):
        
        
        subcharts = [remove_data(c) for c in subcharts]

    return data, subcharts


_Parameter: TypeAlias = Union[
    core.VariableParameter, core.TopLevelSelectionParameter, core.SelectionParameter
]


def _viewless_dict(param: _Parameter) -> dict[str, Any]:
    d = param.to_dict()
    d.pop("views", None)
    return d


def _needs_name(subchart: ChartType) -> bool:
    
    if (subchart.name is not Undefined) or (not isinstance(subchart, Chart)):
        return False

    
    return not all(isinstance(p, core.VariableParameter) for p in subchart.params)



def _prepare_to_lift(param: _Parameter) -> _Parameter:
    param = param.copy()

    if isinstance(param, core.VariableParameter):
        return param

    if isinstance(param, core.SelectionParameter):
        return core.TopLevelSelectionParameter(**param.to_dict(), views=[])

    if param.views is Undefined:
        param.views = []

    return param


def _remove_duplicate_params(layer: list[ChartType]) -> list[ChartType]:
    subcharts = [subchart.copy() for subchart in layer]
    found_params = []

    for subchart in subcharts:
        if (not hasattr(subchart, "params")) or (utils.is_undefined(subchart.params)):
            continue

        params: list[_Parameter] = []

        
        for param in subchart.params:
            if isinstance(param, core.VariableParameter):
                params.append(param)
                continue

            p = param.copy()
            pd = _viewless_dict(p)

            if pd not in found_params:
                params.append(p)
                found_params.append(pd)

        if len(params) == 0:
            subchart.params = Undefined
        else:
            subchart.params = params

    return subcharts


def _combine_subchart_params(  
    params: Optional[Sequence[_Parameter]], subcharts: list[ChartType]
) -> tuple[Optional[Sequence[_Parameter]], list[ChartType]]:
    if utils.is_undefined(params):
        params = []

    
    param_info: list[tuple[_Parameter, dict[str, Any], list[str]]] = []

    
    for param in params:
        p = _prepare_to_lift(param)
        param_info.append(
            (
                p,
                _viewless_dict(p),
                [] if isinstance(p, core.VariableParameter) else p.views,
            )
        )

    subcharts = [subchart.copy() for subchart in subcharts]

    for subchart in subcharts:
        if (not hasattr(subchart, "params")) or (utils.is_undefined(subchart.params)):
            continue

        if _needs_name(subchart):
            subchart.name = subchart._get_name()

        for param in subchart.params:
            p = _prepare_to_lift(param)
            pd = _viewless_dict(p)

            dlist = [d for _, d, _ in param_info]
            found = pd in dlist

            if isinstance(p, core.VariableParameter) and found:
                continue

            if isinstance(p, core.VariableParameter) and not found:
                param_info.append((p, pd, []))
                continue

            

            if isinstance(subchart, Chart) and (subchart.name not in p.views):
                p.views.append(subchart.name)

            if found:
                i = dlist.index(pd)
                _, _, old_views = param_info[i]
                new_views = [v for v in p.views if v not in old_views]
                old_views += new_views
            else:
                param_info.append((p, pd, p.views))

        subchart.params = Undefined

    for p, _, v in param_info:
        if len(v) > 0:
            p.views = v

    subparams: Any = [p for p, _, _ in param_info]

    if len(subparams) == 0:
        subparams = Undefined

    return subparams, subcharts


def _get_repeat_strings(
    repeat: list[str] | LayerRepeatMapping | RepeatMapping,
) -> list[str]:
    if isinstance(repeat, list):
        return repeat
    elif isinstance(repeat, core.LayerRepeatMapping):
        klist = ["row", "column", "layer"]
    elif isinstance(repeat, core.RepeatMapping):
        klist = ["row", "column"]
    rclist = [k for k in klist if repeat[k] is not Undefined]
    rcstrings = [[f"{k}_{v}" for v in repeat[k]] for k in rclist]
    return ["".join(s) for s in itertools.product(*rcstrings)]


def _extend_view_name(v: str, r: str, spec: Chart | LayerChart) -> str:
    
    if isinstance(spec, Chart):
        if v.endswith("child__" + r):
            return v
        else:
            return f"{v}_child__{r}"
    elif isinstance(spec, LayerChart):
        if v.startswith("child__" + r):
            return v
        else:
            return f"child__{r}_{v}"
    else:
        msg = f"Expected 'Chart | LayerChart', but got: {type(spec).__name__!r}"
        raise TypeError(msg)


def _repeat_names(
    params: Optional[Sequence[_Parameter]],
    repeat: list[str] | LayerRepeatMapping | RepeatMapping,
    spec: Chart | LayerChart,
) -> Optional[Sequence[_Parameter]]:
    if utils.is_undefined(params):
        return params

    repeat = _get_repeat_strings(repeat)
    params_named: list[_Parameter] = []

    for param in params:
        if not isinstance(param, core.TopLevelSelectionParameter):
            params_named.append(param)
            continue
        p = param.copy()
        views = []
        repeat_strings = _get_repeat_strings(repeat)
        for v in param.views:
            if isinstance(spec, Chart):
                if any(v.endswith(f"child__{r}") for r in repeat_strings):
                    views.append(v)
                else:
                    views += [_extend_view_name(v, r, spec) for r in repeat_strings]
            elif isinstance(spec, LayerChart):
                if any(v.startswith(f"child__{r}") for r in repeat_strings):
                    views.append(v)
                else:
                    views += [_extend_view_name(v, r, spec) for r in repeat_strings]

        p.views = views
        params_named.append(p)

    return params_named


def _remove_layer_props(  
    chart: LayerChart, subcharts: list[ChartType], layer_props: Iterable[str]
) -> tuple[dict[str, Any], list[ChartType]]:
    def remove_prop(subchart: ChartType, prop: str) -> ChartType:
        
        try:
            if subchart[prop] is not Undefined:
                subchart = subchart.copy()
                subchart[prop] = Undefined
        except KeyError:
            pass
        return subchart

    output_dict: dict[str, Any] = {}

    if not subcharts:
        
        return output_dict, subcharts

    for prop in layer_props:
        if chart[prop] is Undefined:
            
            
            values = []
            for c in subcharts:
                
                try:
                    val = c[prop]
                    if val is not Undefined:
                        values.append(val)
                except KeyError:
                    pass
            if len(values) == 0:
                pass
            elif all(v == values[0] for v in values[1:]):
                output_dict[prop] = values[0]
            else:
                msg = f"There are inconsistent values {values} for {prop}"
                raise ValueError(msg)
        elif all(
            getattr(c, prop, Undefined) is Undefined or c[prop] == chart[prop]
            for c in subcharts
        ):
            
            
            output_dict[prop] = chart[prop]
        else:
            msg = f"There are inconsistent values {values} for {prop}"  
            raise ValueError(msg)
        subcharts = [remove_prop(c, prop) for c in subcharts]

    return output_dict, subcharts


@utils.use_signature(core.SequenceParams)
def sequence(
    start: Optional[float],
    stop: Optional[float | None] = None,
    step: Optional[float] = Undefined,
    as_: Optional[str] = Undefined,
    **kwds: Any,
) -> SequenceGenerator:
    
    if stop is None:
        start, stop = 0, start
    params = core.SequenceParams(start=start, stop=stop, step=step, **{"as": as_})
    return core.SequenceGenerator(sequence=params, **kwds)


@utils.use_signature(core.GraticuleParams)
def graticule(**kwds: Any) -> GraticuleGenerator:
    
    
    graticule: Any = core.GraticuleParams(**kwds) if kwds else True
    return core.GraticuleGenerator(graticule=graticule)


def sphere() -> SphereGenerator:
    
    return core.SphereGenerator(sphere=True)


ChartType: TypeAlias = Union[
    Chart, RepeatChart, ConcatChart, HConcatChart, VConcatChart, FacetChart, LayerChart
]
ConcatType: TypeAlias = Union[
    ChartType,
    core.FacetSpec,
    core.LayerSpec,
    core.RepeatSpec,
    core.FacetedUnitSpec,
    core.LayerRepeatSpec,
    core.NonNormalizedSpec,
    core.NonLayerRepeatSpec,
    core.ConcatSpecGenericSpec,
    core.ConcatSpecGenericSpec,
    core.HConcatSpecGenericSpec,
    core.VConcatSpecGenericSpec,
]
LayerType: TypeAlias = Union[ChartType, core.UnitSpec, core.LayerSpec]


def is_chart_type(obj: Any) -> TypeIs[ChartType]:
    
    return isinstance(
        obj,
        (Chart, RepeatChart, ConcatChart, HConcatChart, VConcatChart, FacetChart, LayerChart)
    )  
