


from __future__ import annotations








import sys
from typing import TYPE_CHECKING, Any, Literal, TypedDict, Union, overload

if sys.version_info >= (3, 10):
    from typing import TypeAlias
else:
    from typing_extensions import TypeAlias
import narwhals.stable.v1 as nw

from altair.utils import infer_encoding_types as _infer_encoding_types
from altair.utils import parse_shorthand
from altair.utils.schemapi import Undefined, with_property_setters

from . import core
from ._typing import *  

if TYPE_CHECKING:
    
    from collections.abc import Sequence

    from altair import Parameter, SchemaBase
    from altair.typing import Optional
    from altair.vegalite.v5.api import Bin, Impute, IntoCondition
    from altair.vegalite.v5.schema.core import (
        Axis,
        DateTime,
        EncodingSortField,
        Header,
        Legend,
        RepeatRef,
        Scale,
        TimeUnitParams,
    )

    if sys.version_info >= (3, 11):
        from typing import Self
    else:
        from typing_extensions import Self


__all__ = [
    "X2",
    "Y2",
    "Angle",
    "AngleDatum",
    "AngleValue",
    "Color",
    "ColorDatum",
    "ColorValue",
    "Column",
    "DatumChannelMixin",
    "Description",
    "DescriptionValue",
    "Detail",
    "Facet",
    "FieldChannelMixin",
    "Fill",
    "FillDatum",
    "FillOpacity",
    "FillOpacityDatum",
    "FillOpacityValue",
    "FillValue",
    "Href",
    "HrefValue",
    "Key",
    "Latitude",
    "Latitude2",
    "Latitude2Datum",
    "Latitude2Value",
    "LatitudeDatum",
    "Longitude",
    "Longitude2",
    "Longitude2Datum",
    "Longitude2Value",
    "LongitudeDatum",
    "Opacity",
    "OpacityDatum",
    "OpacityValue",
    "Order",
    "OrderValue",
    "Radius",
    "Radius2",
    "Radius2Datum",
    "Radius2Value",
    "RadiusDatum",
    "RadiusValue",
    "Row",
    "Shape",
    "ShapeDatum",
    "ShapeValue",
    "Size",
    "SizeDatum",
    "SizeValue",
    "Stroke",
    "StrokeDash",
    "StrokeDashDatum",
    "StrokeDashValue",
    "StrokeDatum",
    "StrokeOpacity",
    "StrokeOpacityDatum",
    "StrokeOpacityValue",
    "StrokeValue",
    "StrokeWidth",
    "StrokeWidthDatum",
    "StrokeWidthValue",
    "Text",
    "TextDatum",
    "TextValue",
    "Theta",
    "Theta2",
    "Theta2Datum",
    "Theta2Value",
    "ThetaDatum",
    "ThetaValue",
    "Tooltip",
    "TooltipValue",
    "Url",
    "UrlValue",
    "ValueChannelMixin",
    "X",
    "X2Datum",
    "X2Value",
    "XDatum",
    "XError",
    "XError2",
    "XError2Value",
    "XErrorValue",
    "XOffset",
    "XOffsetDatum",
    "XOffsetValue",
    "XValue",
    "Y",
    "Y2Datum",
    "Y2Value",
    "YDatum",
    "YError",
    "YError2",
    "YError2Value",
    "YErrorValue",
    "YOffset",
    "YOffsetDatum",
    "YOffsetValue",
    "YValue",
    "with_property_setters",
]


class FieldChannelMixin:
    _encoding_name: str

    def to_dict(
        self,
        validate: bool = True,
        ignore: list[str] | None = None,
        context: dict[str, Any] | None = None,
    ) -> dict | list[dict]:
        context = context or {}
        ignore = ignore or []
        shorthand = self._get("shorthand")  
        field = self._get("field")  

        if shorthand is not Undefined and field is not Undefined:
            msg = f"{self.__class__.__name__} specifies both shorthand={shorthand} and field={field}. "
            raise ValueError(msg)

        if isinstance(shorthand, (tuple, list)):
            
            kwds = self._kwds.copy()  
            kwds.pop("shorthand")
            return [
                self.__class__(sh, **kwds).to_dict(  
                    validate=validate, ignore=ignore, context=context
                )
                for sh in shorthand
            ]

        if shorthand is Undefined:
            parsed = {}
        elif isinstance(shorthand, str):
            data: nw.DataFrame | Any = context.get("data", None)
            parsed = parse_shorthand(shorthand, data=data)
            type_required = "type" in self._kwds  
            type_in_shorthand = "type" in parsed
            type_defined_explicitly = self._get("type") is not Undefined  
            if not type_required:
                
                
                parsed.pop("type", None)
            elif not (type_in_shorthand or type_defined_explicitly):
                if isinstance(data, nw.DataFrame):
                    msg = (
                        f'Unable to determine data type for the field "{shorthand}";'
                        " verify that the field name is not misspelled."
                        " If you are referencing a field from a transform,"
                        " also confirm that the data type is specified correctly."
                    )
                    raise ValueError(msg)
                else:
                    msg = (
                        f"{shorthand} encoding field is specified without a type; "
                        "the type cannot be automatically inferred because "
                        "the data is not specified as a pandas.DataFrame."
                    )
                    raise ValueError(msg)
        else:
            
            
            parsed = {"field": shorthand}
        context["parsed_shorthand"] = parsed

        return super().to_dict(validate=validate, ignore=ignore, context=context)


class ValueChannelMixin:
    _encoding_name: str

    def to_dict(
        self,
        validate: bool = True,
        ignore: list[str] | None = None,
        context: dict[str, Any] | None = None,
    ) -> dict:
        context = context or {}
        ignore = ignore or []
        condition = self._get("condition", Undefined)  
        copy = self  
        if condition is not Undefined:
            if isinstance(condition, core.SchemaBase):
                pass
            elif "field" in condition and "type" not in condition:
                kwds = parse_shorthand(condition["field"], context.get("data", None))
                copy = self.copy(deep=["condition"])  
                copy["condition"].update(kwds)  
        return super(ValueChannelMixin, copy).to_dict(
            validate=validate, ignore=ignore, context=context
        )


class DatumChannelMixin:
    _encoding_name: str

    def to_dict(
        self,
        validate: bool = True,
        ignore: list[str] | None = None,
        context: dict[str, Any] | None = None,
    ) -> dict:
        context = context or {}
        ignore = ignore or []
        datum = self._get("datum", Undefined)  
        copy = self  
        return super(DatumChannelMixin, copy).to_dict(
            validate=validate, ignore=ignore, context=context
        )


@with_property_setters
class Angle(FieldChannelMixin, core.FieldOrDatumDefWithConditionMarkPropFieldDefnumber):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "angle"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Angle: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Angle: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Angle: ...
    @overload
    def bandPosition(self, _: float, /) -> Angle: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> Angle: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Angle: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> Angle: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> Angle: ...
    @overload
    def condition(self, _: list[core.ConditionalValueDefnumberExprRef], /) -> Angle: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Angle: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Angle: ...
    @overload
    def legend(self, _: Legend | None, /) -> Angle: ...
    @overload
    def legend(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        clipHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columnPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columns: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        cornerRadius: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        direction: Optional[SchemaBase | Orientation_T] = Undefined,
        fillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        gradientLength: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gradientStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientThickness: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridAlign: Optional[Parameter | SchemaBase | Map | LayoutAlign_T] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[SchemaBase | LegendOrient_T] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        rowPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        strokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        symbolDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolFillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolType: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[Parameter | SchemaBase | Map | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        type: Optional[Literal["symbol", "gradient"]] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> Angle: ...
    @overload
    def scale(self, _: Scale | None, /) -> Angle: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> Angle: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> Angle: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Angle: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Angle: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Angle: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Angle: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Angle: ...
    @overload
    def type(self, _: StandardType_T, /) -> Angle: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            legend=legend,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class AngleDatum(DatumChannelMixin, core.FieldOrDatumDefWithConditionDatumDefnumber):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "angle"

    @overload
    def bandPosition(self, _: float, /) -> AngleDatum: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> AngleDatum: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> AngleDatum: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> AngleDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> AngleDatum: ...
    @overload
    def type(self, _: Type_T, /) -> AngleDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            condition=condition,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class AngleValue(
    ValueChannelMixin, core.ValueDefWithConditionMarkPropFieldOrDatumDefnumber
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "angle"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> AngleValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> AngleValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> AngleValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> AngleValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> AngleValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> AngleValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> AngleValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class Color(
    FieldChannelMixin,
    core.FieldOrDatumDefWithConditionMarkPropFieldDefGradientstringnull,
):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "color"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Color: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Color: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Color: ...
    @overload
    def bandPosition(self, _: float, /) -> Color: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> Color: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Color: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> Color: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> Color: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefGradientstringnullExprRef], /
    ) -> Color: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Color: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Color: ...
    @overload
    def legend(self, _: Legend | None, /) -> Color: ...
    @overload
    def legend(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        clipHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columnPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columns: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        cornerRadius: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        direction: Optional[SchemaBase | Orientation_T] = Undefined,
        fillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        gradientLength: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gradientStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientThickness: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridAlign: Optional[Parameter | SchemaBase | Map | LayoutAlign_T] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[SchemaBase | LegendOrient_T] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        rowPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        strokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        symbolDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolFillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolType: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[Parameter | SchemaBase | Map | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        type: Optional[Literal["symbol", "gradient"]] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> Color: ...
    @overload
    def scale(self, _: Scale | None, /) -> Color: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> Color: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> Color: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Color: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Color: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Color: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Color: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Color: ...
    @overload
    def type(self, _: StandardType_T, /) -> Color: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            legend=legend,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class ColorDatum(
    DatumChannelMixin, core.FieldOrDatumDefWithConditionDatumDefGradientstringnull
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "color"

    @overload
    def bandPosition(self, _: float, /) -> ColorDatum: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> ColorDatum: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> ColorDatum: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefGradientstringnullExprRef], /
    ) -> ColorDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> ColorDatum: ...
    @overload
    def type(self, _: Type_T, /) -> ColorDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            condition=condition,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class ColorValue(
    ValueChannelMixin,
    core.ValueDefWithConditionMarkPropFieldOrDatumDefGradientstringnull,
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "color"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> ColorValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> ColorValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> ColorValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> ColorValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> ColorValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> ColorValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefGradientstringnullExprRef], /
    ) -> ColorValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class Column(FieldChannelMixin, core.RowColumnEncodingFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "column"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Column: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Column: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Column: ...
    @overload
    def align(self, _: LayoutAlign_T, /) -> Column: ...
    @overload
    def bandPosition(self, _: float, /) -> Column: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> Column: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Column: ...
    @overload
    def center(self, _: bool, /) -> Column: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Column: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Column: ...
    @overload
    def header(self, _: Header | None, /) -> Column: ...
    @overload
    def header(
        self,
        *,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelAnchor: Optional[SchemaBase | TitleAnchor_T] = Undefined,
        labelAngle: Optional[float] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOrient: Optional[SchemaBase | Orient_T] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labels: Optional[bool] = Undefined,
        orient: Optional[SchemaBase | Orient_T] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[SchemaBase | TitleAnchor_T] = Undefined,
        titleAngle: Optional[float] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[SchemaBase | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> Column: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | EncodingSortField
        | Sequence[DateTime | Temporal]
        | SortOrder_T
        | None,
        /,
    ) -> Column: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Column: ...
    @overload
    def spacing(self, _: float, /) -> Column: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Column: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Column: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Column: ...
    @overload
    def type(self, _: StandardType_T, /) -> Column: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        align: Optional[SchemaBase | LayoutAlign_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        center: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        header: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | SortOrder_T
            | None
        ] = Undefined,
        spacing: Optional[float] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            align=align,
            bandPosition=bandPosition,
            bin=bin,
            center=center,
            field=field,
            header=header,
            sort=sort,
            spacing=spacing,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class Description(FieldChannelMixin, core.StringFieldDefWithCondition):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "description"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Description: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Description: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Description: ...
    @overload
    def bandPosition(self, _: float, /) -> Description: ...
    @overload
    def bin(self, _: bool | Bin | Literal["binned"] | None, /) -> Description: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Description: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map] = Undefined,
    ) -> Description: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map] = Undefined,
    ) -> Description: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefstringExprRef], /
    ) -> Description: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Description: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Description: ...
    @overload
    def format(self, _: str, /) -> Description: ...
    @overload
    def format(self, _: Map, /) -> Description: ...
    @overload
    def formatType(self, _: str, /) -> Description: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Description: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Description: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Description: ...
    @overload
    def type(self, _: StandardType_T, /) -> Description: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            format=format,
            formatType=formatType,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class DescriptionValue(ValueChannelMixin, core.StringValueDefWithCondition):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "description"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> DescriptionValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> DescriptionValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> DescriptionValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> DescriptionValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> DescriptionValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> DescriptionValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefstringnullExprRef], /
    ) -> DescriptionValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class Detail(FieldChannelMixin, core.FieldDefWithoutScale):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "detail"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Detail: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Detail: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Detail: ...
    @overload
    def bandPosition(self, _: float, /) -> Detail: ...
    @overload
    def bin(self, _: bool | Bin | Literal["binned"] | None, /) -> Detail: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Detail: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Detail: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Detail: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Detail: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Detail: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Detail: ...
    @overload
    def type(self, _: StandardType_T, /) -> Detail: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class Facet(FieldChannelMixin, core.FacetEncodingFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "facet"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Facet: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Facet: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Facet: ...
    @overload
    def align(self, _: RowColKwds[LayoutAlign_T] | LayoutAlign_T, /) -> Facet: ...
    @overload
    def align(
        self,
        *,
        column: Optional[SchemaBase | LayoutAlign_T] = Undefined,
        row: Optional[SchemaBase | LayoutAlign_T] = Undefined,
    ) -> Facet: ...
    @overload
    def bandPosition(self, _: float, /) -> Facet: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> Facet: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Facet: ...
    @overload
    def bounds(self, _: Literal["full", "flush"], /) -> Facet: ...
    @overload
    def center(self, _: bool | RowColKwds[bool], /) -> Facet: ...
    @overload
    def center(
        self, *, column: Optional[bool] = Undefined, row: Optional[bool] = Undefined
    ) -> Facet: ...
    @overload
    def columns(self, _: float, /) -> Facet: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Facet: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Facet: ...
    @overload
    def header(self, _: Header | None, /) -> Facet: ...
    @overload
    def header(
        self,
        *,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelAnchor: Optional[SchemaBase | TitleAnchor_T] = Undefined,
        labelAngle: Optional[float] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOrient: Optional[SchemaBase | Orient_T] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labels: Optional[bool] = Undefined,
        orient: Optional[SchemaBase | Orient_T] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[SchemaBase | TitleAnchor_T] = Undefined,
        titleAngle: Optional[float] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[SchemaBase | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> Facet: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | EncodingSortField
        | Sequence[DateTime | Temporal]
        | SortOrder_T
        | None,
        /,
    ) -> Facet: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Facet: ...
    @overload
    def spacing(self, _: float | RowColKwds[float], /) -> Facet: ...
    @overload
    def spacing(
        self, *, column: Optional[float] = Undefined, row: Optional[float] = Undefined
    ) -> Facet: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Facet: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Facet: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Facet: ...
    @overload
    def type(self, _: StandardType_T, /) -> Facet: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        align: Optional[SchemaBase | Map | LayoutAlign_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        bounds: Optional[Literal["full", "flush"]] = Undefined,
        center: Optional[bool | SchemaBase | Map] = Undefined,
        columns: Optional[float] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        header: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | SortOrder_T
            | None
        ] = Undefined,
        spacing: Optional[float | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            align=align,
            bandPosition=bandPosition,
            bin=bin,
            bounds=bounds,
            center=center,
            columns=columns,
            field=field,
            header=header,
            sort=sort,
            spacing=spacing,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class Fill(
    FieldChannelMixin,
    core.FieldOrDatumDefWithConditionMarkPropFieldDefGradientstringnull,
):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "fill"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Fill: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Fill: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Fill: ...
    @overload
    def bandPosition(self, _: float, /) -> Fill: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> Fill: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Fill: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> Fill: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> Fill: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefGradientstringnullExprRef], /
    ) -> Fill: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Fill: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Fill: ...
    @overload
    def legend(self, _: Legend | None, /) -> Fill: ...
    @overload
    def legend(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        clipHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columnPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columns: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        cornerRadius: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        direction: Optional[SchemaBase | Orientation_T] = Undefined,
        fillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        gradientLength: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gradientStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientThickness: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridAlign: Optional[Parameter | SchemaBase | Map | LayoutAlign_T] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[SchemaBase | LegendOrient_T] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        rowPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        strokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        symbolDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolFillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolType: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[Parameter | SchemaBase | Map | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        type: Optional[Literal["symbol", "gradient"]] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> Fill: ...
    @overload
    def scale(self, _: Scale | None, /) -> Fill: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> Fill: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> Fill: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Fill: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Fill: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Fill: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Fill: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Fill: ...
    @overload
    def type(self, _: StandardType_T, /) -> Fill: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            legend=legend,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class FillDatum(
    DatumChannelMixin, core.FieldOrDatumDefWithConditionDatumDefGradientstringnull
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "fill"

    @overload
    def bandPosition(self, _: float, /) -> FillDatum: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> FillDatum: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> FillDatum: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefGradientstringnullExprRef], /
    ) -> FillDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> FillDatum: ...
    @overload
    def type(self, _: Type_T, /) -> FillDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            condition=condition,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class FillValue(
    ValueChannelMixin,
    core.ValueDefWithConditionMarkPropFieldOrDatumDefGradientstringnull,
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "fill"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> FillValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> FillValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> FillValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> FillValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> FillValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> FillValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefGradientstringnullExprRef], /
    ) -> FillValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class FillOpacity(
    FieldChannelMixin, core.FieldOrDatumDefWithConditionMarkPropFieldDefnumber
):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "fillOpacity"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> FillOpacity: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> FillOpacity: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> FillOpacity: ...
    @overload
    def bandPosition(self, _: float, /) -> FillOpacity: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> FillOpacity: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> FillOpacity: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> FillOpacity: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> FillOpacity: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> FillOpacity: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> FillOpacity: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> FillOpacity: ...
    @overload
    def legend(self, _: Legend | None, /) -> FillOpacity: ...
    @overload
    def legend(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        clipHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columnPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columns: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        cornerRadius: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        direction: Optional[SchemaBase | Orientation_T] = Undefined,
        fillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        gradientLength: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gradientStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientThickness: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridAlign: Optional[Parameter | SchemaBase | Map | LayoutAlign_T] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[SchemaBase | LegendOrient_T] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        rowPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        strokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        symbolDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolFillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolType: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[Parameter | SchemaBase | Map | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        type: Optional[Literal["symbol", "gradient"]] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> FillOpacity: ...
    @overload
    def scale(self, _: Scale | None, /) -> FillOpacity: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> FillOpacity: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> FillOpacity: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> FillOpacity: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> FillOpacity: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> FillOpacity: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> FillOpacity: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> FillOpacity: ...
    @overload
    def type(self, _: StandardType_T, /) -> FillOpacity: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            legend=legend,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class FillOpacityDatum(
    DatumChannelMixin, core.FieldOrDatumDefWithConditionDatumDefnumber
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "fillOpacity"

    @overload
    def bandPosition(self, _: float, /) -> FillOpacityDatum: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> FillOpacityDatum: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> FillOpacityDatum: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> FillOpacityDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> FillOpacityDatum: ...
    @overload
    def type(self, _: Type_T, /) -> FillOpacityDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            condition=condition,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class FillOpacityValue(
    ValueChannelMixin, core.ValueDefWithConditionMarkPropFieldOrDatumDefnumber
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "fillOpacity"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> FillOpacityValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> FillOpacityValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> FillOpacityValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> FillOpacityValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> FillOpacityValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> FillOpacityValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> FillOpacityValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class Href(FieldChannelMixin, core.StringFieldDefWithCondition):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "href"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Href: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Href: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Href: ...
    @overload
    def bandPosition(self, _: float, /) -> Href: ...
    @overload
    def bin(self, _: bool | Bin | Literal["binned"] | None, /) -> Href: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Href: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map] = Undefined,
    ) -> Href: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map] = Undefined,
    ) -> Href: ...
    @overload
    def condition(self, _: list[core.ConditionalValueDefstringExprRef], /) -> Href: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Href: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Href: ...
    @overload
    def format(self, _: str, /) -> Href: ...
    @overload
    def format(self, _: Map, /) -> Href: ...
    @overload
    def formatType(self, _: str, /) -> Href: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Href: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Href: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Href: ...
    @overload
    def type(self, _: StandardType_T, /) -> Href: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            format=format,
            formatType=formatType,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class HrefValue(ValueChannelMixin, core.StringValueDefWithCondition):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "href"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> HrefValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> HrefValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> HrefValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> HrefValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> HrefValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> HrefValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefstringnullExprRef], /
    ) -> HrefValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class Key(FieldChannelMixin, core.FieldDefWithoutScale):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "key"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Key: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Key: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Key: ...
    @overload
    def bandPosition(self, _: float, /) -> Key: ...
    @overload
    def bin(self, _: bool | Bin | Literal["binned"] | None, /) -> Key: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Key: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Key: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Key: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Key: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Key: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Key: ...
    @overload
    def type(self, _: StandardType_T, /) -> Key: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class Latitude(FieldChannelMixin, core.LatLongFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "latitude"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Latitude: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Latitude: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Latitude: ...
    @overload
    def bandPosition(self, _: float, /) -> Latitude: ...
    @overload
    def bin(self, _: None, /) -> Latitude: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Latitude: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Latitude: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Latitude: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Latitude: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Latitude: ...
    @overload
    def type(self, _: Literal["quantitative"], /) -> Latitude: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[Literal["quantitative"]] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class LatitudeDatum(DatumChannelMixin, core.DatumDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "latitude"

    @overload
    def bandPosition(self, _: float, /) -> LatitudeDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> LatitudeDatum: ...
    @overload
    def type(self, _: Type_T, /) -> LatitudeDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum, bandPosition=bandPosition, title=title, type=type, **kwds
        )


@with_property_setters
class Latitude2(FieldChannelMixin, core.SecondaryFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "latitude2"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Latitude2: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Latitude2: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Latitude2: ...
    @overload
    def bandPosition(self, _: float, /) -> Latitude2: ...
    @overload
    def bin(self, _: None, /) -> Latitude2: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Latitude2: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Latitude2: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Latitude2: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Latitude2: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Latitude2: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            **kwds,
        )


@with_property_setters
class Latitude2Datum(DatumChannelMixin, core.DatumDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "latitude2"

    @overload
    def bandPosition(self, _: float, /) -> Latitude2Datum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Latitude2Datum: ...
    @overload
    def type(self, _: Type_T, /) -> Latitude2Datum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum, bandPosition=bandPosition, title=title, type=type, **kwds
        )


@with_property_setters
class Latitude2Value(ValueChannelMixin, core.PositionValueDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "latitude2"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class Longitude(FieldChannelMixin, core.LatLongFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "longitude"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Longitude: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Longitude: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Longitude: ...
    @overload
    def bandPosition(self, _: float, /) -> Longitude: ...
    @overload
    def bin(self, _: None, /) -> Longitude: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Longitude: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Longitude: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Longitude: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Longitude: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Longitude: ...
    @overload
    def type(self, _: Literal["quantitative"], /) -> Longitude: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[Literal["quantitative"]] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class LongitudeDatum(DatumChannelMixin, core.DatumDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "longitude"

    @overload
    def bandPosition(self, _: float, /) -> LongitudeDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> LongitudeDatum: ...
    @overload
    def type(self, _: Type_T, /) -> LongitudeDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum, bandPosition=bandPosition, title=title, type=type, **kwds
        )


@with_property_setters
class Longitude2(FieldChannelMixin, core.SecondaryFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "longitude2"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Longitude2: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Longitude2: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Longitude2: ...
    @overload
    def bandPosition(self, _: float, /) -> Longitude2: ...
    @overload
    def bin(self, _: None, /) -> Longitude2: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Longitude2: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Longitude2: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Longitude2: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Longitude2: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Longitude2: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            **kwds,
        )


@with_property_setters
class Longitude2Datum(DatumChannelMixin, core.DatumDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "longitude2"

    @overload
    def bandPosition(self, _: float, /) -> Longitude2Datum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Longitude2Datum: ...
    @overload
    def type(self, _: Type_T, /) -> Longitude2Datum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum, bandPosition=bandPosition, title=title, type=type, **kwds
        )


@with_property_setters
class Longitude2Value(ValueChannelMixin, core.PositionValueDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "longitude2"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class Opacity(
    FieldChannelMixin, core.FieldOrDatumDefWithConditionMarkPropFieldDefnumber
):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "opacity"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Opacity: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Opacity: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Opacity: ...
    @overload
    def bandPosition(self, _: float, /) -> Opacity: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> Opacity: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Opacity: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> Opacity: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> Opacity: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> Opacity: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Opacity: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Opacity: ...
    @overload
    def legend(self, _: Legend | None, /) -> Opacity: ...
    @overload
    def legend(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        clipHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columnPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columns: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        cornerRadius: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        direction: Optional[SchemaBase | Orientation_T] = Undefined,
        fillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        gradientLength: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gradientStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientThickness: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridAlign: Optional[Parameter | SchemaBase | Map | LayoutAlign_T] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[SchemaBase | LegendOrient_T] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        rowPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        strokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        symbolDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolFillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolType: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[Parameter | SchemaBase | Map | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        type: Optional[Literal["symbol", "gradient"]] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> Opacity: ...
    @overload
    def scale(self, _: Scale | None, /) -> Opacity: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> Opacity: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> Opacity: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Opacity: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Opacity: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Opacity: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Opacity: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Opacity: ...
    @overload
    def type(self, _: StandardType_T, /) -> Opacity: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            legend=legend,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class OpacityDatum(DatumChannelMixin, core.FieldOrDatumDefWithConditionDatumDefnumber):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "opacity"

    @overload
    def bandPosition(self, _: float, /) -> OpacityDatum: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> OpacityDatum: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> OpacityDatum: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> OpacityDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> OpacityDatum: ...
    @overload
    def type(self, _: Type_T, /) -> OpacityDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            condition=condition,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class OpacityValue(
    ValueChannelMixin, core.ValueDefWithConditionMarkPropFieldOrDatumDefnumber
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "opacity"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> OpacityValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> OpacityValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> OpacityValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> OpacityValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> OpacityValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> OpacityValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> OpacityValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class Order(FieldChannelMixin, core.OrderFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "order"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Order: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Order: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Order: ...
    @overload
    def bandPosition(self, _: float, /) -> Order: ...
    @overload
    def bin(self, _: bool | Bin | Literal["binned"] | None, /) -> Order: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Order: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Order: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Order: ...
    @overload
    def sort(self, _: SortOrder_T, /) -> Order: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Order: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Order: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Order: ...
    @overload
    def type(self, _: StandardType_T, /) -> Order: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        sort: Optional[SchemaBase | SortOrder_T] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class OrderValue(ValueChannelMixin, core.OrderValueDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "order"

    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float] = Undefined,
    ) -> OrderValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float] = Undefined,
    ) -> OrderValue: ...
    @overload
    def condition(self, _: list[core.ConditionalValueDefnumber], /) -> OrderValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class Radius(FieldChannelMixin, core.PositionFieldDefBase):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "radius"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Radius: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Radius: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Radius: ...
    @overload
    def bandPosition(self, _: float, /) -> Radius: ...
    @overload
    def bin(self, _: bool | Bin | Literal["binned"] | None, /) -> Radius: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Radius: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Radius: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Radius: ...
    @overload
    def scale(self, _: Scale | None, /) -> Radius: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> Radius: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> Radius: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Radius: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Radius: ...
    @overload
    def stack(self, _: bool | StackOffset_T | None, /) -> Radius: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Radius: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Radius: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Radius: ...
    @overload
    def type(self, _: StandardType_T, /) -> Radius: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        stack: Optional[bool | SchemaBase | StackOffset_T | None] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            scale=scale,
            sort=sort,
            stack=stack,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class RadiusDatum(DatumChannelMixin, core.PositionDatumDefBase):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "radius"

    @overload
    def bandPosition(self, _: float, /) -> RadiusDatum: ...
    @overload
    def scale(self, _: Scale | None, /) -> RadiusDatum: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> RadiusDatum: ...
    @overload
    def stack(self, _: bool | StackOffset_T | None, /) -> RadiusDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> RadiusDatum: ...
    @overload
    def type(self, _: Type_T, /) -> RadiusDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        stack: Optional[bool | SchemaBase | StackOffset_T | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            scale=scale,
            stack=stack,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class RadiusValue(ValueChannelMixin, core.PositionValueDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "radius"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class Radius2(FieldChannelMixin, core.SecondaryFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "radius2"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Radius2: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Radius2: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Radius2: ...
    @overload
    def bandPosition(self, _: float, /) -> Radius2: ...
    @overload
    def bin(self, _: None, /) -> Radius2: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Radius2: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Radius2: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Radius2: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Radius2: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Radius2: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            **kwds,
        )


@with_property_setters
class Radius2Datum(DatumChannelMixin, core.DatumDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "radius2"

    @overload
    def bandPosition(self, _: float, /) -> Radius2Datum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Radius2Datum: ...
    @overload
    def type(self, _: Type_T, /) -> Radius2Datum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum, bandPosition=bandPosition, title=title, type=type, **kwds
        )


@with_property_setters
class Radius2Value(ValueChannelMixin, core.PositionValueDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "radius2"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class Row(FieldChannelMixin, core.RowColumnEncodingFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "row"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Row: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Row: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Row: ...
    @overload
    def align(self, _: LayoutAlign_T, /) -> Row: ...
    @overload
    def bandPosition(self, _: float, /) -> Row: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> Row: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Row: ...
    @overload
    def center(self, _: bool, /) -> Row: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Row: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Row: ...
    @overload
    def header(self, _: Header | None, /) -> Row: ...
    @overload
    def header(
        self,
        *,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelAnchor: Optional[SchemaBase | TitleAnchor_T] = Undefined,
        labelAngle: Optional[float] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOrient: Optional[SchemaBase | Orient_T] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labels: Optional[bool] = Undefined,
        orient: Optional[SchemaBase | Orient_T] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[SchemaBase | TitleAnchor_T] = Undefined,
        titleAngle: Optional[float] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[SchemaBase | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> Row: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | EncodingSortField
        | Sequence[DateTime | Temporal]
        | SortOrder_T
        | None,
        /,
    ) -> Row: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Row: ...
    @overload
    def spacing(self, _: float, /) -> Row: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Row: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Row: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Row: ...
    @overload
    def type(self, _: StandardType_T, /) -> Row: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        align: Optional[SchemaBase | LayoutAlign_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        center: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        header: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | SortOrder_T
            | None
        ] = Undefined,
        spacing: Optional[float] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            align=align,
            bandPosition=bandPosition,
            bin=bin,
            center=center,
            field=field,
            header=header,
            sort=sort,
            spacing=spacing,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class Shape(
    FieldChannelMixin,
    core.FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapestringnull,
):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "shape"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Shape: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Shape: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Shape: ...
    @overload
    def bandPosition(self, _: float, /) -> Shape: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> Shape: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Shape: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> Shape: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> Shape: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefstringnullExprRef], /
    ) -> Shape: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Shape: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Shape: ...
    @overload
    def legend(self, _: Legend | None, /) -> Shape: ...
    @overload
    def legend(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        clipHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columnPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columns: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        cornerRadius: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        direction: Optional[SchemaBase | Orientation_T] = Undefined,
        fillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        gradientLength: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gradientStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientThickness: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridAlign: Optional[Parameter | SchemaBase | Map | LayoutAlign_T] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[SchemaBase | LegendOrient_T] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        rowPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        strokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        symbolDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolFillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolType: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[Parameter | SchemaBase | Map | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        type: Optional[Literal["symbol", "gradient"]] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> Shape: ...
    @overload
    def scale(self, _: Scale | None, /) -> Shape: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> Shape: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> Shape: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Shape: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Shape: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Shape: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Shape: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Shape: ...
    @overload
    def type(self, _: TypeForShape_T, /) -> Shape: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | TypeForShape_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            legend=legend,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class ShapeDatum(
    DatumChannelMixin, core.FieldOrDatumDefWithConditionDatumDefstringnull
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "shape"

    @overload
    def bandPosition(self, _: float, /) -> ShapeDatum: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> ShapeDatum: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> ShapeDatum: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefstringnullExprRef], /
    ) -> ShapeDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> ShapeDatum: ...
    @overload
    def type(self, _: Type_T, /) -> ShapeDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            condition=condition,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class ShapeValue(
    ValueChannelMixin,
    core.ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapestringnull,
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "shape"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | TypeForShape_T] = Undefined,
    ) -> ShapeValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> ShapeValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | TypeForShape_T] = Undefined,
    ) -> ShapeValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> ShapeValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> ShapeValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> ShapeValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefstringnullExprRef], /
    ) -> ShapeValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class Size(FieldChannelMixin, core.FieldOrDatumDefWithConditionMarkPropFieldDefnumber):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "size"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Size: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Size: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Size: ...
    @overload
    def bandPosition(self, _: float, /) -> Size: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> Size: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Size: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> Size: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> Size: ...
    @overload
    def condition(self, _: list[core.ConditionalValueDefnumberExprRef], /) -> Size: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Size: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Size: ...
    @overload
    def legend(self, _: Legend | None, /) -> Size: ...
    @overload
    def legend(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        clipHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columnPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columns: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        cornerRadius: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        direction: Optional[SchemaBase | Orientation_T] = Undefined,
        fillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        gradientLength: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gradientStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientThickness: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridAlign: Optional[Parameter | SchemaBase | Map | LayoutAlign_T] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[SchemaBase | LegendOrient_T] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        rowPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        strokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        symbolDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolFillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolType: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[Parameter | SchemaBase | Map | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        type: Optional[Literal["symbol", "gradient"]] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> Size: ...
    @overload
    def scale(self, _: Scale | None, /) -> Size: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> Size: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> Size: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Size: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Size: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Size: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Size: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Size: ...
    @overload
    def type(self, _: StandardType_T, /) -> Size: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            legend=legend,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class SizeDatum(DatumChannelMixin, core.FieldOrDatumDefWithConditionDatumDefnumber):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "size"

    @overload
    def bandPosition(self, _: float, /) -> SizeDatum: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> SizeDatum: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> SizeDatum: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> SizeDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> SizeDatum: ...
    @overload
    def type(self, _: Type_T, /) -> SizeDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            condition=condition,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class SizeValue(
    ValueChannelMixin, core.ValueDefWithConditionMarkPropFieldOrDatumDefnumber
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "size"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> SizeValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> SizeValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> SizeValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> SizeValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> SizeValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> SizeValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> SizeValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class Stroke(
    FieldChannelMixin,
    core.FieldOrDatumDefWithConditionMarkPropFieldDefGradientstringnull,
):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "stroke"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Stroke: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Stroke: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Stroke: ...
    @overload
    def bandPosition(self, _: float, /) -> Stroke: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> Stroke: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Stroke: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> Stroke: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> Stroke: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefGradientstringnullExprRef], /
    ) -> Stroke: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Stroke: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Stroke: ...
    @overload
    def legend(self, _: Legend | None, /) -> Stroke: ...
    @overload
    def legend(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        clipHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columnPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columns: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        cornerRadius: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        direction: Optional[SchemaBase | Orientation_T] = Undefined,
        fillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        gradientLength: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gradientStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientThickness: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridAlign: Optional[Parameter | SchemaBase | Map | LayoutAlign_T] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[SchemaBase | LegendOrient_T] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        rowPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        strokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        symbolDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolFillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolType: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[Parameter | SchemaBase | Map | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        type: Optional[Literal["symbol", "gradient"]] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> Stroke: ...
    @overload
    def scale(self, _: Scale | None, /) -> Stroke: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> Stroke: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> Stroke: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Stroke: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Stroke: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Stroke: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Stroke: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Stroke: ...
    @overload
    def type(self, _: StandardType_T, /) -> Stroke: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            legend=legend,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class StrokeDatum(
    DatumChannelMixin, core.FieldOrDatumDefWithConditionDatumDefGradientstringnull
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "stroke"

    @overload
    def bandPosition(self, _: float, /) -> StrokeDatum: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> StrokeDatum: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> StrokeDatum: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefGradientstringnullExprRef], /
    ) -> StrokeDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> StrokeDatum: ...
    @overload
    def type(self, _: Type_T, /) -> StrokeDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            condition=condition,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class StrokeValue(
    ValueChannelMixin,
    core.ValueDefWithConditionMarkPropFieldOrDatumDefGradientstringnull,
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "stroke"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> StrokeValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> StrokeValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> StrokeValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> StrokeValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> StrokeValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> StrokeValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefGradientstringnullExprRef], /
    ) -> StrokeValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class StrokeDash(
    FieldChannelMixin, core.FieldOrDatumDefWithConditionMarkPropFieldDefnumberArray
):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "strokeDash"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> StrokeDash: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> StrokeDash: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> StrokeDash: ...
    @overload
    def bandPosition(self, _: float, /) -> StrokeDash: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> StrokeDash: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> StrokeDash: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
    ) -> StrokeDash: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
    ) -> StrokeDash: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberArrayExprRef], /
    ) -> StrokeDash: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> StrokeDash: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> StrokeDash: ...
    @overload
    def legend(self, _: Legend | None, /) -> StrokeDash: ...
    @overload
    def legend(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        clipHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columnPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columns: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        cornerRadius: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        direction: Optional[SchemaBase | Orientation_T] = Undefined,
        fillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        gradientLength: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gradientStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientThickness: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridAlign: Optional[Parameter | SchemaBase | Map | LayoutAlign_T] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[SchemaBase | LegendOrient_T] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        rowPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        strokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        symbolDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolFillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolType: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[Parameter | SchemaBase | Map | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        type: Optional[Literal["symbol", "gradient"]] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> StrokeDash: ...
    @overload
    def scale(self, _: Scale | None, /) -> StrokeDash: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeDash: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> StrokeDash: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> StrokeDash: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> StrokeDash: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> StrokeDash: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> StrokeDash: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> StrokeDash: ...
    @overload
    def type(self, _: StandardType_T, /) -> StrokeDash: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            legend=legend,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class StrokeDashDatum(
    DatumChannelMixin, core.FieldOrDatumDefWithConditionDatumDefnumberArray
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "strokeDash"

    @overload
    def bandPosition(self, _: float, /) -> StrokeDashDatum: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
    ) -> StrokeDashDatum: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
    ) -> StrokeDashDatum: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberArrayExprRef], /
    ) -> StrokeDashDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> StrokeDashDatum: ...
    @overload
    def type(self, _: Type_T, /) -> StrokeDashDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            condition=condition,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class StrokeDashValue(
    ValueChannelMixin, core.ValueDefWithConditionMarkPropFieldOrDatumDefnumberArray
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "strokeDash"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> StrokeDashValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> StrokeDashValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> StrokeDashValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> StrokeDashValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
    ) -> StrokeDashValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
    ) -> StrokeDashValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberArrayExprRef], /
    ) -> StrokeDashValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class StrokeOpacity(
    FieldChannelMixin, core.FieldOrDatumDefWithConditionMarkPropFieldDefnumber
):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "strokeOpacity"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> StrokeOpacity: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> StrokeOpacity: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> StrokeOpacity: ...
    @overload
    def bandPosition(self, _: float, /) -> StrokeOpacity: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> StrokeOpacity: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> StrokeOpacity: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeOpacity: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeOpacity: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> StrokeOpacity: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> StrokeOpacity: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> StrokeOpacity: ...
    @overload
    def legend(self, _: Legend | None, /) -> StrokeOpacity: ...
    @overload
    def legend(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        clipHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columnPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columns: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        cornerRadius: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        direction: Optional[SchemaBase | Orientation_T] = Undefined,
        fillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        gradientLength: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gradientStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientThickness: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridAlign: Optional[Parameter | SchemaBase | Map | LayoutAlign_T] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[SchemaBase | LegendOrient_T] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        rowPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        strokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        symbolDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolFillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolType: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[Parameter | SchemaBase | Map | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        type: Optional[Literal["symbol", "gradient"]] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> StrokeOpacity: ...
    @overload
    def scale(self, _: Scale | None, /) -> StrokeOpacity: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeOpacity: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> StrokeOpacity: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> StrokeOpacity: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> StrokeOpacity: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> StrokeOpacity: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> StrokeOpacity: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> StrokeOpacity: ...
    @overload
    def type(self, _: StandardType_T, /) -> StrokeOpacity: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            legend=legend,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class StrokeOpacityDatum(
    DatumChannelMixin, core.FieldOrDatumDefWithConditionDatumDefnumber
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "strokeOpacity"

    @overload
    def bandPosition(self, _: float, /) -> StrokeOpacityDatum: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeOpacityDatum: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeOpacityDatum: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> StrokeOpacityDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> StrokeOpacityDatum: ...
    @overload
    def type(self, _: Type_T, /) -> StrokeOpacityDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            condition=condition,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class StrokeOpacityValue(
    ValueChannelMixin, core.ValueDefWithConditionMarkPropFieldOrDatumDefnumber
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "strokeOpacity"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> StrokeOpacityValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> StrokeOpacityValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> StrokeOpacityValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> StrokeOpacityValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeOpacityValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeOpacityValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> StrokeOpacityValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class StrokeWidth(
    FieldChannelMixin, core.FieldOrDatumDefWithConditionMarkPropFieldDefnumber
):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "strokeWidth"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> StrokeWidth: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> StrokeWidth: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> StrokeWidth: ...
    @overload
    def bandPosition(self, _: float, /) -> StrokeWidth: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> StrokeWidth: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> StrokeWidth: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeWidth: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeWidth: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> StrokeWidth: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> StrokeWidth: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> StrokeWidth: ...
    @overload
    def legend(self, _: Legend | None, /) -> StrokeWidth: ...
    @overload
    def legend(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        clipHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columnPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        columns: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        cornerRadius: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        direction: Optional[SchemaBase | Orientation_T] = Undefined,
        fillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        gradientLength: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gradientStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gradientThickness: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridAlign: Optional[Parameter | SchemaBase | Map | LayoutAlign_T] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        legendY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[SchemaBase | LegendOrient_T] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        rowPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        strokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        symbolDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolFillColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolStrokeColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        symbolStrokeWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        symbolType: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOrient: Optional[Parameter | SchemaBase | Map | Orient_T] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        type: Optional[Literal["symbol", "gradient"]] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> StrokeWidth: ...
    @overload
    def scale(self, _: Scale | None, /) -> StrokeWidth: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeWidth: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> StrokeWidth: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> StrokeWidth: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> StrokeWidth: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> StrokeWidth: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> StrokeWidth: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> StrokeWidth: ...
    @overload
    def type(self, _: StandardType_T, /) -> StrokeWidth: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            legend=legend,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class StrokeWidthDatum(
    DatumChannelMixin, core.FieldOrDatumDefWithConditionDatumDefnumber
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "strokeWidth"

    @overload
    def bandPosition(self, _: float, /) -> StrokeWidthDatum: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeWidthDatum: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeWidthDatum: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> StrokeWidthDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> StrokeWidthDatum: ...
    @overload
    def type(self, _: Type_T, /) -> StrokeWidthDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            condition=condition,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class StrokeWidthValue(
    ValueChannelMixin, core.ValueDefWithConditionMarkPropFieldOrDatumDefnumber
):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "strokeWidth"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> StrokeWidthValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> StrokeWidthValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> StrokeWidthValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> StrokeWidthValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeWidthValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[float | Parameter | SchemaBase | Map] = Undefined,
    ) -> StrokeWidthValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefnumberExprRef], /
    ) -> StrokeWidthValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class Text(FieldChannelMixin, core.FieldOrDatumDefWithConditionStringFieldDefText):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "text"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Text: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Text: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Text: ...
    @overload
    def bandPosition(self, _: float, /) -> Text: ...
    @overload
    def bin(self, _: bool | Bin | Literal["binned"] | None, /) -> Text: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Text: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Sequence[str] | Map] = Undefined,
    ) -> Text: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Sequence[str] | Map] = Undefined,
    ) -> Text: ...
    @overload
    def condition(self, _: list[core.ConditionalValueDefTextExprRef], /) -> Text: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Text: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Text: ...
    @overload
    def format(self, _: str, /) -> Text: ...
    @overload
    def format(self, _: Map, /) -> Text: ...
    @overload
    def formatType(self, _: str, /) -> Text: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Text: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Text: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Text: ...
    @overload
    def type(self, _: StandardType_T, /) -> Text: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            format=format,
            formatType=formatType,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class TextDatum(DatumChannelMixin, core.FieldOrDatumDefWithConditionStringDatumDefText):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "text"

    @overload
    def bandPosition(self, _: float, /) -> TextDatum: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Sequence[str] | Map] = Undefined,
    ) -> TextDatum: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Sequence[str] | Map] = Undefined,
    ) -> TextDatum: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefTextExprRef], /
    ) -> TextDatum: ...
    @overload
    def format(self, _: str, /) -> TextDatum: ...
    @overload
    def format(self, _: Map, /) -> TextDatum: ...
    @overload
    def formatType(self, _: str, /) -> TextDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> TextDatum: ...
    @overload
    def type(self, _: Type_T, /) -> TextDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            condition=condition,
            format=format,
            formatType=formatType,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class TextValue(ValueChannelMixin, core.ValueDefWithConditionStringFieldDefText):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "text"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> TextValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> TextValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Sequence[str] | Map] = Undefined,
    ) -> TextValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Sequence[str] | Map] = Undefined,
    ) -> TextValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefTextExprRef], /
    ) -> TextValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class Theta(FieldChannelMixin, core.PositionFieldDefBase):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "theta"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Theta: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Theta: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Theta: ...
    @overload
    def bandPosition(self, _: float, /) -> Theta: ...
    @overload
    def bin(self, _: bool | Bin | Literal["binned"] | None, /) -> Theta: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Theta: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Theta: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Theta: ...
    @overload
    def scale(self, _: Scale | None, /) -> Theta: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> Theta: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> Theta: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Theta: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Theta: ...
    @overload
    def stack(self, _: bool | StackOffset_T | None, /) -> Theta: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Theta: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Theta: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Theta: ...
    @overload
    def type(self, _: StandardType_T, /) -> Theta: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        stack: Optional[bool | SchemaBase | StackOffset_T | None] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            scale=scale,
            sort=sort,
            stack=stack,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class ThetaDatum(DatumChannelMixin, core.PositionDatumDefBase):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "theta"

    @overload
    def bandPosition(self, _: float, /) -> ThetaDatum: ...
    @overload
    def scale(self, _: Scale | None, /) -> ThetaDatum: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> ThetaDatum: ...
    @overload
    def stack(self, _: bool | StackOffset_T | None, /) -> ThetaDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> ThetaDatum: ...
    @overload
    def type(self, _: Type_T, /) -> ThetaDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        stack: Optional[bool | SchemaBase | StackOffset_T | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            scale=scale,
            stack=stack,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class ThetaValue(ValueChannelMixin, core.PositionValueDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "theta"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class Theta2(FieldChannelMixin, core.SecondaryFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "theta2"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Theta2: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Theta2: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Theta2: ...
    @overload
    def bandPosition(self, _: float, /) -> Theta2: ...
    @overload
    def bin(self, _: None, /) -> Theta2: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Theta2: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Theta2: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Theta2: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Theta2: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Theta2: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            **kwds,
        )


@with_property_setters
class Theta2Datum(DatumChannelMixin, core.DatumDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "theta2"

    @overload
    def bandPosition(self, _: float, /) -> Theta2Datum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Theta2Datum: ...
    @overload
    def type(self, _: Type_T, /) -> Theta2Datum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum, bandPosition=bandPosition, title=title, type=type, **kwds
        )


@with_property_setters
class Theta2Value(ValueChannelMixin, core.PositionValueDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "theta2"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class Tooltip(FieldChannelMixin, core.StringFieldDefWithCondition):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "tooltip"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Tooltip: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> Tooltip: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> Tooltip: ...
    @overload
    def bandPosition(self, _: float, /) -> Tooltip: ...
    @overload
    def bin(self, _: bool | Bin | Literal["binned"] | None, /) -> Tooltip: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Tooltip: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map] = Undefined,
    ) -> Tooltip: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map] = Undefined,
    ) -> Tooltip: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefstringExprRef], /
    ) -> Tooltip: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Tooltip: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Tooltip: ...
    @overload
    def format(self, _: str, /) -> Tooltip: ...
    @overload
    def format(self, _: Map, /) -> Tooltip: ...
    @overload
    def formatType(self, _: str, /) -> Tooltip: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Tooltip: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Tooltip: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Tooltip: ...
    @overload
    def type(self, _: StandardType_T, /) -> Tooltip: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            format=format,
            formatType=formatType,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class TooltipValue(ValueChannelMixin, core.StringValueDefWithCondition):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "tooltip"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> TooltipValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> TooltipValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> TooltipValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> TooltipValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> TooltipValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> TooltipValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefstringnullExprRef], /
    ) -> TooltipValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class Url(FieldChannelMixin, core.StringFieldDefWithCondition):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "url"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Url: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Url: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Url: ...
    @overload
    def bandPosition(self, _: float, /) -> Url: ...
    @overload
    def bin(self, _: bool | Bin | Literal["binned"] | None, /) -> Url: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Url: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map] = Undefined,
    ) -> Url: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map] = Undefined,
    ) -> Url: ...
    @overload
    def condition(self, _: list[core.ConditionalValueDefstringExprRef], /) -> Url: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Url: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Url: ...
    @overload
    def format(self, _: str, /) -> Url: ...
    @overload
    def format(self, _: Map, /) -> Url: ...
    @overload
    def formatType(self, _: str, /) -> Url: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Url: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Url: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Url: ...
    @overload
    def type(self, _: StandardType_T, /) -> Url: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            condition=condition,
            field=field,
            format=format,
            formatType=formatType,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class UrlValue(ValueChannelMixin, core.StringValueDefWithCondition):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "url"

    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> UrlValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        test: Optional[str | SchemaBase | Map] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> UrlValue: ...
    @overload
    def condition(
        self,
        *,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        empty: Optional[bool] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
    ) -> UrlValue: ...
    @overload
    def condition(
        self,
        *,
        bandPosition: Optional[float] = Undefined,
        datum: Optional[
            Temporal | Parameter | SchemaBase | Map | PrimitiveValue_T
        ] = Undefined,
        empty: Optional[bool] = Undefined,
        legend: Optional[SchemaBase | Map | None] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
    ) -> UrlValue: ...
    @overload
    def condition(
        self,
        *,
        test: Optional[str | SchemaBase | Map] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> UrlValue: ...
    @overload
    def condition(
        self,
        *,
        empty: Optional[bool] = Undefined,
        param: Optional[str | SchemaBase] = Undefined,
        value: Optional[str | Parameter | SchemaBase | Map | None] = Undefined,
    ) -> UrlValue: ...
    @overload
    def condition(
        self, _: list[core.ConditionalValueDefstringnullExprRef], /
    ) -> UrlValue: ...

    def __init__(
        self,
        value,
        condition: Optional[SchemaBase | Sequence[SchemaBase | Map] | Map] = Undefined,
        **kwds,
    ):
        super().__init__(value=value, condition=condition, **kwds)


@with_property_setters
class X(FieldChannelMixin, core.PositionFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "x"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> X: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> X: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> X: ...
    @overload
    def axis(self, _: Axis | None, /) -> X: ...
    @overload
    def axis(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        bandPosition: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[bool] = Undefined,
        domainCap: Optional[Parameter | SchemaBase | Map | StrokeCap_T] = Undefined,
        domainColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        domainDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        domainDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        grid: Optional[bool] = Undefined,
        gridCap: Optional[Parameter | SchemaBase | Map | StrokeCap_T] = Undefined,
        gridColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gridDash: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        gridDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelAngle: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelBound: Optional[bool | float | Parameter | SchemaBase | Map] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFlush: Optional[bool | float] = Undefined,
        labelFlushOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labels: Optional[bool] = Undefined,
        maxExtent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        minExtent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[Parameter | SchemaBase | Map | AxisOrient_T] = Undefined,
        position: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        style: Optional[str | Sequence[str]] = Undefined,
        tickBand: Optional[
            Parameter | SchemaBase | Literal["center", "extent"] | Map
        ] = Undefined,
        tickCap: Optional[Parameter | SchemaBase | Map | StrokeCap_T] = Undefined,
        tickColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickDash: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        tickDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickExtra: Optional[bool] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickRound: Optional[bool] = Undefined,
        tickSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        ticks: Optional[bool] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleAngle: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        translate: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> X: ...
    @overload
    def bandPosition(self, _: float, /) -> X: ...
    @overload
    def bin(self, _: bool | Bin | Literal["binned"] | None, /) -> X: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> X: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> X: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> X: ...
    @overload
    def impute(self, _: Impute | None, /) -> X: ...
    @overload
    def impute(
        self,
        *,
        frame: Optional[Sequence[float | None]] = Undefined,
        keyvals: Optional[SchemaBase | Sequence[Any] | Map] = Undefined,
        method: Optional[SchemaBase | ImputeMethod_T] = Undefined,
        value: Optional[Any] = Undefined,
    ) -> X: ...
    @overload
    def scale(self, _: Scale | None, /) -> X: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> X: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> X: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> X: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> X: ...
    @overload
    def stack(self, _: bool | StackOffset_T | None, /) -> X: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> X: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> X: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> X: ...
    @overload
    def type(self, _: StandardType_T, /) -> X: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        axis: Optional[SchemaBase | Map | None] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        impute: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        stack: Optional[bool | SchemaBase | StackOffset_T | None] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            axis=axis,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            impute=impute,
            scale=scale,
            sort=sort,
            stack=stack,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class XDatum(DatumChannelMixin, core.PositionDatumDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "x"

    @overload
    def axis(self, _: Axis | None, /) -> XDatum: ...
    @overload
    def axis(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        bandPosition: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[bool] = Undefined,
        domainCap: Optional[Parameter | SchemaBase | Map | StrokeCap_T] = Undefined,
        domainColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        domainDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        domainDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        grid: Optional[bool] = Undefined,
        gridCap: Optional[Parameter | SchemaBase | Map | StrokeCap_T] = Undefined,
        gridColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gridDash: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        gridDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelAngle: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelBound: Optional[bool | float | Parameter | SchemaBase | Map] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFlush: Optional[bool | float] = Undefined,
        labelFlushOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labels: Optional[bool] = Undefined,
        maxExtent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        minExtent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[Parameter | SchemaBase | Map | AxisOrient_T] = Undefined,
        position: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        style: Optional[str | Sequence[str]] = Undefined,
        tickBand: Optional[
            Parameter | SchemaBase | Literal["center", "extent"] | Map
        ] = Undefined,
        tickCap: Optional[Parameter | SchemaBase | Map | StrokeCap_T] = Undefined,
        tickColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickDash: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        tickDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickExtra: Optional[bool] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickRound: Optional[bool] = Undefined,
        tickSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        ticks: Optional[bool] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleAngle: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        translate: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> XDatum: ...
    @overload
    def bandPosition(self, _: float, /) -> XDatum: ...
    @overload
    def impute(self, _: Impute | None, /) -> XDatum: ...
    @overload
    def impute(
        self,
        *,
        frame: Optional[Sequence[float | None]] = Undefined,
        keyvals: Optional[SchemaBase | Sequence[Any] | Map] = Undefined,
        method: Optional[SchemaBase | ImputeMethod_T] = Undefined,
        value: Optional[Any] = Undefined,
    ) -> XDatum: ...
    @overload
    def scale(self, _: Scale | None, /) -> XDatum: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> XDatum: ...
    @overload
    def stack(self, _: bool | StackOffset_T | None, /) -> XDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> XDatum: ...
    @overload
    def type(self, _: Type_T, /) -> XDatum: ...

    def __init__(
        self,
        datum,
        axis: Optional[SchemaBase | Map | None] = Undefined,
        bandPosition: Optional[float] = Undefined,
        impute: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        stack: Optional[bool | SchemaBase | StackOffset_T | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            axis=axis,
            bandPosition=bandPosition,
            impute=impute,
            scale=scale,
            stack=stack,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class XValue(ValueChannelMixin, core.PositionValueDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "x"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class X2(FieldChannelMixin, core.SecondaryFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "x2"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> X2: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> X2: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> X2: ...
    @overload
    def bandPosition(self, _: float, /) -> X2: ...
    @overload
    def bin(self, _: None, /) -> X2: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> X2: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> X2: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> X2: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> X2: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> X2: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            **kwds,
        )


@with_property_setters
class X2Datum(DatumChannelMixin, core.DatumDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "x2"

    @overload
    def bandPosition(self, _: float, /) -> X2Datum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> X2Datum: ...
    @overload
    def type(self, _: Type_T, /) -> X2Datum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum, bandPosition=bandPosition, title=title, type=type, **kwds
        )


@with_property_setters
class X2Value(ValueChannelMixin, core.PositionValueDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "x2"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class XError(FieldChannelMixin, core.SecondaryFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "xError"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> XError: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> XError: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> XError: ...
    @overload
    def bandPosition(self, _: float, /) -> XError: ...
    @overload
    def bin(self, _: None, /) -> XError: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> XError: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> XError: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> XError: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> XError: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> XError: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            **kwds,
        )


@with_property_setters
class XErrorValue(ValueChannelMixin, core.ValueDefnumber):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "xError"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class XError2(FieldChannelMixin, core.SecondaryFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "xError2"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> XError2: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> XError2: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> XError2: ...
    @overload
    def bandPosition(self, _: float, /) -> XError2: ...
    @overload
    def bin(self, _: None, /) -> XError2: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> XError2: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> XError2: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> XError2: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> XError2: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> XError2: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            **kwds,
        )


@with_property_setters
class XError2Value(ValueChannelMixin, core.ValueDefnumber):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "xError2"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class XOffset(FieldChannelMixin, core.ScaleFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "xOffset"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> XOffset: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> XOffset: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> XOffset: ...
    @overload
    def bandPosition(self, _: float, /) -> XOffset: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> XOffset: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> XOffset: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> XOffset: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> XOffset: ...
    @overload
    def scale(self, _: Scale | None, /) -> XOffset: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> XOffset: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> XOffset: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> XOffset: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> XOffset: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> XOffset: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> XOffset: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> XOffset: ...
    @overload
    def type(self, _: StandardType_T, /) -> XOffset: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class XOffsetDatum(DatumChannelMixin, core.ScaleDatumDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "xOffset"

    @overload
    def bandPosition(self, _: float, /) -> XOffsetDatum: ...
    @overload
    def scale(self, _: Scale | None, /) -> XOffsetDatum: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> XOffsetDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> XOffsetDatum: ...
    @overload
    def type(self, _: Type_T, /) -> XOffsetDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            scale=scale,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class XOffsetValue(ValueChannelMixin, core.ValueDefnumber):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "xOffset"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class Y(FieldChannelMixin, core.PositionFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "y"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Y: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Y: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Y: ...
    @overload
    def axis(self, _: Axis | None, /) -> Y: ...
    @overload
    def axis(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        bandPosition: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[bool] = Undefined,
        domainCap: Optional[Parameter | SchemaBase | Map | StrokeCap_T] = Undefined,
        domainColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        domainDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        domainDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        grid: Optional[bool] = Undefined,
        gridCap: Optional[Parameter | SchemaBase | Map | StrokeCap_T] = Undefined,
        gridColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gridDash: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        gridDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelAngle: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelBound: Optional[bool | float | Parameter | SchemaBase | Map] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFlush: Optional[bool | float] = Undefined,
        labelFlushOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labels: Optional[bool] = Undefined,
        maxExtent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        minExtent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[Parameter | SchemaBase | Map | AxisOrient_T] = Undefined,
        position: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        style: Optional[str | Sequence[str]] = Undefined,
        tickBand: Optional[
            Parameter | SchemaBase | Literal["center", "extent"] | Map
        ] = Undefined,
        tickCap: Optional[Parameter | SchemaBase | Map | StrokeCap_T] = Undefined,
        tickColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickDash: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        tickDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickExtra: Optional[bool] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickRound: Optional[bool] = Undefined,
        tickSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        ticks: Optional[bool] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleAngle: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        translate: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> Y: ...
    @overload
    def bandPosition(self, _: float, /) -> Y: ...
    @overload
    def bin(self, _: bool | Bin | Literal["binned"] | None, /) -> Y: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> Y: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Y: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Y: ...
    @overload
    def impute(self, _: Impute | None, /) -> Y: ...
    @overload
    def impute(
        self,
        *,
        frame: Optional[Sequence[float | None]] = Undefined,
        keyvals: Optional[SchemaBase | Sequence[Any] | Map] = Undefined,
        method: Optional[SchemaBase | ImputeMethod_T] = Undefined,
        value: Optional[Any] = Undefined,
    ) -> Y: ...
    @overload
    def scale(self, _: Scale | None, /) -> Y: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> Y: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> Y: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Y: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> Y: ...
    @overload
    def stack(self, _: bool | StackOffset_T | None, /) -> Y: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Y: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Y: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Y: ...
    @overload
    def type(self, _: StandardType_T, /) -> Y: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        axis: Optional[SchemaBase | Map | None] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Literal["binned"] | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        impute: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        stack: Optional[bool | SchemaBase | StackOffset_T | None] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            axis=axis,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            impute=impute,
            scale=scale,
            sort=sort,
            stack=stack,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class YDatum(DatumChannelMixin, core.PositionDatumDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "y"

    @overload
    def axis(self, _: Axis | None, /) -> YDatum: ...
    @overload
    def axis(
        self,
        *,
        aria: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        bandPosition: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        description: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[bool] = Undefined,
        domainCap: Optional[Parameter | SchemaBase | Map | StrokeCap_T] = Undefined,
        domainColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        domainDash: Optional[
            Parameter | SchemaBase | Sequence[float] | Map
        ] = Undefined,
        domainDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        format: Optional[str | SchemaBase | Map] = Undefined,
        formatType: Optional[str] = Undefined,
        grid: Optional[bool] = Undefined,
        gridCap: Optional[Parameter | SchemaBase | Map | StrokeCap_T] = Undefined,
        gridColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        gridDash: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        gridDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        gridWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        labelAngle: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        labelBound: Optional[bool | float | Parameter | SchemaBase | Map] = Undefined,
        labelColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        labelExpr: Optional[str] = Undefined,
        labelFlush: Optional[bool | float] = Undefined,
        labelFlushOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        labelFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        labelLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelOverlap: Optional[
            bool | Parameter | SchemaBase | Literal["greedy", "parity"] | Map
        ] = Undefined,
        labelPadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labelSeparation: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        labels: Optional[bool] = Undefined,
        maxExtent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        minExtent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        offset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        orient: Optional[Parameter | SchemaBase | Map | AxisOrient_T] = Undefined,
        position: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        style: Optional[str | Sequence[str]] = Undefined,
        tickBand: Optional[
            Parameter | SchemaBase | Literal["center", "extent"] | Map
        ] = Undefined,
        tickCap: Optional[Parameter | SchemaBase | Map | StrokeCap_T] = Undefined,
        tickColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        tickCount: Optional[
            float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        tickDash: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        tickDashOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickExtra: Optional[bool] = Undefined,
        tickMinStep: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickOffset: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickRound: Optional[bool] = Undefined,
        tickSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        tickWidth: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        ticks: Optional[bool] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        titleAlign: Optional[Parameter | SchemaBase | Map | Align_T] = Undefined,
        titleAnchor: Optional[Parameter | SchemaBase | Map | TitleAnchor_T] = Undefined,
        titleAngle: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleBaseline: Optional[
            Parameter | SchemaBase | Map | TextBaseline_T
        ] = Undefined,
        titleColor: Optional[
            str | Parameter | SchemaBase | Map | ColorName_T | None
        ] = Undefined,
        titleFont: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontSize: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleFontStyle: Optional[str | Parameter | SchemaBase | Map] = Undefined,
        titleFontWeight: Optional[
            Parameter | SchemaBase | Map | FontWeight_T
        ] = Undefined,
        titleLimit: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleLineHeight: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleOpacity: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titlePadding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleX: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        titleY: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        translate: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        values: Optional[
            Parameter
            | SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
        ] = Undefined,
        zindex: Optional[float] = Undefined,
    ) -> YDatum: ...
    @overload
    def bandPosition(self, _: float, /) -> YDatum: ...
    @overload
    def impute(self, _: Impute | None, /) -> YDatum: ...
    @overload
    def impute(
        self,
        *,
        frame: Optional[Sequence[float | None]] = Undefined,
        keyvals: Optional[SchemaBase | Sequence[Any] | Map] = Undefined,
        method: Optional[SchemaBase | ImputeMethod_T] = Undefined,
        value: Optional[Any] = Undefined,
    ) -> YDatum: ...
    @overload
    def scale(self, _: Scale | None, /) -> YDatum: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> YDatum: ...
    @overload
    def stack(self, _: bool | StackOffset_T | None, /) -> YDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> YDatum: ...
    @overload
    def type(self, _: Type_T, /) -> YDatum: ...

    def __init__(
        self,
        datum,
        axis: Optional[SchemaBase | Map | None] = Undefined,
        bandPosition: Optional[float] = Undefined,
        impute: Optional[SchemaBase | Map | None] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        stack: Optional[bool | SchemaBase | StackOffset_T | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            axis=axis,
            bandPosition=bandPosition,
            impute=impute,
            scale=scale,
            stack=stack,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class YValue(ValueChannelMixin, core.PositionValueDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "y"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class Y2(FieldChannelMixin, core.SecondaryFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "y2"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> Y2: ...
    @overload
    def aggregate(self, *, argmax: Optional[str | SchemaBase] = Undefined) -> Y2: ...
    @overload
    def aggregate(self, *, argmin: Optional[str | SchemaBase] = Undefined) -> Y2: ...
    @overload
    def bandPosition(self, _: float, /) -> Y2: ...
    @overload
    def bin(self, _: None, /) -> Y2: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> Y2: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> Y2: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> Y2: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> Y2: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Y2: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            **kwds,
        )


@with_property_setters
class Y2Datum(DatumChannelMixin, core.DatumDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "y2"

    @overload
    def bandPosition(self, _: float, /) -> Y2Datum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> Y2Datum: ...
    @overload
    def type(self, _: Type_T, /) -> Y2Datum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum, bandPosition=bandPosition, title=title, type=type, **kwds
        )


@with_property_setters
class Y2Value(ValueChannelMixin, core.PositionValueDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "y2"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class YError(FieldChannelMixin, core.SecondaryFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "yError"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> YError: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> YError: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> YError: ...
    @overload
    def bandPosition(self, _: float, /) -> YError: ...
    @overload
    def bin(self, _: None, /) -> YError: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> YError: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> YError: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> YError: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> YError: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> YError: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            **kwds,
        )


@with_property_setters
class YErrorValue(ValueChannelMixin, core.ValueDefnumber):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "yError"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class YError2(FieldChannelMixin, core.SecondaryFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "yError2"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> YError2: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> YError2: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> YError2: ...
    @overload
    def bandPosition(self, _: float, /) -> YError2: ...
    @overload
    def bin(self, _: None, /) -> YError2: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> YError2: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> YError2: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> YError2: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> YError2: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> YError2: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            timeUnit=timeUnit,
            title=title,
            **kwds,
        )


@with_property_setters
class YError2Value(ValueChannelMixin, core.ValueDefnumber):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "yError2"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


@with_property_setters
class YOffset(FieldChannelMixin, core.ScaleFieldDef):
    r

    _class_is_valid_at_instantiation = False
    _encoding_name = "yOffset"

    @overload
    def aggregate(self, _: NonArgAggregateOp_T, /) -> YOffset: ...
    @overload
    def aggregate(
        self, *, argmax: Optional[str | SchemaBase] = Undefined
    ) -> YOffset: ...
    @overload
    def aggregate(
        self, *, argmin: Optional[str | SchemaBase] = Undefined
    ) -> YOffset: ...
    @overload
    def bandPosition(self, _: float, /) -> YOffset: ...
    @overload
    def bin(self, _: bool | Bin | None, /) -> YOffset: ...
    @overload
    def bin(
        self,
        *,
        anchor: Optional[float] = Undefined,
        base: Optional[float] = Undefined,
        binned: Optional[bool] = Undefined,
        divide: Optional[Sequence[float]] = Undefined,
        extent: Optional[Parameter | SchemaBase | Sequence[float] | Map] = Undefined,
        maxbins: Optional[float] = Undefined,
        minstep: Optional[float] = Undefined,
        nice: Optional[bool] = Undefined,
        step: Optional[float] = Undefined,
        steps: Optional[Sequence[float]] = Undefined,
    ) -> YOffset: ...
    @overload
    def field(self, _: str | RepeatRef, /) -> YOffset: ...
    @overload
    def field(
        self,
        *,
        repeat: Optional[Literal["row", "column", "repeat", "layer"]] = Undefined,
    ) -> YOffset: ...
    @overload
    def scale(self, _: Scale | None, /) -> YOffset: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> YOffset: ...
    @overload
    def sort(
        self,
        _: Sequence[str]
        | Sequence[bool]
        | Sequence[float]
        | Sequence[DateTime | Temporal]
        | AllSortString_T
        | None,
        /,
    ) -> YOffset: ...
    @overload
    def sort(
        self,
        *,
        field: Optional[str | SchemaBase | Map] = Undefined,
        op: Optional[SchemaBase | NonArgAggregateOp_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> YOffset: ...
    @overload
    def sort(
        self,
        *,
        encoding: Optional[SchemaBase | SortByChannel_T] = Undefined,
        order: Optional[SchemaBase | SortOrder_T | None] = Undefined,
    ) -> YOffset: ...
    @overload
    def timeUnit(
        self,
        _: TimeUnitParams | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T,
        /,
    ) -> YOffset: ...
    @overload
    def timeUnit(
        self,
        *,
        binned: Optional[bool] = Undefined,
        maxbins: Optional[float] = Undefined,
        step: Optional[float] = Undefined,
        unit: Optional[SchemaBase | MultiTimeUnit_T | SingleTimeUnit_T] = Undefined,
        utc: Optional[bool] = Undefined,
    ) -> YOffset: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> YOffset: ...
    @overload
    def type(self, _: StandardType_T, /) -> YOffset: ...

    def __init__(
        self,
        shorthand: Optional[str | SchemaBase | Sequence[str] | Map] = Undefined,
        aggregate: Optional[SchemaBase | Map | NonArgAggregateOp_T] = Undefined,
        bandPosition: Optional[float] = Undefined,
        bin: Optional[bool | SchemaBase | Map | None] = Undefined,
        field: Optional[str | SchemaBase | Map] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        sort: Optional[
            SchemaBase
            | Sequence[str]
            | Sequence[bool]
            | Sequence[float]
            | Sequence[Temporal | SchemaBase | Map]
            | Map
            | AllSortString_T
            | None
        ] = Undefined,
        timeUnit: Optional[
            SchemaBase | Map | MultiTimeUnit_T | BinnedTimeUnit_T | SingleTimeUnit_T
        ] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | StandardType_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            shorthand=shorthand,
            aggregate=aggregate,
            bandPosition=bandPosition,
            bin=bin,
            field=field,
            scale=scale,
            sort=sort,
            timeUnit=timeUnit,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class YOffsetDatum(DatumChannelMixin, core.ScaleDatumDef):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "yOffset"

    @overload
    def bandPosition(self, _: float, /) -> YOffsetDatum: ...
    @overload
    def scale(self, _: Scale | None, /) -> YOffsetDatum: ...
    @overload
    def scale(
        self,
        *,
        align: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        base: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        bins: Optional[SchemaBase | Sequence[float] | Map] = Undefined,
        clamp: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        constant: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domain: Optional[
            Parameter
            | SchemaBase
            | Literal["unaggregated"]
            | Sequence[
                str | bool | float | Temporal | Parameter | SchemaBase | Map | None
            ]
            | Map
        ] = Undefined,
        domainMax: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainMid: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        domainMin: Optional[
            float | Temporal | Parameter | SchemaBase | Map
        ] = Undefined,
        domainRaw: Optional[Parameter | SchemaBase | Map] = Undefined,
        exponent: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        interpolate: Optional[
            Parameter | SchemaBase | Map | ScaleInterpolateEnum_T
        ] = Undefined,
        nice: Optional[
            bool | float | Parameter | SchemaBase | Map | TimeInterval_T
        ] = Undefined,
        padding: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingInner: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        paddingOuter: Optional[float | Parameter | SchemaBase | Map] = Undefined,
        range: Optional[
            SchemaBase
            | Sequence[str | float | Parameter | SchemaBase | Sequence[float] | Map]
            | Map
            | RangeEnum_T
        ] = Undefined,
        rangeMax: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        rangeMin: Optional[str | float | Parameter | SchemaBase | Map] = Undefined,
        reverse: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        round: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
        scheme: Optional[Parameter | SchemaBase | Map | ColorScheme_T] = Undefined,
        type: Optional[SchemaBase | ScaleType_T] = Undefined,
        zero: Optional[bool | Parameter | SchemaBase | Map] = Undefined,
    ) -> YOffsetDatum: ...
    @overload
    def title(self, _: str | Sequence[str] | None, /) -> YOffsetDatum: ...
    @overload
    def type(self, _: Type_T, /) -> YOffsetDatum: ...

    def __init__(
        self,
        datum,
        bandPosition: Optional[float] = Undefined,
        scale: Optional[SchemaBase | Map | None] = Undefined,
        title: Optional[str | SchemaBase | Sequence[str] | None] = Undefined,
        type: Optional[SchemaBase | Type_T] = Undefined,
        **kwds,
    ):
        super().__init__(
            datum=datum,
            bandPosition=bandPosition,
            scale=scale,
            title=title,
            type=type,
            **kwds,
        )


@with_property_setters
class YOffsetValue(ValueChannelMixin, core.ValueDefnumber):
    

    _class_is_valid_at_instantiation = False
    _encoding_name = "yOffset"

    def __init__(self, value, **kwds):
        super().__init__(value=value, **kwds)


AnyAngle: TypeAlias = Union[Angle, AngleDatum, AngleValue]
AnyColor: TypeAlias = Union[Color, ColorDatum, ColorValue]
AnyDescription: TypeAlias = Union[Description, DescriptionValue]
AnyFill: TypeAlias = Union[Fill, FillDatum, FillValue]
AnyFillOpacity: TypeAlias = Union[FillOpacity, FillOpacityDatum, FillOpacityValue]
AnyHref: TypeAlias = Union[Href, HrefValue]
AnyLatitude: TypeAlias = Union[Latitude, LatitudeDatum]
AnyLatitude2: TypeAlias = Union[Latitude2, Latitude2Datum, Latitude2Value]
AnyLongitude: TypeAlias = Union[Longitude, LongitudeDatum]
AnyLongitude2: TypeAlias = Union[Longitude2, Longitude2Datum, Longitude2Value]
AnyOpacity: TypeAlias = Union[Opacity, OpacityDatum, OpacityValue]
AnyOrder: TypeAlias = Union[Order, OrderValue]
AnyRadius: TypeAlias = Union[Radius, RadiusDatum, RadiusValue]
AnyRadius2: TypeAlias = Union[Radius2, Radius2Datum, Radius2Value]
AnyShape: TypeAlias = Union[Shape, ShapeDatum, ShapeValue]
AnySize: TypeAlias = Union[Size, SizeDatum, SizeValue]
AnyStroke: TypeAlias = Union[Stroke, StrokeDatum, StrokeValue]
AnyStrokeDash: TypeAlias = Union[StrokeDash, StrokeDashDatum, StrokeDashValue]
AnyStrokeOpacity: TypeAlias = Union[
    StrokeOpacity, StrokeOpacityDatum, StrokeOpacityValue
]
AnyStrokeWidth: TypeAlias = Union[StrokeWidth, StrokeWidthDatum, StrokeWidthValue]
AnyText: TypeAlias = Union[Text, TextDatum, TextValue]
AnyTheta: TypeAlias = Union[Theta, ThetaDatum, ThetaValue]
AnyTheta2: TypeAlias = Union[Theta2, Theta2Datum, Theta2Value]
AnyTooltip: TypeAlias = Union[Tooltip, TooltipValue]
AnyUrl: TypeAlias = Union[Url, UrlValue]
AnyX: TypeAlias = Union[X, XDatum, XValue]
AnyX2: TypeAlias = Union[X2, X2Datum, X2Value]
AnyXError: TypeAlias = Union[XError, XErrorValue]
AnyXError2: TypeAlias = Union[XError2, XError2Value]
AnyXOffset: TypeAlias = Union[XOffset, XOffsetDatum, XOffsetValue]
AnyY: TypeAlias = Union[Y, YDatum, YValue]
AnyY2: TypeAlias = Union[Y2, Y2Datum, Y2Value]
AnyYError: TypeAlias = Union[YError, YErrorValue]
AnyYError2: TypeAlias = Union[YError2, YError2Value]
AnyYOffset: TypeAlias = Union[YOffset, YOffsetDatum, YOffsetValue]

ChannelAngle: TypeAlias = Union[str, AnyAngle, "IntoCondition", Map]
ChannelColor: TypeAlias = Union[str, AnyColor, "IntoCondition", Map]
ChannelColumn: TypeAlias = Union[str, Column, "IntoCondition", Map]
ChannelDescription: TypeAlias = Union[str, AnyDescription, "IntoCondition", Map]
ChannelDetail: TypeAlias = OneOrSeq[Union[str, Detail, "IntoCondition", Map]]
ChannelFacet: TypeAlias = Union[str, Facet, "IntoCondition", Map]
ChannelFill: TypeAlias = Union[str, AnyFill, "IntoCondition", Map]
ChannelFillOpacity: TypeAlias = Union[str, AnyFillOpacity, "IntoCondition", Map]
ChannelHref: TypeAlias = Union[str, AnyHref, "IntoCondition", Map]
ChannelKey: TypeAlias = Union[str, Key, "IntoCondition", Map]
ChannelLatitude: TypeAlias = Union[str, AnyLatitude, "IntoCondition", Map]
ChannelLatitude2: TypeAlias = Union[str, AnyLatitude2, "IntoCondition", Map]
ChannelLongitude: TypeAlias = Union[str, AnyLongitude, "IntoCondition", Map]
ChannelLongitude2: TypeAlias = Union[str, AnyLongitude2, "IntoCondition", Map]
ChannelOpacity: TypeAlias = Union[str, AnyOpacity, "IntoCondition", Map]
ChannelOrder: TypeAlias = OneOrSeq[Union[str, AnyOrder, "IntoCondition", Map]]
ChannelRadius: TypeAlias = Union[str, AnyRadius, "IntoCondition", Map]
ChannelRadius2: TypeAlias = Union[str, AnyRadius2, "IntoCondition", Map]
ChannelRow: TypeAlias = Union[str, Row, "IntoCondition", Map]
ChannelShape: TypeAlias = Union[str, AnyShape, "IntoCondition", Map]
ChannelSize: TypeAlias = Union[str, AnySize, "IntoCondition", Map]
ChannelStroke: TypeAlias = Union[str, AnyStroke, "IntoCondition", Map]
ChannelStrokeDash: TypeAlias = Union[str, AnyStrokeDash, "IntoCondition", Map]
ChannelStrokeOpacity: TypeAlias = Union[str, AnyStrokeOpacity, "IntoCondition", Map]
ChannelStrokeWidth: TypeAlias = Union[str, AnyStrokeWidth, "IntoCondition", Map]
ChannelText: TypeAlias = Union[str, AnyText, "IntoCondition", Map]
ChannelTheta: TypeAlias = Union[str, AnyTheta, "IntoCondition", Map]
ChannelTheta2: TypeAlias = Union[str, AnyTheta2, "IntoCondition", Map]
ChannelTooltip: TypeAlias = OneOrSeq[Union[str, AnyTooltip, "IntoCondition", Map]]
ChannelUrl: TypeAlias = Union[str, AnyUrl, "IntoCondition", Map]
ChannelX: TypeAlias = Union[str, AnyX, "IntoCondition", Map]
ChannelX2: TypeAlias = Union[str, AnyX2, "IntoCondition", Map]
ChannelXError: TypeAlias = Union[str, AnyXError, "IntoCondition", Map]
ChannelXError2: TypeAlias = Union[str, AnyXError2, "IntoCondition", Map]
ChannelXOffset: TypeAlias = Union[str, AnyXOffset, "IntoCondition", Map]
ChannelY: TypeAlias = Union[str, AnyY, "IntoCondition", Map]
ChannelY2: TypeAlias = Union[str, AnyY2, "IntoCondition", Map]
ChannelYError: TypeAlias = Union[str, AnyYError, "IntoCondition", Map]
ChannelYError2: TypeAlias = Union[str, AnyYError2, "IntoCondition", Map]
ChannelYOffset: TypeAlias = Union[str, AnyYOffset, "IntoCondition", Map]


class _EncodingMixin:
    def encode(
        self,
        *args: Any,
        angle: Optional[str | AnyAngle | IntoCondition | Map] = Undefined,
        color: Optional[str | AnyColor | IntoCondition | Map] = Undefined,
        column: Optional[str | Column | IntoCondition | Map] = Undefined,
        description: Optional[str | AnyDescription | IntoCondition | Map] = Undefined,
        detail: Optional[OneOrSeq[str | Detail | IntoCondition | Map]] = Undefined,
        facet: Optional[str | Facet | IntoCondition | Map] = Undefined,
        fill: Optional[str | AnyFill | IntoCondition | Map] = Undefined,
        fillOpacity: Optional[str | AnyFillOpacity | IntoCondition | Map] = Undefined,
        href: Optional[str | AnyHref | IntoCondition | Map] = Undefined,
        key: Optional[str | Key | IntoCondition | Map] = Undefined,
        latitude: Optional[str | AnyLatitude | IntoCondition | Map] = Undefined,
        latitude2: Optional[str | AnyLatitude2 | IntoCondition | Map] = Undefined,
        longitude: Optional[str | AnyLongitude | IntoCondition | Map] = Undefined,
        longitude2: Optional[str | AnyLongitude2 | IntoCondition | Map] = Undefined,
        opacity: Optional[str | AnyOpacity | IntoCondition | Map] = Undefined,
        order: Optional[OneOrSeq[str | AnyOrder | IntoCondition | Map]] = Undefined,
        radius: Optional[str | AnyRadius | IntoCondition | Map] = Undefined,
        radius2: Optional[str | AnyRadius2 | IntoCondition | Map] = Undefined,
        row: Optional[str | Row | IntoCondition | Map] = Undefined,
        shape: Optional[str | AnyShape | IntoCondition | Map] = Undefined,
        size: Optional[str | AnySize | IntoCondition | Map] = Undefined,
        stroke: Optional[str | AnyStroke | IntoCondition | Map] = Undefined,
        strokeDash: Optional[str | AnyStrokeDash | IntoCondition | Map] = Undefined,
        strokeOpacity: Optional[
            str | AnyStrokeOpacity | IntoCondition | Map
        ] = Undefined,
        strokeWidth: Optional[str | AnyStrokeWidth | IntoCondition | Map] = Undefined,
        text: Optional[str | AnyText | IntoCondition | Map] = Undefined,
        theta: Optional[str | AnyTheta | IntoCondition | Map] = Undefined,
        theta2: Optional[str | AnyTheta2 | IntoCondition | Map] = Undefined,
        tooltip: Optional[OneOrSeq[str | AnyTooltip | IntoCondition | Map]] = Undefined,
        url: Optional[str | AnyUrl | IntoCondition | Map] = Undefined,
        x: Optional[str | AnyX | IntoCondition | Map] = Undefined,
        x2: Optional[str | AnyX2 | IntoCondition | Map] = Undefined,
        xError: Optional[str | AnyXError | IntoCondition | Map] = Undefined,
        xError2: Optional[str | AnyXError2 | IntoCondition | Map] = Undefined,
        xOffset: Optional[str | AnyXOffset | IntoCondition | Map] = Undefined,
        y: Optional[str | AnyY | IntoCondition | Map] = Undefined,
        y2: Optional[str | AnyY2 | IntoCondition | Map] = Undefined,
        yError: Optional[str | AnyYError | IntoCondition | Map] = Undefined,
        yError2: Optional[str | AnyYError2 | IntoCondition | Map] = Undefined,
        yOffset: Optional[str | AnyYOffset | IntoCondition | Map] = Undefined,
    ) -> Self:
        
        kwargs = {
            "angle": angle,
            "color": color,
            "column": column,
            "description": description,
            "detail": detail,
            "facet": facet,
            "fill": fill,
            "fillOpacity": fillOpacity,
            "href": href,
            "key": key,
            "latitude": latitude,
            "latitude2": latitude2,
            "longitude": longitude,
            "longitude2": longitude2,
            "opacity": opacity,
            "order": order,
            "radius": radius,
            "radius2": radius2,
            "row": row,
            "shape": shape,
            "size": size,
            "stroke": stroke,
            "strokeDash": strokeDash,
            "strokeOpacity": strokeOpacity,
            "strokeWidth": strokeWidth,
            "text": text,
            "theta": theta,
            "theta2": theta2,
            "tooltip": tooltip,
            "url": url,
            "x": x,
            "x2": x2,
            "xError": xError,
            "xError2": xError2,
            "xOffset": xOffset,
            "y": y,
            "y2": y2,
            "yError": yError,
            "yError2": yError2,
            "yOffset": yOffset,
        }
        if args:
            kwargs = {k: v for k, v in kwargs.items() if v is not Undefined}

        
        kwargs = _infer_encoding_types(args, kwargs)
        
        
        copy = self.copy(deep=["encoding"])  
        encoding = copy._get("encoding", {})
        if isinstance(encoding, core.VegaLiteSchema):
            encoding = {k: v for k, v in encoding._kwds.items() if v is not Undefined}
        
        encoding.update(kwargs)
        copy.encoding = core.FacetedEncoding(**encoding)
        return copy


class EncodeKwds(TypedDict, total=False):
    

    angle: str | AnyAngle | IntoCondition | Map
    color: str | AnyColor | IntoCondition | Map
    column: str | Column | IntoCondition | Map
    description: str | AnyDescription | IntoCondition | Map
    detail: OneOrSeq[str | Detail | IntoCondition | Map]
    facet: str | Facet | IntoCondition | Map
    fill: str | AnyFill | IntoCondition | Map
    fillOpacity: str | AnyFillOpacity | IntoCondition | Map
    href: str | AnyHref | IntoCondition | Map
    key: str | Key | IntoCondition | Map
    latitude: str | AnyLatitude | IntoCondition | Map
    latitude2: str | AnyLatitude2 | IntoCondition | Map
    longitude: str | AnyLongitude | IntoCondition | Map
    longitude2: str | AnyLongitude2 | IntoCondition | Map
    opacity: str | AnyOpacity | IntoCondition | Map
    order: OneOrSeq[str | AnyOrder | IntoCondition | Map]
    radius: str | AnyRadius | IntoCondition | Map
    radius2: str | AnyRadius2 | IntoCondition | Map
    row: str | Row | IntoCondition | Map
    shape: str | AnyShape | IntoCondition | Map
    size: str | AnySize | IntoCondition | Map
    stroke: str | AnyStroke | IntoCondition | Map
    strokeDash: str | AnyStrokeDash | IntoCondition | Map
    strokeOpacity: str | AnyStrokeOpacity | IntoCondition | Map
    strokeWidth: str | AnyStrokeWidth | IntoCondition | Map
    text: str | AnyText | IntoCondition | Map
    theta: str | AnyTheta | IntoCondition | Map
    theta2: str | AnyTheta2 | IntoCondition | Map
    tooltip: OneOrSeq[str | AnyTooltip | IntoCondition | Map]
    url: str | AnyUrl | IntoCondition | Map
    x: str | AnyX | IntoCondition | Map
    x2: str | AnyX2 | IntoCondition | Map
    xError: str | AnyXError | IntoCondition | Map
    xError2: str | AnyXError2 | IntoCondition | Map
    xOffset: str | AnyXOffset | IntoCondition | Map
    y: str | AnyY | IntoCondition | Map
    y2: str | AnyY2 | IntoCondition | Map
    yError: str | AnyYError | IntoCondition | Map
    yError2: str | AnyYError2 | IntoCondition | Map
    yOffset: str | AnyYOffset | IntoCondition | Map
