


__all__ = ["RefLog", "RefLogEntry"]

from mmap import mmap
import os.path as osp
import re
import time as _time

from git.compat import defenc
from git.objects.util import (
    Serializable,
    altz_to_utctz_str,
    parse_date,
)
from git.util import (
    Actor,
    LockedFD,
    LockFile,
    assure_directory_exists,
    bin_to_hex,
    file_contents_ro_filepath,
    to_native_path,
)



from typing import Iterator, List, Tuple, TYPE_CHECKING, Union

from git.types import PathLike

if TYPE_CHECKING:
    from io import BytesIO

    from git.config import GitConfigParser, SectionConstraint
    from git.refs import SymbolicReference




class RefLogEntry(Tuple[str, str, Actor, Tuple[int, int], str]):
    

    _re_hexsha_only = re.compile(r"^[0-9A-Fa-f]{40}$")

    __slots__ = ()

    def __repr__(self) -> str:
        
        return self.format()

    def format(self) -> str:
        
        act = self.actor
        time = self.time
        return "{} {} {} <{}> {!s} {}\t{}\n".format(
            self.oldhexsha,
            self.newhexsha,
            act.name,
            act.email,
            time[0],
            altz_to_utctz_str(time[1]),
            self.message,
        )

    @property
    def oldhexsha(self) -> str:
        
        return self[0]

    @property
    def newhexsha(self) -> str:
        
        return self[1]

    @property
    def actor(self) -> Actor:
        
        return self[2]

    @property
    def time(self) -> Tuple[int, int]:
        
        return self[3]

    @property
    def message(self) -> str:
        
        return self[4]

    @classmethod
    def new(
        cls,
        oldhexsha: str,
        newhexsha: str,
        actor: Actor,
        time: int,
        tz_offset: int,
        message: str,
    ) -> "RefLogEntry":  
        
        if not isinstance(actor, Actor):
            raise ValueError("Need actor instance, got %s" % actor)
        
        return RefLogEntry((oldhexsha, newhexsha, actor, (time, tz_offset), message))

    @classmethod
    def from_line(cls, line: bytes) -> "RefLogEntry":
        
        line_str = line.decode(defenc)
        fields = line_str.split("\t", 1)
        if len(fields) == 1:
            info, msg = fields[0], None
        elif len(fields) == 2:
            info, msg = fields
        else:
            raise ValueError("Line must have up to two TAB-separated fields. Got %s" % repr(line_str))
        

        oldhexsha = info[:40]
        newhexsha = info[41:81]
        for hexsha in (oldhexsha, newhexsha):
            if not cls._re_hexsha_only.match(hexsha):
                raise ValueError("Invalid hexsha: %r" % (hexsha,))
            
        

        email_end = info.find(">", 82)
        if email_end == -1:
            raise ValueError("Missing token: >")
        

        actor = Actor._from_string(info[82 : email_end + 1])
        time, tz_offset = parse_date(info[email_end + 2 :])  

        return RefLogEntry((oldhexsha, newhexsha, actor, (time, tz_offset), msg))


class RefLog(List[RefLogEntry], Serializable):
    R

    __slots__ = ("_path",)

    def __new__(cls, filepath: Union[PathLike, None] = None) -> "RefLog":
        inst = super().__new__(cls)
        return inst

    def __init__(self, filepath: Union[PathLike, None] = None) -> None:
        
        self._path = filepath
        if filepath is not None:
            self._read_from_file()
        

    def _read_from_file(self) -> None:
        try:
            fmap = file_contents_ro_filepath(self._path, stream=True, allow_mmap=True)
        except OSError:
            
            return
        

        try:
            self._deserialize(fmap)
        finally:
            fmap.close()
        

    

    @classmethod
    def from_file(cls, filepath: PathLike) -> "RefLog":
        
        return cls(filepath)

    @classmethod
    def path(cls, ref: "SymbolicReference") -> str:
        
        return osp.join(ref.repo.git_dir, "logs", to_native_path(ref.path))

    @classmethod
    def iter_entries(cls, stream: Union[str, "BytesIO", mmap]) -> Iterator[RefLogEntry]:
        
        new_entry = RefLogEntry.from_line
        if isinstance(stream, str):
            
            _stream = file_contents_ro_filepath(stream)
            assert isinstance(_stream, mmap)
        else:
            _stream = stream
        
        while True:
            line = _stream.readline()
            if not line:
                return
            yield new_entry(line.strip())
        

    @classmethod
    def entry_at(cls, filepath: PathLike, index: int) -> "RefLogEntry":
        
        with open(filepath, "rb") as fp:
            if index < 0:
                return RefLogEntry.from_line(fp.readlines()[index].strip())
            

            for i in range(index + 1):
                line = fp.readline()
                if not line:
                    raise IndexError(f"Index file ended at line {i + 1}, before given index was reached")
                
            

            return RefLogEntry.from_line(line.strip())
        

    def to_file(self, filepath: PathLike) -> None:
        
        lfd = LockedFD(filepath)
        assure_directory_exists(filepath, is_file=True)

        fp = lfd.open(write=True, stream=True)
        try:
            self._serialize(fp)
            lfd.commit()
        except BaseException:
            lfd.rollback()
            raise
        

    @classmethod
    def append_entry(
        cls,
        config_reader: Union[Actor, "GitConfigParser", "SectionConstraint", None],
        filepath: PathLike,
        oldbinsha: bytes,
        newbinsha: bytes,
        message: str,
        write: bool = True,
    ) -> "RefLogEntry":
        

        if len(oldbinsha) != 20 or len(newbinsha) != 20:
            raise ValueError("Shas need to be given in binary format")
        
        assure_directory_exists(filepath, is_file=True)
        first_line = message.split("\n")[0]
        if isinstance(config_reader, Actor):
            committer = config_reader  
        else:
            committer = Actor.committer(config_reader)
        entry = RefLogEntry(
            (
                bin_to_hex(oldbinsha).decode("ascii"),
                bin_to_hex(newbinsha).decode("ascii"),
                committer,
                (int(_time.time()), _time.altzone),
                first_line,
            )
        )

        if write:
            lf = LockFile(filepath)
            lf._obtain_lock_or_raise()
            fd = open(filepath, "ab")
            try:
                fd.write(entry.format().encode(defenc))
            finally:
                fd.close()
                lf._release_lock()
            
        return entry

    def write(self) -> "RefLog":
        
        if self._path is None:
            raise ValueError("Instance was not initialized with a path, use to_file(...) instead")
        
        self.to_file(self._path)
        return self

    

    

    def _serialize(self, stream: "BytesIO") -> "RefLog":
        write = stream.write

        
        for e in self:
            write(e.format().encode(defenc))
        
        return self

    def _deserialize(self, stream: "BytesIO") -> "RefLog":
        self.extend(self.iter_entries(stream))
        return self

    
