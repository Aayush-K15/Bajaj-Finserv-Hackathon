


__all__ = ["Reference"]

from git.util import IterableObj, LazyMixin

from .symbolic import SymbolicReference, T_References



from typing import Any, Callable, Iterator, TYPE_CHECKING, Type, Union

from git.types import AnyGitObject, PathLike, _T

if TYPE_CHECKING:
    from git.repo import Repo






def require_remote_ref_path(func: Callable[..., _T]) -> Callable[..., _T]:
    

    def wrapper(self: T_References, *args: Any) -> _T:
        if not self.is_remote():
            raise ValueError("ref path does not point to a remote reference: %s" % self.path)
        return func(self, *args)

    
    wrapper.__name__ = func.__name__
    return wrapper





class Reference(SymbolicReference, LazyMixin, IterableObj):
    

    __slots__ = ()

    _points_to_commits_only = False
    _resolve_ref_on_create = True
    _common_path_default = "refs"

    def __init__(self, repo: "Repo", path: PathLike, check_path: bool = True) -> None:
        
        if check_path and not str(path).startswith(self._common_path_default + "/"):
            raise ValueError(f"Cannot instantiate {self.__class__.__name__!r} from path {path}")
        self.path: str  
        super().__init__(repo, path)

    def __str__(self) -> str:
        return self.name

    

    
    def set_object(
        self,
        object: Union[AnyGitObject, "SymbolicReference", str],
        logmsg: Union[str, None] = None,
    ) -> "Reference":
        
        oldbinsha = None
        if logmsg is not None:
            head = self.repo.head
            if not head.is_detached and head.ref == self:
                oldbinsha = self.commit.binsha
            
        

        super().set_object(object, logmsg)

        if oldbinsha is not None:
            
            
            
            
            
            
            
            
            
            
            
            
            
            self.repo.head.log_append(oldbinsha, logmsg)
        

        return self

    

    @property
    def name(self) -> str:
        
        
        
        tokens = self.path.split("/")
        if len(tokens) < 3:
            return self.path  
        return "/".join(tokens[2:])

    @classmethod
    def iter_items(
        cls: Type[T_References],
        repo: "Repo",
        common_path: Union[PathLike, None] = None,
        *args: Any,
        **kwargs: Any,
    ) -> Iterator[T_References]:
        
        return cls._iter_items(repo, common_path)

    

    

    @property
    @require_remote_ref_path
    def remote_name(self) -> str:
        
        tokens = self.path.split("/")
        
        return tokens[2]

    @property
    @require_remote_ref_path
    def remote_head(self) -> str:
        
        tokens = self.path.split("/")
        return "/".join(tokens[3:])

    
