




__all__ = ["HEAD", "Head"]

from git.config import GitConfigParser, SectionConstraint
from git.exc import GitCommandError
from git.util import join_path

from .reference import Reference
from .symbolic import SymbolicReference



from typing import Any, Sequence, TYPE_CHECKING, Union

from git.types import Commit_ish, PathLike

if TYPE_CHECKING:
    from git.objects import Commit
    from git.refs import RemoteReference
    from git.repo import Repo




def strip_quotes(string: str) -> str:
    if string.startswith('"') and string.endswith('"'):
        return string[1:-1]
    return string


class HEAD(SymbolicReference):
    

    _HEAD_NAME = "HEAD"
    _ORIG_HEAD_NAME = "ORIG_HEAD"

    __slots__ = ()

    
    commit: "Commit"

    def __init__(self, repo: "Repo", path: PathLike = _HEAD_NAME) -> None:
        if path != self._HEAD_NAME:
            raise ValueError("HEAD instance must point to %r, got %r" % (self._HEAD_NAME, path))
        super().__init__(repo, path)

    def orig_head(self) -> SymbolicReference:
        
        return SymbolicReference(self.repo, self._ORIG_HEAD_NAME)

    def reset(
        self,
        commit: Union[Commit_ish, SymbolicReference, str] = "HEAD",
        index: bool = True,
        working_tree: bool = False,
        paths: Union[PathLike, Sequence[PathLike], None] = None,
        **kwargs: Any,
    ) -> "HEAD":
        
        mode: Union[str, None]
        mode = "--soft"
        if index:
            mode = "--mixed"

            
            
            if paths:
                mode = None
            
        

        if working_tree:
            mode = "--hard"
            if not index:
                raise ValueError("Cannot reset the working tree if the index is not reset as well")

        

        try:
            self.repo.git.reset(mode, commit, "--", paths, **kwargs)
        except GitCommandError as e:
            
            
            if e.status != 1:
                raise
        

        return self


class Head(Reference):
    

    _common_path_default = "refs/heads"
    k_config_remote = "remote"
    k_config_remote_ref = "merge"  

    @classmethod
    def delete(cls, repo: "Repo", *heads: "Union[Head, str]", force: bool = False, **kwargs: Any) -> None:
        
        flag = "-d"
        if force:
            flag = "-D"
        repo.git.branch(flag, *heads)

    def set_tracking_branch(self, remote_reference: Union["RemoteReference", None]) -> "Head":
        
        from .remote import RemoteReference

        if remote_reference is not None and not isinstance(remote_reference, RemoteReference):
            raise ValueError("Incorrect parameter type: %r" % remote_reference)
        

        with self.config_writer() as writer:
            if remote_reference is None:
                writer.remove_option(self.k_config_remote)
                writer.remove_option(self.k_config_remote_ref)
                if len(writer.options()) == 0:
                    writer.remove_section()
            else:
                writer.set_value(self.k_config_remote, remote_reference.remote_name)
                writer.set_value(
                    self.k_config_remote_ref,
                    Head.to_full_path(remote_reference.remote_head),
                )

        return self

    def tracking_branch(self) -> Union["RemoteReference", None]:
        
        from .remote import RemoteReference

        reader = self.config_reader()
        if reader.has_option(self.k_config_remote) and reader.has_option(self.k_config_remote_ref):
            ref = Head(
                self.repo,
                Head.to_full_path(strip_quotes(reader.get_value(self.k_config_remote_ref))),
            )
            remote_refpath = RemoteReference.to_full_path(join_path(reader.get_value(self.k_config_remote), ref.name))
            return RemoteReference(self.repo, remote_refpath)
        

        
        return None

    def rename(self, new_path: PathLike, force: bool = False) -> "Head":
        
        flag = "-m"
        if force:
            flag = "-M"

        self.repo.git.branch(flag, self, new_path)
        self.path = "%s/%s" % (self._common_path_default, new_path)
        return self

    def checkout(self, force: bool = False, **kwargs: Any) -> Union["HEAD", "Head"]:
        
        kwargs["f"] = force
        if kwargs["f"] is False:
            kwargs.pop("f")

        self.repo.git.checkout(self, **kwargs)
        if self.repo.head.is_detached:
            return self.repo.head
        else:
            return self.repo.active_branch

    
    def _config_parser(self, read_only: bool) -> SectionConstraint[GitConfigParser]:
        if read_only:
            parser = self.repo.config_reader()
        else:
            parser = self.repo.config_writer()
        

        return SectionConstraint(parser, 'branch "%s"' % self.name)

    def config_reader(self) -> SectionConstraint[GitConfigParser]:
        
        return self._config_parser(read_only=True)

    def config_writer(self) -> SectionConstraint[GitConfigParser]:
        
        return self._config_parser(read_only=False)

    
