


import os
import sys
from typing import (
    Any,
    Callable,
    Dict,
    List,
    NoReturn,
    Optional,
    Sequence as Sequence,
    Tuple,
    TYPE_CHECKING,
    Type,
    TypeVar,
    Union,
)
import warnings

if sys.version_info >= (3, 8):
    from typing import (
        Literal,
        Protocol,
        SupportsIndex as SupportsIndex,
        TypedDict,
        runtime_checkable,
    )
else:
    from typing_extensions import (
        Literal,
        Protocol,
        SupportsIndex as SupportsIndex,
        TypedDict,
        runtime_checkable,
    )

if TYPE_CHECKING:
    from git.objects import Commit, Tree, TagObject, Blob
    from git.repo import Repo

PathLike = Union[str, "os.PathLike[str]"]


TBD = Any


_T = TypeVar("_T")


AnyGitObject = Union["Commit", "Tree", "TagObject", "Blob"]


Tree_ish = Union["Commit", "Tree", "TagObject"]


Commit_ish = Union["Commit", "TagObject"]


GitObjectTypeString = Literal["commit", "tag", "blob", "tree"]


Lit_commit_ish: Type[Literal["commit", "tag"]]



def _getattr(name: str) -> Any:
    if name != "Lit_commit_ish":
        raise AttributeError(f"module {__name__!r} has no attribute {name!r}")

    warnings.warn(
        "Lit_commit_ish is deprecated. It is currently defined as "
        '`Literal["commit", "tag"]`, which should be used in its place if desired. It '
        'had previously been defined as `Literal["commit", "tag", "blob", "tree"]`, '
        "covering all four git object type strings including those that are never "
        "commit-ish. For that, use the GitObjectTypeString type instead.",
        DeprecationWarning,
        stacklevel=2,
    )
    return Literal["commit", "tag"]


if not TYPE_CHECKING:  
    __getattr__ = _getattr


def __dir__() -> List[str]:
    return [*globals(), "Lit_commit_ish"]




Lit_config_levels = Literal["system", "global", "user", "repository"]


ConfigLevels_Tup = Tuple[Literal["system"], Literal["user"], Literal["global"], Literal["repository"]]




CallableProgress = Optional[Callable[[int, Union[str, float], Union[str, float, None], str], None]]





def assert_never(inp: NoReturn, raise_error: bool = True, exc: Union[Exception, None] = None) -> None:
    
    if raise_error:
        if exc is None:
            raise ValueError(f"An unhandled literal ({inp!r}) in an if/else chain was found")
        else:
            raise exc


class Files_TD(TypedDict):
    

    insertions: int
    deletions: int
    lines: int
    change_type: str


class Total_TD(TypedDict):
    

    insertions: int
    deletions: int
    lines: int
    files: int


class HSH_TD(TypedDict):
    

    total: Total_TD
    files: Dict[PathLike, Files_TD]


@runtime_checkable
class Has_Repo(Protocol):
    

    repo: "Repo"


@runtime_checkable
class Has_id_attribute(Protocol):
    

    _id_attribute_: str
