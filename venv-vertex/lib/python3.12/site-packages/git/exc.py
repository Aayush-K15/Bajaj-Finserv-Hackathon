






__all__ = [
    
    "AmbiguousObjectName",
    "BadName",
    "BadObject",
    "BadObjectType",
    "InvalidDBRoot",
    "ODBError",
    "ParseError",
    "UnsupportedOperation",
    
    "GitError",
    "InvalidGitRepositoryError",
    "WorkTreeRepositoryUnsupported",
    "NoSuchPathError",
    "UnsafeProtocolError",
    "UnsafeOptionError",
    "CommandError",
    "GitCommandNotFound",
    "GitCommandError",
    "CheckoutError",
    "CacheError",
    "UnmergedEntriesError",
    "HookExecutionError",
    "RepositoryDirtyError",
]

from gitdb.exc import (
    AmbiguousObjectName,
    BadName,
    BadObject,
    BadObjectType,
    InvalidDBRoot,
    ODBError,
    ParseError,
    UnsupportedOperation,
)

from git.compat import safe_decode
from git.util import remove_password_if_present



from typing import List, Sequence, Tuple, TYPE_CHECKING, Union

from git.types import PathLike

if TYPE_CHECKING:
    from git.repo.base import Repo




class GitError(Exception):
    


class InvalidGitRepositoryError(GitError):
    


class WorkTreeRepositoryUnsupported(InvalidGitRepositoryError):
    


class NoSuchPathError(GitError, OSError):
    


class UnsafeProtocolError(GitError):
    


class UnsafeOptionError(GitError):
    


class CommandError(GitError):
    

    _msg = "Cmd('%s') failed%s"
    

    def __init__(
        self,
        command: Union[List[str], Tuple[str, ...], str],
        status: Union[str, int, None, Exception] = None,
        stderr: Union[bytes, str, None] = None,
        stdout: Union[bytes, str, None] = None,
    ) -> None:
        if not isinstance(command, (tuple, list)):
            command = command.split()
        self.command = remove_password_if_present(command)
        self.status = status
        if status:
            if isinstance(status, Exception):
                status = "%s('%s')" % (type(status).__name__, safe_decode(str(status)))
            else:
                try:
                    status = "exit code(%s)" % int(status)
                except (ValueError, TypeError):
                    s = safe_decode(str(status))
                    status = "'%s'" % s if isinstance(status, str) else s

        self._cmd = safe_decode(self.command[0])
        self._cmdline = " ".join(safe_decode(i) for i in self.command)
        self._cause = status and " due to: %s" % status or "!"
        stdout_decode = safe_decode(stdout)
        stderr_decode = safe_decode(stderr)
        self.stdout = stdout_decode and "\n  stdout: '%s'" % stdout_decode or ""
        self.stderr = stderr_decode and "\n  stderr: '%s'" % stderr_decode or ""

    def __str__(self) -> str:
        return (self._msg + "\n  cmdline: %s%s%s") % (
            self._cmd,
            self._cause,
            self._cmdline,
            self.stdout,
            self.stderr,
        )


class GitCommandNotFound(CommandError):
    

    def __init__(self, command: Union[List[str], Tuple[str], str], cause: Union[str, Exception]) -> None:
        super().__init__(command, cause)
        self._msg = "Cmd('%s') not found%s"


class GitCommandError(CommandError):
    

    def __init__(
        self,
        command: Union[List[str], Tuple[str, ...], str],
        status: Union[str, int, None, Exception] = None,
        stderr: Union[bytes, str, None] = None,
        stdout: Union[bytes, str, None] = None,
    ) -> None:
        super().__init__(command, status, stderr, stdout)


class CheckoutError(GitError):
    

    def __init__(
        self,
        message: str,
        failed_files: Sequence[PathLike],
        valid_files: Sequence[PathLike],
        failed_reasons: List[str],
    ) -> None:
        Exception.__init__(self, message)
        self.failed_files = failed_files
        self.failed_reasons = failed_reasons
        self.valid_files = valid_files

    def __str__(self) -> str:
        return Exception.__str__(self) + ":%s" % self.failed_files


class CacheError(GitError):
    


class UnmergedEntriesError(CacheError):
    


class HookExecutionError(CommandError):
    

    def __init__(
        self,
        command: Union[List[str], Tuple[str, ...], str],
        status: Union[str, int, None, Exception],
        stderr: Union[bytes, str, None] = None,
        stdout: Union[bytes, str, None] = None,
    ) -> None:
        super().__init__(command, status, stderr, stdout)
        self._msg = "Hook('%s') failed%s"


class RepositoryDirtyError(GitError):
    

    def __init__(self, repo: "Repo", message: str) -> None:
        self.repo = repo
        self.message = message

    def __str__(self) -> str:
        return "Operation cannot be performed on %r: %s" % (self.repo, self.message)
