






__all__ = ["RemoteProgress", "PushInfo", "FetchInfo", "Remote"]

import contextlib
import logging
import re

from git.cmd import Git, handle_process_output
from git.compat import defenc, force_text
from git.config import GitConfigParser, SectionConstraint, cp
from git.exc import GitCommandError
from git.refs import Head, Reference, RemoteReference, SymbolicReference, TagReference
from git.util import (
    CallableRemoteProgress,
    IterableList,
    IterableObj,
    LazyMixin,
    RemoteProgress,
    join_path,
)



from typing import (
    Any,
    Callable,
    Dict,
    Iterator,
    List,
    NoReturn,
    Optional,
    Sequence,
    TYPE_CHECKING,
    Type,
    Union,
    cast,
    overload,
)

from git.types import AnyGitObject, Literal, PathLike

if TYPE_CHECKING:
    from git.objects.commit import Commit
    from git.objects.submodule.base import UpdateProgress
    from git.repo.base import Repo

flagKeyLiteral = Literal[" ", "!", "+", "-", "*", "=", "t", "?"]



_logger = logging.getLogger(__name__)




def add_progress(
    kwargs: Any,
    git: Git,
    progress: Union[RemoteProgress, "UpdateProgress", Callable[..., RemoteProgress], None],
) -> Any:
    
    if progress is not None:
        v = git.version_info[:2]
        if v >= (1, 7):
            kwargs["progress"] = True
        
    
    return kwargs





@overload
def to_progress_instance(progress: None) -> RemoteProgress: ...


@overload
def to_progress_instance(progress: Callable[..., Any]) -> CallableRemoteProgress: ...


@overload
def to_progress_instance(progress: RemoteProgress) -> RemoteProgress: ...


def to_progress_instance(
    progress: Union[Callable[..., Any], RemoteProgress, None],
) -> Union[RemoteProgress, CallableRemoteProgress]:
    
    
    if callable(progress):
        return CallableRemoteProgress(progress)

    
    elif progress is None:
        return RemoteProgress()

    
    return progress


class PushInfo(IterableObj):
    

    __slots__ = (
        "local_ref",
        "remote_ref_string",
        "flags",
        "_old_commit_sha",
        "_remote",
        "summary",
    )

    _id_attribute_ = "pushinfo"

    (
        NEW_TAG,
        NEW_HEAD,
        NO_MATCH,
        REJECTED,
        REMOTE_REJECTED,
        REMOTE_FAILURE,
        DELETED,
        FORCED_UPDATE,
        FAST_FORWARD,
        UP_TO_DATE,
        ERROR,
    ) = [1 << x for x in range(11)]

    _flag_map = {
        "X": NO_MATCH,
        "-": DELETED,
        "*": 0,
        "+": FORCED_UPDATE,
        " ": FAST_FORWARD,
        "=": UP_TO_DATE,
        "!": ERROR,
    }

    def __init__(
        self,
        flags: int,
        local_ref: Union[SymbolicReference, None],
        remote_ref_string: str,
        remote: "Remote",
        old_commit: Optional[str] = None,
        summary: str = "",
    ) -> None:
        
        self.flags = flags
        self.local_ref = local_ref
        self.remote_ref_string = remote_ref_string
        self._remote = remote
        self._old_commit_sha = old_commit
        self.summary = summary

    @property
    def old_commit(self) -> Union["Commit", None]:
        return self._old_commit_sha and self._remote.repo.commit(self._old_commit_sha) or None

    @property
    def remote_ref(self) -> Union[RemoteReference, TagReference]:
        
        
        if self.remote_ref_string.startswith("refs/tags"):
            return TagReference(self._remote.repo, self.remote_ref_string)
        elif self.remote_ref_string.startswith("refs/heads"):
            remote_ref = Reference(self._remote.repo, self.remote_ref_string)
            return RemoteReference(
                self._remote.repo,
                "refs/remotes/%s/%s" % (str(self._remote), remote_ref.name),
            )
        else:
            raise ValueError("Could not handle remote ref: %r" % self.remote_ref_string)
        

    @classmethod
    def _from_line(cls, remote: "Remote", line: str) -> "PushInfo":
        
        control_character, from_to, summary = line.split("\t", 3)
        flags = 0

        
        try:
            flags |= cls._flag_map[control_character]
        except KeyError as e:
            raise ValueError("Control character %r unknown as parsed from line %r" % (control_character, line)) from e
        

        
        from_ref_string, to_ref_string = from_to.split(":")
        if flags & cls.DELETED:
            from_ref: Union[SymbolicReference, None] = None
        else:
            if from_ref_string == "(delete)":
                from_ref = None
            else:
                from_ref = Reference.from_path(remote.repo, from_ref_string)

        
        old_commit: Optional[str] = None
        if summary.startswith("["):
            if "[rejected]" in summary:
                flags |= cls.REJECTED
            elif "[remote rejected]" in summary:
                flags |= cls.REMOTE_REJECTED
            elif "[remote failure]" in summary:
                flags |= cls.REMOTE_FAILURE
            elif "[no match]" in summary:
                flags |= cls.ERROR
            elif "[new tag]" in summary:
                flags |= cls.NEW_TAG
            elif "[new branch]" in summary:
                flags |= cls.NEW_HEAD
            
        else:
            
            
            split_token = "..."
            if control_character == " ":
                split_token = ".."
            old_sha, _new_sha = summary.split(" ")[0].split(split_token)
            
            old_commit = old_sha
        

        return PushInfo(flags, from_ref, to_ref_string, remote, old_commit, summary)

    @classmethod
    def iter_items(cls, repo: "Repo", *args: Any, **kwargs: Any) -> NoReturn:  
        raise NotImplementedError


class PushInfoList(IterableList[PushInfo]):
    

    def __new__(cls) -> "PushInfoList":
        return cast(PushInfoList, IterableList.__new__(cls, "push_infos"))

    def __init__(self) -> None:
        super().__init__("push_infos")
        self.error: Optional[Exception] = None

    def raise_if_error(self) -> None:
        
        if self.error:
            raise self.error


class FetchInfo(IterableObj):
    

    __slots__ = ("ref", "old_commit", "flags", "note", "remote_ref_path")

    _id_attribute_ = "fetchinfo"

    (
        NEW_TAG,
        NEW_HEAD,
        HEAD_UPTODATE,
        TAG_UPDATE,
        REJECTED,
        FORCED_UPDATE,
        FAST_FORWARD,
        ERROR,
    ) = [1 << x for x in range(8)]

    _re_fetch_result = re.compile(r"^ *(?:.{0,3})(.) (\[[\w \.$@]+\]|[\w\.$@]+) +(.+) -> ([^ ]+)(    \(.*\)?$)?")

    _flag_map: Dict[flagKeyLiteral, int] = {
        "!": ERROR,
        "+": FORCED_UPDATE,
        "*": 0,
        "=": HEAD_UPTODATE,
        " ": FAST_FORWARD,
        "-": TAG_UPDATE,
    }

    @classmethod
    def refresh(cls) -> Literal[True]:
        
        
        with contextlib.suppress(KeyError):
            del cls._flag_map["t"]
        with contextlib.suppress(KeyError):
            del cls._flag_map["-"]

        
        if Git().version_info[:2] >= (2, 10):
            cls._flag_map["t"] = cls.TAG_UPDATE
        else:
            cls._flag_map["-"] = cls.TAG_UPDATE

        return True

    def __init__(
        self,
        ref: SymbolicReference,
        flags: int,
        note: str = "",
        old_commit: Union[AnyGitObject, None] = None,
        remote_ref_path: Optional[PathLike] = None,
    ) -> None:
        
        self.ref = ref
        self.flags = flags
        self.note = note
        self.old_commit = old_commit
        self.remote_ref_path = remote_ref_path

    def __str__(self) -> str:
        return self.name

    @property
    def name(self) -> str:
        
        return self.ref.name

    @property
    def commit(self) -> "Commit":
        
        return self.ref.commit

    @classmethod
    def _from_line(cls, repo: "Repo", line: str, fetch_line: str) -> "FetchInfo":
        
        match = cls._re_fetch_result.match(line)
        if match is None:
            raise ValueError("Failed to parse line: %r" % line)

        
        remote_local_ref_str: str
        (
            control_character,
            operation,
            local_remote_ref,
            remote_local_ref_str,
            note,
        ) = match.groups()
        control_character = cast(flagKeyLiteral, control_character)
        try:
            _new_hex_sha, _fetch_operation, fetch_note = fetch_line.split("\t")
            ref_type_name, fetch_note = fetch_note.split(" ", 1)
        except ValueError as e:  
            raise ValueError("Failed to parse FETCH_HEAD line: %r" % fetch_line) from e

        
        flags = 0
        try:
            flags |= cls._flag_map[control_character]
        except KeyError as e:
            raise ValueError("Control character %r unknown as parsed from line %r" % (control_character, line)) from e
        

        
        
        old_commit: Union[AnyGitObject, None] = None
        is_tag_operation = False
        if "rejected" in operation:
            flags |= cls.REJECTED
        if "new tag" in operation:
            flags |= cls.NEW_TAG
            is_tag_operation = True
        if "tag update" in operation:
            flags |= cls.TAG_UPDATE
            is_tag_operation = True
        if "new branch" in operation:
            flags |= cls.NEW_HEAD
        if "..." in operation or ".." in operation:
            split_token = "..."
            if control_character == " ":
                split_token = split_token[:-1]
            old_commit = repo.rev_parse(operation.split(split_token)[0])
        

        
        
        
        
        ref_type: Optional[Type[SymbolicReference]] = None
        if remote_local_ref_str == "FETCH_HEAD":
            ref_type = SymbolicReference
        elif ref_type_name == "tag" or is_tag_operation:
            
            
            
            ref_type = TagReference
        elif ref_type_name in ("remote-tracking", "branch"):
            
            
            
            ref_type = RemoteReference
        elif "/" in ref_type_name:
            
            
            
            ref_type = Head
        else:
            raise TypeError("Cannot handle reference type: %r" % ref_type_name)
        

        
        if ref_type is SymbolicReference:
            remote_local_ref = ref_type(repo, "FETCH_HEAD")
        else:
            
            
            
            
            
            
            ref_path: Optional[PathLike] = None
            remote_local_ref_str = remote_local_ref_str.strip()

            if remote_local_ref_str.startswith(Reference._common_path_default + "/"):
                
                
                
                ref_path = remote_local_ref_str
                if ref_type is not TagReference and not remote_local_ref_str.startswith(
                    RemoteReference._common_path_default + "/"
                ):
                    ref_type = Reference
                
            elif ref_type is TagReference and "tags/" in remote_local_ref_str:
                
                ref_path = join_path(RemoteReference._common_path_default, remote_local_ref_str)
            else:
                ref_path = join_path(ref_type._common_path_default, remote_local_ref_str)
            

            
            
            remote_local_ref = ref_type(repo, ref_path, check_path=False)
        

        note = (note and note.strip()) or ""

        return cls(remote_local_ref, flags, note, old_commit, local_remote_ref)

    @classmethod
    def iter_items(cls, repo: "Repo", *args: Any, **kwargs: Any) -> NoReturn:  
        raise NotImplementedError


class Remote(LazyMixin, IterableObj):
    

    __slots__ = ("repo", "name", "_config_reader")

    _id_attribute_ = "name"

    unsafe_git_fetch_options = [
        
        
        "--upload-pack",
    ]
    unsafe_git_pull_options = [
        
        
        "--upload-pack"
    ]
    unsafe_git_push_options = [
        
        
        "--receive-pack",
        "--exec",
    ]

    url: str  
    

    def __init__(self, repo: "Repo", name: str) -> None:
        
        self.repo = repo
        self.name = name

    def __getattr__(self, attr: str) -> Any:
        
        if attr == "_config_reader":
            return super().__getattr__(attr)

        
        
        try:
            return self._config_reader.get(attr)
        except cp.NoOptionError:
            return super().__getattr__(attr)
        

    def _config_section_name(self) -> str:
        return 'remote "%s"' % self.name

    def _set_cache_(self, attr: str) -> None:
        if attr == "_config_reader":
            
            
            self._config_reader = SectionConstraint(
                self.repo.config_reader("repository"),
                self._config_section_name(),
            )
        else:
            super()._set_cache_(attr)

    def __str__(self) -> str:
        return self.name

    def __repr__(self) -> str:
        return '<git.%s "%s">' % (self.__class__.__name__, self.name)

    def __eq__(self, other: object) -> bool:
        return isinstance(other, type(self)) and self.name == other.name

    def __ne__(self, other: object) -> bool:
        return not (self == other)

    def __hash__(self) -> int:
        return hash(self.name)

    def exists(self) -> bool:
        
        try:
            self.config_reader.get("url")
            return True
        except cp.NoOptionError:
            
            return True
        except cp.NoSectionError:
            return False

    @classmethod
    def iter_items(cls, repo: "Repo", *args: Any, **kwargs: Any) -> Iterator["Remote"]:
        
        for section in repo.config_reader("repository").sections():
            if not section.startswith("remote "):
                continue
            lbound = section.find('"')
            rbound = section.rfind('"')
            if lbound == -1 or rbound == -1:
                raise ValueError("Remote-Section has invalid format: %r" % section)
            yield Remote(repo, section[lbound + 1 : rbound])
        

    def set_url(
        self, new_url: str, old_url: Optional[str] = None, allow_unsafe_protocols: bool = False, **kwargs: Any
    ) -> "Remote":
        
        if not allow_unsafe_protocols:
            Git.check_unsafe_protocols(new_url)
        scmd = "set-url"
        kwargs["insert_kwargs_after"] = scmd
        if old_url:
            self.repo.git.remote(scmd, "--", self.name, new_url, old_url, **kwargs)
        else:
            self.repo.git.remote(scmd, "--", self.name, new_url, **kwargs)
        return self

    def add_url(self, url: str, allow_unsafe_protocols: bool = False, **kwargs: Any) -> "Remote":
        
        return self.set_url(url, add=True, allow_unsafe_protocols=allow_unsafe_protocols)

    def delete_url(self, url: str, **kwargs: Any) -> "Remote":
        
        return self.set_url(url, delete=True)

    @property
    def urls(self) -> Iterator[str]:
        
        try:
            remote_details = self.repo.git.remote("get-url", "--all", self.name)
            assert isinstance(remote_details, str)
            for line in remote_details.split("\n"):
                yield line
        except GitCommandError as ex:
            
            
            
            
            
            if "Unknown subcommand: get-url" in str(ex):
                try:
                    remote_details = self.repo.git.remote("show", self.name)
                    assert isinstance(remote_details, str)
                    for line in remote_details.split("\n"):
                        if "  Push  URL:" in line:
                            yield line.split(": ")[-1]
                except GitCommandError as _ex:
                    if any(msg in str(_ex) for msg in ["correct access rights", "cannot run ssh"]):
                        
                        remote_details = self.repo.git.config("--get-all", "remote.%s.url" % self.name)
                        assert isinstance(remote_details, str)
                        for line in remote_details.split("\n"):
                            yield line
                    else:
                        raise _ex
            else:
                raise ex

    @property
    def refs(self) -> IterableList[RemoteReference]:
        
        out_refs: IterableList[RemoteReference] = IterableList(RemoteReference._id_attribute_, "%s/" % self.name)
        out_refs.extend(RemoteReference.list_items(self.repo, remote=self.name))
        return out_refs

    @property
    def stale_refs(self) -> IterableList[Reference]:
        
        out_refs: IterableList[Reference] = IterableList(RemoteReference._id_attribute_, "%s/" % self.name)
        for line in self.repo.git.remote("prune", "--dry-run", self).splitlines()[2:]:
            
            
            token = " * [would prune] "
            if not line.startswith(token):
                continue
            ref_name = line.replace(token, "")
            
            if ref_name.startswith(Reference._common_path_default + "/"):
                out_refs.append(Reference.from_path(self.repo, ref_name))
            else:
                fqhn = "%s/%s" % (RemoteReference._common_path_default, ref_name)
                out_refs.append(RemoteReference(self.repo, fqhn))
            
        
        return out_refs

    @classmethod
    def create(cls, repo: "Repo", name: str, url: str, allow_unsafe_protocols: bool = False, **kwargs: Any) -> "Remote":
        
        scmd = "add"
        kwargs["insert_kwargs_after"] = scmd
        url = Git.polish_url(url)
        if not allow_unsafe_protocols:
            Git.check_unsafe_protocols(url)
        repo.git.remote(scmd, "--", name, url, **kwargs)
        return cls(repo, name)

    
    @classmethod
    def add(cls, repo: "Repo", name: str, url: str, **kwargs: Any) -> "Remote":
        return cls.create(repo, name, url, **kwargs)

    @classmethod
    def remove(cls, repo: "Repo", name: str) -> str:
        
        repo.git.remote("rm", name)
        if isinstance(name, cls):
            name._clear_cache()
        return name

    @classmethod
    def rm(cls, repo: "Repo", name: str) -> str:
        
        return cls.remove(repo, name)

    def rename(self, new_name: str) -> "Remote":
        
        if self.name == new_name:
            return self

        self.repo.git.remote("rename", self.name, new_name)
        self.name = new_name
        self._clear_cache()

        return self

    def update(self, **kwargs: Any) -> "Remote":
        
        scmd = "update"
        kwargs["insert_kwargs_after"] = scmd
        self.repo.git.remote(scmd, self.name, **kwargs)
        return self

    def _get_fetch_info_from_stderr(
        self,
        proc: "Git.AutoInterrupt",
        progress: Union[Callable[..., Any], RemoteProgress, None],
        kill_after_timeout: Union[None, float] = None,
    ) -> IterableList["FetchInfo"]:
        progress = to_progress_instance(progress)

        
        output: IterableList["FetchInfo"] = IterableList("name")

        
        
        
        fetch_info_lines = []
        
        
        cmds = set(FetchInfo._flag_map.keys())

        progress_handler = progress.new_message_handler()
        handle_process_output(
            proc,
            None,
            progress_handler,
            finalizer=None,
            decode_streams=False,
            kill_after_timeout=kill_after_timeout,
        )

        stderr_text = progress.error_lines and "\n".join(progress.error_lines) or ""
        proc.wait(stderr=stderr_text)
        if stderr_text:
            _logger.warning("Error lines received while fetching: %s", stderr_text)

        for line in progress.other_lines:
            line = force_text(line)
            for cmd in cmds:
                if len(line) > 1 and line[0] == " " and line[1] == cmd:
                    fetch_info_lines.append(line)
                    continue

        
        fetch_head = SymbolicReference(self.repo, "FETCH_HEAD")
        with open(fetch_head.abspath, "rb") as fp:
            fetch_head_info = [line.decode(defenc) for line in fp.readlines()]

        l_fil = len(fetch_info_lines)
        l_fhi = len(fetch_head_info)
        if l_fil != l_fhi:
            msg = "Fetch head lines do not match lines provided via progress information\n"
            msg += "length of progress lines %i should be equal to lines in FETCH_HEAD file %i\n"
            msg += "Will ignore extra progress lines or fetch head lines."
            msg %= (l_fil, l_fhi)
            _logger.debug(msg)
            _logger.debug(b"info lines: " + str(fetch_info_lines).encode("UTF-8"))
            _logger.debug(b"head info: " + str(fetch_head_info).encode("UTF-8"))
            if l_fil < l_fhi:
                fetch_head_info = fetch_head_info[:l_fil]
            else:
                fetch_info_lines = fetch_info_lines[:l_fhi]
            
        

        for err_line, fetch_line in zip(fetch_info_lines, fetch_head_info):
            try:
                output.append(FetchInfo._from_line(self.repo, err_line, fetch_line))
            except ValueError as exc:
                _logger.debug("Caught error while parsing line: %s", exc)
                _logger.warning("Git informed while fetching: %s", err_line.strip())
        return output

    def _get_push_info(
        self,
        proc: "Git.AutoInterrupt",
        progress: Union[Callable[..., Any], RemoteProgress, None],
        kill_after_timeout: Union[None, float] = None,
    ) -> PushInfoList:
        progress = to_progress_instance(progress)

        
        
        
        
        progress_handler = progress.new_message_handler()
        output: PushInfoList = PushInfoList()

        def stdout_handler(line: str) -> None:
            try:
                output.append(PushInfo._from_line(self, line))
            except ValueError:
                
                pass

        handle_process_output(
            proc,
            stdout_handler,
            progress_handler,
            finalizer=None,
            decode_streams=False,
            kill_after_timeout=kill_after_timeout,
        )
        stderr_text = progress.error_lines and "\n".join(progress.error_lines) or ""
        try:
            proc.wait(stderr=stderr_text)
        except Exception as e:
            
            
            if not output:
                raise
            elif stderr_text:
                _logger.warning("Error lines received while fetching: %s", stderr_text)
                output.error = e

        return output

    def _assert_refspec(self) -> None:
        
        config = self.config_reader
        unset = "placeholder"
        try:
            if config.get_value("fetch", default=unset) is unset:
                msg = "Remote '%s' has no refspec set.\n"
                msg += "You can set it as follows:"
                msg += " 'git config --add \"remote.%s.fetch +refs/heads/*:refs/heads/*\"'."
                raise AssertionError(msg % (self.name, self.name))
        finally:
            config.release()

    def fetch(
        self,
        refspec: Union[str, List[str], None] = None,
        progress: Union[RemoteProgress, None, "UpdateProgress"] = None,
        verbose: bool = True,
        kill_after_timeout: Union[None, float] = None,
        allow_unsafe_protocols: bool = False,
        allow_unsafe_options: bool = False,
        **kwargs: Any,
    ) -> IterableList[FetchInfo]:
        
        if refspec is None:
            
            self._assert_refspec()

        kwargs = add_progress(kwargs, self.repo.git, progress)
        if isinstance(refspec, list):
            args: Sequence[Optional[str]] = refspec
        else:
            args = [refspec]

        if not allow_unsafe_protocols:
            for ref in args:
                if ref:
                    Git.check_unsafe_protocols(ref)

        if not allow_unsafe_options:
            Git.check_unsafe_options(options=list(kwargs.keys()), unsafe_options=self.unsafe_git_fetch_options)

        proc = self.repo.git.fetch(
            "--", self, *args, as_process=True, with_stdout=False, universal_newlines=True, v=verbose, **kwargs
        )
        res = self._get_fetch_info_from_stderr(proc, progress, kill_after_timeout=kill_after_timeout)
        if hasattr(self.repo.odb, "update_cache"):
            self.repo.odb.update_cache()
        return res

    def pull(
        self,
        refspec: Union[str, List[str], None] = None,
        progress: Union[RemoteProgress, "UpdateProgress", None] = None,
        kill_after_timeout: Union[None, float] = None,
        allow_unsafe_protocols: bool = False,
        allow_unsafe_options: bool = False,
        **kwargs: Any,
    ) -> IterableList[FetchInfo]:
        
        if refspec is None:
            
            self._assert_refspec()
        kwargs = add_progress(kwargs, self.repo.git, progress)

        refspec = Git._unpack_args(refspec or [])
        if not allow_unsafe_protocols:
            for ref in refspec:
                Git.check_unsafe_protocols(ref)

        if not allow_unsafe_options:
            Git.check_unsafe_options(options=list(kwargs.keys()), unsafe_options=self.unsafe_git_pull_options)

        proc = self.repo.git.pull(
            "--", self, refspec, with_stdout=False, as_process=True, universal_newlines=True, v=True, **kwargs
        )
        res = self._get_fetch_info_from_stderr(proc, progress, kill_after_timeout=kill_after_timeout)
        if hasattr(self.repo.odb, "update_cache"):
            self.repo.odb.update_cache()
        return res

    def push(
        self,
        refspec: Union[str, List[str], None] = None,
        progress: Union[RemoteProgress, "UpdateProgress", Callable[..., RemoteProgress], None] = None,
        kill_after_timeout: Union[None, float] = None,
        allow_unsafe_protocols: bool = False,
        allow_unsafe_options: bool = False,
        **kwargs: Any,
    ) -> PushInfoList:
        
        kwargs = add_progress(kwargs, self.repo.git, progress)

        refspec = Git._unpack_args(refspec or [])
        if not allow_unsafe_protocols:
            for ref in refspec:
                Git.check_unsafe_protocols(ref)

        if not allow_unsafe_options:
            Git.check_unsafe_options(options=list(kwargs.keys()), unsafe_options=self.unsafe_git_push_options)

        proc = self.repo.git.push(
            "--",
            self,
            refspec,
            porcelain=True,
            as_process=True,
            universal_newlines=True,
            kill_after_timeout=kill_after_timeout,
            **kwargs,
        )
        return self._get_push_info(proc, progress, kill_after_timeout=kill_after_timeout)

    @property
    def config_reader(self) -> SectionConstraint[GitConfigParser]:
        
        return self._config_reader

    def _clear_cache(self) -> None:
        try:
            del self._config_reader
        except AttributeError:
            pass
        

    @property
    def config_writer(self) -> SectionConstraint:
        
        writer = self.repo.config_writer()

        
        self._clear_cache()
        return SectionConstraint(writer, self._config_section_name())
