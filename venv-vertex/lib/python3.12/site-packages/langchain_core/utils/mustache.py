

from __future__ import annotations

import logging
from collections.abc import Iterator, Mapping, Sequence
from types import MappingProxyType
from typing import (
    TYPE_CHECKING,
    Any,
    Literal,
    Optional,
    Union,
    cast,
)

if TYPE_CHECKING:
    from typing_extensions import TypeAlias

logger = logging.getLogger(__name__)


Scopes: TypeAlias = list[Union[Literal[False, 0], Mapping[str, Any]]]



_CURRENT_LINE = 1
_LAST_TAG_LINE = None


class ChevronError(SyntaxError):
    







def grab_literal(template: str, l_del: str) -> tuple[str, str]:
    
    global _CURRENT_LINE

    try:
        
        literal, template = template.split(l_del, 1)
        _CURRENT_LINE += literal.count("\n")

    
    except ValueError:
        
        return (template, "")

    return (literal, template)


def l_sa_check(
    template: str,  
    literal: str,
    is_standalone: bool,  
) -> bool:
    
    
    if literal.find("\n") != -1 or is_standalone:
        padding = literal.split("\n")[-1]

        
        
        
        return padding.isspace() or padding == ""
    return False


def r_sa_check(
    template: str,
    tag_type: str,
    is_standalone: bool,  
) -> bool:
    
    
    if is_standalone and tag_type not in {"variable", "no escape"}:
        on_newline = template.split("\n", 1)

        
        return on_newline[0].isspace() or not on_newline[0]

    
    return False


def parse_tag(template: str, l_del: str, r_del: str) -> tuple[tuple[str, str], str]:
    
    tag_types = {
        "!": "comment",
        "
        "^": "inverted section",
        "/": "end",
        ">": "partial",
        "=": "set delimiter?",
        "{": "no escape?",
        "&": "no escape",
    }

    
    try:
        tag, template = template.split(r_del, 1)
    except ValueError as e:
        msg = f"unclosed tag at line {_CURRENT_LINE}"
        raise ChevronError(msg) from e

    
    if not tag.strip():
        msg = f"empty tag at line {_CURRENT_LINE}"
        raise ChevronError(msg)

    
    tag_type = tag_types.get(tag[0], "variable")

    
    if tag_type != "variable":
        
        tag = tag[1:]

    
    if tag_type == "set delimiter?":
        
        if tag.endswith("="):
            tag_type = "set delimiter"
            
            tag = tag[:-1]

        
        else:
            msg = f"unclosed set delimiter tag\nat line {_CURRENT_LINE}"
            raise ChevronError(msg)

    elif (
        
        tag_type == "no escape?"
        
        
        and l_del == "{{"
        and r_del == "}}"
        and template.startswith("}")
    ):
        
        template = template[1:]
        tag_type = "no escape"

    
    return ((tag_type, tag.strip()), template)







def tokenize(
    template: str, def_ldel: str = "{{", def_rdel: str = "}}"
) -> Iterator[tuple[str, str]]:
    
    global _CURRENT_LINE, _LAST_TAG_LINE
    _CURRENT_LINE = 1
    _LAST_TAG_LINE = None

    is_standalone = True
    open_sections = []
    l_del = def_ldel
    r_del = def_rdel

    while template:
        literal, template = grab_literal(template, l_del)

        
        if not template:
            
            yield ("literal", literal)
            break

        
        is_standalone = l_sa_check(template, literal, is_standalone)

        
        tag, template = parse_tag(template, l_del, r_del)
        tag_type, tag_key = tag

        

        
        if tag_type == "set delimiter":
            
            dels = tag_key.strip().split(" ")
            l_del, r_del = dels[0], dels[-1]

        
        elif tag_type in {"section", "inverted section"}:
            
            open_sections.append(tag_key)
            _LAST_TAG_LINE = _CURRENT_LINE

        
        elif tag_type == "end":
            
            
            try:
                last_section = open_sections.pop()
            except IndexError as e:
                msg = (
                    f'Trying to close tag "{tag_key}"\n'
                    "Looks like it was not opened.\n"
                    f"line {_CURRENT_LINE + 1}"
                )
                raise ChevronError(msg) from e
            if tag_key != last_section:
                
                msg = (
                    f'Trying to close tag "{tag_key}"\n'
                    f'last open tag is "{last_section}"\n'
                    f"line {_CURRENT_LINE + 1}"
                )
                raise ChevronError(msg)

        
        is_standalone = r_sa_check(template, tag_type, is_standalone)

        
        if is_standalone:
            
            template = template.split("\n", 1)[-1]

            
            if tag_type != "partial":
                
                literal = literal.rstrip(" ")

        
        
        if literal != "":
            yield ("literal", literal)

        
        if tag_type not in {"comment", "set delimiter?"}:
            yield (tag_type, tag_key)

    
    if open_sections:
        
        msg = (
            "Unexpected EOF\n"
            f'the tag "{open_sections[-1]}" was never closed\n'
            f"was opened at line {_LAST_TAG_LINE}"
        )
        raise ChevronError(msg)







def _html_escape(string: str) -> str:
    
    html_codes = {
        '"': "&quot;",
        "<": "&lt;",
        ">": "&gt;",
    }

    
    string = string.replace("&", "&amp;")
    for char, code in html_codes.items():
        string = string.replace(char, code)
    return string


def _get_key(
    key: str,
    scopes: Scopes,
    *,
    warn: bool,
    keep: bool,
    def_ldel: str,
    def_rdel: str,
) -> Any:
    
    
    if key == ".":
        
        return scopes[0]

    
    for scope in scopes:
        try:
            
            
            if scope in (0, False):
                return scope

            resolved_scope = scope
            
            for child in key.split("."):
                
                
                if resolved_scope in (0, False):
                    return resolved_scope
                
                try:
                    
                    resolved_scope = cast("dict[str, Any]", resolved_scope)[child]
                except (TypeError, AttributeError):
                    try:
                        resolved_scope = getattr(resolved_scope, child)
                    except (TypeError, AttributeError):
                        
                        resolved_scope = resolved_scope[int(child)]  

            try:
                
                
                if resolved_scope._CHEVRON_return_scope_when_falsy:  
                    return resolved_scope
            except AttributeError:
                if resolved_scope in (0, False):
                    return resolved_scope
                return resolved_scope or ""
        except (AttributeError, KeyError, IndexError, ValueError):
            
            
            pass

    

    if warn:
        logger.warning("Could not find key '%s'", key)

    if keep:
        return f"{def_ldel} {key} {def_rdel}"

    return ""


def _get_partial(name: str, partials_dict: Mapping[str, str]) -> str:
    
    try:
        
        return partials_dict[name]
    except KeyError:
        return ""





g_token_cache: dict[str, list[tuple[str, str]]] = {}

EMPTY_DICT: MappingProxyType[str, str] = MappingProxyType({})


def render(
    template: Union[str, list[tuple[str, str]]] = "",
    data: Mapping[str, Any] = EMPTY_DICT,
    partials_dict: Mapping[str, str] = EMPTY_DICT,
    padding: str = "",
    def_ldel: str = "{{",
    def_rdel: str = "}}",
    scopes: Optional[Scopes] = None,
    warn: bool = False,  
    keep: bool = False,  
) -> str:
    
    
    if isinstance(template, Sequence) and not isinstance(template, str):
        
        
        tokens: Iterator[tuple[str, str]] = (token for token in template)
    elif template in g_token_cache:
        tokens = (token for token in g_token_cache[template])
    else:
        
        tokens = tokenize(template, def_ldel, def_rdel)

    output = ""

    if scopes is None:
        scopes = [data]

    
    for tag, key in tokens:
        
        current_scope = scopes[0]

        
        if tag == "end":
            
            del scopes[0]

        
        elif not current_scope and len(scopes) != 1:
            if tag in {"section", "inverted section"}:
                
                scopes.insert(0, False)

        
        elif tag == "literal":
            
            output += key.replace("\n", "\n" + padding)

        
        elif tag == "variable":
            
            thing = _get_key(
                key, scopes, warn=warn, keep=keep, def_ldel=def_ldel, def_rdel=def_rdel
            )
            if thing is True and key == ".":
                
                
                
                thing = scopes[1]
            if not isinstance(thing, str):
                thing = str(thing)
            output += _html_escape(thing)

        
        elif tag == "no escape":
            
            thing = _get_key(
                key, scopes, warn=warn, keep=keep, def_ldel=def_ldel, def_rdel=def_rdel
            )
            if not isinstance(thing, str):
                thing = str(thing)
            output += thing

        
        elif tag == "section":
            
            scope = _get_key(
                key, scopes, warn=warn, keep=keep, def_ldel=def_ldel, def_rdel=def_rdel
            )

            
            
            if callable(scope):
                
                text = ""
                tags: list[tuple[str, str]] = []
                for token in tokens:
                    if token == ("end", key):
                        break

                    tags.append(token)
                    tag_type, tag_key = token
                    if tag_type == "literal":
                        text += tag_key
                    elif tag_type == "no escape":
                        text += f"{def_ldel}& {tag_key} {def_rdel}"
                    else:
                        text += "{}{} {}{}".format(
                            def_ldel,
                            {
                                "comment": "!",
                                "section": "
                                "inverted section": "^",
                                "end": "/",
                                "partial": ">",
                                "set delimiter": "=",
                                "no escape": "&",
                                "variable": "",
                            }[tag_type],
                            tag_key,
                            def_rdel,
                        )

                g_token_cache[text] = tags

                rend = scope(
                    text,
                    lambda template, data=None: render(
                        template,
                        data={},
                        partials_dict=partials_dict,
                        padding=padding,
                        def_ldel=def_ldel,
                        def_rdel=def_rdel,
                        scopes=(data and [data, *scopes]) or scopes,
                        warn=warn,
                        keep=keep,
                    ),
                )

                output += rend

            
            
            elif isinstance(scope, (Sequence, Iterator)) and not isinstance(scope, str):
                

                
                
                
                tags = []
                tags_with_same_key = 0
                for token in tokens:
                    if token == ("section", key):
                        tags_with_same_key += 1
                    if token == ("end", key):
                        tags_with_same_key -= 1
                        if tags_with_same_key < 0:
                            break
                    tags.append(token)

                
                for thing in scope:
                    
                    new_scope = [thing, *scopes]
                    rend = render(
                        template=tags,
                        scopes=new_scope,
                        padding=padding,
                        partials_dict=partials_dict,
                        def_ldel=def_ldel,
                        def_rdel=def_rdel,
                        warn=warn,
                        keep=keep,
                    )

                    output += rend

            else:
                
                scopes.insert(0, scope)

        
        elif tag == "inverted section":
            
            scope = _get_key(
                key, scopes, warn=warn, keep=keep, def_ldel=def_ldel, def_rdel=def_rdel
            )
            scopes.insert(0, cast("Literal[False]", not scope))

        
        elif tag == "partial":
            
            partial = _get_partial(key, partials_dict)

            
            left = output.rpartition("\n")[2]
            part_padding = padding
            if left.isspace():
                part_padding += left

            
            part_out = render(
                template=partial,
                partials_dict=partials_dict,
                def_ldel=def_ldel,
                def_rdel=def_rdel,
                padding=part_padding,
                scopes=scopes,
                warn=warn,
                keep=keep,
            )

            
            if left.isspace():
                
                part_out = part_out.rstrip(" \t")

            
            output += part_out

    return output
