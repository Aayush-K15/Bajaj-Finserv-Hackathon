

from abc import ABC, abstractmethod
from collections.abc import AsyncIterator, Iterator, Sequence
from typing import (
    Any,
    Generic,
    Optional,
    TypeVar,
    Union,
)

from langchain_core.exceptions import LangChainException
from langchain_core.runnables import run_in_executor

K = TypeVar("K")
V = TypeVar("V")


class BaseStore(ABC, Generic[K, V]):
    

    @abstractmethod
    def mget(self, keys: Sequence[K]) -> list[Optional[V]]:
        

    async def amget(self, keys: Sequence[K]) -> list[Optional[V]]:
        
        return await run_in_executor(None, self.mget, keys)

    @abstractmethod
    def mset(self, key_value_pairs: Sequence[tuple[K, V]]) -> None:
        

    async def amset(self, key_value_pairs: Sequence[tuple[K, V]]) -> None:
        
        return await run_in_executor(None, self.mset, key_value_pairs)

    @abstractmethod
    def mdelete(self, keys: Sequence[K]) -> None:
        

    async def amdelete(self, keys: Sequence[K]) -> None:
        
        return await run_in_executor(None, self.mdelete, keys)

    @abstractmethod
    def yield_keys(
        self, *, prefix: Optional[str] = None
    ) -> Union[Iterator[K], Iterator[str]]:
        

    async def ayield_keys(
        self, *, prefix: Optional[str] = None
    ) -> Union[AsyncIterator[K], AsyncIterator[str]]:
        
        iterator = await run_in_executor(None, self.yield_keys, prefix=prefix)
        done = object()
        while True:
            item = await run_in_executor(None, lambda it: next(it, done), iterator)
            if item is done:
                break
            yield item  


ByteStore = BaseStore[str, bytes]


class InMemoryBaseStore(BaseStore[str, V], Generic[V]):
    

    def __init__(self) -> None:
        
        self.store: dict[str, V] = {}

    def mget(self, keys: Sequence[str]) -> list[Optional[V]]:
        
        return [self.store.get(key) for key in keys]

    async def amget(self, keys: Sequence[str]) -> list[Optional[V]]:
        
        return self.mget(keys)

    def mset(self, key_value_pairs: Sequence[tuple[str, V]]) -> None:
        
        for key, value in key_value_pairs:
            self.store[key] = value

    async def amset(self, key_value_pairs: Sequence[tuple[str, V]]) -> None:
        
        return self.mset(key_value_pairs)

    def mdelete(self, keys: Sequence[str]) -> None:
        
        for key in keys:
            if key in self.store:
                del self.store[key]

    async def amdelete(self, keys: Sequence[str]) -> None:
        
        self.mdelete(keys)

    def yield_keys(self, prefix: Optional[str] = None) -> Iterator[str]:
        
        if prefix is None:
            yield from self.store.keys()
        else:
            for key in self.store:
                if key.startswith(prefix):
                    yield key

    async def ayield_keys(self, prefix: Optional[str] = None) -> AsyncIterator[str]:
        
        if prefix is None:
            for key in self.store:
                yield key
        else:
            for key in self.store:
                if key.startswith(prefix):
                    yield key


class InMemoryStore(InMemoryBaseStore[Any]):
    


class InMemoryByteStore(InMemoryBaseStore[bytes]):
    


class InvalidKeyException(LangChainException):
    
