  

from __future__ import annotations

import json
from collections.abc import Sequence
from typing import Any, Literal, Union

from langchain_core.load.serializable import Serializable
from langchain_core.messages import (
    AIMessage,
    BaseMessage,
    FunctionMessage,
    HumanMessage,
)


class AgentAction(Serializable):
    

    tool: str
    
    tool_input: Union[str, dict]
    
    log: str
    
    type: Literal["AgentAction"] = "AgentAction"

    
    def __init__(
        self, tool: str, tool_input: Union[str, dict], log: str, **kwargs: Any
    ):
        
        super().__init__(tool=tool, tool_input=tool_input, log=log, **kwargs)

    @classmethod
    def is_lc_serializable(cls) -> bool:
        
        return True

    @classmethod
    def get_lc_namespace(cls) -> list[str]:
        
        return ["langchain", "schema", "agent"]

    @property
    def messages(self) -> Sequence[BaseMessage]:
        
        return _convert_agent_action_to_messages(self)


class AgentActionMessageLog(AgentAction):
    

    message_log: Sequence[BaseMessage]
    
    
    
    
    type: Literal["AgentActionMessageLog"] = "AgentActionMessageLog"  


class AgentStep(Serializable):
    

    action: AgentAction
    
    observation: Any
    

    @property
    def messages(self) -> Sequence[BaseMessage]:
        
        return _convert_agent_observation_to_messages(self.action, self.observation)


class AgentFinish(Serializable):
    

    return_values: dict
    
    log: str
    
    type: Literal["AgentFinish"] = "AgentFinish"

    def __init__(self, return_values: dict, log: str, **kwargs: Any):
        
        super().__init__(return_values=return_values, log=log, **kwargs)

    @classmethod
    def is_lc_serializable(cls) -> bool:
        
        return True

    @classmethod
    def get_lc_namespace(cls) -> list[str]:
        
        return ["langchain", "schema", "agent"]

    @property
    def messages(self) -> Sequence[BaseMessage]:
        
        return [AIMessage(content=self.log)]


def _convert_agent_action_to_messages(
    agent_action: AgentAction,
) -> Sequence[BaseMessage]:
    
    if isinstance(agent_action, AgentActionMessageLog):
        return agent_action.message_log
    return [AIMessage(content=agent_action.log)]


def _convert_agent_observation_to_messages(
    agent_action: AgentAction, observation: Any
) -> Sequence[BaseMessage]:
    
    if isinstance(agent_action, AgentActionMessageLog):
        return [_create_function_message(agent_action, observation)]
    content = observation
    if not isinstance(observation, str):
        try:
            content = json.dumps(observation, ensure_ascii=False)
        except Exception:
            content = str(observation)
    return [HumanMessage(content=content)]


def _create_function_message(
    agent_action: AgentAction, observation: Any
) -> FunctionMessage:
    
    if not isinstance(observation, str):
        try:
            content = json.dumps(observation, ensure_ascii=False)
        except Exception:
            content = str(observation)
    else:
        content = observation
    return FunctionMessage(
        name=agent_action.tool,
        content=content,
    )
