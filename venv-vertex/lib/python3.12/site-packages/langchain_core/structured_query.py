

from __future__ import annotations

from abc import ABC, abstractmethod
from enum import Enum
from typing import TYPE_CHECKING, Any, Optional, Union

from pydantic import BaseModel

if TYPE_CHECKING:
    from collections.abc import Sequence


class Visitor(ABC):
    

    allowed_comparators: Optional[Sequence[Comparator]] = None
    
    allowed_operators: Optional[Sequence[Operator]] = None
    

    def _validate_func(self, func: Union[Operator, Comparator]) -> None:
        if (
            isinstance(func, Operator)
            and self.allowed_operators is not None
            and func not in self.allowed_operators
        ):
            msg = (
                f"Received disallowed operator {func}. Allowed "
                f"comparators are {self.allowed_operators}"
            )
            raise ValueError(msg)
        if (
            isinstance(func, Comparator)
            and self.allowed_comparators is not None
            and func not in self.allowed_comparators
        ):
            msg = (
                f"Received disallowed comparator {func}. Allowed "
                f"comparators are {self.allowed_comparators}"
            )
            raise ValueError(msg)

    @abstractmethod
    def visit_operation(self, operation: Operation) -> Any:
        

    @abstractmethod
    def visit_comparison(self, comparison: Comparison) -> Any:
        

    @abstractmethod
    def visit_structured_query(self, structured_query: StructuredQuery) -> Any:
        


def _to_snake_case(name: str) -> str:
    
    snake_case = ""
    for i, char in enumerate(name):
        if char.isupper() and i != 0:
            snake_case += "_" + char.lower()
        else:
            snake_case += char.lower()
    return snake_case


class Expr(BaseModel):
    

    def accept(self, visitor: Visitor) -> Any:
        
        return getattr(visitor, f"visit_{_to_snake_case(self.__class__.__name__)}")(
            self
        )


class Operator(str, Enum):
    

    AND = "and"
    OR = "or"
    NOT = "not"


class Comparator(str, Enum):
    

    EQ = "eq"
    NE = "ne"
    GT = "gt"
    GTE = "gte"
    LT = "lt"
    LTE = "lte"
    CONTAIN = "contain"
    LIKE = "like"
    IN = "in"
    NIN = "nin"


class FilterDirective(Expr, ABC):
    


class Comparison(FilterDirective):
    

    comparator: Comparator
    
    attribute: str
    
    value: Any
    

    def __init__(
        self, comparator: Comparator, attribute: str, value: Any, **kwargs: Any
    ) -> None:
        
        
        super().__init__(  
            comparator=comparator, attribute=attribute, value=value, **kwargs
        )


class Operation(FilterDirective):
    

    operator: Operator
    
    arguments: list[FilterDirective]
    

    def __init__(
        self, operator: Operator, arguments: list[FilterDirective], **kwargs: Any
    ) -> None:
        
        
        super().__init__(  
            operator=operator, arguments=arguments, **kwargs
        )


class StructuredQuery(Expr):
    

    query: str
    
    filter: Optional[FilterDirective]
    
    limit: Optional[int]
    

    def __init__(
        self,
        query: str,
        filter: Optional[FilterDirective],  
        limit: Optional[int] = None,
        **kwargs: Any,
    ) -> None:
        
        
        super().__init__(  
            query=query, filter=filter, limit=limit, **kwargs
        )
