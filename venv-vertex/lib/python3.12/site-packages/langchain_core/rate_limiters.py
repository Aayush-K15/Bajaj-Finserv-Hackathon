

from __future__ import annotations

import abc
import asyncio
import threading
import time
from typing import Optional


class BaseRateLimiter(abc.ABC):
    

    @abc.abstractmethod
    def acquire(self, *, blocking: bool = True) -> bool:
        

    @abc.abstractmethod
    async def aacquire(self, *, blocking: bool = True) -> bool:
        


class InMemoryRateLimiter(BaseRateLimiter):
      

    def __init__(
        self,
        *,
        requests_per_second: float = 1,
        check_every_n_seconds: float = 0.1,
        max_bucket_size: float = 1,
    ) -> None:
        
        
        self.requests_per_second = requests_per_second
        
        self.available_tokens = 0.0
        self.max_bucket_size = max_bucket_size
        
        
        self._consume_lock = threading.Lock()
        
        self.last: Optional[float] = None
        self.check_every_n_seconds = check_every_n_seconds

    def _consume(self) -> bool:
        
        with self._consume_lock:
            now = time.monotonic()

            
            if self.last is None:
                self.last = now

            elapsed = now - self.last

            if elapsed * self.requests_per_second >= 1:
                self.available_tokens += elapsed * self.requests_per_second
                self.last = now

            
            
            self.available_tokens = min(self.available_tokens, self.max_bucket_size)

            
            if self.available_tokens >= 1:
                self.available_tokens -= 1
                return True

            return False

    def acquire(self, *, blocking: bool = True) -> bool:
        
        if not blocking:
            return self._consume()

        while not self._consume():
            time.sleep(self.check_every_n_seconds)
        return True

    async def aacquire(self, *, blocking: bool = True) -> bool:
        
        if not blocking:
            return self._consume()

        while not self._consume():  
            
            
            
            
            
            
            await asyncio.sleep(self.check_every_n_seconds)
        return True


__all__ = [
    "BaseRateLimiter",
    "InMemoryRateLimiter",
]
