import string
import sys

if sys.version_info < (3, 10):
    from collections import Sequence
else:
    from collections.abc import Sequence

try:
    from . import global_state
    from .base_boxes import bindArrows
except (SystemError, ValueError, ImportError):
    import global_state
    from base_boxes import bindArrows

try:
    import tkinter as tk  
    import tkinter.font as tk_Font
except:
    import Tkinter as tk  
    import tkFont as tk_Font


def choicebox(msg="Pick an item", title="", choices=None, preselect=0,
              callback=None,
              run=True):
    
    mb = ChoiceBox(msg, title, choices, preselect=preselect,
                   multiple_select=False,
                   callback=callback)
    if run:
        reply = mb.run()
        return reply
    else:
        return mb


def multchoicebox(msg="Pick an item", title="", choices=None,
                  preselect=0, callback=None,
                  run=True):
    
    mb = ChoiceBox(msg, title, choices, preselect=preselect,
                   multiple_select=True,
                   callback=callback)
    if run:
        reply = mb.run()
        return reply
    else:
        return mb



def make_list_or_none(obj, cast_type=None):
    
    
    
    
    
    
    
    
    ret_val = obj
    if ret_val is None:
        return None
    
    if not isinstance(obj, Sequence):
        if cast_type is not None:
            try:
                ret_val = cast_type(obj)
            except Exception as e:
                raise Exception("Value {} cannot be converted to type: {}".format(obj, cast_type))
        ret_val = [ret_val,]
    
    if cast_type is not None:
        try:
            ret_val = [cast_type(elem) for elem in ret_val]
        except:
            raise Exception("Not all values in {}\n can be converted to type: {}".format(ret_val, cast_type))
    return ret_val


class ChoiceBox(object):

    def __init__(self, msg, title, choices, preselect, multiple_select, callback):

        self.callback = callback

        if choices is None:
            
            choices = ('Choice 1', 'Choice 2')
        self.choices = self.to_list_of_str(choices)

        
        preselect_list = make_list_or_none(preselect, cast_type=int)
        if not multiple_select and len(preselect_list)>1:
            raise ValueError("Multiple selections not allowed, yet preselect has multiple values:{}".format(preselect_list))

        self.ui = GUItk(msg, title, self.choices, preselect_list, multiple_select,
                        self.callback_ui)

    def run(self):
        
        self.ui.run()
        self.ui = None
        return self.choices

    def stop(self):
        
        self.ui.stop()

    def callback_ui(self, ui, command, choices):
        
        if command == 'update':  
            self.choices = choices
            if self.callback:
                
                self.callback(self)
            else:
                self.stop()
        elif command == 'x':
            self.stop()
            self.choices = None
        elif command == 'cancel':
            self.stop()
            self.choices = None

    

    @property
    def msg(self):
        
        return self._msg

    @msg.setter
    def msg(self, msg):
        self.ui.set_msg(msg)

    @msg.deleter
    def msg(self):
        self._msg = ""
        self.ui.set_msg(self._msg)

    

    def to_list_of_str(self, choices):
        choices = [str(c) for c in choices]

        while len(choices) < 2:
            raise ValueError('at least two choices need to be specified')

        return choices



class GUItk(object):

    

    def __init__(self, msg, title, choices, preselect, multiple_select, callback):

        self.callback = callback

        self.choices = choices

        self.width_in_chars = global_state.prop_font_line_length
        
        
        
        

        self.multiple_select = multiple_select

        self.boxRoot = tk.Tk()

        self.boxFont = tk_Font.nametofont("TkTextFont")

        self.config_root(title)

        self.set_pos(global_state.window_position)  

        self.create_msg_widget(msg)

        self.create_choicearea()

        self.create_ok_button()

        self.create_cancel_button()

        self.create_special_buttons()
        
        self.preselect_choice(preselect)

        self.choiceboxWidget.focus_force()

    

    def run(self):
        self.boxRoot.mainloop()  
        self.boxRoot.destroy()   

    def stop(self):
        
        self.get_pos()

        self.boxRoot.quit()

    def x_pressed(self):
        self.callback(self, command='x', choices=self.get_choices())

    def cancel_pressed(self, event):
        self.callback(self, command='cancel', choices=self.get_choices())

    def ok_pressed(self, event):
        self.callback(self, command='update', choices=self.get_choices())

    

    

    def set_msg(self, msg):
        self.messageArea.config(state=tk.NORMAL)
        self.messageArea.delete(1.0, tk.END)
        self.messageArea.insert(tk.END, msg)
        self.messageArea.config(state=tk.DISABLED)
        
        self.messageArea.update()
        numlines = self.get_num_lines(self.messageArea)
        self.set_msg_height(numlines)
        self.messageArea.update()
        

    def set_msg_height(self, numlines):
        self.messageArea.configure(height=numlines)

    def get_num_lines(self, widget):
        end_position = widget.index(tk.END)  
        end_line = end_position.split('.')[0]  
        return int(end_line) + 1  

    def set_pos(self, pos=None):
        if not pos:
            pos = global_state.window_position
        self.boxRoot.geometry(pos)

    def get_pos(self):
        
        
        
        
        geom = self.boxRoot.geometry()  
        global_state.window_position = '+' + geom.split('+', 1)[1]

    def preselect_choice(self, preselect):
        if preselect != None:
            for v in preselect:
                self.choiceboxWidget.select_set(v)
                self.choiceboxWidget.activate(v)

    def get_choices(self):
        choices_index = self.choiceboxWidget.curselection()
        if not choices_index:
            return None
        if self.multiple_select:
            selected_choices = [self.choiceboxWidget.get(index)
                                for index in choices_index]
        else:
            selected_choices = self.choiceboxWidget.get(choices_index)

        return selected_choices

    
    def calc_character_width(self):
        char_width = self.boxFont.measure('W')
        return char_width

    def config_root(self, title):

        screen_width = self.boxRoot.winfo_screenwidth()
        screen_height = self.boxRoot.winfo_screenheight()
        self.root_width = int((screen_width * 0.8))
        root_height = int((screen_height * 0.5))

        self.boxRoot.title(title)
        self.boxRoot.iconname('Dialog')
        self.boxRoot.expand = tk.NO
        

        self.set_pos()

        self.boxRoot.protocol('WM_DELETE_WINDOW', self.x_pressed)
        self.boxRoot.bind('<Any-Key>', self.KeyboardListener)
        self.boxRoot.bind("<Escape>", self.cancel_pressed)

        self.boxRoot.attributes("-topmost", True)  

    def create_msg_widget(self, msg):

        if msg is None:
            msg = ""

        self.msgFrame = tk.Frame(
            self.boxRoot,
            padx=2 * self.calc_character_width(),

        )
        self.messageArea = tk.Text(
            self.msgFrame,
            width=self.width_in_chars,
            state=tk.DISABLED,
            background=self.boxRoot.config()["background"][-1],
            relief='flat',
            padx=(global_state.default_hpad_in_chars *
                  self.calc_character_width()),
            pady=(global_state.default_hpad_in_chars *
                  self.calc_character_width()),
            wrap=tk.WORD,

        )
        self.set_msg(msg)

        self.msgFrame.pack(side=tk.TOP, expand=1, fill='both')

        self.messageArea.pack(side=tk.TOP, expand=1, fill='both')

    def create_choicearea(self):

        self.choiceboxFrame = tk.Frame(master=self.boxRoot)
        self.choiceboxFrame.pack(side=tk.TOP, fill=tk.BOTH, expand=tk.YES)

        lines_to_show = min(len(self.choices), 20)

        
        self.choiceboxWidget = tk.Listbox(self.choiceboxFrame,
                                          height=lines_to_show,
                                          borderwidth="1m", relief="flat",
                                          bg="white"
                                          )

        if self.multiple_select:
            self.choiceboxWidget.configure(selectmode=tk.MULTIPLE)

        
        

        
        rightScrollbar = tk.Scrollbar(self.choiceboxFrame, orient=tk.VERTICAL,
                                      command=self.choiceboxWidget.yview)
        self.choiceboxWidget.configure(yscrollcommand=rightScrollbar.set)

        
        bottomScrollbar = tk.Scrollbar(self.choiceboxFrame,
                                       orient=tk.HORIZONTAL,
                                       command=self.choiceboxWidget.xview)
        self.choiceboxWidget.configure(xscrollcommand=bottomScrollbar.set)

        
        
        
        
        

        bottomScrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        rightScrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.choiceboxWidget.pack(
            side=tk.LEFT, padx="1m", pady="1m", expand=tk.YES, fill=tk.BOTH)

        
        for choice in self.choices:
            self.choiceboxWidget.insert(tk.END, choice)

        
        self.choiceboxWidget.bind("<Return>", self.ok_pressed)
        self.choiceboxWidget.bind("<Double-Button-1>",
                                  self.ok_pressed)

    def create_ok_button(self):

        self.buttonsFrame = tk.Frame(self.boxRoot)
        self.buttonsFrame.pack(side=tk.TOP, expand=tk.YES, pady=0)

        
        okButton = tk.Button(self.buttonsFrame, takefocus=tk.YES,
                             text="OK", height=1, width=6)
        bindArrows(okButton)
        okButton.pack(expand=tk.NO, side=tk.RIGHT, padx='2m', pady='1m',
                      ipady="1m", ipadx="2m")

        
        okButton.bind("<Return>", self.ok_pressed)
        okButton.bind("<Button-1>", self.ok_pressed)
        okButton.bind("<space>", self.ok_pressed)

    def create_cancel_button(self):
        cancelButton = tk.Button(self.buttonsFrame, takefocus=tk.YES,
                                 text="Cancel", height=1, width=6)
        bindArrows(cancelButton)
        cancelButton.pack(expand=tk.NO, side=tk.LEFT, padx='2m', pady='1m',
                          ipady="1m", ipadx="2m")
        cancelButton.bind("<Return>", self.cancel_pressed)
        cancelButton.bind("<Button-1>", self.cancel_pressed)
        
        
        

    def create_special_buttons(self):
        
        if not self.multiple_select:
            return

        selectAllButton = tk.Button(
            self.buttonsFrame, text="Select All", height=1, width=6)
        selectAllButton.pack(expand=tk.NO, side=tk.LEFT, padx='2m',
                             pady='1m',
                             ipady="1m", ipadx="2m")

        clearAllButton = tk.Button(self.buttonsFrame, text="Clear All",
                                   height=1, width=6)
        clearAllButton.pack(expand=tk.NO, side=tk.LEFT,
                            padx='2m', pady='1m',
                            ipady="1m", ipadx="2m")

        selectAllButton.bind("<Button-1>", self.choiceboxSelectAll)
        bindArrows(selectAllButton)
        clearAllButton.bind("<Button-1>", self.choiceboxClearAll)
        bindArrows(clearAllButton)

    def KeyboardListener(self, event):
        key = event.keysym
        if len(key) <= 1:
            if key in string.printable:
                
                
                try:
                    start_n = int(self.choiceboxWidget.curselection()[0])
                except IndexError:
                    start_n = -1

                
                self.choiceboxWidget.selection_clear(0, 'end')

                
                for n in range(start_n + 1, len(self.choices)):
                    item = self.choices[n]
                    if item[0].lower() == key.lower():
                        self.choiceboxWidget.selection_set(first=n)
                        self.choiceboxWidget.see(n)
                        return
                else:
                    
                    for n, item in enumerate(self.choices):
                        if item[0].lower() == key.lower():
                            self.choiceboxWidget.selection_set(first=n)
                            self.choiceboxWidget.see(n)
                            return

                    
                    for n, item in enumerate(self.choices):
                        if item[0].lower() > key.lower():
                            if n > 0:
                                self.choiceboxWidget.selection_set(
                                    first=(n - 1))
                            else:
                                self.choiceboxWidget.selection_set(first=0)
                            self.choiceboxWidget.see(n)
                            return

                    
                    
                    lastIndex = len(self.choices) - 1
                    self.choiceboxWidget.selection_set(first=lastIndex)
                    self.choiceboxWidget.see(lastIndex)
                    return

    def choiceboxClearAll(self, event):
        self.choiceboxWidget.selection_clear(0, len(self.choices) - 1)

    def choiceboxSelectAll(self, event):
        self.choiceboxWidget.selection_set(0, len(self.choices) - 1)

if __name__ == '__main__':
    users_choice = multchoicebox(choices=['choice1', 'choice2'])
    print("User's choice is: {}".format(users_choice))
