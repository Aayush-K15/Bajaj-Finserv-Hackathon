

try:
    from . import global_state
except:
    import global_state

try:
    import tkinter as tk  
except:
    import Tkinter as tk  






def multpasswordbox(msg="Fill in values for the fields.",
                    title=" ", fields=tuple(), values=tuple(),
                    callback=None, run=True):
    r
    if run:
        mb = MultiBox(msg, title, fields, values, mask_last=True,
                      callback=callback)

        reply = mb.run()

        return reply

    else:

        mb = MultiBox(msg, title, fields, values, mask_last=True,
                      callback=callback)

        return mb









def multenterbox(msg="Fill in values for the fields.", title=" ",
                 fields=[], values=[], callback=None, run=True):
    r
    if run:
        mb = MultiBox(msg, title, fields, values, mask_last=False,
                      callback=callback)
        reply = mb.run()
        return reply
    else:
        mb = MultiBox(msg, title, fields, values, mask_last=False,
                      callback=callback)
        return mb


class MultiBox(object):

    

    def __init__(self, msg, title, fields, values, mask_last, callback):
        

        self.callback = callback

        self.fields, self.values = self.check_fields(fields, values)

        self.ui = GUItk(msg, title, self.fields, self.values,
                        mask_last, self.callback_ui)

    def run(self):
        
        self.ui.run()
        self.ui = None
        return self.values

    def stop(self):
        
        self.ui.stop()

    def callback_ui(self, ui, command, values):
        
        if command == 'update':  
            self.values = values
            if self.callback:
                
                self.callback(self)
            else:
                self.stop()
        elif command == 'x':
            self.stop()
            self.values = None
        elif command == 'cancel':
            self.stop()
            self.values = None

    

    @property
    def msg(self):
        
        return self._msg

    @msg.setter
    def msg(self, msg):
        self.ui.set_msg(msg)

    @msg.deleter
    def msg(self):
        self._msg = ""
        self.ui.set_msg(self._msg)

    

    def check_fields(self, fields, values):
        if len(fields) == 0:
            return None

        fields = list(fields[:])  
        values = list(values[:])  

        
        
        if len(values) == len(fields):
            pass
        elif len(values) > len(fields):
            fields = fields[0:len(values)]
        else:
            while len(values) < len(fields):
                values.append("")

        return fields, values


class GUItk(object):

    

    def __init__(self, msg, title, fields, values, mask_last, callback):

        self.callback = callback

        self.boxRoot = tk.Tk()

        self.create_root(title)

        self.set_pos(global_state.window_position)  

        self.create_msg_widget(msg)

        self.create_entryWidgets(fields, values, mask_last)

        self.create_buttons()

        self.entryWidgets[0].focus_force()  

    

    def run(self):
        self.boxRoot.mainloop()  
        self.boxRoot.destroy()   

    def stop(self):
        
        self.get_pos()

        self.boxRoot.quit()

    def x_pressed(self):
        self.callback(self, command='x', values=self.get_values())

    def cancel_pressed(self, event):
        self.callback(self, command='cancel', values=self.get_values())

    def ok_pressed(self, event):
        self.callback(self, command='update', values=self.get_values())

    

    def set_msg(self, msg):
        self.messageWidget.configure(text=msg)
        self.entryWidgets[0].focus_force()  

    def set_pos(self, pos):
        self.boxRoot.geometry(pos)

    def get_pos(self):
        
        
        
        
        geom = self.boxRoot.geometry()  
        global_state.window_position = '+' + geom.split('+', 1)[1]

    def get_values(self):
        values = []
        for entryWidget in self.entryWidgets:
            values.append(entryWidget.get())
        return values

    
    

    def create_root(self, title):

        self.boxRoot.protocol('WM_DELETE_WINDOW', self.x_pressed)
        self.boxRoot.title(title)
        self.boxRoot.iconname('Dialog')
        self.boxRoot.bind("<Escape>", self.cancel_pressed)
        self.boxRoot.attributes("-topmost", True)  

    def create_msg_widget(self, msg):
        
        self.messageWidget = tk.Message(self.boxRoot, width="4.5i", text=msg)
        self.messageWidget.configure(
            font=(global_state.PROPORTIONAL_FONT_FAMILY, global_state.PROPORTIONAL_FONT_SIZE))
        self.messageWidget.pack(
            side=tk.TOP, expand=1, fill=tk.BOTH, padx='3m', pady='3m')

    def create_entryWidgets(self, fields, values, mask_last):

        self.entryWidgets = []

        lastWidgetIndex = len(fields) - 1

        for widgetIndex in range(len(fields)):
            name = fields[widgetIndex]
            value = values[widgetIndex]
            entryFrame = tk.Frame(master=self.boxRoot)
            entryFrame.pack(side=tk.TOP, fill=tk.BOTH)

            
            labelWidget = tk.Label(entryFrame, text=name)
            labelWidget.pack(side=tk.LEFT)

            entryWidget = tk.Entry(entryFrame, width=40, highlightthickness=2)
            self.entryWidgets.append(entryWidget)
            entryWidget.configure(
                font=(global_state.PROPORTIONAL_FONT_FAMILY, global_state.TEXT_ENTRY_FONT_SIZE))
            entryWidget.pack(side=tk.RIGHT, padx="3m")

            self.bindArrows(entryWidget)

            entryWidget.bind("<Return>", self.ok_pressed)
            entryWidget.bind("<Escape>", self.cancel_pressed)

            
            
            if widgetIndex == lastWidgetIndex:
                if mask_last:
                    self.entryWidgets[widgetIndex].configure(show="*")

            
            if value is None:
                value = ''
            self.entryWidgets[widgetIndex].insert(
                0, '{}'.format(value))

    def create_buttons(self):
        self.buttonsFrame = tk.Frame(master=self.boxRoot)
        self.buttonsFrame.pack(side=tk.BOTTOM)

        self.create_cancel_button()
        self.create_ok_button()

    def create_ok_button(self):

        okButton = tk.Button(self.buttonsFrame, takefocus=1, text="OK")
        self.bindArrows(okButton)
        okButton.pack(expand=1, side=tk.LEFT, padx='3m', pady='3m',
                      ipadx='2m', ipady='1m')

        
        
        commandButton = okButton
        handler = self.ok_pressed
        for selectionEvent in global_state.STANDARD_SELECTION_EVENTS:
            commandButton.bind("<%s>" % selectionEvent, handler)

    def create_cancel_button(self):

        cancelButton = tk.Button(self.buttonsFrame, takefocus=1, text="Cancel")
        self.bindArrows(cancelButton)
        cancelButton.pack(expand=1, side=tk.LEFT, padx='3m', pady='3m',
                          ipadx='2m', ipady='1m')

        
        
        commandButton = cancelButton
        handler = self.cancel_pressed
        for selectionEvent in global_state.STANDARD_SELECTION_EVENTS:
            commandButton.bind("<%s>" % selectionEvent, handler)

    def bindArrows(self, widget):

        widget.bind("<Down>", self.tabRight)
        widget.bind("<Up>", self.tabLeft)

        widget.bind("<Right>", self.tabRight)
        widget.bind("<Left>", self.tabLeft)

    def tabRight(self, event):
        self.boxRoot.event_generate("<Tab>")

    def tabLeft(self, event):
        self.boxRoot.event_generate("<Shift-Tab>")


def demo1():
    msg = "Enter your personal information"
    title = "Credit Card Application"
    fieldNames = ["Name", "Street Address", "City", "State", "ZipCode"]
    fieldValues = []  

    
    while True:

        fieldValues = multenterbox(msg, title, fieldNames, fieldValues)
        cancelled = fieldValues is None
        errors = []
        if cancelled:
            pass
        else:  
            for name, value in zip(fieldNames, fieldValues):
                if value.strip() == "":
                    errors.append('"{}" is a required field.'.format(name))

        all_ok = not errors

        if cancelled or all_ok:
            break  

        msg = "\n".join(errors)

    print("Reply was: {}".format(fieldValues))


class Demo2():

    def __init__(self):
        msg = "Without flicker. Enter your personal information"
        title = "Credit Card Application"
        fieldNames = ["Name", "Street Address", "City", "State", "ZipCode"]
        fieldValues = []  

        fieldValues = multenterbox(msg, title, fieldNames, fieldValues,
                                   callback=self.check_for_blank_fields)
        print("Reply was: {}".format(fieldValues))

    def check_for_blank_fields(self, box):
        
        cancelled = box.values is None
        errors = []
        if cancelled:
            pass
        else:  
            for name, value in zip(box.fields, box.values):
                if value.strip() == "":
                    errors.append('"{}" is a required field.'.format(name))

        all_ok = not errors

        if cancelled or all_ok:
            box.stop()  

        box.msg = "\n".join(errors)


if __name__ == '__main__':
    demo1()
    Demo2()
