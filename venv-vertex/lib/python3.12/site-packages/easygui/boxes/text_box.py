


import sys

try:
    from . import global_state
except (SystemError, ValueError, ImportError):
    import global_state

try:
    import tkinter as tk  
    import tkinter.font as tk_Font
except:
    import Tkinter as tk  
    import tkFont as tk_Font


def demo_textbox():
    demo_1()
    Demo2()
    Demo3()


def demo_1():

    title = "Demo of textbox: Classic box"

    gnexp = ("This is a demo of the classic textbox call, "
             "you can see it closes when ok is pressed.\n\n")

    challenge = "INSERT A TEXT WITH MORE THAN TWO PARAGRAPHS"

    text = "Insert your text here\n"

    msg = gnexp + challenge

    finished = False
    while True:

        text = textbox(msg, title, text)
        escaped = not text
        if escaped or finished:
            break

        if text.count("\n") >= 2:
            msg = (u"You did it right! Press OK")
            finished = True
        else:
            msg = u"You did it wrong! Try again!\n" + challenge


class Demo2(object):

    

    def __init__(self):
        

        title = "Demo of textbox: Classic box with callback"

        gnexp = ("This is a demo of the textbox with a callback, "
                 "it doesn't flicker!.\n\n")

        msg = "INSERT A TEXT WITH FIVE OR MORE A\'s"

        text_snippet = "Insert your text here"

        self.finished = False

        textbox(gnexp + msg, title, text_snippet, False,
                callback=self.check_answer, run=True)

    def check_answer(self, box):
        

        if self.finished:
            box.stop()

        if box.text.lower().count("a") >= 5:
            box.msg = u"\n\nYou did it right! Press OK button to continue."
            box.stop()
            self.finished
        else:
            box.msg = u"\n\nMore a's are needed!"


class Demo3(object):

    

    def __init__(self):
        

        self.finished = False

        title = "Demo of textbox: Object with callback"

        msg = ("This is a demo of the textbox set as "
               "an object with a callback, "
               "you can configure it and when you are finished, "
               "you run it.\n\nThere is a typo in it. Find and correct it.")

        text_snippet = "Hello"  

        box = textbox(
            msg, title, text_snippet, False, callback=self.check_answer, run=False)

        box.text = (
            "It was the west of times, and it was the worst of times. "
            "The  rich ate cake, and the poor had cake recommended to them, "
            "but wished only for enough cash to buy bread."
            "The time was ripe for revolution! ")

        box.run()

    def check_answer(self, box):
        
        if self.finished:
            box.stop()

        if "best" in box.text:
            box.msg = u"\n\nYou did right! Press OK button to continue."
            self.finished = True
        else:
            box.msg = u"\n\nLook to the west!"


def textbox(msg="", title=" ", text="",
            codebox=False, callback=None, run=True):
    

    tb = TextBox(msg=msg, title=title, text=text,
                 codebox=codebox, callback=callback)
    if not run:
        return tb
    else:
        reply = tb.run()
        return reply


class TextBox(object):

    

    def __init__(self, msg, title, text, codebox, callback=lambda *args, **kwargs: True):
        

        self.callback = callback
        self.ui = GUItk(msg, title, text, codebox, self.callback_ui)
        self.text = text

    def run(self):
        
        self.ui.run()
        self.ui = None
        return self._text

    def stop(self):
        
        self.ui.stop()

    def callback_ui(self, ui, command, text):
        
        if command == 'update':  
            self._text = text
            if self.callback:
                
                self.callback(self)
            else:
                self.stop()
        elif command == 'x':
            self.stop()
            self._text = None
        elif command == 'cancel':
            self.stop()
            self._text = None

    
    @property
    def text(self):
        
        return self._text

    @text.setter
    def text(self, text):
        self._text = self.to_string(text)
        self.ui.set_text(self._text)

    @text.deleter
    def text(self):
        self._text = ""
        self.ui.set_text(self._text)

    @property
    def msg(self):
        
        return self._msg

    @msg.setter
    def msg(self, msg):
        self._msg = self.to_string(msg)
        self.ui.set_msg(self._msg)

    @msg.deleter
    def msg(self):
        self._msg = ""
        self.ui.set_msg(self._msg)

    

    def to_string(self, something):
        try:
            basestring  
        except NameError:
            basestring = str  

        if isinstance(something, basestring):
            return something
        try:
            text = "".join(something)  
        except:
            textbox(
                "Exception when trying to convert {} to text in self.textArea"
                .format(type(something)))
            sys.exit(16)
        return text


class GUItk(object):

    

    def __init__(self, msg, title, text, codebox, callback):
        

        self.callback = callback

        self.boxRoot = tk.Tk()
        
        
        

        wrap_text = not codebox
        if wrap_text:
            self.boxFont = tk_Font.nametofont("TkTextFont")
            self.width_in_chars = global_state.prop_font_line_length
        else:
            self.boxFont = tk_Font.nametofont("TkFixedFont")
            self.width_in_chars = global_state.fixw_font_line_length

        

        self.configure_root(title)

        self.create_msg_widget(msg)

        self.create_text_area(wrap_text)

        self.create_buttons_frame()

        self.create_cancel_button()

        self.create_ok_button()

    

    def run(self):
        self.boxRoot.mainloop()
        self.boxRoot.destroy()

    def stop(self):
        
        self.get_pos()
        self.boxRoot.quit()

    

    def set_msg(self, msg):
        self.messageArea.config(state=tk.NORMAL)
        self.messageArea.delete(1.0, tk.END)
        self.messageArea.insert(tk.END, msg)
        self.messageArea.config(state=tk.DISABLED)
        
        self.messageArea.update()
        numlines = self.get_num_lines(self.messageArea)
        self.set_msg_height(numlines)
        self.messageArea.update()

    def set_msg_height(self, numlines):
        self.messageArea.configure(height=numlines)

    def get_num_lines(self, widget):
        end_position = widget.index(tk.END)  
        end_line = end_position.split('.')[0]  
        return int(end_line)  

    def set_text(self, text):
        self.textArea.delete(1.0, tk.END)
        self.textArea.insert(tk.END, text, "normal")
        self.textArea.focus()

    def set_pos(self, pos):
        self.boxRoot.geometry(pos)

    def get_pos(self):
        
        
        
        
        geom = self.boxRoot.geometry()  
        global_state.window_position = '+' + geom.split('+', 1)[1]

    def get_text(self):
        return self.textArea.get(0.0, 'end-1c')

    
    def x_pressed(self):
        self.callback(self, command='x', text=self.get_text())

    def cancel_pressed(self, event):
        self.callback(self, command='cancel', text=self.get_text())

    def ok_button_pressed(self, event):
        self.callback(self, command='update', text=self.get_text())

    
    def calc_character_width(self):
        char_width = self.boxFont.measure('W')
        return char_width

    
    

    def configure_root(self, title):

        self.boxRoot.title(title)

        self.set_pos(global_state.window_position)

        
        self.boxRoot.protocol('WM_DELETE_WINDOW', self.x_pressed)
        self.boxRoot.bind("<Escape>", self.cancel_pressed)

        self.boxRoot.iconname('Dialog')

        self.boxRoot.attributes("-topmost", True)  

    def create_msg_widget(self, msg):

        if msg is None:
            msg = ""

        self.msgFrame = tk.Frame(
            self.boxRoot,
            padx=1.25 * self.calc_character_width(),

        )
        self.messageArea = tk.Text(
            self.msgFrame,
            width=self.width_in_chars,
            state=tk.DISABLED,
            padx=(global_state.default_hpad_in_chars) *
            self.calc_character_width(),
            pady=self.calc_character_width(),
            wrap=tk.WORD,

        )
        self.set_msg(msg)

        self.msgFrame.pack(fill='x')

        self.messageArea.pack(fill='x')

    def create_text_area(self, wrap_text):
        

        self.textFrame = tk.Frame(
            self.boxRoot,
            padx=1.25 * self.calc_character_width(),
        )

        self.textFrame.pack(side=tk.TOP)
        

        self.textArea = tk.Text(
            self.textFrame,
            padx=global_state.default_hpad_in_chars *
            self.calc_character_width(),
            pady=global_state.default_hpad_in_chars *
            self.calc_character_width(),
            height=25,  
            width=self.width_in_chars,   
        )

        if wrap_text:
            self.textArea.configure(wrap=tk.WORD)
        else:
            self.textArea.configure(wrap=tk.NONE)

        
        self.boxRoot.bind("<Next>", self.textArea.yview_scroll(1, tk.PAGES))
        self.boxRoot.bind(
            "<Prior>", self.textArea.yview_scroll(-1, tk.PAGES))

        self.boxRoot.bind("<Right>", self.textArea.xview_scroll(1, tk.PAGES))
        self.boxRoot.bind("<Left>", self.textArea.xview_scroll(-1, tk.PAGES))

        self.boxRoot.bind("<Down>", self.textArea.yview_scroll(1, tk.UNITS))
        self.boxRoot.bind("<Up>", self.textArea.yview_scroll(-1, tk.UNITS))

        
        rightScrollbar = tk.Scrollbar(
            self.textFrame, orient=tk.VERTICAL, command=self.textArea.yview)
        self.textArea.configure(yscrollcommand=rightScrollbar.set)

        
        bottomScrollbar = tk.Scrollbar(
            self.textFrame, orient=tk.HORIZONTAL, command=self.textArea.xview)
        self.textArea.configure(xscrollcommand=bottomScrollbar.set)

        
        
        

        
        
        

        if not wrap_text:
            bottomScrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        rightScrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.textArea.pack(side=tk.LEFT, fill=tk.BOTH, expand=tk.YES)

    def create_buttons_frame(self):

        self.buttonsFrame = tk.Frame(self.boxRoot,
                                     

                                     )
        self.buttonsFrame.pack(side=tk.TOP)

    def create_cancel_button(self):
        
        self.cancelButton = tk.Button(
            self.buttonsFrame, takefocus=tk.YES, text="Cancel",
            height=1, width=6)
        self.cancelButton.pack(
            expand=tk.NO, side=tk.LEFT, padx='2m', pady='1m', ipady="1m",
            ipadx="2m")

        
        
        self.cancelButton.bind("<Return>", self.cancel_pressed)
        self.cancelButton.bind("<Button-1>", self.cancel_pressed)
        self.cancelButton.bind("<Escape>", self.cancel_pressed)

    def create_ok_button(self):
        
        self.okButton = tk.Button(
            self.buttonsFrame, takefocus=tk.YES, text="OK", height=1, width=6)
        self.okButton.pack(
            expand=tk.NO, side=tk.LEFT, padx='2m', pady='1m', ipady="1m",
            ipadx="2m")

        
        
        self.okButton.bind("<Return>", self.ok_button_pressed)
        self.okButton.bind("<Button-1>", self.ok_button_pressed)


if __name__ == '__main__':
    demo_textbox()
