from __future__ import annotations

import math
from collections.abc import Iterator, Mapping, Sequence
from typing import TYPE_CHECKING, Any, Callable, Generic, Literal, overload

from narwhals._utils import (
    Implementation,
    _validate_rolling_arguments,
    ensure_type,
    generate_repr,
    is_compliant_series,
    is_index_selector,
    supports_arrow_c_stream,
)
from narwhals.dependencies import is_numpy_scalar
from narwhals.dtypes import _validate_dtype
from narwhals.exceptions import ComputeError
from narwhals.series_cat import SeriesCatNamespace
from narwhals.series_dt import SeriesDateTimeNamespace
from narwhals.series_list import SeriesListNamespace
from narwhals.series_str import SeriesStringNamespace
from narwhals.series_struct import SeriesStructNamespace
from narwhals.translate import to_native
from narwhals.typing import IntoSeriesT

if TYPE_CHECKING:
    from types import ModuleType

    import pandas as pd
    import polars as pl
    import pyarrow as pa
    from typing_extensions import Self

    from narwhals._compliant import CompliantSeries
    from narwhals.dataframe import DataFrame, MultiIndexSelector
    from narwhals.dtypes import DType
    from narwhals.typing import (
        ClosedInterval,
        FillNullStrategy,
        IntoDType,
        NonNestedLiteral,
        NumericLiteral,
        RankMethod,
        RollingInterpolationMethod,
        SingleIndexSelector,
        TemporalLiteral,
        _1DArray,
    )


class Series(Generic[IntoSeriesT]):
    

    @property
    def _dataframe(self) -> type[DataFrame[Any]]:
        from narwhals.dataframe import DataFrame

        return DataFrame

    def __init__(
        self, series: Any, *, level: Literal["full", "lazy", "interchange"]
    ) -> None:
        self._level: Literal["full", "lazy", "interchange"] = level
        if is_compliant_series(series):
            self._compliant_series: CompliantSeries[IntoSeriesT] = (
                series.__narwhals_series__()
            )
        else:  
            msg = f"Expected Polars Series or an object which implements `__narwhals_series__`, got: {type(series)}."
            raise AssertionError(msg)

    @property
    def implementation(self) -> Implementation:
        
        return self._compliant_series._implementation

    def __array__(self, dtype: Any = None, copy: bool | None = None) -> _1DArray:  
        return self._compliant_series.__array__(dtype=dtype, copy=copy)

    @overload
    def __getitem__(self, idx: SingleIndexSelector) -> Any: ...

    @overload
    def __getitem__(self, idx: MultiIndexSelector) -> Self: ...

    def __getitem__(self, idx: SingleIndexSelector | MultiIndexSelector) -> Any | Self:
        
        if isinstance(idx, int) or (
            is_numpy_scalar(idx) and idx.dtype.kind in {"i", "u"}
        ):
            idx = int(idx) if not isinstance(idx, int) else idx
            return self._compliant_series.item(idx)

        if isinstance(idx, self.to_native().__class__):
            idx = self._with_compliant(self._compliant_series._with_native(idx))

        if not is_index_selector(idx):
            msg = (
                f"Unexpected type for `Series.__getitem__`: {type(idx)}.\n\n"
                "Hints:\n"
                "- use `s.item` to select a single item.\n"
                "- Use `s[indices]` to select rows positionally.\n"
                "- Use `s.filter(mask)` to filter rows based on a boolean mask."
            )
            raise TypeError(msg)
        if isinstance(idx, Series):
            return self._with_compliant(self._compliant_series[idx._compliant_series])
        assert not isinstance(idx, int)  
        return self._with_compliant(self._compliant_series[idx])

    def __native_namespace__(self) -> ModuleType:
        return self._compliant_series.__native_namespace__()

    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object:
        
        native_series = self._compliant_series.native
        if supports_arrow_c_stream(native_series):
            return native_series.__arrow_c_stream__(requested_schema=requested_schema)
        try:
            pa_version = Implementation.PYARROW._backend_version()
        except ModuleNotFoundError as exc:  
            msg = f"'pyarrow>=16.0.0' is required for `Series.__arrow_c_stream__` for object of type {type(native_series)}"
            raise ModuleNotFoundError(msg) from exc
        if pa_version < (16, 0):  
            msg = f"'pyarrow>=16.0.0' is required for `Series.__arrow_c_stream__` for object of type {type(native_series)}"
            raise ModuleNotFoundError(msg)
        from narwhals._arrow.utils import chunked_array

        ca = chunked_array(self.to_arrow())
        return ca.__arrow_c_stream__(requested_schema=requested_schema)

    def to_native(self) -> IntoSeriesT:
        
        return self._compliant_series.native

    def scatter(self, indices: int | Sequence[int], values: Any) -> Self:
        
        return self._with_compliant(
            self._compliant_series.scatter(indices, self._extract_native(values))
        )

    @property
    def shape(self) -> tuple[int]:
        
        return (self._compliant_series.len(),)

    def _extract_native(self, arg: Any) -> Any:
        from narwhals.series import Series

        if isinstance(arg, Series):
            return arg._compliant_series
        return arg

    def _with_compliant(self, series: Any) -> Self:
        return self.__class__(series, level=self._level)

    def pipe(self, function: Callable[[Any], Self], *args: Any, **kwargs: Any) -> Self:
        
        return function(self, *args, **kwargs)

    def __repr__(self) -> str:  
        return generate_repr("Narwhals Series", self.to_native().__repr__())

    def __len__(self) -> int:
        return len(self._compliant_series)

    def len(self) -> int:
        r
        return len(self._compliant_series)

    @property
    def dtype(self) -> DType:
        
        return self._compliant_series.dtype

    @property
    def name(self) -> str:
        
        return self._compliant_series.name

    def ewm_mean(
        self,
        *,
        com: float | None = None,
        span: float | None = None,
        half_life: float | None = None,
        alpha: float | None = None,
        adjust: bool = True,
        min_samples: int = 1,
        ignore_nulls: bool = False,
    ) -> Self:
        r
        return self._with_compliant(
            self._compliant_series.ewm_mean(
                com=com,
                span=span,
                half_life=half_life,
                alpha=alpha,
                adjust=adjust,
                min_samples=min_samples,
                ignore_nulls=ignore_nulls,
            )
        )

    def cast(self, dtype: IntoDType) -> Self:
        
        _validate_dtype(dtype)
        return self._with_compliant(self._compliant_series.cast(dtype))

    def to_frame(self) -> DataFrame[Any]:
        
        return self._dataframe(self._compliant_series.to_frame(), level=self._level)

    def to_list(self) -> list[Any]:
        
        return self._compliant_series.to_list()

    def mean(self) -> float:
        
        return self._compliant_series.mean()

    def median(self) -> float:
        
        return self._compliant_series.median()

    def skew(self) -> float | None:
        
        return self._compliant_series.skew()

    def kurtosis(self) -> float | None:
        
        return self._compliant_series.kurtosis()

    def count(self) -> int:
        
        return self._compliant_series.count()

    def any(self) -> bool:
        
        return self._compliant_series.any()

    def all(self) -> bool:
        
        return self._compliant_series.all()

    def min(self) -> Any:
        
        return self._compliant_series.min()

    def max(self) -> Any:
        
        return self._compliant_series.max()

    def arg_min(self) -> int:
        
        return self._compliant_series.arg_min()

    def arg_max(self) -> int:
        
        return self._compliant_series.arg_max()

    def sum(self) -> float:
        
        return self._compliant_series.sum()

    def std(self, *, ddof: int = 1) -> float:
        
        return self._compliant_series.std(ddof=ddof)

    def var(self, *, ddof: int = 1) -> float:
        
        return self._compliant_series.var(ddof=ddof)

    def clip(
        self,
        lower_bound: Self | NumericLiteral | TemporalLiteral | None = None,
        upper_bound: Self | NumericLiteral | TemporalLiteral | None = None,
    ) -> Self:
        r
        return self._with_compliant(
            self._compliant_series.clip(
                lower_bound=self._extract_native(lower_bound),
                upper_bound=self._extract_native(upper_bound),
            )
        )

    def is_in(self, other: Any) -> Self:
        
        return self._with_compliant(
            self._compliant_series.is_in(to_native(other, pass_through=True))
        )

    def arg_true(self) -> Self:
        
        return self._with_compliant(self._compliant_series.arg_true())

    def drop_nulls(self) -> Self:
        
        return self._with_compliant(self._compliant_series.drop_nulls())

    def abs(self) -> Self:
        
        return self._with_compliant(self._compliant_series.abs())

    def cum_sum(self, *, reverse: bool = False) -> Self:
        
        return self._with_compliant(self._compliant_series.cum_sum(reverse=reverse))

    def unique(self, *, maintain_order: bool = False) -> Self:
        
        return self._with_compliant(
            self._compliant_series.unique(maintain_order=maintain_order)
        )

    def diff(self) -> Self:
        
        return self._with_compliant(self._compliant_series.diff())

    def shift(self, n: int) -> Self:
        
        ensure_type(n, int, param_name="n")

        return self._with_compliant(self._compliant_series.shift(n))

    def sample(
        self,
        n: int | None = None,
        *,
        fraction: float | None = None,
        with_replacement: bool = False,
        seed: int | None = None,
    ) -> Self:
        
        return self._with_compliant(
            self._compliant_series.sample(
                n=n, fraction=fraction, with_replacement=with_replacement, seed=seed
            )
        )

    def alias(self, name: str) -> Self:
        
        return self._with_compliant(self._compliant_series.alias(name=name))

    def rename(self, name: str) -> Self:
        
        return self.alias(name=name)

    def replace_strict(
        self,
        old: Sequence[Any] | Mapping[Any, Any],
        new: Sequence[Any] | None = None,
        *,
        return_dtype: IntoDType | None = None,
    ) -> Self:
        
        if new is None:
            if not isinstance(old, Mapping):
                msg = "`new` argument is required if `old` argument is not a Mapping type"
                raise TypeError(msg)

            new = list(old.values())
            old = list(old.keys())

        return self._with_compliant(
            self._compliant_series.replace_strict(old, new, return_dtype=return_dtype)
        )

    def sort(self, *, descending: bool = False, nulls_last: bool = False) -> Self:
        
        return self._with_compliant(
            self._compliant_series.sort(descending=descending, nulls_last=nulls_last)
        )

    def is_null(self) -> Self:
        
        return self._with_compliant(self._compliant_series.is_null())

    def is_nan(self) -> Self:
        
        return self._with_compliant(self._compliant_series.is_nan())

    def fill_null(
        self,
        value: Self | NonNestedLiteral = None,
        strategy: FillNullStrategy | None = None,
        limit: int | None = None,
    ) -> Self:
        
        if value is not None and strategy is not None:
            msg = "cannot specify both `value` and `strategy`"
            raise ValueError(msg)
        if value is None and strategy is None:
            msg = "must specify either a fill `value` or `strategy`"
            raise ValueError(msg)
        if strategy is not None and strategy not in {"forward", "backward"}:
            msg = f"strategy not supported: {strategy}"
            raise ValueError(msg)
        return self._with_compliant(
            self._compliant_series.fill_null(
                value=self._extract_native(value), strategy=strategy, limit=limit
            )
        )

    def is_between(
        self,
        lower_bound: Any | Self,
        upper_bound: Any | Self,
        closed: ClosedInterval = "both",
    ) -> Self:
        
        return self._with_compliant(
            self._compliant_series.is_between(
                self._extract_native(lower_bound),
                self._extract_native(upper_bound),
                closed=closed,
            )
        )

    def n_unique(self) -> int:
        
        return self._compliant_series.n_unique()

    def to_numpy(self) -> _1DArray:
        
        return self._compliant_series.to_numpy(None, copy=None)

    def to_pandas(self) -> pd.Series[Any]:
        
        return self._compliant_series.to_pandas()

    def to_polars(self) -> pl.Series:
        
        return self._compliant_series.to_polars()

    def __add__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__add__(self._extract_native(other))
        )

    def __radd__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__radd__(self._extract_native(other))
        )

    def __sub__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__sub__(self._extract_native(other))
        )

    def __rsub__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__rsub__(self._extract_native(other))
        )

    def __mul__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__mul__(self._extract_native(other))
        )

    def __rmul__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__rmul__(self._extract_native(other))
        )

    def __truediv__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__truediv__(self._extract_native(other))
        )

    def __rtruediv__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__rtruediv__(self._extract_native(other))
        )

    def __floordiv__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__floordiv__(self._extract_native(other))
        )

    def __rfloordiv__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__rfloordiv__(self._extract_native(other))
        )

    def __pow__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__pow__(self._extract_native(other))
        )

    def __rpow__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__rpow__(self._extract_native(other))
        )

    def __mod__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__mod__(self._extract_native(other))
        )

    def __rmod__(self, other: object) -> Self:
        return self._with_compliant(
            self._compliant_series.__rmod__(self._extract_native(other))
        )

    def __eq__(self, other: object) -> Self:  
        return self._with_compliant(
            self._compliant_series.__eq__(self._extract_native(other))
        )

    def __ne__(self, other: object) -> Self:  
        return self._with_compliant(
            self._compliant_series.__ne__(self._extract_native(other))
        )

    def __gt__(self, other: Any) -> Self:
        return self._with_compliant(
            self._compliant_series.__gt__(self._extract_native(other))
        )

    def __ge__(self, other: Any) -> Self:
        return self._with_compliant(
            self._compliant_series.__ge__(self._extract_native(other))
        )

    def __lt__(self, other: Any) -> Self:
        return self._with_compliant(
            self._compliant_series.__lt__(self._extract_native(other))
        )

    def __le__(self, other: Any) -> Self:
        return self._with_compliant(
            self._compliant_series.__le__(self._extract_native(other))
        )

    def __and__(self, other: Any) -> Self:
        return self._with_compliant(
            self._compliant_series.__and__(self._extract_native(other))
        )

    def __rand__(self, other: Any) -> Self:
        return self._with_compliant(
            self._compliant_series.__rand__(self._extract_native(other))
        )

    def __or__(self, other: Any) -> Self:
        return self._with_compliant(
            self._compliant_series.__or__(self._extract_native(other))
        )

    def __ror__(self, other: Any) -> Self:
        return self._with_compliant(
            self._compliant_series.__ror__(self._extract_native(other))
        )

    
    def __invert__(self) -> Self:
        return self._with_compliant(self._compliant_series.__invert__())

    def filter(self, predicate: Any) -> Self:
        
        return self._with_compliant(
            self._compliant_series.filter(self._extract_native(predicate))
        )

    
    def is_duplicated(self) -> Self:
        r
        return ~self.is_unique()

    def is_empty(self) -> bool:
        r
        return self._compliant_series.len() == 0

    def is_unique(self) -> Self:
        r
        return self._with_compliant(self._compliant_series.is_unique())

    def null_count(self) -> int:
        r
        return self._compliant_series.null_count()

    def is_first_distinct(self) -> Self:
        r
        return self._with_compliant(self._compliant_series.is_first_distinct())

    def is_last_distinct(self) -> Self:
        r
        return self._with_compliant(self._compliant_series.is_last_distinct())

    def is_sorted(self, *, descending: bool = False) -> bool:
        r
        return self._compliant_series.is_sorted(descending=descending)

    def value_counts(
        self,
        *,
        sort: bool = False,
        parallel: bool = False,
        name: str | None = None,
        normalize: bool = False,
    ) -> DataFrame[Any]:
        r
        return self._dataframe(
            self._compliant_series.value_counts(
                sort=sort, parallel=parallel, name=name, normalize=normalize
            ),
            level=self._level,
        )

    def quantile(
        self, quantile: float, interpolation: RollingInterpolationMethod
    ) -> float:
        
        return self._compliant_series.quantile(
            quantile=quantile, interpolation=interpolation
        )

    def zip_with(self, mask: Self, other: Self) -> Self:
        
        return self._with_compliant(
            self._compliant_series.zip_with(
                self._extract_native(mask), self._extract_native(other)
            )
        )

    def item(self, index: int | None = None) -> Any:
        r
        return self._compliant_series.item(index=index)

    def head(self, n: int = 10) -> Self:
        r
        return self._with_compliant(self._compliant_series.head(n))

    def tail(self, n: int = 10) -> Self:
        r
        return self._with_compliant(self._compliant_series.tail(n))

    def round(self, decimals: int = 0) -> Self:
        r
        return self._with_compliant(self._compliant_series.round(decimals))

    def to_dummies(
        self, *, separator: str = "_", drop_first: bool = False
    ) -> DataFrame[Any]:
        r
        return self._dataframe(
            self._compliant_series.to_dummies(separator=separator, drop_first=drop_first),
            level=self._level,
        )

    def gather_every(self, n: int, offset: int = 0) -> Self:
        r
        return self._with_compliant(
            self._compliant_series.gather_every(n=n, offset=offset)
        )

    def to_arrow(self) -> pa.Array[Any]:
        r
        return self._compliant_series.to_arrow()

    def mode(self) -> Self:
        r
        return self._with_compliant(self._compliant_series.mode())

    def is_finite(self) -> Self:
        
        return self._with_compliant(self._compliant_series.is_finite())

    def cum_count(self, *, reverse: bool = False) -> Self:
        r
        return self._with_compliant(self._compliant_series.cum_count(reverse=reverse))

    def cum_min(self, *, reverse: bool = False) -> Self:
        r
        return self._with_compliant(self._compliant_series.cum_min(reverse=reverse))

    def cum_max(self, *, reverse: bool = False) -> Self:
        r
        return self._with_compliant(self._compliant_series.cum_max(reverse=reverse))

    def cum_prod(self, *, reverse: bool = False) -> Self:
        r
        return self._with_compliant(self._compliant_series.cum_prod(reverse=reverse))

    def rolling_sum(
        self, window_size: int, *, min_samples: int | None = None, center: bool = False
    ) -> Self:
        
        window_size, min_samples_int = _validate_rolling_arguments(
            window_size=window_size, min_samples=min_samples
        )

        if len(self) == 0:  
            return self

        return self._with_compliant(
            self._compliant_series.rolling_sum(
                window_size=window_size, min_samples=min_samples_int, center=center
            )
        )

    def rolling_mean(
        self, window_size: int, *, min_samples: int | None = None, center: bool = False
    ) -> Self:
        
        window_size, min_samples = _validate_rolling_arguments(
            window_size=window_size, min_samples=min_samples
        )

        if len(self) == 0:  
            return self

        return self._with_compliant(
            self._compliant_series.rolling_mean(
                window_size=window_size, min_samples=min_samples, center=center
            )
        )

    def rolling_var(
        self,
        window_size: int,
        *,
        min_samples: int | None = None,
        center: bool = False,
        ddof: int = 1,
    ) -> Self:
        
        window_size, min_samples = _validate_rolling_arguments(
            window_size=window_size, min_samples=min_samples
        )

        if len(self) == 0:  
            return self

        return self._with_compliant(
            self._compliant_series.rolling_var(
                window_size=window_size, min_samples=min_samples, center=center, ddof=ddof
            )
        )

    def rolling_std(
        self,
        window_size: int,
        *,
        min_samples: int | None = None,
        center: bool = False,
        ddof: int = 1,
    ) -> Self:
        
        window_size, min_samples = _validate_rolling_arguments(
            window_size=window_size, min_samples=min_samples
        )

        if len(self) == 0:  
            return self

        return self._with_compliant(
            self._compliant_series.rolling_std(
                window_size=window_size, min_samples=min_samples, center=center, ddof=ddof
            )
        )

    def __iter__(self) -> Iterator[Any]:
        yield from self._compliant_series.__iter__()

    def __contains__(self, other: Any) -> bool:
        return self._compliant_series.__contains__(other)

    def rank(self, method: RankMethod = "average", *, descending: bool = False) -> Self:
        
        supported_rank_methods = {"average", "min", "max", "dense", "ordinal"}
        if method not in supported_rank_methods:
            msg = (
                "Ranking method must be one of {'average', 'min', 'max', 'dense', 'ordinal'}. "
                f"Found '{method}'"
            )
            raise ValueError(msg)

        return self._with_compliant(
            self._compliant_series.rank(method=method, descending=descending)
        )

    def hist(
        self,
        bins: list[float] | None = None,
        *,
        bin_count: int | None = None,
        include_breakpoint: bool = True,
    ) -> DataFrame[Any]:
        
        if bins is not None:
            if any(bins[i - 1] >= bins[i] for i in range(1, len(bins))):
                msg = "bins must increase monotonically"
                raise ComputeError(msg)
            if bin_count is not None:
                msg = f"can only provide one of `bin_count` or `bins`, got: {bin_count=}, {bins=}"
                raise ComputeError(msg)
            result = self._compliant_series.hist_from_bins(
                bins=bins, include_breakpoint=include_breakpoint
            )
        else:
            
            default = 10
            bin_count = default if bin_count is None else bin_count
            result = self._compliant_series.hist_from_bin_count(
                bin_count=bin_count, include_breakpoint=include_breakpoint
            )

        return self._dataframe(result, level=self._level)

    def log(self, base: float = math.e) -> Self:
        r
        return self._with_compliant(self._compliant_series.log(base=base))

    def exp(self) -> Self:
        r
        return self._with_compliant(self._compliant_series.exp())

    def sqrt(self) -> Self:
        r
        return self._with_compliant(self._compliant_series.sqrt())

    @property
    def str(self) -> SeriesStringNamespace[Self]:
        return SeriesStringNamespace(self)

    @property
    def dt(self) -> SeriesDateTimeNamespace[Self]:
        return SeriesDateTimeNamespace(self)

    @property
    def cat(self) -> SeriesCatNamespace[Self]:
        return SeriesCatNamespace(self)

    @property
    def list(self) -> SeriesListNamespace[Self]:
        return SeriesListNamespace(self)

    @property
    def struct(self) -> SeriesStructNamespace[Self]:
        return SeriesStructNamespace(self)
