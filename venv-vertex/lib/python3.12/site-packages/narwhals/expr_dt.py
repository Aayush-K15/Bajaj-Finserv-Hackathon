from __future__ import annotations

from typing import TYPE_CHECKING, Generic, TypeVar

if TYPE_CHECKING:
    from narwhals.expr import Expr
    from narwhals.typing import TimeUnit

ExprT = TypeVar("ExprT", bound="Expr")


class ExprDateTimeNamespace(Generic[ExprT]):
    def __init__(self, expr: ExprT) -> None:
        self._expr = expr

    def date(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.date()
        )

    def year(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.year()
        )

    def month(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.month()
        )

    def day(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.day()
        )

    def hour(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.hour()
        )

    def minute(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.minute()
        )

    def second(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.second()
        )

    def millisecond(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.millisecond()
        )

    def microsecond(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.microsecond()
        )

    def nanosecond(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.nanosecond()
        )

    def ordinal_day(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.ordinal_day()
        )

    def weekday(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.weekday()
        )

    def total_minutes(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.total_minutes()
        )

    def total_seconds(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.total_seconds()
        )

    def total_milliseconds(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.total_milliseconds()
        )

    def total_microseconds(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.total_microseconds()
        )

    def total_nanoseconds(self) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.total_nanoseconds()
        )

    def to_string(self, format: str) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.to_string(format)
        )

    def replace_time_zone(self, time_zone: str | None) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.replace_time_zone(time_zone)
        )

    def convert_time_zone(self, time_zone: str) -> ExprT:
        
        if time_zone is None:
            msg = "Target `time_zone` cannot be `None` in `convert_time_zone`. Please use `replace_time_zone(None)` if you want to remove the time zone."
            raise TypeError(msg)
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.convert_time_zone(time_zone)
        )

    def timestamp(self, time_unit: TimeUnit = "us") -> ExprT:
        
        if time_unit not in {"ns", "us", "ms"}:
            msg = (
                "invalid `time_unit`"
                f"\n\nExpected one of {{'ns', 'us', 'ms'}}, got {time_unit!r}."
            )
            raise ValueError(msg)
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.timestamp(time_unit)
        )

    def truncate(self, every: str) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.truncate(every)
        )

    def offset_by(self, by: str) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).dt.offset_by(by)
        )
