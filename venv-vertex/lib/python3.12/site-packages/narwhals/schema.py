

from __future__ import annotations

from collections import OrderedDict
from functools import partial
from typing import TYPE_CHECKING, cast

from narwhals._utils import Implementation, Version

if TYPE_CHECKING:
    from collections.abc import Iterable, Mapping
    from typing import Any, ClassVar

    import polars as pl
    import pyarrow as pa

    from narwhals.dtypes import DType
    from narwhals.typing import DTypeBackend


__all__ = ["Schema"]


class Schema(OrderedDict[str, "DType"]):
    

    _version: ClassVar[Version] = Version.MAIN

    def __init__(
        self, schema: Mapping[str, DType] | Iterable[tuple[str, DType]] | None = None
    ) -> None:
        schema = schema or {}
        super().__init__(schema)

    def names(self) -> list[str]:
        
        return list(self.keys())

    def dtypes(self) -> list[DType]:
        
        return list(self.values())

    def len(self) -> int:
        
        return len(self)

    def to_arrow(self) -> pa.Schema:
        
        import pyarrow as pa  

        from narwhals._arrow.utils import narwhals_to_native_dtype

        return pa.schema(
            (name, narwhals_to_native_dtype(dtype, self._version))
            for name, dtype in self.items()
        )

    def to_pandas(
        self, dtype_backend: DTypeBackend | Iterable[DTypeBackend] = None
    ) -> dict[str, Any]:
        
        from narwhals._pandas_like.utils import narwhals_to_native_dtype

        to_native_dtype = partial(
            narwhals_to_native_dtype,
            implementation=Implementation.PANDAS,
            version=self._version,
        )
        if dtype_backend is None or isinstance(dtype_backend, str):
            return {
                name: to_native_dtype(dtype=dtype, dtype_backend=dtype_backend)
                for name, dtype in self.items()
            }
        else:
            backends = tuple(dtype_backend)
            if len(backends) != len(self):
                from itertools import chain, islice, repeat

                n_user, n_actual = len(backends), len(self)
                suggestion = tuple(
                    islice(
                        chain.from_iterable(islice(repeat(backends), n_actual)), n_actual
                    )
                )
                msg = (
                    f"Provided {n_user!r} `dtype_backend`(s), but schema contains {n_actual!r} field(s).\n"
                    "Hint: instead of\n"
                    f"    schema.to_pandas({backends})\n"
                    "you may want to use\n"
                    f"    schema.to_pandas({backends[0]})\n"
                    f"or\n"
                    f"    schema.to_pandas({suggestion})"
                )
                raise ValueError(msg)
            return {
                name: to_native_dtype(dtype=dtype, dtype_backend=backend)
                for name, dtype, backend in zip(self.keys(), self.values(), backends)
            }

    def to_polars(self) -> pl.Schema:
        
        import polars as pl  

        from narwhals._polars.utils import narwhals_to_native_dtype

        pl_version = Implementation.POLARS._backend_version()
        schema = (
            (name, narwhals_to_native_dtype(dtype, self._version))
            for name, dtype in self.items()
        )
        return (
            pl.Schema(schema)
            if pl_version >= (1, 0, 0)
            else cast("pl.Schema", dict(schema))
        )
