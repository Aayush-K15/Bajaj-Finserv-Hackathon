from __future__ import annotations

import math
from collections.abc import Iterable, Mapping, Sequence
from typing import TYPE_CHECKING, Any, Callable

from narwhals._expression_parsing import (
    ExprMetadata,
    apply_n_ary_operation,
    combine_metadata,
    extract_compliant,
)
from narwhals._utils import _validate_rolling_arguments, ensure_type, flatten
from narwhals.dtypes import _validate_dtype
from narwhals.exceptions import InvalidOperationError
from narwhals.expr_cat import ExprCatNamespace
from narwhals.expr_dt import ExprDateTimeNamespace
from narwhals.expr_list import ExprListNamespace
from narwhals.expr_name import ExprNameNamespace
from narwhals.expr_str import ExprStringNamespace
from narwhals.expr_struct import ExprStructNamespace
from narwhals.translate import to_native

if TYPE_CHECKING:
    from typing import TypeVar

    from typing_extensions import Concatenate, ParamSpec, Self, TypeAlias

    from narwhals._compliant import CompliantExpr, CompliantNamespace
    from narwhals.dtypes import DType
    from narwhals.typing import (
        ClosedInterval,
        FillNullStrategy,
        IntoDType,
        IntoExpr,
        NonNestedLiteral,
        NumericLiteral,
        RankMethod,
        RollingInterpolationMethod,
        TemporalLiteral,
    )

    PS = ParamSpec("PS")
    R = TypeVar("R")
    _ToCompliant: TypeAlias = Callable[
        [CompliantNamespace[Any, Any]], CompliantExpr[Any, Any]
    ]


class Expr:
    def __init__(self, to_compliant_expr: _ToCompliant, metadata: ExprMetadata) -> None:
        
        def func(plx: CompliantNamespace[Any, Any]) -> CompliantExpr[Any, Any]:
            result = to_compliant_expr(plx)
            result._metadata = self._metadata
            return result

        self._to_compliant_expr: _ToCompliant = func
        self._metadata = metadata

    def _with_elementwise(self, to_compliant_expr: Callable[[Any], Any]) -> Self:
        return self.__class__(to_compliant_expr, self._metadata.with_elementwise_op())

    def _with_aggregation(self, to_compliant_expr: Callable[[Any], Any]) -> Self:
        return self.__class__(to_compliant_expr, self._metadata.with_aggregation())

    def _with_orderable_aggregation(
        self, to_compliant_expr: Callable[[Any], Any]
    ) -> Self:
        return self.__class__(
            to_compliant_expr, self._metadata.with_orderable_aggregation()
        )

    def _with_orderable_window(self, to_compliant_expr: Callable[[Any], Any]) -> Self:
        return self.__class__(to_compliant_expr, self._metadata.with_orderable_window())

    def _with_window(self, to_compliant_expr: Callable[[Any], Any]) -> Self:
        return self.__class__(to_compliant_expr, self._metadata.with_window())

    def _with_filtration(self, to_compliant_expr: Callable[[Any], Any]) -> Self:
        return self.__class__(to_compliant_expr, self._metadata.with_filtration())

    def _with_orderable_filtration(self, to_compliant_expr: Callable[[Any], Any]) -> Self:
        return self.__class__(
            to_compliant_expr, self._metadata.with_orderable_filtration()
        )

    def __repr__(self) -> str:
        return f"Narwhals Expr\nmetadata: {self._metadata}\n"

    def _taxicab_norm(self) -> Self:
        
        
        return self._with_aggregation(
            lambda plx: self._to_compliant_expr(plx).abs().sum()
        )

    
    def alias(self, name: str) -> Self:
        
        
        return self.__class__(
            lambda plx: self._to_compliant_expr(plx).alias(name), self._metadata
        )

    def pipe(
        self,
        function: Callable[Concatenate[Self, PS], R],
        *args: PS.args,
        **kwargs: PS.kwargs,
    ) -> R:
        
        return function(self, *args, **kwargs)

    def cast(self, dtype: IntoDType) -> Self:
        
        _validate_dtype(dtype)
        return self._with_elementwise(
            lambda plx: self._to_compliant_expr(plx).cast(dtype)
        )

    
    def __eq__(self, other: Self | Any) -> Self:  
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x == y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __ne__(self, other: Self | Any) -> Self:  
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x != y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __and__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x & y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __rand__(self, other: Any) -> Self:
        return (self & other).alias("literal")  

    def __or__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x | y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __ror__(self, other: Any) -> Self:
        return (self | other).alias("literal")  

    def __add__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x + y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __radd__(self, other: Any) -> Self:
        return (self + other).alias("literal")  

    def __sub__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x - y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __rsub__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x.__rsub__(y), self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __truediv__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x / y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __rtruediv__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x.__rtruediv__(y), self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __mul__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x * y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __rmul__(self, other: Any) -> Self:
        return (self * other).alias("literal")  

    def __le__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x <= y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __lt__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x < y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __gt__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x > y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __ge__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x >= y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __pow__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x**y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __rpow__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x.__rpow__(y), self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __floordiv__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x // y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __rfloordiv__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x.__rfloordiv__(y), self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __mod__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x % y, self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    def __rmod__(self, other: Any) -> Self:
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, lambda x, y: x.__rmod__(y), self, other, str_as_lit=True
            ),
            ExprMetadata.from_binary_op(self, other),
        )

    
    def __invert__(self) -> Self:
        return self._with_elementwise(
            lambda plx: self._to_compliant_expr(plx).__invert__()
        )

    def any(self) -> Self:
        
        return self._with_aggregation(lambda plx: self._to_compliant_expr(plx).any())

    def all(self) -> Self:
        
        return self._with_aggregation(lambda plx: self._to_compliant_expr(plx).all())

    def ewm_mean(
        self,
        *,
        com: float | None = None,
        span: float | None = None,
        half_life: float | None = None,
        alpha: float | None = None,
        adjust: bool = True,
        min_samples: int = 1,
        ignore_nulls: bool = False,
    ) -> Self:
        r
        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).ewm_mean(
                com=com,
                span=span,
                half_life=half_life,
                alpha=alpha,
                adjust=adjust,
                min_samples=min_samples,
                ignore_nulls=ignore_nulls,
            )
        )

    def mean(self) -> Self:
        
        return self._with_aggregation(lambda plx: self._to_compliant_expr(plx).mean())

    def median(self) -> Self:
        
        return self._with_aggregation(lambda plx: self._to_compliant_expr(plx).median())

    def std(self, *, ddof: int = 1) -> Self:
        
        return self._with_aggregation(
            lambda plx: self._to_compliant_expr(plx).std(ddof=ddof)
        )

    def var(self, *, ddof: int = 1) -> Self:
        
        return self._with_aggregation(
            lambda plx: self._to_compliant_expr(plx).var(ddof=ddof)
        )

    def map_batches(
        self,
        function: Callable[[Any], CompliantExpr[Any, Any]],
        return_dtype: DType | None = None,
    ) -> Self:
        
        
        return self._with_orderable_filtration(
            lambda plx: self._to_compliant_expr(plx).map_batches(
                function=function, return_dtype=return_dtype
            )
        )

    def skew(self) -> Self:
        
        return self._with_aggregation(lambda plx: self._to_compliant_expr(plx).skew())

    def kurtosis(self) -> Self:
        
        return self._with_aggregation(lambda plx: self._to_compliant_expr(plx).kurtosis())

    def sum(self) -> Expr:
        
        return self._with_aggregation(lambda plx: self._to_compliant_expr(plx).sum())

    def min(self) -> Self:
        
        return self._with_aggregation(lambda plx: self._to_compliant_expr(plx).min())

    def max(self) -> Self:
        
        return self._with_aggregation(lambda plx: self._to_compliant_expr(plx).max())

    def count(self) -> Self:
        
        return self._with_aggregation(lambda plx: self._to_compliant_expr(plx).count())

    def n_unique(self) -> Self:
        
        return self._with_aggregation(lambda plx: self._to_compliant_expr(plx).n_unique())

    def unique(self) -> Self:
        
        return self._with_filtration(lambda plx: self._to_compliant_expr(plx).unique())

    def abs(self) -> Self:
        
        return self._with_elementwise(lambda plx: self._to_compliant_expr(plx).abs())

    def cum_sum(self, *, reverse: bool = False) -> Self:
        
        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).cum_sum(reverse=reverse)
        )

    def diff(self) -> Self:
        
        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).diff()
        )

    def shift(self, n: int) -> Self:
        
        ensure_type(n, int, param_name="n")

        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).shift(n)
        )

    def replace_strict(
        self,
        old: Sequence[Any] | Mapping[Any, Any],
        new: Sequence[Any] | None = None,
        *,
        return_dtype: IntoDType | None = None,
    ) -> Self:
        
        if new is None:
            if not isinstance(old, Mapping):
                msg = "`new` argument is required if `old` argument is not a Mapping type"
                raise TypeError(msg)

            new = list(old.values())
            old = list(old.keys())

        return self._with_elementwise(
            lambda plx: self._to_compliant_expr(plx).replace_strict(
                old, new, return_dtype=return_dtype
            )
        )

    
    def is_between(
        self,
        lower_bound: Any | IntoExpr,
        upper_bound: Any | IntoExpr,
        closed: ClosedInterval = "both",
    ) -> Self:
        

        def func(
            compliant_expr: CompliantExpr[Any, Any],
            lb: CompliantExpr[Any, Any],
            ub: CompliantExpr[Any, Any],
        ) -> CompliantExpr[Any, Any]:
            if closed == "left":
                return (compliant_expr >= lb) & (compliant_expr < ub)
            elif closed == "right":
                return (compliant_expr > lb) & (compliant_expr <= ub)
            elif closed == "none":
                return (compliant_expr > lb) & (compliant_expr < ub)
            return (compliant_expr >= lb) & (compliant_expr <= ub)

        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx, func, self, lower_bound, upper_bound, str_as_lit=False
            ),
            combine_metadata(
                self,
                lower_bound,
                upper_bound,
                str_as_lit=False,
                allow_multi_output=False,
                to_single_output=False,
            ),
        )

    def is_in(self, other: Any) -> Self:
        
        if isinstance(other, Iterable) and not isinstance(other, (str, bytes)):
            return self._with_elementwise(
                lambda plx: self._to_compliant_expr(plx).is_in(
                    to_native(other, pass_through=True)
                )
            )
        else:
            msg = "Narwhals `is_in` doesn't accept expressions as an argument, as opposed to Polars. You should provide an iterable instead."
            raise NotImplementedError(msg)

    def filter(self, *predicates: Any) -> Self:
        
        flat_predicates = flatten(predicates)
        metadata = combine_metadata(
            self,
            *flat_predicates,
            str_as_lit=False,
            allow_multi_output=True,
            to_single_output=False,
        ).with_filtration()
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx,
                lambda *exprs: exprs[0].filter(*exprs[1:]),
                self,
                *flat_predicates,
                str_as_lit=False,
            ),
            metadata,
        )

    def is_null(self) -> Self:
        
        return self._with_elementwise(lambda plx: self._to_compliant_expr(plx).is_null())

    def is_nan(self) -> Self:
        
        return self._with_elementwise(lambda plx: self._to_compliant_expr(plx).is_nan())

    def fill_null(
        self,
        value: Expr | NonNestedLiteral = None,
        strategy: FillNullStrategy | None = None,
        limit: int | None = None,
    ) -> Self:
        
        if value is not None and strategy is not None:
            msg = "cannot specify both `value` and `strategy`"
            raise ValueError(msg)
        if value is None and strategy is None:
            msg = "must specify either a fill `value` or `strategy`"
            raise ValueError(msg)
        if strategy is not None and strategy not in {"forward", "backward"}:
            msg = f"strategy not supported: {strategy}"
            raise ValueError(msg)

        return self.__class__(
            lambda plx: self._to_compliant_expr(plx).fill_null(
                value=extract_compliant(plx, value, str_as_lit=True),
                strategy=strategy,
                limit=limit,
            ),
            self._metadata.with_orderable_window()
            if strategy is not None
            else self._metadata,
        )

    
    def drop_nulls(self) -> Self:
        
        return self._with_filtration(
            lambda plx: self._to_compliant_expr(plx).drop_nulls()
        )

    def over(
        self,
        *partition_by: str | Sequence[str],
        order_by: str | Sequence[str] | None = None,
    ) -> Self:
        
        flat_partition_by = flatten(partition_by)
        flat_order_by = [order_by] if isinstance(order_by, str) else (order_by or [])
        if not flat_partition_by and not flat_order_by:  
            msg = "At least one of `partition_by` or `order_by` must be specified."
            raise ValueError(msg)

        current_meta = self._metadata
        if flat_order_by:
            next_meta = current_meta.with_ordered_over()
        elif not flat_partition_by:  
            msg = "At least one of `partition_by` or `order_by` must be specified."
            raise InvalidOperationError(msg)
        else:
            next_meta = current_meta.with_partitioned_over()

        return self.__class__(
            lambda plx: self._to_compliant_expr(plx).over(
                flat_partition_by, flat_order_by
            ),
            next_meta,
        )

    def is_duplicated(self) -> Self:
        r
        return ~self.is_unique()

    def is_unique(self) -> Self:
        r
        return self._with_window(lambda plx: self._to_compliant_expr(plx).is_unique())

    def null_count(self) -> Self:
        r
        return self._with_aggregation(
            lambda plx: self._to_compliant_expr(plx).null_count()
        )

    def is_first_distinct(self) -> Self:
        r
        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).is_first_distinct()
        )

    def is_last_distinct(self) -> Self:
        r
        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).is_last_distinct()
        )

    def quantile(
        self, quantile: float, interpolation: RollingInterpolationMethod
    ) -> Self:
        r
        return self._with_aggregation(
            lambda plx: self._to_compliant_expr(plx).quantile(quantile, interpolation)
        )

    def round(self, decimals: int = 0) -> Self:
        r
        return self._with_elementwise(
            lambda plx: self._to_compliant_expr(plx).round(decimals)
        )

    def len(self) -> Self:
        r
        return self._with_aggregation(lambda plx: self._to_compliant_expr(plx).len())

    def clip(
        self,
        lower_bound: IntoExpr | NumericLiteral | TemporalLiteral | None = None,
        upper_bound: IntoExpr | NumericLiteral | TemporalLiteral | None = None,
    ) -> Self:
        r
        return self.__class__(
            lambda plx: apply_n_ary_operation(
                plx,
                lambda *exprs: exprs[0].clip(
                    exprs[1] if lower_bound is not None else None,
                    exprs[2] if upper_bound is not None else None,
                ),
                self,
                lower_bound,
                upper_bound,
                str_as_lit=False,
            ),
            combine_metadata(
                self,
                lower_bound,
                upper_bound,
                str_as_lit=False,
                allow_multi_output=False,
                to_single_output=False,
            ),
        )

    def mode(self) -> Self:
        r
        return self._with_filtration(lambda plx: self._to_compliant_expr(plx).mode())

    def is_finite(self) -> Self:
        
        return self._with_elementwise(
            lambda plx: self._to_compliant_expr(plx).is_finite()
        )

    def cum_count(self, *, reverse: bool = False) -> Self:
        r
        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).cum_count(reverse=reverse)
        )

    def cum_min(self, *, reverse: bool = False) -> Self:
        r
        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).cum_min(reverse=reverse)
        )

    def cum_max(self, *, reverse: bool = False) -> Self:
        r
        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).cum_max(reverse=reverse)
        )

    def cum_prod(self, *, reverse: bool = False) -> Self:
        r
        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).cum_prod(reverse=reverse)
        )

    def rolling_sum(
        self, window_size: int, *, min_samples: int | None = None, center: bool = False
    ) -> Self:
        
        window_size, min_samples_int = _validate_rolling_arguments(
            window_size=window_size, min_samples=min_samples
        )

        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).rolling_sum(
                window_size=window_size, min_samples=min_samples_int, center=center
            )
        )

    def rolling_mean(
        self, window_size: int, *, min_samples: int | None = None, center: bool = False
    ) -> Self:
        
        window_size, min_samples = _validate_rolling_arguments(
            window_size=window_size, min_samples=min_samples
        )

        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).rolling_mean(
                window_size=window_size, min_samples=min_samples, center=center
            )
        )

    def rolling_var(
        self,
        window_size: int,
        *,
        min_samples: int | None = None,
        center: bool = False,
        ddof: int = 1,
    ) -> Self:
        
        window_size, min_samples = _validate_rolling_arguments(
            window_size=window_size, min_samples=min_samples
        )

        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).rolling_var(
                window_size=window_size, min_samples=min_samples, center=center, ddof=ddof
            )
        )

    def rolling_std(
        self,
        window_size: int,
        *,
        min_samples: int | None = None,
        center: bool = False,
        ddof: int = 1,
    ) -> Self:
        
        window_size, min_samples = _validate_rolling_arguments(
            window_size=window_size, min_samples=min_samples
        )

        return self._with_orderable_window(
            lambda plx: self._to_compliant_expr(plx).rolling_std(
                window_size=window_size, min_samples=min_samples, center=center, ddof=ddof
            )
        )

    def rank(self, method: RankMethod = "average", *, descending: bool = False) -> Self:
        
        supported_rank_methods = {"average", "min", "max", "dense", "ordinal"}
        if method not in supported_rank_methods:
            msg = (
                "Ranking method must be one of {'average', 'min', 'max', 'dense', 'ordinal'}. "
                f"Found '{method}'"
            )
            raise ValueError(msg)

        return self._with_window(
            lambda plx: self._to_compliant_expr(plx).rank(
                method=method, descending=descending
            )
        )

    def log(self, base: float = math.e) -> Self:
        r
        return self._with_elementwise(
            lambda plx: self._to_compliant_expr(plx).log(base=base)
        )

    def exp(self) -> Self:
        r
        return self._with_elementwise(lambda plx: self._to_compliant_expr(plx).exp())

    def sqrt(self) -> Self:
        r
        return self._with_elementwise(lambda plx: self._to_compliant_expr(plx).sqrt())

    @property
    def str(self) -> ExprStringNamespace[Self]:
        return ExprStringNamespace(self)

    @property
    def dt(self) -> ExprDateTimeNamespace[Self]:
        return ExprDateTimeNamespace(self)

    @property
    def cat(self) -> ExprCatNamespace[Self]:
        return ExprCatNamespace(self)

    @property
    def name(self) -> ExprNameNamespace[Self]:
        return ExprNameNamespace(self)

    @property
    def list(self) -> ExprListNamespace[Self]:
        return ExprListNamespace(self)

    @property
    def struct(self) -> ExprStructNamespace[Self]:
        return ExprStructNamespace(self)


__all__ = ["Expr"]
