from __future__ import annotations

from typing import TYPE_CHECKING, Generic, TypeVar

if TYPE_CHECKING:
    from narwhals.expr import Expr

ExprT = TypeVar("ExprT", bound="Expr")


class ExprStringNamespace(Generic[ExprT]):
    def __init__(self, expr: ExprT) -> None:
        self._expr = expr

    def len_chars(self) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.len_chars()
        )

    def replace(
        self, pattern: str, value: str, *, literal: bool = False, n: int = 1
    ) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.replace(
                pattern, value, literal=literal, n=n
            )
        )

    def replace_all(self, pattern: str, value: str, *, literal: bool = False) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.replace_all(
                pattern, value, literal=literal
            )
        )

    def strip_chars(self, characters: str | None = None) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.strip_chars(characters)
        )

    def starts_with(self, prefix: str) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.starts_with(prefix)
        )

    def ends_with(self, suffix: str) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.ends_with(suffix)
        )

    def contains(self, pattern: str, *, literal: bool = False) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.contains(
                pattern, literal=literal
            )
        )

    def slice(self, offset: int, length: int | None = None) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.slice(
                offset=offset, length=length
            )
        )

    def split(self, by: str) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.split(by=by)
        )

    def head(self, n: int = 5) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.slice(0, n)
        )

    def tail(self, n: int = 5) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.slice(
                offset=-n, length=None
            )
        )

    def to_datetime(self, format: str | None = None) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.to_datetime(format=format)
        )

    def to_date(self, format: str | None = None) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.to_date(format=format)
        )

    def to_uppercase(self) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.to_uppercase()
        )

    def to_lowercase(self) -> ExprT:
        r
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.to_lowercase()
        )

    def zfill(self, width: int) -> ExprT:
        
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).str.zfill(width)
        )
