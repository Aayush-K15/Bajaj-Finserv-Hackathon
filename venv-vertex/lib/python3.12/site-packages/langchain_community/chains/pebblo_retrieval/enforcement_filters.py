

import logging
from typing import Any, List, Optional, Union

from langchain_core.vectorstores import VectorStoreRetriever

from langchain_community.chains.pebblo_retrieval.models import (
    AuthContext,
    SemanticContext,
)

logger = logging.getLogger(__name__)

PINECONE = "Pinecone"
QDRANT = "Qdrant"
PGVECTOR = "PGVector"
PINECONE_VECTOR_STORE = "PineconeVectorStore"

SUPPORTED_VECTORSTORES = {PINECONE, QDRANT, PGVECTOR, PINECONE_VECTOR_STORE}


def clear_enforcement_filters(retriever: VectorStoreRetriever) -> None:
    
    if retriever.vectorstore.__class__.__name__ == PGVECTOR:
        search_kwargs = retriever.search_kwargs
        if "filter" in search_kwargs:
            filters = search_kwargs["filter"]
            _pgvector_clear_pebblo_filters(
                search_kwargs, filters, "authorized_identities"
            )
            _pgvector_clear_pebblo_filters(
                search_kwargs, filters, "pebblo_semantic_topics"
            )
            _pgvector_clear_pebblo_filters(
                search_kwargs, filters, "pebblo_semantic_entities"
            )


def set_enforcement_filters(
    retriever: VectorStoreRetriever,
    auth_context: Optional[AuthContext],
    semantic_context: Optional[SemanticContext],
) -> None:
    
    
    clear_enforcement_filters(retriever)
    if auth_context is not None:
        _set_identity_enforcement_filter(retriever, auth_context)
    if semantic_context is not None:
        _set_semantic_enforcement_filter(retriever, semantic_context)


def _apply_qdrant_semantic_filter(
    search_kwargs: dict, semantic_context: Optional[SemanticContext]
) -> None:
    
    try:
        from qdrant_client.http import models as rest
    except ImportError as e:
        raise ValueError(
            "Could not import `qdrant-client.http` python package. "
            "Please install it with `pip install qdrant-client`."
        ) from e

    
    semantic_filters: List[
        Union[
            rest.FieldCondition,
            rest.IsEmptyCondition,
            rest.IsNullCondition,
            rest.HasIdCondition,
            rest.NestedCondition,
            rest.Filter,
        ]
    ] = []

    if (
        semantic_context is not None
        and semantic_context.pebblo_semantic_topics is not None
    ):
        semantic_topics_filter = rest.FieldCondition(
            key="metadata.pebblo_semantic_topics",
            match=rest.MatchAny(any=semantic_context.pebblo_semantic_topics.deny),
        )
        semantic_filters.append(semantic_topics_filter)
    if (
        semantic_context is not None
        and semantic_context.pebblo_semantic_entities is not None
    ):
        semantic_entities_filter = rest.FieldCondition(
            key="metadata.pebblo_semantic_entities",
            match=rest.MatchAny(any=semantic_context.pebblo_semantic_entities.deny),
        )
        semantic_filters.append(semantic_entities_filter)

    
    if "filter" in search_kwargs:
        existing_filter: rest.Filter = search_kwargs["filter"]

        
        if isinstance(existing_filter, rest.Filter):
            
            if isinstance(existing_filter.must_not, list):
                
                
                new_must_not_conditions: List[
                    Union[
                        rest.FieldCondition,
                        rest.IsEmptyCondition,
                        rest.IsNullCondition,
                        rest.HasIdCondition,
                        rest.NestedCondition,
                        rest.Filter,
                    ]
                ] = []
                
                for condition in existing_filter.must_not:
                    if hasattr(condition, "key"):
                        if condition.key == "metadata.pebblo_semantic_topics":
                            continue
                        if condition.key == "metadata.pebblo_semantic_entities":
                            continue
                        new_must_not_conditions.append(condition)
                
                existing_filter.must_not = new_must_not_conditions
                existing_filter.must_not.extend(semantic_filters)
            else:
                
                existing_filter.must_not = semantic_filters
        else:
            raise TypeError(
                "Using dict as a `filter` is deprecated. "
                "Please use qdrant-client filters directly: "
                "https://qdrant.tech/documentation/concepts/filtering/"
            )
    else:
        
        search_kwargs["filter"] = rest.Filter(must_not=semantic_filters)


def _apply_qdrant_authorization_filter(
    search_kwargs: dict, auth_context: Optional[AuthContext]
) -> None:
    
    try:
        from qdrant_client.http import models as rest
    except ImportError as e:
        raise ValueError(
            "Could not import `qdrant-client.http` python package. "
            "Please install it with `pip install qdrant-client`."
        ) from e

    if auth_context is not None:
        
        identity_enforcement_filter = rest.FieldCondition(
            key="metadata.authorized_identities",
            match=rest.MatchAny(any=auth_context.user_auth),
        )
    else:
        return

    
    if "filter" in search_kwargs:
        existing_filter: rest.Filter = search_kwargs["filter"]

        
        if isinstance(existing_filter, rest.Filter):
            
            if existing_filter.must:
                new_must_conditions: List[
                    Union[
                        rest.FieldCondition,
                        rest.IsEmptyCondition,
                        rest.IsNullCondition,
                        rest.HasIdCondition,
                        rest.NestedCondition,
                        rest.Filter,
                    ]
                ] = []
                
                for condition in existing_filter.must:
                    if (
                        hasattr(condition, "key")
                        and condition.key == "metadata.authorized_identities"
                    ):
                        continue
                    new_must_conditions.append(condition)

                
                existing_filter.must = new_must_conditions
                existing_filter.must.append(identity_enforcement_filter)
            else:
                
                existing_filter.must = [identity_enforcement_filter]
        else:
            raise TypeError(
                "Using dict as a `filter` is deprecated. "
                "Please use qdrant-client filters directly: "
                "https://qdrant.tech/documentation/concepts/filtering/"
            )
    else:
        
        search_kwargs["filter"] = rest.Filter(must=[identity_enforcement_filter])


def _apply_pinecone_semantic_filter(
    search_kwargs: dict, semantic_context: Optional[SemanticContext]
) -> None:
    
    
    semantic_context = semantic_context
    if semantic_context is not None:
        if semantic_context.pebblo_semantic_topics is not None:
            
            search_kwargs.setdefault("filter", {})["pebblo_semantic_topics"] = {
                "$nin": semantic_context.pebblo_semantic_topics.deny
            }

        if semantic_context.pebblo_semantic_entities is not None:
            
            search_kwargs.setdefault("filter", {})["pebblo_semantic_entities"] = {
                "$nin": semantic_context.pebblo_semantic_entities.deny
            }


def _apply_pinecone_authorization_filter(
    search_kwargs: dict, auth_context: Optional[AuthContext]
) -> None:
    
    if auth_context is not None:
        search_kwargs.setdefault("filter", {})["authorized_identities"] = {
            "$in": auth_context.user_auth
        }


def _apply_pgvector_filter(
    search_kwargs: dict, filters: Optional[Any], pebblo_filter: dict
) -> None:
    
    if isinstance(filters, dict):
        if len(filters) == 1:
            
            
            key, value = list(filters.items())[0]
            if key.startswith("$"):
                
                if key.lower() not in ["$and", "$or", "$not"]:
                    raise ValueError(
                        f"Invalid filter condition. Expected $and, $or or $not "
                        f"but got: {key}"
                    )
                if not isinstance(value, list):
                    raise ValueError(
                        f"Expected a list, but got {type(value)} for value: {value}"
                    )

                
                if key.lower() == "$and":
                    
                    value.append(pebblo_filter)
                elif key.lower() == "$not":
                    
                    _key, _value = list(pebblo_filter.items())[0]
                    if _key.startswith("$"):
                        
                        if _key.lower() == "$not":
                            
                            value.append(_value)
                            logger.warning(
                                "Adding $not operator to the existing $not operator"
                            )
                            return
                        else:
                            
                            raise ValueError(
                                f"Invalid filter key. Expected '$not' but got: {_key}"
                            )
                    else:
                        
                        search_kwargs["filter"] = {"$and": [filters, pebblo_filter]}
                        return
                elif key.lower() == "$or":
                    search_kwargs["filter"] = {"$and": [filters, pebblo_filter]}
            else:
                
                
                _key, _ = list(pebblo_filter.items())[0]
                if _key.startswith("$"):
                    
                    if _key.lower() == "$not":
                        
                        search_kwargs["filter"] = {"$and": [filters, pebblo_filter]}
                        return
                    else:
                        
                        raise ValueError(
                            f"Invalid filter key. Expected '$not' but got: {_key}"
                        )
                else:
                    
                    filters.update(pebblo_filter)
                    return
        elif len(filters) > 1:
            
            for key in filters.keys():
                if key.startswith("$"):
                    raise ValueError(
                        f"Invalid filter condition. Expected a field but got: {key}"
                    )
            
            
            _key, _ = list(pebblo_filter.items())[0]
            if _key.startswith("$"):
                
                if _key.lower() == "$not":
                    
                    search_kwargs["filter"] = {"$and": [filters, pebblo_filter]}
                    return
                else:
                    
                    raise ValueError(
                        f"Invalid filter key. Expected '$not' but got: {_key}"
                    )
            else:
                
                filters.update(pebblo_filter)
                return
        else:
            
            search_kwargs.setdefault("filter", {}).update(pebblo_filter)
    elif filters is None:
        
        search_kwargs.setdefault("filter", {}).update(pebblo_filter)
    else:
        raise ValueError(
            f"Invalid filter. Expected a dictionary/None but got type: {type(filters)}"
        )


def _pgvector_clear_pebblo_filters(
    search_kwargs: dict, filters: dict, pebblo_filter_key: str
) -> None:
    
    if isinstance(filters, dict):
        if len(filters) == 1:
            
            
            key, value = list(filters.items())[0]
            if key.startswith("$"):
                
                
                if key.lower() not in ["$and", "$or", "$not"]:
                    raise ValueError(
                        f"Invalid filter condition. Expected $and, $or or $not "
                        f"but got: {key}"
                    )
                elif not isinstance(value, list):
                    raise ValueError(
                        f"Expected a list, but got {type(value)} for value: {value}"
                    )

                
                if key.lower() == "$and":
                    
                    for i, _filter in enumerate(value):
                        if pebblo_filter_key in _filter:
                            
                            value.pop(i)
                            break
                        
                        if "$not" in _filter:
                            sem_filter_found = False
                            
                            for j, nested_filter in enumerate(_filter["$not"]):
                                if pebblo_filter_key in nested_filter:
                                    if len(_filter["$not"]) == 1:
                                        
                                        
                                        value.pop(i)
                                    else:
                                        value[i]["$not"].pop(j)
                                    sem_filter_found = True
                                    break
                            if sem_filter_found:
                                break
                    if len(value) == 1:
                        
                        search_kwargs["filter"] = value[0]
                elif key.lower() == "$not":
                    
                    for i, _filter in enumerate(value):
                        if pebblo_filter_key in _filter:
                            
                            value.pop(i)
                            break
                    if len(value) == 0:
                        
                        search_kwargs["filter"] = {}
                elif key.lower() == "$or":
                    
                    return
            else:
                
                if key == pebblo_filter_key:
                    filters.pop(key)
                return
        elif len(filters) > 1:
            
            if pebblo_filter_key in filters:
                
                filters.pop(pebblo_filter_key)
            return
        else:
            
            return
    elif filters is None:
        
        return
    else:
        raise ValueError(
            f"Invalid filter. Expected a dictionary/None but got type: {type(filters)}"
        )


def _apply_pgvector_semantic_filter(
    search_kwargs: dict, semantic_context: Optional[SemanticContext]
) -> None:
    
    
    if semantic_context is not None:
        _semantic_filters = []
        filters = search_kwargs.get("filter")
        if semantic_context.pebblo_semantic_topics is not None:
            
            topic_filter: dict = {
                "pebblo_semantic_topics": {
                    "$eq": semantic_context.pebblo_semantic_topics.deny
                }
            }
            _semantic_filters.append(topic_filter)

        if semantic_context.pebblo_semantic_entities is not None:
            
            entity_filter: dict = {
                "pebblo_semantic_entities": {
                    "$eq": semantic_context.pebblo_semantic_entities.deny
                }
            }
            _semantic_filters.append(entity_filter)

        if len(_semantic_filters) > 0:
            semantic_filter: dict = {"$not": _semantic_filters}
            _apply_pgvector_filter(search_kwargs, filters, semantic_filter)


def _apply_pgvector_authorization_filter(
    search_kwargs: dict, auth_context: Optional[AuthContext]
) -> None:
    
    if auth_context is not None:
        auth_filter: dict = {"authorized_identities": {"$eq": auth_context.user_auth}}
        filters = search_kwargs.get("filter")
        _apply_pgvector_filter(search_kwargs, filters, auth_filter)


def _set_identity_enforcement_filter(
    retriever: VectorStoreRetriever, auth_context: Optional[AuthContext]
) -> None:
    
    search_kwargs = retriever.search_kwargs
    if retriever.vectorstore.__class__.__name__ in [PINECONE, PINECONE_VECTOR_STORE]:
        _apply_pinecone_authorization_filter(search_kwargs, auth_context)
    elif retriever.vectorstore.__class__.__name__ == QDRANT:
        _apply_qdrant_authorization_filter(search_kwargs, auth_context)
    elif retriever.vectorstore.__class__.__name__ == PGVECTOR:
        _apply_pgvector_authorization_filter(search_kwargs, auth_context)


def _set_semantic_enforcement_filter(
    retriever: VectorStoreRetriever, semantic_context: Optional[SemanticContext]
) -> None:
    
    search_kwargs = retriever.search_kwargs
    if retriever.vectorstore.__class__.__name__ == PINECONE:
        _apply_pinecone_semantic_filter(search_kwargs, semantic_context)
    elif retriever.vectorstore.__class__.__name__ == QDRANT:
        _apply_qdrant_semantic_filter(search_kwargs, semantic_context)
    elif retriever.vectorstore.__class__.__name__ == PGVECTOR:
        _apply_pgvector_semantic_filter(search_kwargs, semantic_context)
