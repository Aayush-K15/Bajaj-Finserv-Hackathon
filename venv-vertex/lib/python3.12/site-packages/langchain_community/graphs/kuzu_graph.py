from hashlib import md5
from typing import Any, Dict, List, Tuple

from langchain_community.graphs.graph_document import GraphDocument, Relationship


class KuzuGraph:
    

    def __init__(
        self, db: Any, database: str = "kuzu", allow_dangerous_requests: bool = False
    ) -> None:
        

        if allow_dangerous_requests is not True:
            raise ValueError(
                "The KuzuGraph class is a powerful tool that can be used to execute "
                "arbitrary queries on the database. To enable this functionality, "
                "set the `allow_dangerous_requests` parameter to `True` when "
                "constructing the KuzuGraph object."
            )

        try:
            import kuzu
        except ImportError:
            raise ImportError(
                "Could not import Kùzu python package."
                "Please install Kùzu with `pip install kuzu`."
            )
        self.db = db
        self.conn = kuzu.Connection(self.db)
        self.database = database
        self.refresh_schema()

    @property
    def get_schema(self) -> str:
        
        return self.schema

    def query(self, query: str, params: dict = {}) -> List[Dict[str, Any]]:
        
        result = self.conn.execute(query, params)
        column_names = result.get_column_names()
        return_list = []
        while result.has_next():
            row = result.get_next()
            return_list.append(dict(zip(column_names, row)))
        return return_list

    def refresh_schema(self) -> None:
        
        node_properties = []
        node_table_names = self.conn._get_node_table_names()
        for table_name in node_table_names:
            current_table_schema = {"properties": [], "label": table_name}
            properties = self.conn._get_node_property_names(table_name)
            for property_name in properties:
                property_type = properties[property_name]["type"]
                list_type_flag = ""
                if properties[property_name]["dimension"] > 0:
                    if "shape" in properties[property_name]:
                        for s in properties[property_name]["shape"]:
                            list_type_flag += f"[{s}]"
                    else:
                        for i in range(properties[property_name]["dimension"]):
                            list_type_flag += "[]"
                property_type += list_type_flag
                current_table_schema["properties"].append(
                    (
                        property_name,
                        property_type,
                    )
                )
            node_properties.append(current_table_schema)

        relationships = []
        rel_tables = self.conn._get_rel_table_names()
        for table in rel_tables:
            relationships.append(
                f"(:{table['src']})-[:{table['name']}]->(:{table['dst']})"
            )

        rel_properties = []
        for table in rel_tables:
            table_name = table["name"]
            current_table_schema = {"properties": [], "label": table_name}
            query_result = self.conn.execute(
                f"CALL table_info('{table_name}') RETURN *;"
            )
            while query_result.has_next():
                row = query_result.get_next()
                prop_name = row[1]
                prop_type = row[2]
                current_table_schema["properties"].append((prop_name, prop_type))
            rel_properties.append(current_table_schema)

        self.schema = (
            f"Node properties: {node_properties}\n"
            f"Relationships properties: {rel_properties}\n"
            f"Relationships: {relationships}\n"
        )

    def _create_chunk_node_table(self) -> None:
        self.conn.execute(
            
        )

    def _create_entity_node_table(self, node_label: str) -> None:
        self.conn.execute(
            f
        )

    def _create_entity_relationship_table(self, rel: Relationship) -> None:
        self.conn.execute(
            f
        )

    def add_graph_documents(
        self,
        graph_documents: List[GraphDocument],
        allowed_relationships: List[Tuple[str, str, str]],
        include_source: bool = False,
    ) -> None:
        
        
        node_labels = list(
            {node.type for document in graph_documents for node in document.nodes}
        )

        for document in graph_documents:
            
            
            if include_source:
                self._create_chunk_node_table()
                if not document.source.metadata.get("id"):
                    
                    document.source.metadata["id"] = md5(
                        document.source.page_content.encode("utf-8")
                    ).hexdigest()

                self.conn.execute(
                    f,  
                    parameters={
                        "id": document.source.metadata["id"],
                        "text": document.source.page_content,
                    },
                )

            for node_label in node_labels:
                self._create_entity_node_table(node_label)

            
            for node in document.nodes:
                self.conn.execute(
                    f,
                    parameters={"id": node.id},
                )
                if include_source:
                    
                    
                    self._create_chunk_node_table()
                    ddl = "CREATE REL TABLE GROUP IF NOT EXISTS MENTIONS ("
                    table_names = []
                    for node_label in node_labels:
                        table_names.append(f"FROM Chunk TO {node_label}")
                    table_names = list(set(table_names))
                    ddl += ", ".join(table_names)
                    
                    ddl += ", label STRING, triplet_source_id STRING)"
                    if ddl:
                        self.conn.execute(ddl)

                    
                    if node.type in node_labels:
                        self.conn.execute(
                            f,
                            parameters={
                                "id": document.source.metadata["id"],
                                "node_id": node.id,
                            },
                        )

            
            for rel in document.relationships:
                self._create_entity_relationship_table(rel)
                
                source_label = rel.source.type
                source_id = rel.source.id
                target_label = rel.target.type
                target_id = rel.target.id
                self.conn.execute(
                    f,
                    parameters={
                        "source_id": source_id,
                        "target_id": target_id,
                    },
                )
