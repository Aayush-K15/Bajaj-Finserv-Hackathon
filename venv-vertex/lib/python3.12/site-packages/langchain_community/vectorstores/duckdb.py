
from __future__ import annotations

import json
import logging
import uuid
import warnings
from typing import Any, Iterable, List, Optional, Type

from langchain_core.documents import Document
from langchain_core.embeddings import Embeddings
from langchain_core.vectorstores import VST, VectorStore

logger = logging.getLogger(__name__)

DEFAULT_VECTOR_KEY = "embedding"
DEFAULT_ID_KEY = "id"
DEFAULT_TEXT_KEY = "text"
DEFAULT_TABLE_NAME = "embeddings"
SIMILARITY_ALIAS = "similarity_score"
DUCKDB_FETCHALL_PAGE_CONTENT_INDEX = 1
DUCKDB_FETCHALL_METADATA_INDEX = 3
DUCKDB_FETCHALL_SIMILARITY_SCORE_INDEX = 4


class DuckDB(VectorStore):
    

    def __init__(
        self,
        *,
        connection: Optional[Any] = None,
        embedding: Embeddings,
        vector_key: str = DEFAULT_VECTOR_KEY,
        id_key: str = DEFAULT_ID_KEY,
        text_key: str = DEFAULT_TEXT_KEY,
        table_name: str = DEFAULT_TABLE_NAME,
    ):
        
        try:
            import duckdb
        except ImportError:
            raise ImportError(
                "Could not import duckdb package. "
                "Please install it with `pip install duckdb`."
            )

        self.duckdb = duckdb
        self._embedding = embedding
        self._vector_key = vector_key
        self._id_key = id_key
        self._text_key = text_key
        self._table_name = table_name

        if self._embedding is None:
            raise ValueError("An embedding function or model must be provided.")

        if connection is None:
            warnings.warn(
                "No DuckDB connection provided. A new connection will be created."
                "This connection is running in memory and no data will be persisted."
                "To persist data, specify `connection=duckdb.connect(...)` when using "
                "the API. Please review the documentation of the vectorstore for "
                "security recommendations on configuring the connection."
            )

        self._connection = connection or self.duckdb.connect(
            database=":memory:", config={"enable_external_access": "false"}
        )
        self._ensure_table()
        self._table = self._connection.table(self._table_name)

    @property
    def embeddings(self) -> Optional[Embeddings]:
        
        return self._embedding

    def add_texts(
        self,
        texts: Iterable[str],
        metadatas: Optional[List[dict]] = None,
        **kwargs: Any,
    ) -> List[str]:
        
        have_pandas = False
        try:
            import pandas as pd

            have_pandas = True
        except ImportError:
            logger.info(
                "Unable to import pandas. "
                "Install it with `pip install -U pandas` "
                "to improve performance of add_texts()."
            )

        
        ids = kwargs.pop("ids", [str(uuid.uuid4()) for _ in texts])

        
        ids = ids or [str(uuid.uuid4()) for _ in texts]
        embeddings = self._embedding.embed_documents(list(texts))
        data = []
        for idx, text in enumerate(texts):
            embedding = embeddings[idx]
            
            metadata = (
                json.dumps(metadatas[idx])
                if metadatas and idx < len(metadatas)
                else None
            )
            if have_pandas:
                data.append(
                    {
                        self._id_key: ids[idx],
                        self._text_key: text,
                        self._vector_key: embedding,
                        "metadata": metadata,
                    }
                )
            else:
                self._connection.execute(
                    f"INSERT INTO {self._table_name} VALUES (?,?,?,?)",
                    [ids[idx], text, embedding, metadata],
                )

        if have_pandas:
            
            df = pd.DataFrame.from_dict(data)  
            self._connection.register("df", df)
            self._connection.execute(
                f"INSERT INTO {self._table_name} SELECT * FROM df",
            )
        return ids

    def similarity_search_pd(
        self, query: str, k: int = 4, **kwargs: Any
    ) -> List[Document]:
        
        try:
            import pandas as pandas
        except ImportError:
            warnings.warn("You may need to `pip install pandas` to use this method.")

        embedding = self._embedding.embed_query(query)
        list_cosine_similarity = self.duckdb.FunctionExpression(
            "list_cosine_similarity",
            self.duckdb.ColumnExpression(self._vector_key),
            self.duckdb.ConstantExpression(embedding),
        )
        docs = (
            self._table.select(
                *[
                    self.duckdb.StarExpression(exclude=[]),
                    list_cosine_similarity.alias(SIMILARITY_ALIAS),
                ]
            )
            .order(f"{SIMILARITY_ALIAS} desc")
            .limit(k)
            .fetchdf()
        )
        return [
            Document(
                page_content=docs[self._text_key][idx],
                metadata={
                    **json.loads(docs["metadata"][idx]),
                    
                    f"_{SIMILARITY_ALIAS}": docs[SIMILARITY_ALIAS][idx],
                }
                if docs["metadata"][idx]
                else {},
            )
            for idx in range(len(docs))
        ]

    def similarity_search(
        self, query: str, k: int = 4, **kwargs: Any
    ) -> List[Document]:
        

        embedding = self._embedding.embed_query(query)
        list_cosine_similarity = self.duckdb.FunctionExpression(
            "list_cosine_similarity",
            self.duckdb.ColumnExpression(self._vector_key),
            self.duckdb.ConstantExpression(embedding),
        )
        docs = (
            self._table.select(
                *[
                    self.duckdb.StarExpression(exclude=[]),
                    list_cosine_similarity.alias(SIMILARITY_ALIAS),
                ]
            )
            .order(f"{SIMILARITY_ALIAS} desc")
            .limit(k)
            .fetchall()
        )
        return [
            Document(
                page_content=docs[idx][DUCKDB_FETCHALL_PAGE_CONTENT_INDEX],
                metadata={
                    **json.loads(docs[idx][DUCKDB_FETCHALL_METADATA_INDEX]),
                    
                    f"_{SIMILARITY_ALIAS}": docs[idx][
                        DUCKDB_FETCHALL_SIMILARITY_SCORE_INDEX
                    ],
                }
                if docs[idx][DUCKDB_FETCHALL_METADATA_INDEX]
                else {},
            )
            for idx in range(len(docs))
        ]

    @classmethod
    def from_texts(
        cls: Type[VST],
        texts: List[str],
        embedding: Embeddings,
        metadatas: Optional[List[dict]] = None,
        **kwargs: Any,
    ) -> DuckDB:
        

        
        connection = kwargs.get("connection", None)
        vector_key = kwargs.get("vector_key", DEFAULT_VECTOR_KEY)
        id_key = kwargs.get("id_key", DEFAULT_ID_KEY)
        text_key = kwargs.get("text_key", DEFAULT_TEXT_KEY)
        table_name = kwargs.get("table_name", DEFAULT_TABLE_NAME)

        
        instance = DuckDB(
            connection=connection,
            embedding=embedding,
            vector_key=vector_key,
            id_key=id_key,
            text_key=text_key,
            table_name=table_name,
        )
        
        instance.add_texts(texts, metadatas=metadatas, **kwargs)

        return instance

    def _ensure_table(self) -> None:
        
        create_table_sql = f
        self._connection.execute(create_table_sql)
