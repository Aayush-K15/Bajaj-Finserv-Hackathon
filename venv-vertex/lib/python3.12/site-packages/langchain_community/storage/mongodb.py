from typing import Iterator, List, Optional, Sequence, Tuple

from langchain_core.documents import Document
from langchain_core.stores import BaseStore


class MongoDBByteStore(BaseStore[str, bytes]):
    

    def __init__(
        self,
        connection_string: str,
        db_name: str,
        collection_name: str,
        *,
        client_kwargs: Optional[dict] = None,
    ) -> None:
        
        try:
            from pymongo import MongoClient
        except ImportError as e:
            raise ImportError(
                "The MongoDBStore requires the pymongo library to be "
                "installed. "
                "pip install pymongo"
            ) from e

        if not connection_string:
            raise ValueError("connection_string must be provided.")
        if not db_name:
            raise ValueError("db_name must be provided.")
        if not collection_name:
            raise ValueError("collection_name must be provided.")

        self.client: MongoClient = MongoClient(
            connection_string, **(client_kwargs or {})
        )
        self.collection = self.client[db_name][collection_name]

    def mget(self, keys: Sequence[str]) -> List[Optional[bytes]]:
        
        result = self.collection.find({"_id": {"$in": keys}})
        result_dict = {doc["_id"]: doc["value"] for doc in result}
        return [result_dict.get(key) for key in keys]

    def mset(self, key_value_pairs: Sequence[Tuple[str, bytes]]) -> None:
        
        from pymongo import UpdateOne

        updates = [{"_id": k, "value": v} for k, v in key_value_pairs]
        self.collection.bulk_write(
            [UpdateOne({"_id": u["_id"]}, {"$set": u}, upsert=True) for u in updates]
        )

    def mdelete(self, keys: Sequence[str]) -> None:
        
        self.collection.delete_many({"_id": {"$in": keys}})

    def yield_keys(self, prefix: Optional[str] = None) -> Iterator[str]:
        
        if prefix is None:
            for doc in self.collection.find(projection=["_id"]):
                yield doc["_id"]
        else:
            for doc in self.collection.find(
                {"_id": {"$regex": f"^{prefix}"}}, projection=["_id"]
            ):
                yield doc["_id"]


class MongoDBStore(BaseStore[str, Document]):
    

    def __init__(
        self,
        connection_string: str,
        db_name: str,
        collection_name: str,
        *,
        client_kwargs: Optional[dict] = None,
    ) -> None:
        
        try:
            from pymongo import MongoClient
        except ImportError as e:
            raise ImportError(
                "The MongoDBStore requires the pymongo library to be "
                "installed. "
                "pip install pymongo"
            ) from e

        if not connection_string:
            raise ValueError("connection_string must be provided.")
        if not db_name:
            raise ValueError("db_name must be provided.")
        if not collection_name:
            raise ValueError("collection_name must be provided.")

        self.client: MongoClient = MongoClient(
            connection_string, **(client_kwargs or {})
        )
        self.collection = self.client[db_name][collection_name]

    def mget(self, keys: Sequence[str]) -> List[Optional[Document]]:
        
        result = self.collection.find({"_id": {"$in": keys}})
        result_dict = {doc["_id"]: Document(**doc["value"]) for doc in result}
        return [result_dict.get(key) for key in keys]

    def mset(self, key_value_pairs: Sequence[Tuple[str, Document]]) -> None:
        
        from pymongo import UpdateOne

        updates = [{"_id": k, "value": v.__dict__} for k, v in key_value_pairs]
        self.collection.bulk_write(
            [UpdateOne({"_id": u["_id"]}, {"$set": u}, upsert=True) for u in updates]
        )

    def mdelete(self, keys: Sequence[str]) -> None:
        
        self.collection.delete_many({"_id": {"$in": keys}})

    def yield_keys(self, prefix: Optional[str] = None) -> Iterator[str]:
        
        if prefix is None:
            for doc in self.collection.find(projection=["_id"]):
                yield doc["_id"]
        else:
            for doc in self.collection.find(
                {"_id": {"$regex": f"^{prefix}"}}, projection=["_id"]
            ):
                yield doc["_id"]
