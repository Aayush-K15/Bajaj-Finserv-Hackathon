from functools import partial
from typing import Any, Dict, List, Mapping, Optional, Set

from langchain_core.callbacks import CallbackManagerForLLMRun
from langchain_core.language_models.llms import LLM
from langchain_core.utils import pre_init
from pydantic import ConfigDict, Field

from langchain_community.llms.utils import enforce_stop_tokens


class GPT4All(LLM):
    

    model: str
    

    backend: Optional[str] = Field(None, alias="backend")

    max_tokens: int = Field(200, alias="max_tokens")
    

    n_parts: int = Field(-1, alias="n_parts")
    

    seed: int = Field(0, alias="seed")
    

    f16_kv: bool = Field(False, alias="f16_kv")
    

    logits_all: bool = Field(False, alias="logits_all")
    

    vocab_only: bool = Field(False, alias="vocab_only")
    

    use_mlock: bool = Field(False, alias="use_mlock")
    

    embedding: bool = Field(False, alias="embedding")
    

    n_threads: Optional[int] = Field(4, alias="n_threads")
    

    n_predict: Optional[int] = 256
    

    temp: Optional[float] = 0.7
    

    top_p: Optional[float] = 0.1
    

    top_k: Optional[int] = 40
    

    echo: Optional[bool] = False
    

    stop: Optional[List[str]] = []
    

    repeat_last_n: Optional[int] = 64
    "Last n tokens to penalize"

    repeat_penalty: Optional[float] = 1.18
    

    n_batch: int = Field(8, alias="n_batch")
    

    streaming: bool = False
    

    allow_download: bool = False
    

    device: Optional[str] = Field("cpu", alias="device")
    

    client: Any = None  

    model_config = ConfigDict(
        extra="forbid",
    )

    @staticmethod
    def _model_param_names() -> Set[str]:
        return {
            "max_tokens",
            "n_predict",
            "top_k",
            "top_p",
            "temp",
            "n_batch",
            "repeat_penalty",
            "repeat_last_n",
            "streaming",
        }

    def _default_params(self) -> Dict[str, Any]:
        return {
            "max_tokens": self.max_tokens,
            "n_predict": self.n_predict,
            "top_k": self.top_k,
            "top_p": self.top_p,
            "temp": self.temp,
            "n_batch": self.n_batch,
            "repeat_penalty": self.repeat_penalty,
            "repeat_last_n": self.repeat_last_n,
            "streaming": self.streaming,
        }

    @pre_init
    def validate_environment(cls, values: Dict) -> Dict:
        
        try:
            from gpt4all import GPT4All as GPT4AllModel
        except ImportError:
            raise ImportError(
                "Could not import gpt4all python package. "
                "Please install it with `pip install gpt4all`."
            )

        full_path = values["model"]
        model_path, delimiter, model_name = full_path.rpartition("/")
        model_path += delimiter

        values["client"] = GPT4AllModel(
            model_name,
            model_path=model_path or None,
            model_type=values["backend"],
            allow_download=values["allow_download"],
            device=values["device"],
        )
        if values["n_threads"] is not None:
            
            values["client"].model.set_thread_count(values["n_threads"])

        try:
            values["backend"] = values["client"].model_type
        except AttributeError:
            
            values["backend"] = values["client"].model.model_type

        return values

    @property
    def _identifying_params(self) -> Mapping[str, Any]:
        
        return {
            "model": self.model,
            **self._default_params(),
            **{
                k: v for k, v in self.__dict__.items() if k in self._model_param_names()
            },
        }

    @property
    def _llm_type(self) -> str:
        
        return "gpt4all"

    def _call(
        self,
        prompt: str,
        stop: Optional[List[str]] = None,
        run_manager: Optional[CallbackManagerForLLMRun] = None,
        **kwargs: Any,
    ) -> str:
        r
        text_callback = None
        if run_manager:
            text_callback = partial(run_manager.on_llm_new_token, verbose=self.verbose)
        text = ""
        params = {**self._default_params(), **kwargs}
        for token in self.client.generate(prompt, **params):
            if text_callback:
                text_callback(token)
            text += token
        if stop is not None:
            text = enforce_stop_tokens(text, stop)
        return text
