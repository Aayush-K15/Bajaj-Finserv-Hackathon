from typing import Any, Dict, List, Optional, Sequence

from langchain_core.callbacks import CallbackManagerForLLMRun
from langchain_core.language_models.llms import LLM
from langchain_core.utils import convert_to_secret_str, get_from_dict_or_env, pre_init
from pydantic import ConfigDict, SecretStr

from langchain_community.llms.utils import enforce_stop_tokens


class AlephAlpha(LLM):
    

    client: Any = None  
    model: Optional[str] = "luminous-base"
    

    maximum_tokens: int = 64
    

    temperature: float = 0.0
    

    top_k: int = 0
    

    top_p: float = 0.0
    

    presence_penalty: float = 0.0
    

    frequency_penalty: float = 0.0
    

    repetition_penalties_include_prompt: Optional[bool] = False
    

    use_multiplicative_presence_penalty: Optional[bool] = False
    

    penalty_bias: Optional[str] = None
    

    penalty_exceptions: Optional[List[str]] = None
    

    penalty_exceptions_include_stop_sequences: Optional[bool] = None
    

    best_of: Optional[int] = None
    

    n: int = 1
    

    logit_bias: Optional[Dict[int, float]] = None
    

    log_probs: Optional[int] = None
    

    tokens: Optional[bool] = False
    

    disable_optimizations: Optional[bool] = False

    minimum_tokens: Optional[int] = 0
    

    echo: bool = False
    

    use_multiplicative_frequency_penalty: bool = False

    sequence_penalty: float = 0.0

    sequence_penalty_min_length: int = 2

    use_multiplicative_sequence_penalty: bool = False

    completion_bias_inclusion: Optional[Sequence[str]] = None

    completion_bias_inclusion_first_token_only: bool = False

    completion_bias_exclusion: Optional[Sequence[str]] = None

    completion_bias_exclusion_first_token_only: bool = False
    

    contextual_control_threshold: Optional[float] = None
    

    control_log_additive: Optional[bool] = True
    

    repetition_penalties_include_completion: bool = True
    

    raw_completion: bool = False
    

    stop_sequences: Optional[List[str]] = None
    

    
    aleph_alpha_api_key: Optional[SecretStr] = None
    
    host: str = "https://api.aleph-alpha.com"
    
    hosting: Optional[str] = None
    
    request_timeout_seconds: int = 305
    
    total_retries: int = 8
    
    nice: bool = False
    

    model_config = ConfigDict(
        extra="forbid",
    )

    @pre_init
    def validate_environment(cls, values: Dict) -> Dict:
        
        values["aleph_alpha_api_key"] = convert_to_secret_str(
            get_from_dict_or_env(values, "aleph_alpha_api_key", "ALEPH_ALPHA_API_KEY")
        )
        try:
            from aleph_alpha_client import Client

            values["client"] = Client(
                token=values["aleph_alpha_api_key"].get_secret_value(),
                host=values["host"],
                hosting=values["hosting"],
                request_timeout_seconds=values["request_timeout_seconds"],
                total_retries=values["total_retries"],
                nice=values["nice"],
            )
        except ImportError:
            raise ImportError(
                "Could not import aleph_alpha_client python package. "
                "Please install it with `pip install aleph_alpha_client`."
            )
        return values

    @property
    def _default_params(self) -> Dict[str, Any]:
        
        return {
            "maximum_tokens": self.maximum_tokens,
            "temperature": self.temperature,
            "top_k": self.top_k,
            "top_p": self.top_p,
            "presence_penalty": self.presence_penalty,
            "frequency_penalty": self.frequency_penalty,
            "n": self.n,
            "repetition_penalties_include_prompt": self.repetition_penalties_include_prompt,  
            "use_multiplicative_presence_penalty": self.use_multiplicative_presence_penalty,  
            "penalty_bias": self.penalty_bias,
            "penalty_exceptions": self.penalty_exceptions,
            "penalty_exceptions_include_stop_sequences": self.penalty_exceptions_include_stop_sequences,  
            "best_of": self.best_of,
            "logit_bias": self.logit_bias,
            "log_probs": self.log_probs,
            "tokens": self.tokens,
            "disable_optimizations": self.disable_optimizations,
            "minimum_tokens": self.minimum_tokens,
            "echo": self.echo,
            "use_multiplicative_frequency_penalty": self.use_multiplicative_frequency_penalty,  
            "sequence_penalty": self.sequence_penalty,
            "sequence_penalty_min_length": self.sequence_penalty_min_length,
            "use_multiplicative_sequence_penalty": self.use_multiplicative_sequence_penalty,  
            "completion_bias_inclusion": self.completion_bias_inclusion,
            "completion_bias_inclusion_first_token_only": self.completion_bias_inclusion_first_token_only,  
            "completion_bias_exclusion": self.completion_bias_exclusion,
            "completion_bias_exclusion_first_token_only": self.completion_bias_exclusion_first_token_only,  
            "contextual_control_threshold": self.contextual_control_threshold,
            "control_log_additive": self.control_log_additive,
            "repetition_penalties_include_completion": self.repetition_penalties_include_completion,  
            "raw_completion": self.raw_completion,
        }

    @property
    def _identifying_params(self) -> Dict[str, Any]:
        
        return {**{"model": self.model}, **self._default_params}

    @property
    def _llm_type(self) -> str:
        
        return "aleph_alpha"

    def _call(
        self,
        prompt: str,
        stop: Optional[List[str]] = None,
        run_manager: Optional[CallbackManagerForLLMRun] = None,
        **kwargs: Any,
    ) -> str:
        
        from aleph_alpha_client import CompletionRequest, Prompt

        params = self._default_params
        if self.stop_sequences is not None and stop is not None:
            raise ValueError(
                "stop sequences found in both the input and default params."
            )
        elif self.stop_sequences is not None:
            params["stop_sequences"] = self.stop_sequences
        else:
            params["stop_sequences"] = stop
        params = {**params, **kwargs}
        request = CompletionRequest(prompt=Prompt.from_text(prompt), **params)
        response = self.client.complete(model=self.model, request=request)
        text = response.completions[0].completion
        
        
        if stop is not None or self.stop_sequences is not None:
            text = enforce_stop_tokens(text, params["stop_sequences"])
        return text


if __name__ == "__main__":
    aa = AlephAlpha()

    print(aa.invoke("How are you?"))  
