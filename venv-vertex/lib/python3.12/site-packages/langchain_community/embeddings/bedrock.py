import asyncio
import json
import os
from typing import Any, Dict, List, Optional

import numpy as np
from langchain_core._api.deprecation import deprecated
from langchain_core.embeddings import Embeddings
from langchain_core.runnables.config import run_in_executor
from pydantic import BaseModel, ConfigDict, model_validator
from typing_extensions import Self


@deprecated(
    since="0.2.11",
    removal="1.0",
    alternative_import="langchain_aws.BedrockEmbeddings",
)
class BedrockEmbeddings(BaseModel, Embeddings):
    

    

    client: Any = None  
    
    region_name: Optional[str] = None
    

    credentials_profile_name: Optional[str] = None
    

    model_id: str = "amazon.titan-embed-text-v1"
    

    model_kwargs: Optional[Dict] = None
    

    endpoint_url: Optional[str] = None
    

    normalize: bool = False
    

    model_config = ConfigDict(extra="forbid", protected_namespaces=())

    @model_validator(mode="after")
    def validate_environment(self) -> Self:
        

        if self.client is not None:
            return self

        try:
            import boto3

            if self.credentials_profile_name is not None:
                session = boto3.Session(profile_name=self.credentials_profile_name)
            else:
                
                session = boto3.Session()

            client_params = {}
            if self.region_name:
                client_params["region_name"] = self.region_name

            if self.endpoint_url:
                client_params["endpoint_url"] = self.endpoint_url

            self.client = session.client("bedrock-runtime", **client_params)

        except ImportError:
            raise ImportError(
                "Could not import boto3 python package. "
                "Please install it with `pip install boto3`."
            )
        except Exception as e:
            raise ValueError(
                "Could not load credentials to authenticate with AWS client. "
                "Please check that credentials in the specified "
                f"profile name are valid. Bedrock error: {e}"
            ) from e

        return self

    def _embedding_func(self, text: str) -> List[float]:
        
        
        text = text.replace(os.linesep, " ")

        
        provider = self.model_id.split(".")[0]
        _model_kwargs = self.model_kwargs or {}
        input_body = {**_model_kwargs}
        if provider == "cohere":
            if "input_type" not in input_body.keys():
                input_body["input_type"] = "search_document"
            input_body["texts"] = [text]
        else:
            
            input_body["inputText"] = text
        body = json.dumps(input_body)

        try:
            
            response = self.client.invoke_model(
                body=body,
                modelId=self.model_id,
                accept="application/json",
                contentType="application/json",
            )

            
            response_body = json.loads(response.get("body").read())
            if provider == "cohere":
                return response_body.get("embeddings")[0]
            else:
                
                return response_body.get("embedding")
        except Exception as e:
            raise ValueError(f"Error raised by inference endpoint: {e}")

    def _normalize_vector(self, embeddings: List[float]) -> List[float]:
        
        emb = np.array(embeddings)
        norm_emb = emb / np.linalg.norm(emb)
        return norm_emb.tolist()

    def embed_documents(self, texts: List[str]) -> List[List[float]]:
        
        results = []
        for text in texts:
            response = self._embedding_func(text)

            if self.normalize:
                response = self._normalize_vector(response)

            results.append(response)

        return results

    def embed_query(self, text: str) -> List[float]:
        
        embedding = self._embedding_func(text)

        if self.normalize:
            return self._normalize_vector(embedding)

        return embedding

    async def aembed_query(self, text: str) -> List[float]:
        

        return await run_in_executor(None, self.embed_query, text)

    async def aembed_documents(self, texts: List[str]) -> List[List[float]]:
        

        result = await asyncio.gather(*[self.aembed_query(text) for text in texts])

        return list(result)
