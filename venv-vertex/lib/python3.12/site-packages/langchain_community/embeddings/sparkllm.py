import base64
import hashlib
import hmac
import json
import logging
from datetime import datetime
from time import mktime
from typing import Any, Dict, List, Literal, Optional
from urllib.parse import urlencode
from wsgiref.handlers import format_date_time

import numpy as np
import requests
from langchain_core.embeddings import Embeddings
from langchain_core.utils import (
    secret_from_env,
)
from numpy import ndarray
from pydantic import BaseModel, ConfigDict, Field, SecretStr











logger = logging.getLogger(__name__)


class Url:
    

    def __init__(self, host: str, path: str, schema: str) -> None:
        self.host = host
        self.path = path
        self.schema = schema
        pass


class SparkLLMTextEmbeddings(BaseModel, Embeddings):
      

    spark_app_id: SecretStr = Field(
        alias="app_id", default_factory=secret_from_env("SPARK_APP_ID")
    )
    
    spark_api_key: Optional[SecretStr] = Field(
        alias="api_key", default_factory=secret_from_env("SPARK_API_KEY", default=None)
    )
    
    spark_api_secret: Optional[SecretStr] = Field(
        alias="api_secret",
        default_factory=secret_from_env("SPARK_API_SECRET", default=None),
    )
    
    base_url: str = Field(default="https://emb-cn-huabei-1.xf-yun.com/")
    
    domain: Literal["para", "query"] = Field(default="para")
    

    model_config = ConfigDict(
        populate_by_name=True,
    )

    def _embed(self, texts: List[str], host: str) -> Optional[List[List[float]]]:
        
        app_id = ""
        api_key = ""
        api_secret = ""
        if self.spark_app_id:
            app_id = self.spark_app_id.get_secret_value()
        if self.spark_api_key:
            api_key = self.spark_api_key.get_secret_value()
        if self.spark_api_secret:
            api_secret = self.spark_api_secret.get_secret_value()
        url = self._assemble_ws_auth_url(
            request_url=host,
            method="POST",
            api_key=api_key,
            api_secret=api_secret,
        )
        embed_result: list = []
        for text in texts:
            query_context = {"messages": [{"content": text, "role": "user"}]}
            content = self._get_body(app_id, query_context)
            response = requests.post(
                url, json=content, headers={"content-type": "application/json"}
            ).text
            res_arr = self._parser_message(response)
            if res_arr is not None:
                embed_result.append(res_arr.tolist())
            else:
                embed_result.append(None)
        return embed_result

    def embed_documents(self, texts: List[str]) -> Optional[List[List[float]]]:  
        
        return self._embed(texts, self.base_url)

    def embed_query(self, text: str) -> Optional[List[float]]:  
        
        result = self._embed([text], self.base_url)
        return result[0] if result is not None else None

    @staticmethod
    def _assemble_ws_auth_url(
        request_url: str, method: str = "GET", api_key: str = "", api_secret: str = ""
    ) -> str:
        u = SparkLLMTextEmbeddings._parse_url(request_url)
        host = u.host
        path = u.path
        now = datetime.now()
        date = format_date_time(mktime(now.timetuple()))
        signature_origin = "host: {}\ndate: {}\n{} {} HTTP/1.1".format(
            host, date, method, path
        )
        signature_sha = hmac.new(
            api_secret.encode("utf-8"),
            signature_origin.encode("utf-8"),
            digestmod=hashlib.sha256,
        ).digest()
        signature_sha_str = base64.b64encode(signature_sha).decode(encoding="utf-8")
        authorization_origin = (
            'api_key="%s", algorithm="%s", headers="%s", signature="%s"'
            % (api_key, "hmac-sha256", "host date request-line", signature_sha_str)
        )
        authorization = base64.b64encode(authorization_origin.encode("utf-8")).decode(
            encoding="utf-8"
        )
        values = {"host": host, "date": date, "authorization": authorization}

        return request_url + "?" + urlencode(values)

    @staticmethod
    def _parse_url(request_url: str) -> Url:
        stidx = request_url.index("://")
        host = request_url[stidx + 3 :]
        schema = request_url[: stidx + 3]
        edidx = host.index("/")
        if edidx <= 0:
            raise AssembleHeaderException("invalid request url:" + request_url)
        path = host[edidx:]
        host = host[:edidx]
        u = Url(host, path, schema)
        return u

    def _get_body(self, appid: str, text: dict) -> Dict[str, Any]:
        body = {
            "header": {"app_id": appid, "uid": "39769795890", "status": 3},
            "parameter": {
                "emb": {"domain": self.domain, "feature": {"encoding": "utf8"}}
            },
            "payload": {
                "messages": {
                    "text": base64.b64encode(json.dumps(text).encode("utf-8")).decode()
                }
            },
        }
        return body

    @staticmethod
    def _parser_message(
        message: str,
    ) -> Optional[ndarray]:
        data = json.loads(message)
        code = data["header"]["code"]
        if code != 0:
            logger.warning(f"Request error: {code}, {data}")
            return None
        else:
            text_base = data["payload"]["feature"]["text"]
            text_data = base64.b64decode(text_base)
            dt = np.dtype(np.float32)
            dt = dt.newbyteorder("<")
            text = np.frombuffer(text_data, dtype=dt)
            if len(text) > 2560:
                array = text[:2560]
            else:
                array = text
            return array


class AssembleHeaderException(Exception):
    

    def __init__(self, msg: str) -> None:
        self.message = msg
