

from contextlib import asynccontextmanager
from typing import Any, AsyncGenerator, Dict, Literal, Optional, Union

import aiohttp
import requests
from pydantic import BaseModel, ConfigDict
from requests import Response


class Requests(BaseModel):
    

    headers: Optional[Dict[str, str]] = None
    aiosession: Optional[aiohttp.ClientSession] = None
    auth: Optional[Any] = None
    verify: Optional[bool] = True

    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        extra="forbid",
    )

    def get(self, url: str, **kwargs: Any) -> requests.Response:
        
        return requests.get(
            url, headers=self.headers, auth=self.auth, verify=self.verify, **kwargs
        )

    def post(self, url: str, data: Dict[str, Any], **kwargs: Any) -> requests.Response:
        
        return requests.post(
            url,
            json=data,
            headers=self.headers,
            auth=self.auth,
            verify=self.verify,
            **kwargs,
        )

    def patch(self, url: str, data: Dict[str, Any], **kwargs: Any) -> requests.Response:
        
        return requests.patch(
            url,
            json=data,
            headers=self.headers,
            auth=self.auth,
            verify=self.verify,
            **kwargs,
        )

    def put(self, url: str, data: Dict[str, Any], **kwargs: Any) -> requests.Response:
        
        return requests.put(
            url,
            json=data,
            headers=self.headers,
            auth=self.auth,
            verify=self.verify,
            **kwargs,
        )

    def delete(self, url: str, **kwargs: Any) -> requests.Response:
        
        return requests.delete(
            url, headers=self.headers, auth=self.auth, verify=self.verify, **kwargs
        )

    @asynccontextmanager
    async def _arequest(
        self, method: str, url: str, **kwargs: Any
    ) -> AsyncGenerator[aiohttp.ClientResponse, None]:
        
        if not self.aiosession:
            async with aiohttp.ClientSession() as session:
                async with session.request(
                    method,
                    url,
                    headers=self.headers,
                    auth=self.auth,
                    **kwargs,
                ) as response:
                    yield response
        else:
            async with self.aiosession.request(
                method,
                url,
                headers=self.headers,
                auth=self.auth,
                **kwargs,
            ) as response:
                yield response

    @asynccontextmanager
    async def aget(
        self, url: str, **kwargs: Any
    ) -> AsyncGenerator[aiohttp.ClientResponse, None]:
        
        async with self._arequest("GET", url, **kwargs) as response:
            yield response

    @asynccontextmanager
    async def apost(
        self, url: str, data: Dict[str, Any], **kwargs: Any
    ) -> AsyncGenerator[aiohttp.ClientResponse, None]:
        
        async with self._arequest("POST", url, json=data, **kwargs) as response:
            yield response

    @asynccontextmanager
    async def apatch(
        self, url: str, data: Dict[str, Any], **kwargs: Any
    ) -> AsyncGenerator[aiohttp.ClientResponse, None]:
        
        async with self._arequest("PATCH", url, json=data, **kwargs) as response:
            yield response

    @asynccontextmanager
    async def aput(
        self, url: str, data: Dict[str, Any], **kwargs: Any
    ) -> AsyncGenerator[aiohttp.ClientResponse, None]:
        
        async with self._arequest("PUT", url, json=data, **kwargs) as response:
            yield response

    @asynccontextmanager
    async def adelete(
        self, url: str, **kwargs: Any
    ) -> AsyncGenerator[aiohttp.ClientResponse, None]:
        
        async with self._arequest("DELETE", url, **kwargs) as response:
            yield response


class GenericRequestsWrapper(BaseModel):
    

    headers: Optional[Dict[str, str]] = None
    aiosession: Optional[aiohttp.ClientSession] = None
    auth: Optional[Any] = None
    response_content_type: Literal["text", "json"] = "text"
    verify: bool = True

    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        extra="forbid",
    )

    @property
    def requests(self) -> Requests:
        return Requests(
            headers=self.headers,
            aiosession=self.aiosession,
            auth=self.auth,
            verify=self.verify,
        )

    def _get_resp_content(self, response: Response) -> Union[str, Dict[str, Any]]:
        if self.response_content_type == "text":
            return response.text
        elif self.response_content_type == "json":
            return response.json()
        else:
            raise ValueError(f"Invalid return type: {self.response_content_type}")

    async def _aget_resp_content(
        self, response: aiohttp.ClientResponse
    ) -> Union[str, Dict[str, Any]]:
        if self.response_content_type == "text":
            return await response.text()
        elif self.response_content_type == "json":
            return await response.json()
        else:
            raise ValueError(f"Invalid return type: {self.response_content_type}")

    def get(self, url: str, **kwargs: Any) -> Union[str, Dict[str, Any]]:
        
        return self._get_resp_content(self.requests.get(url, **kwargs))

    def post(
        self, url: str, data: Dict[str, Any], **kwargs: Any
    ) -> Union[str, Dict[str, Any]]:
        
        return self._get_resp_content(self.requests.post(url, data, **kwargs))

    def patch(
        self, url: str, data: Dict[str, Any], **kwargs: Any
    ) -> Union[str, Dict[str, Any]]:
        
        return self._get_resp_content(self.requests.patch(url, data, **kwargs))

    def put(
        self, url: str, data: Dict[str, Any], **kwargs: Any
    ) -> Union[str, Dict[str, Any]]:
        
        return self._get_resp_content(self.requests.put(url, data, **kwargs))

    def delete(self, url: str, **kwargs: Any) -> Union[str, Dict[str, Any]]:
        
        return self._get_resp_content(self.requests.delete(url, **kwargs))

    async def aget(self, url: str, **kwargs: Any) -> Union[str, Dict[str, Any]]:
        
        async with self.requests.aget(url, **kwargs) as response:
            return await self._aget_resp_content(response)

    async def apost(
        self, url: str, data: Dict[str, Any], **kwargs: Any
    ) -> Union[str, Dict[str, Any]]:
        
        async with self.requests.apost(url, data, **kwargs) as response:
            return await self._aget_resp_content(response)

    async def apatch(
        self, url: str, data: Dict[str, Any], **kwargs: Any
    ) -> Union[str, Dict[str, Any]]:
        
        async with self.requests.apatch(url, data, **kwargs) as response:
            return await self._aget_resp_content(response)

    async def aput(
        self, url: str, data: Dict[str, Any], **kwargs: Any
    ) -> Union[str, Dict[str, Any]]:
        
        async with self.requests.aput(url, data, **kwargs) as response:
            return await self._aget_resp_content(response)

    async def adelete(self, url: str, **kwargs: Any) -> Union[str, Dict[str, Any]]:
        
        async with self.requests.adelete(url, **kwargs) as response:
            return await self._aget_resp_content(response)


class JsonRequestsWrapper(GenericRequestsWrapper):
    

    response_content_type: Literal["text", "json"] = "json"


class TextRequestsWrapper(GenericRequestsWrapper):
    

    response_content_type: Literal["text", "json"] = "text"



RequestsWrapper = TextRequestsWrapper
