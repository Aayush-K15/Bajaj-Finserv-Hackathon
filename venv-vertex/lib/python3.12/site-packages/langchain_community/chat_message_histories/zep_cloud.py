from __future__ import annotations

import logging
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Sequence

from langchain_core.chat_history import BaseChatMessageHistory
from langchain_core.messages import (
    AIMessage,
    BaseMessage,
    HumanMessage,
)

if TYPE_CHECKING:
    from zep_cloud import (
        Memory,
        MemoryGetRequestMemoryType,
        MemorySearchResult,
        Message,
        NotFoundError,
        RoleType,
        SearchScope,
        SearchType,
    )

logger = logging.getLogger(__name__)


def condense_zep_memory_into_human_message(zep_memory: Memory) -> BaseMessage:
    
    prompt = ""
    if zep_memory.facts:
        prompt = "\n".join(zep_memory.facts)
    if zep_memory.summary and zep_memory.summary.content:
        prompt += "\n" + zep_memory.summary.content
    for msg in zep_memory.messages or []:
        prompt += f"\n{msg.role or msg.role_type}: {msg.content}"
    return HumanMessage(content=prompt)


def get_zep_message_role_type(role: str) -> RoleType:
    
    if role == "human":
        return "user"
    elif role == "ai":
        return "assistant"
    elif role == "system":
        return "system"
    elif role == "function":
        return "function"
    elif role == "tool":
        return "tool"
    else:
        return "system"


class ZepCloudChatMessageHistory(BaseChatMessageHistory):
    

    def __init__(
        self,
        session_id: str,
        api_key: str,
        *,
        memory_type: Optional[MemoryGetRequestMemoryType] = None,
        lastn: Optional[int] = None,
        ai_prefix: Optional[str] = None,
        human_prefix: Optional[str] = None,
        summary_instruction: Optional[str] = None,
    ) -> None:
        try:
            from zep_cloud.client import AsyncZep, Zep
        except ImportError:
            raise ImportError(
                "Could not import zep-cloud package. "
                "Please install it with `pip install zep-cloud`."
            )

        self.zep_client = Zep(api_key=api_key)
        self.zep_client_async = AsyncZep(api_key=api_key)
        self.session_id = session_id

        self.memory_type = memory_type or "perpetual"
        self.lastn = lastn
        self.ai_prefix = ai_prefix or "ai"
        self.human_prefix = human_prefix or "human"
        self.summary_instruction = summary_instruction

    @property
    def messages(self) -> List[BaseMessage]:  
        
        zep_memory: Optional[Memory] = self._get_memory()
        if not zep_memory:
            return []

        return [condense_zep_memory_into_human_message(zep_memory)]

    @property
    def zep_messages(self) -> List[Message]:
        
        zep_memory: Optional[Memory] = self._get_memory()
        if not zep_memory:
            return []

        return zep_memory.messages or []

    @property
    def zep_summary(self) -> Optional[str]:
        
        zep_memory: Optional[Memory] = self._get_memory()
        if not zep_memory or not zep_memory.summary:
            return None

        return zep_memory.summary.content

    @property
    def zep_facts(self) -> Optional[List[str]]:
        
        if self.memory_type != "perpetual":
            return None
        zep_memory: Optional[Memory] = self._get_memory()
        if not zep_memory or not zep_memory.facts:
            return None

        return zep_memory.facts

    def _get_memory(self) -> Optional[Memory]:
        
        from zep_cloud import NotFoundError

        try:
            zep_memory: Memory = self.zep_client.memory.get(
                self.session_id, memory_type=self.memory_type, lastn=self.lastn
            )
        except NotFoundError:
            logger.warning(
                f"Session {self.session_id} not found in Zep. Returning None"
            )
            return None
        return zep_memory

    def add_user_message(  
        self, message: str, metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        
        self.add_message(HumanMessage(content=message), metadata=metadata)

    def add_ai_message(  
        self, message: str, metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        
        self.add_message(AIMessage(content=message), metadata=metadata)

    def add_message(
        self, message: BaseMessage, metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        
        from zep_cloud import Message

        self.zep_client.memory.add(
            self.session_id,
            messages=[
                Message(
                    content=str(message.content),
                    role=message.type,
                    role_type=get_zep_message_role_type(message.type),
                    metadata=metadata,
                )
            ],
        )

    def add_messages(self, messages: Sequence[BaseMessage]) -> None:
        
        from zep_cloud import Message

        zep_messages = [
            Message(
                content=str(message.content),
                role=message.type,
                role_type=get_zep_message_role_type(message.type),
                metadata=message.additional_kwargs.get("metadata", None),
            )
            for message in messages
        ]

        self.zep_client.memory.add(self.session_id, messages=zep_messages)

    async def aadd_messages(self, messages: Sequence[BaseMessage]) -> None:
        
        from zep_cloud import Message

        zep_messages = [
            Message(
                content=str(message.content),
                role=message.type,
                role_type=get_zep_message_role_type(message.type),
                metadata=message.additional_kwargs.get("metadata", None),
            )
            for message in messages
        ]

        await self.zep_client_async.memory.add(self.session_id, messages=zep_messages)

    def search(
        self,
        query: str,
        metadata: Optional[Dict] = None,
        search_scope: SearchScope = "messages",
        search_type: SearchType = "similarity",
        mmr_lambda: Optional[float] = None,
        limit: Optional[int] = None,
    ) -> List[MemorySearchResult]:
        

        return self.zep_client.memory.search(
            self.session_id,
            text=query,
            metadata=metadata,
            search_scope=search_scope,
            search_type=search_type,
            mmr_lambda=mmr_lambda,
            limit=limit,
        )

    def clear(self) -> None:
        
        try:
            self.zep_client.memory.delete(self.session_id)
        except NotFoundError:
            logger.warning(
                f"Session {self.session_id} not found in Zep. Skipping delete."
            )

    async def aclear(self) -> None:
        
        try:
            await self.zep_client_async.memory.delete(self.session_id)
        except NotFoundError:
            logger.warning(
                f"Session {self.session_id} not found in Zep. Skipping delete."
            )
