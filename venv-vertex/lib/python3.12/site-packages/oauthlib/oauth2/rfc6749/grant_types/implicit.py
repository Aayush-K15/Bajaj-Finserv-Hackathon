
import logging

from oauthlib import common

from .. import errors
from .base import GrantTypeBase

log = logging.getLogger(__name__)


class ImplicitGrant(GrantTypeBase):

    

    response_types = ['token']
    grant_allows_refresh_token = False

    def create_authorization_response(self, request, token_handler):
        
        return self.create_token_response(request, token_handler)

    def create_token_response(self, request, token_handler):
        
        try:
            self.validate_token_request(request)

        
        
        
        
        
        except errors.FatalClientError as e:
            log.debug('Fatal client error during validation of %r. %r.',
                      request, e)
            raise

        
        
        
        
        
        
        except errors.OAuth2Error as e:
            log.debug('Client error during validation of %r. %r.', request, e)
            return {'Location': common.add_params_to_uri(request.redirect_uri, e.twotuples,
                                                         fragment=True)}, None, 302

        
        
        
        token = token_handler.create_token(request, refresh_token=False) if 'token' in request.response_type.split() else {}

        if request.state is not None:
            token['state'] = request.state

        for modifier in self._token_modifiers:
            token = modifier(token, token_handler, request)

        
        
        if "token" in request.response_type.split():
            self.request_validator.save_token(token, request)

        return self.prepare_authorization_response(
            request, token, {}, None, 302)

    def validate_authorization_request(self, request):
        
        return self.validate_token_request(request)

    def validate_token_request(self, request):
        

        

        
        
        
        
        

        
        for param in ('client_id', 'response_type', 'redirect_uri', 'scope', 'state'):
            try:
                duplicate_params = request.duplicate_params
            except ValueError:
                raise errors.InvalidRequestFatalError(description='Unable to parse query string', request=request)
            if param in duplicate_params:
                raise errors.InvalidRequestFatalError(description='Duplicate %s parameter.' % param, request=request)

        
        
        if not request.client_id:
            raise errors.MissingClientIdError(request=request)

        if not self.request_validator.validate_client_id(request.client_id, request):
            raise errors.InvalidClientIdError(request=request)

        
        
        self._handle_redirects(request)

        

        request_info = self._run_custom_validators(request,
                                                   self.custom_validators.all_pre)

        
        
        
        
        
        

        
        

        
        if request.response_type is None:
            raise errors.MissingResponseTypeError(request=request)
        
        elif not set(request.response_type.split()).issubset(self.response_types):
            raise errors.UnsupportedResponseTypeError(request=request)

        log.debug('Validating use of response_type token for client %r (%r).',
                  request.client_id, request.client)
        if not self.request_validator.validate_response_type(request.client_id,
                                                             request.response_type,
                                                             request.client, request):

            log.debug('Client %s is not authorized to use response_type %s.',
                      request.client_id, request.response_type)
            raise errors.UnauthorizedClientError(request=request)

        
        
        self.validate_scopes(request)

        request_info.update({
            'client_id': request.client_id,
            'redirect_uri': request.redirect_uri,
            'response_type': request.response_type,
            'state': request.state,
            'request': request,
        })

        request_info = self._run_custom_validators(
            request,
            self.custom_validators.all_post,
            request_info
        )

        return request.scopes, request_info

    def _run_custom_validators(self,
                               request,
                               validations,
                               request_info=None):
        
        request_info = {} if request_info is None else request_info.copy()
        
        
        
        for validator in validations:
            result = validator(request)
            if result is not None:
                request_info.update(result)
        return request_info
