








































from __future__ import print_function
from ._json_formatter import JsonFormatter
from ._logger_adapter import OletoolsLoggerAdapter
from . import _root_logger_wrapper
from ..io_encoding import ensure_stdout_handles_unicode
import logging
import sys


LOG_LEVELS = {
    'debug': logging.DEBUG,
    'info': logging.INFO,
    'warning': logging.WARNING,
    'error': logging.ERROR,
    'critical': logging.CRITICAL
}



NOTSET = logging.NOTSET

DEFAULT_LOGGER_NAME = 'oletools'
DEFAULT_MESSAGE_FORMAT = '%(levelname)-8s %(message)s'


class LogHelper:
    

    
    NOTSET = logging.NOTSET

    def __init__(self):
        self._all_names = set()  
        self._use_json = False
        self._is_enabled = False
        self._target_stream = None

    def get_or_create_silent_logger(self, name=DEFAULT_LOGGER_NAME, level=logging.CRITICAL + 1):
        
        return self._get_or_create_logger(name, level, logging.NullHandler())

    def enable_logging(self, use_json=False, level='warning', log_format=DEFAULT_MESSAGE_FORMAT, stream=None,
                       other_logger_has_first_line=False):
        
        if self._is_enabled:
            raise ValueError('re-enabling logging. Not sure whether that is ok...')

        if stream is None:
            self.target_stream = sys.stdout
        else:
            self.target_stream = stream

        if self.target_stream == sys.stdout:
            ensure_stdout_handles_unicode()

        log_level = LOG_LEVELS[level]
        logging.basicConfig(level=log_level, format=log_format,
                            stream=self.target_stream)
        self._is_enabled = True

        self._use_json = use_json
        sys.excepthook = self._get_except_hook(sys.excepthook)

        
        logging.captureWarnings(True)
        warn_logger = self.get_or_create_silent_logger('py.warnings')
        warn_logger.set_warnings_logger()

        
        
        for name in self._all_names:
            logger = self.get_or_create_silent_logger(name)
            self._set_logger_level(logger, logging.NOTSET)

        
        if self._use_json:
            _root_logger_wrapper.set_formatter(JsonFormatter(other_logger_has_first_line))
            print('[', file=self.target_stream)

    def end_logging(self):
        
        if not self._is_enabled:
            return
        self._is_enabled = False

        
        self._all_names = set()
        logging.captureWarnings(False)
        logging.shutdown()

        
        if self._use_json:
            print(']', file=self.target_stream)
        self._use_json = False

    def _get_except_hook(self, old_hook):
        
        def hook(exctype, value, traceback):
            self.end_logging()
            old_hook(exctype, value, traceback)

        return hook

    def _get_or_create_logger(self, name, level, handler=None):
        

        
        
        if handler and not self._log_exists(name):
            logger = logging.getLogger(name)
            logger.addHandler(handler)
            self._set_logger_level(logger, level)
        else:
            logger = logging.getLogger(name)

        
        
        self._all_names.add(name)

        adapted_logger = OletoolsLoggerAdapter(logger, None)
        adapted_logger.set_json_enabled_function(lambda: self._use_json)

        return adapted_logger

    @staticmethod
    def _set_logger_level(logger, level):
        

        
        if isinstance(logger, OletoolsLoggerAdapter):
            logger = logger.logger

        if _root_logger_wrapper.is_logging_initialized():
            logger.setLevel(logging.NOTSET)
        else:
            logger.setLevel(level)

    @staticmethod
    def _log_exists(name):
        
        return name in logging.Logger.manager.loggerDict
