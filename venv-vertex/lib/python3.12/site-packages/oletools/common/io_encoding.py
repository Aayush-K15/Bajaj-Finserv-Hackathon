


































from __future__ import print_function
import sys
import codecs
import os
from locale import getpreferredencoding

PY3 = sys.version_info.major >= 3

if PY3:
    from builtins import open as builtin_open
else:
    from __builtin__ import open as builtin_open    



FALLBACK_ENCODING_REDIRECT = 'utf8'


FALLBACK_ENCODING_OPEN = 'utf8'


DEBUG = False


try:
    PREFERRED_ENCODING = getpreferredencoding()
except Exception as exc:
    if DEBUG:
        print('Exception getting preferred encoding: {}'.format(exc))
    PREFERRED_ENCODING = None





def ensure_stdout_handles_unicode():
    
    
    if isinstance(sys.stdout, codecs.StreamWriter):
        if DEBUG:
            print('sys.stdout wrapped already')
        return

    
    if PY3:
        output_stream = sys.stdout.buffer
    else:
        output_stream = sys.stdout

    
    try:
        encoding = sys.stdout.encoding
    except AttributeError:              
        encoding = None
    if DEBUG:
        print('sys.stdout encoding is {}'.format(encoding))

    if isinstance(encoding, str) and encoding.lower().startswith('utf'):
        if DEBUG:
            print('encoding is acceptable')
        return     
    elif os.isatty(output_stream.fileno()):   
        
        
        print('Encoding for stdout is only {}, will replace other chars to '
              'avoid unicode error'.format(encoding), file=sys.stderr)
        sys.stdout = codecs.getwriter(encoding)(output_stream, errors='replace')
    else:                                  
        new_encoding = PREFERRED_ENCODING
        if DEBUG:
            print('not a tty, try preferred encoding {}'.format(new_encoding))
        if not isinstance(new_encoding, str) \
                or not new_encoding.lower().startswith('utf'):
            new_encoding = FALLBACK_ENCODING_REDIRECT
            if DEBUG:
                print('preferred encoding also unacceptable, fall back to {}'
                      .format(new_encoding))
        print('Encoding for stdout is only {}, will auto-encode text with {} '
              'before output'.format(encoding, new_encoding), file=sys.stderr)
        sys.stdout = codecs.getwriter(new_encoding)(output_stream)


def uopen(filename, mode='r', *args, **kwargs):
    
    
    if 'b' in mode:
        if DEBUG:
            print('Opening binary file, do not interfere')
        return builtin_open(filename, mode, *args, **kwargs)
    if 'encoding' in kwargs:
        if DEBUG:
            print('Opening file with encoding {!r}, do not interfere'
                  .format(kwargs['encoding']))
        return builtin_open(filename, mode, *args, **kwargs)
    if len(args) > 3:    
        if DEBUG:
            print('Opening file with encoding {!r}, do not interfere'
                  .format(args[3]))
        return builtin_open(filename, mode, *args, **kwargs)

    
    encoding = PREFERRED_ENCODING
    if DEBUG:
        print('preferred encoding is {}'.format(encoding))

    if isinstance(encoding, str) and encoding.lower().startswith('utf'):
        if DEBUG:
            print('encoding is acceptable, open {} regularly'.format(filename))
        return builtin_open(filename, mode, *args, **kwargs)

    
    
    if DEBUG:
        print('Opening {} with fallback encoding {}'
              .format(filename, FALLBACK_ENCODING_OPEN))
    if PY3:
        return builtin_open(filename, mode, *args,
                            encoding=FALLBACK_ENCODING_OPEN, **kwargs)
    else:
        handle = builtin_open(filename, mode, *args, **kwargs)
        return codecs.EncodedFile(handle, FALLBACK_ENCODING_OPEN)
