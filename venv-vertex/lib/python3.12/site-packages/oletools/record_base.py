





























from __future__ import print_function









__version__ = '0.60.2'

















import sys
import os.path
from io import SEEK_CUR

import olefile


PARENT_DIR = os.path.normpath(os.path.dirname(os.path.dirname(
    os.path.abspath(__file__))))
if PARENT_DIR not in sys.path:
    sys.path.insert(0, PARENT_DIR)
del PARENT_DIR
from oletools.common.log_helper import log_helper






OleFileIO = olefile.OleFileIO
STGTY_EMPTY     = olefile.STGTY_EMPTY      
STGTY_STORAGE   = olefile.STGTY_STORAGE    
STGTY_STREAM    = olefile.STGTY_STREAM     
STGTY_LOCKBYTES = olefile.STGTY_LOCKBYTES  
STGTY_PROPERTY  = olefile.STGTY_PROPERTY   
STGTY_ROOT      = olefile.STGTY_ROOT       
STGTY_SUBSTREAM = 10

ENTRY_TYPE2STR = {
    olefile.STGTY_EMPTY: 'empty',
    olefile.STGTY_STORAGE: 'storage',
    olefile.STGTY_STREAM: 'stream',
    olefile.STGTY_LOCKBYTES: 'lock-bytes',
    olefile.STGTY_PROPERTY: 'property',
    olefile.STGTY_ROOT: 'root',
    STGTY_SUBSTREAM: 'substream'
}


logger = log_helper.get_or_create_silent_logger('record_base')


def enable_olefile_logging():
    
    olefile.enable_logging()


def enable_logging():
    
    logger.setLevel(log_helper.NOTSET)







SUMMARY_INFORMATION_STREAM_NAMES = ('\x05SummaryInformation',
                                    '\x05DocumentSummaryInformation')


class OleRecordFile(olefile.OleFileIO):
    

    def open(self, filename, *args, **kwargs):
        
        
        OleFileIO.open(self, filename, *args, **kwargs)

    @classmethod
    def stream_class_for_name(cls, stream_name):
        
        return OleRecordStream    

    def iter_streams(self):
        
        logger.debug('Finding streams in ole file')

        for sid, direntry in enumerate(self.direntries):
            is_orphan = direntry is None
            if is_orphan:
                
                direntry = self._load_direntry(sid)
            is_stream = direntry.entry_type == olefile.STGTY_STREAM
            logger.debug('direntry {:2d} {}: {}'.format(
                sid, '[orphan]' if is_orphan else direntry.name,
                'is stream of size {}'.format(direntry.size) if is_stream else
                'no stream ({})'.format(ENTRY_TYPE2STR[direntry.entry_type])))
            if is_stream:
                if not is_orphan and \
                        direntry.name in SUMMARY_INFORMATION_STREAM_NAMES:
                    clz = OleSummaryInformationStream
                else:
                    clz = self.stream_class_for_name(direntry.name)
                stream = clz(self._open(direntry.isectStart, direntry.size),
                             direntry.size,
                             None if is_orphan else direntry.name,
                             direntry.entry_type)
                yield stream
                stream.close()


class OleRecordStream(object):
    

    def __init__(self, stream, size, name, stream_type):
        self.stream = stream
        self.size = size
        self.name = name
        if stream_type not in ENTRY_TYPE2STR:
            raise ValueError('Unknown stream type: {0}'.format(stream_type))
        self.stream_type = stream_type

    def read_record_head(self):
        
        raise NotImplementedError('Abstract method '
                                  'OleRecordStream.read_record_head called')

    @classmethod
    def record_class_for_type(cls, rec_type):
        
        return OleRecordBase, False

    def iter_records(self, fill_data=False):
        
        while True:
            
            pos = self.stream.tell()
            if pos >= self.size:
                break

            
            rec_type, rec_size, other = self.read_record_head()
            
            

            
            rec_clz, force_read = self.record_class_for_type(rec_type)

            if fill_data or force_read:
                data = self.stream.read(rec_size)
                if len(data) != rec_size:
                    raise IOError('Unexpected end of stream ({0} < {1})'
                                  .format(len(data), rec_size))
            else:
                self.stream.seek(rec_size, SEEK_CUR)
                data = None
            rec_object = rec_clz(rec_type, rec_size, other, pos, data)

            
            rec_object.read_some_more(self.stream)
            yield rec_object

    def close(self):
        
        self.stream.close()

    def __str__(self):
        return '[{0} {1} (type {2}, size {3})' \
               .format(self.__class__.__name__,
                       self.name or '[orphan]',
                       ENTRY_TYPE2STR[self.stream_type],
                       self.size)


class OleSummaryInformationStream(OleRecordStream):
    
    def iter_records(self, fill_data=False):
        
        return
        yield   


class OleRecordBase(object):
    

    
    TYPE = None

    
    MAX_SIZE = None
    SIZE = None

    def __init__(self, type, size, more_data, pos, data):
        
        if self.TYPE is not None and type != self.TYPE:
            raise ValueError('Wrong subclass {0} for type {1}'
                             .format(self.__class__.__name__, type))
        self.type = type
        if self.SIZE is not None and size != self.SIZE:
            raise ValueError('Wrong size {0} for record type {1}'
                             .format(size, type))
        elif self.MAX_SIZE is not None and size > self.MAX_SIZE:
            raise ValueError('Wrong size: {0} > MAX_SIZE for record type {1}'
                             .format(size, type))
        self.size = size
        self.pos = pos
        self.data = data
        self.finish_constructing(more_data)

    def finish_constructing(self, more_data):
        
        pass

    def read_some_more(self, stream):
        
        return

    def _type_str(self):
        
        return '{0} type {1}'.format(self.__class__.__name__, self.type)

    def __str__(self):
        
        return '[' + self._type_str() + \
               ' (size {0} from {1})]'.format(self.size, self.pos)







def test(filenames, ole_file_class=OleRecordFile,
         must_parse=None, do_per_record=None, verbose=False):
    
    log_helper.enable_logging(False, 'debug' if verbose else 'info')
    if do_per_record is None:
        def do_per_record(record):         
            pass   
    if not filenames:
        logger.info('need file name[s]')
        return 2
    for filename in filenames:
        logger.info('checking file {0}'.format(filename))
        if not olefile.isOleFile(filename):
            logger.info('not an ole file - skip')
            continue
        ole = ole_file_class(filename)

        for stream in ole.iter_streams():
            logger.info('  parse ' + str(stream))
            try:
                for record in stream.iter_records():
                    logger.info('    ' + str(record))
                    do_per_record(record)
            except Exception:
                if not must_parse:
                    raise
                elif isinstance(stream, must_parse):
                    raise
                else:
                    logger.info('  failed to parse', exc_info=True)

    log_helper.end_logging()
    return 0


if __name__ == '__main__':
    sys.exit(test(sys.argv[1:]))
