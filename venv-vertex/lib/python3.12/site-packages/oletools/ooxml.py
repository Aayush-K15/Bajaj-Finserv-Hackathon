

































__version__ = '0.54.2'











import sys
from oletools.common.log_helper import log_helper
from oletools.common.io_encoding import uopen
from zipfile import ZipFile, BadZipfile, is_zipfile
from os.path import splitext
import io
import re


try:
    
    import lxml.etree as ET
except ImportError:
    import xml.etree.cElementTree as ET






logger = log_helper.get_or_create_silent_logger('ooxml')


FILE_CONTENT_TYPES = '[Content_Types].xml'
FILE_RELATIONSHIPS = '_rels/.rels'


CONTENT_TYPES_EXCEL = (
    'application/vnd.openxmlformats-officedocument.spreadsheetml.',
    'application/vnd.ms-excel.',
)
CONTENT_TYPES_WORD = (
    'application/vnd.openxmlformats-officedocument.wordprocessingml.',
)
CONTENT_TYPES_PPT = (
    'application/vnd.openxmlformats-officedocument.presentationml.',
)


CONTENT_TYPES_NEUTRAL = (
    'application/xml',
    'application/vnd.openxmlformats-package.relationships+xml',
    'application/vnd.openxmlformats-package.core-properties+xml',
    'application/vnd.openxmlformats-officedocument.theme+xml',
    'application/vnd.openxmlformats-officedocument.extended-properties+xml'
)


OFFICE_XML_PROGID_REGEX = r'<\?mso-application progid="(.*)"\?>'
WORD_XML_PROG_ID = 'Word.Document'
EXCEL_XML_PROG_ID = 'Excel.Sheet'


DOCTYPE_WORD = 'word'
DOCTYPE_EXCEL = 'excel'
DOCTYPE_POWERPOINT = 'powerpoint'
DOCTYPE_NONE = 'none'
DOCTYPE_MIXED = 'mixed'
DOCTYPE_WORD_XML = 'word-xml'
DOCTYPE_EXCEL_XML = 'excel-xml'
DOCTYPE_WORD_XML2003 = 'word-xml2003'
DOCTYPE_EXCEL_XML2003 = 'excel-xml2003'







def debug_str(elem):
    
    if elem is None:
        return u'None'
    if elem.tag[0] == '{' and elem.tag.count('}') == 1:
        parts = ['[tag={{...}}{0}'.format(elem.tag[elem.tag.index('}')+1:]), ]
    else:
        parts = ['[tag={0}'.format(elem.tag), ]
    if elem.text:
        parts.append(u'text="{0}"'.format(elem.text.replace('\n', '\\n')))
    if elem.tail:
        parts.append(u'tail="{0}"'.format(elem.tail.replace('\n', '\\n')))
    for key, value in elem.attrib.items():
        parts.append(u'{0}="{1}"'.format(key, value))
        if key == 'ContentType':
            if value.startswith(CONTENT_TYPES_EXCEL):
                parts[-1] += u'-->xls'
            elif value.startswith(CONTENT_TYPES_WORD):
                parts[-1] += u'-->doc'
            elif value.startswith(CONTENT_TYPES_PPT):
                parts[-1] += u'-->ppt'
            elif value in CONTENT_TYPES_NEUTRAL:
                parts[-1] += u'-->_'
            else:
                parts[-1] += u'!!!'

    text = u', '.join(parts)
    if len(text) > 150:
        return text[:147] + u'...]'
    return text + u']'


def isstr(some_var):
    
    if sys.version_info.major == 2:
        return isinstance(some_var, basestring)  
    return isinstance(some_var, str)         







def get_type(filename):
    
    parser = XmlParser(filename)
    if parser.is_single_xml():
        match = None
        with uopen(filename, 'r') as handle:
            match = re.search(OFFICE_XML_PROGID_REGEX, handle.read(1024))
        if not match:
            return DOCTYPE_NONE
        prog_id = match.groups()[0]
        if prog_id == WORD_XML_PROG_ID:
            return DOCTYPE_WORD_XML
        if prog_id == EXCEL_XML_PROG_ID:
            return DOCTYPE_EXCEL_XML
        return DOCTYPE_NONE

    is_doc = False
    is_xls = False
    is_ppt = False
    try:
        for _, elem, _ in parser.iter_xml(FILE_CONTENT_TYPES):
            logger.debug(u'  ' + debug_str(elem))
            try:
                content_type = elem.attrib['ContentType']
            except KeyError:         
                continue
            is_xls |= content_type.startswith(CONTENT_TYPES_EXCEL)
            is_doc |= content_type.startswith(CONTENT_TYPES_WORD)
            is_ppt |= content_type.startswith(CONTENT_TYPES_PPT)
    except BadOOXML as oo_err:
        if oo_err.more_info.startswith('invalid subfile') and \
                FILE_CONTENT_TYPES in oo_err.more_info:
            
            return DOCTYPE_NONE
        raise

    if is_doc and not is_xls and not is_ppt:
        return DOCTYPE_WORD
    if not is_doc and is_xls and not is_ppt:
        return DOCTYPE_EXCEL
    if not is_doc and not is_xls and is_ppt:
        return DOCTYPE_POWERPOINT
    if not is_doc and not is_xls and not is_ppt:
        return DOCTYPE_NONE
    logger.warning('Encountered contradictory content types')
    return DOCTYPE_MIXED


def is_ooxml(filename):
    
    try:
        doctype = get_type(filename)
    except BadOOXML:
        return False
    except IOError:   
        return False
    if doctype == DOCTYPE_NONE:
        return False
    return True







class ZipSubFile(object):
    
    CHUNK_SIZE = 4096

    def __init__(self, container, filename, mode='r', size=None):
        
        self.container = container
        self.name = filename
        if size is None:
            self.size = container.getinfo(filename).file_size
            logger.debug('zip stream has size {0}'.format(self.size))
        else:
            self.size = size
        if 'w' in mode.lower():
            raise ValueError('Can only read, mode "{0}" not allowed'
                             .format(mode))
        self.mode = mode
        self.handle = None
        self.pos = None
        self.closed = True

    def readable(self):
        return True

    def writable(self):
        return False

    def seekable(self):
        return True

    def open(self):
        
        if self.handle is not None:
            raise IOError('re-opening file not supported!')
        self.handle = self.container.open(self.name, self.mode)
        self.pos = 0
        self.closed = False
        
        return self

    def write(self, *args, **kwargs):
        
        raise IOError('writing not implemented')

    def read(self, size=-1):
        
        if self.handle is None:
            raise IOError('read on closed handle')
        if self.pos >= self.size:
            
            return b''   
        data = self.handle.read(size)
        self.pos += len(data)
        
        return data

    def seek(self, pos, offset=io.SEEK_SET):
        
        
        if offset == io.SEEK_SET:
            new_pos = pos
        elif offset == io.SEEK_CUR:
            new_pos = self.pos + pos
        elif offset == io.SEEK_END:
            new_pos = self.size + pos
        else:
            raise ValueError("invalid offset {0}, need SEEK_* constant"
                             .format(offset))

        
        if new_pos < 0:
            
            raise IOError('Seek beyond start of file not allowed')
        elif new_pos == self.pos:
            
            pass
        elif new_pos == 0:
            
            self.reset()
        elif new_pos < self.pos:
            
            self.reset()
            self._seek_skip(new_pos)             
        elif new_pos < self.size:
            
            self._seek_skip(new_pos - self.pos)  
        else:   
            
            self.pos = new_pos    

    def _seek_skip(self, to_skip):
        
        
        
        n_chunks, leftover = divmod(to_skip, self.CHUNK_SIZE)
        for _ in range(n_chunks):
            self.read(self.CHUNK_SIZE)    
        self.read(leftover)
        
        

    def tell(self):
        
        
        return self.pos

    def reset(self):
        
        
        self.close()
        self.open()

    def close(self):
        
        
        if self.handle is not None:
            self.handle.close()
        self.pos = None
        self.handle = None
        self.closed = True

    def __enter__(self):
        
        
        self.open()
        return self

    def __exit__(self, *args, **kwargs):
        
        
        self.close()

    def __str__(self):
        
        if self.handle is None:
            status = 'closed'
        elif self.pos == 0:
            status = 'open, at start'
        elif self.pos >= self.size:
            status = 'open, at end'
        else:
            status = 'open, at pos {0}'.format(self.pos)

        return '[ZipSubFile {0} (size {1}, mode {2}, {3})]' \
               .format(self.name, self.size, self.mode, status)


class BadOOXML(ValueError):
    

    def __init__(self, filename, more_info=None):
        
        super(BadOOXML, self).__init__(
            '{0} is not an Office XML file{1}'
            .format(filename, ': ' + more_info if more_info else ''))
        self.filename = filename
        self.more_info = more_info







class XmlParser(object):
    

    def __init__(self, filename):
        self.filename = filename
        self.did_iter_all = False
        self.subfiles_no_xml = set()
        self._is_single_xml = None

    def is_single_xml(self):
        
        if self._is_single_xml is not None:
            return self._is_single_xml

        if is_zipfile(self.filename):
            self._is_single_xml = False
            return False

        
        match = None
        with uopen(self.filename, 'r') as handle:
            match = re.search(OFFICE_XML_PROGID_REGEX, handle.read(1024))
        if match:
            self._is_single_xml = True
            return True
        raise BadOOXML(self.filename, 'is no zip and has no prog_id')

    def iter_files(self, args=None):
        
        if self.is_single_xml():
            if args:
                raise BadOOXML(self.filename, 'xml has no subfiles')
            
            with open(self.filename, 'rb') as handle:
                yield None, handle   
            self.did_iter_all = True
        else:
            zipper = None
            subfiles = None
            try:
                zipper = ZipFile(self.filename)
                if not args:
                    subfiles = zipper.namelist()
                elif isstr(args):
                    subfiles = [args, ]
                else:
                    
                    
                    subfiles = tuple(arg for arg in args)

                for subfile in subfiles:
                    with zipper.open(subfile, 'r') as handle:
                        yield subfile, handle
                if not args:
                    self.did_iter_all = True
            except KeyError as orig_err:
                
                
                raise BadOOXML(self.filename,
                               'invalid subfile: ' + str(orig_err))
            except BadZipfile:
                raise BadOOXML(self.filename, 'not in zip format')
            finally:
                if zipper:
                    zipper.close()

    def iter_xml(self, subfiles=None, need_children=False, tags=None):
        
        if tags is None:
            want_tags = []
        elif isstr(tags):
            want_tags = [tags, ]
            logger.debug('looking for tags: {0}'.format(tags))
        else:
            want_tags = tags
            logger.debug('looking for tags: {0}'.format(tags))

        for subfile, handle in self.iter_files(subfiles):
            events = ('start', 'end')
            depth = 0
            inside_tags = []
            try:
                for event, elem in ET.iterparse(handle, events):
                    if elem is None:
                        continue
                    if event == 'start':
                        if elem.tag in want_tags:
                            logger.debug('remember start of tag {0} at {1}'
                                         .format(elem.tag, depth))
                            inside_tags.append((elem.tag, depth))
                        depth += 1
                        continue
                    assert(event == 'end')
                    depth -= 1
                    assert(depth >= 0)

                    is_wanted = elem.tag in want_tags
                    if is_wanted:
                        curr_tag = (elem.tag, depth)
                        try:
                            if inside_tags[-1] == curr_tag:
                                inside_tags.pop()
                            else:
                                logger.error('found end for wanted tag {0} '
                                             'but last start tag {1} does not'
                                             ' match'.format(curr_tag,
                                                             inside_tags[-1]))
                                
                                while inside_tags and \
                                        inside_tags[-1][1] >= depth:
                                    logger.debug('recover: pop {0}'
                                                 .format(inside_tags[-1]))
                                    inside_tags.pop()
                        except IndexError:    
                            logger.error('found end of {0} at depth {1} but '
                                         'no start event')
                    
                    if is_wanted or not want_tags:
                        yield subfile, elem, depth

                    
                    if not need_children and not inside_tags:
                        elem.clear()
                        
                        
                        
            except ET.ParseError as err:
                self.subfiles_no_xml.add(subfile)
                if subfile is None:    
                    raise BadOOXML(self.filename, 'content is not valid XML')
                elif subfile.endswith('.xml'):
                    log = logger.warning
                else:
                    log = logger.debug
                log('  xml-parsing for {0} failed ({1}). '
                    .format(subfile, err) +
                    'Run iter_non_xml to investigate.')
            assert(depth == 0)

    def get_content_types(self):
        
        if self.is_single_xml():
            return {}, {}

        defaults = []
        files = []
        try:
            for _, elem, _ in self.iter_xml(FILE_CONTENT_TYPES):
                if elem.tag.endswith('Default'):
                    extension = elem.attrib['Extension']
                    if extension.startswith('.'):
                        extension = extension[1:]
                    defaults.append((extension, elem.attrib['ContentType']))
                    logger.debug('found content type for extension {0[0]}: '
                                 '{0[1]}'.format(defaults[-1]))
                elif elem.tag.endswith('Override'):
                    subfile = elem.attrib['PartName']
                    if subfile.startswith('/'):
                        subfile = subfile[1:]
                    files.append((subfile, elem.attrib['ContentType']))
                    logger.debug('found content type for subfile {0[0]}: '
                                 '{0[1]}'.format(files[-1]))
        except BadOOXML as oo_err:
            if oo_err.more_info.startswith('invalid subfile') and \
                    FILE_CONTENT_TYPES in oo_err.more_info:
                
                
                pass
            else:
                raise
        return dict(files), dict(defaults)

    def iter_non_xml(self):
        
        if not self.did_iter_all:
            logger.warning('Did not iterate through complete file. '
                           'Should run iter_xml() without args, first.')
        if not self.subfiles_no_xml:
            return

        
        if self.is_single_xml():
            return

        content_types, content_defaults = self.get_content_types()

        with ZipFile(self.filename) as zipper:
            for subfile in self.subfiles_no_xml:
                if subfile.startswith('/'):
                    subfile = subfile[1:]
                content_type = None
                if subfile in content_types:
                    content_type = content_types[subfile]
                else:
                    extension = splitext(subfile)[1]
                    if extension.startswith('.'):
                        extension = extension[1:]   
                    if extension in content_defaults:
                        content_type = content_defaults[extension]
                with ZipSubFile(zipper, subfile) as handle:
                    yield subfile, content_type, handle


def test():
    
    log_helper.enable_logging(False, 'debug')
    if len(sys.argv) != 2:
        print(u'To test this code, give me a single file as arg')
        return 2

    
    print('Detected type: ' + get_type(sys.argv[1]))

    
    parser = XmlParser(sys.argv[1])
    for subfile, elem, depth in parser.iter_xml():
        if depth < 4:
            print(u'{0} {1}{2}'.format(subfile, '  ' * depth, debug_str(elem)))
    for index, (subfile, content_type, _) in enumerate(parser.iter_non_xml()):
        print(u'Non-XML subfile: {0} of type {1}'
              .format(subfile, content_type or u'unknown'))
        if index > 100:
            print(u'...')
            break

    log_helper.end_logging()

    return 0


if __name__ == '__main__':
    sys.exit(test())
