














import dataclasses
import inspect
import json
import os
import sys
import types
import typing
from typing import (
    Any,
    Callable,
    Dict,
    Iterable,
    List,
    Mapping,
    Optional,
    Sequence,
    Set,
    TypedDict,
    Union,
)
from importlib import metadata as importlib_metadata

import proto

from google.cloud.aiplatform import base
from google.api import httpbody_pb2
from google.protobuf import struct_pb2
from google.protobuf import json_format

try:
    
    
    
    import langchain_core.runnables.config

    RunnableConfig = langchain_core.runnables.config.RunnableConfig
except ImportError:
    RunnableConfig = Any

try:
    import packaging

    SpecifierSet = packaging.specifiers.SpecifierSet
except AttributeError:
    SpecifierSet = Any

try:
    _BUILTIN_MODULE_NAMES: Sequence[str] = sys.builtin_module_names
except AttributeError:
    _BUILTIN_MODULE_NAMES: Sequence[str] = []

try:
    
    _STDLIB_MODULE_NAMES: frozenset = sys.stdlib_module_names
except AttributeError:
    _STDLIB_MODULE_NAMES: frozenset = frozenset()

try:
    _PACKAGE_DISTRIBUTIONS: Mapping[
        str, Sequence[str]
    ] = importlib_metadata.packages_distributions()

except AttributeError:
    _PACKAGE_DISTRIBUTIONS: Mapping[str, Sequence[str]] = {}

try:
    from autogen.agentchat import chat

    AutogenChatResult = chat.ChatResult
except ImportError:
    AutogenChatResult = Any

try:
    from autogen.io import run_response

    AutogenRunResponse = run_response.RunResponse
except ImportError:
    AutogenRunResponse = Any

try:
    import pydantic

    BaseModel = pydantic.BaseModel
except ImportError:
    BaseModel = Any

JsonDict = Dict[str, Any]


class _RequirementsValidationActions(TypedDict):
    append: Set[str]


class _RequirementsValidationWarnings(TypedDict):
    missing: Set[str]
    incompatible: Set[str]


class _RequirementsValidationResult(TypedDict):
    warnings: _RequirementsValidationWarnings
    actions: _RequirementsValidationActions


LOGGER = base.Logger("vertexai.agent_engines")

_BASE_MODULES = set(_BUILTIN_MODULE_NAMES + tuple(_STDLIB_MODULE_NAMES))
_DEFAULT_REQUIRED_PACKAGES = frozenset(["cloudpickle", "pydantic"])
_ACTIONS_KEY = "actions"
_ACTION_APPEND = "append"
_WARNINGS_KEY = "warnings"
_WARNING_MISSING = "missing"
_WARNING_INCOMPATIBLE = "incompatible"
_INSTALLATION_SUBDIR = "installation_scripts"


def to_proto(
    obj: Union[JsonDict, proto.Message],
    message: Optional[proto.Message] = None,
) -> proto.Message:
    
    if message is None:
        message = struct_pb2.Struct()
    if isinstance(obj, (proto.Message, struct_pb2.Struct)):
        return obj
    try:
        json_format.ParseDict(obj, message._pb)
    except AttributeError:
        json_format.ParseDict(obj, message)
    return message


def to_dict(message: proto.Message) -> JsonDict:
    
    try:
        
        result: JsonDict = json.loads(
            json_format.MessageToJson(
                message._pb,
                preserving_proto_field_name=True,
            )
        )
    except AttributeError:
        result: JsonDict = json.loads(
            json_format.MessageToJson(
                message,
                preserving_proto_field_name=True,
            )
        )
    return result


def _dataclass_to_dict_or_raise(obj: Any) -> JsonDict:
    
    if not dataclasses.is_dataclass(obj):
        raise TypeError(f"Object is not a dataclass: {obj}")
    return json.loads(json.dumps(dataclasses.asdict(obj)))


def _autogen_run_response_protocol_to_dict(
    obj: AutogenRunResponse,
) -> JsonDict:
    
    if hasattr(obj, "process"):
        obj.process()

    last_speaker = None
    if getattr(obj, "last_speaker", None) is not None:
        last_speaker = {
            "name": getattr(obj.last_speaker, "name", None),
            "description": getattr(obj.last_speaker, "description", None),
        }

    cost = None
    if getattr(obj, "cost", None) is not None:
        if hasattr(obj.cost, "model_dump_json"):
            cost = json.loads(obj.cost.model_dump_json())
        else:
            cost = str(obj.cost)

    result = {
        "summary": getattr(obj, "summary", None),
        "messages": list(getattr(obj, "messages", [])),
        "context_variables": getattr(obj, "context_variables", None),
        "last_speaker": last_speaker,
        "cost": cost,
    }
    return json.loads(json.dumps(result))


def to_json_serializable_autogen_object(
    obj: Union[
        AutogenChatResult,
        AutogenRunResponse,
    ],
) -> JsonDict:
    
    if isinstance(obj, AutogenChatResult):
        return _dataclass_to_dict_or_raise(obj)
    return _autogen_run_response_protocol_to_dict(obj)


def yield_parsed_json(body: httpbody_pb2.HttpBody) -> Iterable[Any]:
    
    content_type = getattr(body, "content_type", None)
    data = getattr(body, "data", None)

    if content_type is None or data is None or "application/json" not in content_type:
        yield body
        return

    try:
        utf8_data = data.decode("utf-8")
    except Exception as e:
        LOGGER.warning(f"Failed to decode data: {data}. Exception: {e}")
        yield body
        return

    if not utf8_data:
        yield None
        return

    
    for line in utf8_data.split("\n"):
        if line:
            try:
                line = json.loads(line)
            except Exception as e:
                LOGGER.warning(f"failed to parse json: {line}. Exception: {e}")
            yield line


def parse_constraints(
    constraints: Sequence[str],
) -> Mapping[str, "SpecifierSet"]:
    
    requirements = _import_packaging_requirements_or_raise()
    result = {}
    for constraint in constraints:
        try:
            if constraint.endswith(".whl"):
                constraint = os.path.basename(constraint)
            requirement = requirements.Requirement(constraint)
        except Exception as e:
            LOGGER.warning(f"Failed to parse constraint: {constraint}. Exception: {e}")
            continue
        result[requirement.name] = requirement.specifier or None
    return result


def validate_requirements_or_warn(
    obj: Any,
    requirements: List[str],
    logger: base.Logger = LOGGER,
) -> Mapping[str, str]:
    
    requirements = requirements.copy()
    try:
        current_requirements = scan_requirements(obj)
        logger.info(f"Identified the following requirements: {current_requirements}")
        constraints = parse_constraints(requirements)
        missing_requirements = compare_requirements(current_requirements, constraints)
        for warning_type, warnings in missing_requirements.get(
            _WARNINGS_KEY, {}
        ).items():
            if warnings:
                logger.warning(
                    f"The following requirements are {warning_type}: {warnings}"
                )
        for action_type, actions in missing_requirements.get(_ACTIONS_KEY, {}).items():
            if actions and action_type == _ACTION_APPEND:
                for action in actions:
                    requirements.append(action)
                logger.info(f"The following requirements are appended: {actions}")
    except Exception as e:
        logger.warning(f"Failed to compile requirements: {e}")
    return requirements


def compare_requirements(
    requirements: Mapping[str, str],
    constraints: Union[Sequence[str], Mapping[str, "SpecifierSet"]],
    *,
    required_packages: Optional[Sequence[str]] = None,
) -> Mapping[str, Mapping[str, Any]]:
    
    packaging_version = _import_packaging_version_or_raise()
    if required_packages is None:
        required_packages = _DEFAULT_REQUIRED_PACKAGES
    result = _RequirementsValidationResult(
        warnings=_RequirementsValidationWarnings(missing=set(), incompatible=set()),
        actions=_RequirementsValidationActions(append=set()),
    )
    if isinstance(constraints, list):
        constraints = parse_constraints(constraints)
    for package, package_version in requirements.items():
        if package not in constraints:
            result[_WARNINGS_KEY][_WARNING_MISSING].add(package)
            if package in required_packages:
                result[_ACTIONS_KEY][_ACTION_APPEND].add(
                    f"{package}=={package_version}"
                )
            continue
        if package_version:
            package_specifier = constraints[package]
            if not package_specifier:
                continue
            if packaging_version.Version(package_version) not in package_specifier:
                result[_WARNINGS_KEY][_WARNING_INCOMPATIBLE].add(
                    f"{package}=={package_version} (required: {str(package_specifier)})"
                )
    return result


def scan_requirements(
    obj: Any,
    ignore_modules: Optional[Sequence[str]] = None,
    package_distributions: Optional[Mapping[str, Sequence[str]]] = None,
    inspect_getmembers_kwargs: Optional[Mapping[str, Any]] = None,
) -> Mapping[str, str]:
    
    if ignore_modules is None:
        ignore_modules = _BASE_MODULES
    if package_distributions is None:
        package_distributions = _PACKAGE_DISTRIBUTIONS
    modules_found = set(_DEFAULT_REQUIRED_PACKAGES)
    inspect_getmembers_kwargs = inspect_getmembers_kwargs or {}
    for _, attr in inspect.getmembers(obj, **inspect_getmembers_kwargs):
        if not attr or inspect.isbuiltin(attr) or not hasattr(attr, "__module__"):
            continue
        module_name = (attr.__module__ or "").split(".")[0]
        if module_name and module_name not in ignore_modules:
            for module in package_distributions.get(module_name, []):
                modules_found.add(module)
    return {module: importlib_metadata.version(module) for module in modules_found}


def generate_schema(
    f: Callable[..., Any],
    *,
    schema_name: Optional[str] = None,
    descriptions: Mapping[str, str] = {},
    required: Sequence[str] = [],
) -> JsonDict:
    
    pydantic = _import_pydantic_or_raise()
    defaults = dict(inspect.signature(f).parameters)
    fields_dict = {
        name: (
            
            
            (param.annotation if param.annotation != inspect.Parameter.empty else Any),
            pydantic.Field(
                
                
                
                
                
                
                description=descriptions.get(name, None),
            ),
        )
        for name, param in defaults.items()
        
        if param.kind
        in (
            inspect.Parameter.POSITIONAL_OR_KEYWORD,
            inspect.Parameter.KEYWORD_ONLY,
            inspect.Parameter.POSITIONAL_ONLY,
        )
    }
    parameters = pydantic.create_model(f.__name__, **fields_dict).schema()
    
    
    
    
    parameters.pop("title", "")
    for name, function_arg in parameters.get("properties", {}).items():
        function_arg.pop("title", "")
        annotation = defaults[name].annotation
        
        
        
        
        if typing.get_origin(annotation) is Union and type(None) in typing.get_args(
            annotation
        ):
            
            
            
            
            for schema in function_arg.pop("anyOf", []):
                schema_type = schema.get("type")
                if schema_type and schema_type != "null":
                    function_arg["type"] = schema_type
                    break
            function_arg["nullable"] = True
    
    if required:
        
        parameters["required"] = required
    else:
        
        parameters["required"] = [
            k
            for k in defaults
            if (
                defaults[k].default == inspect.Parameter.empty
                and defaults[k].kind
                in (
                    inspect.Parameter.POSITIONAL_OR_KEYWORD,
                    inspect.Parameter.KEYWORD_ONLY,
                    inspect.Parameter.POSITIONAL_ONLY,
                )
            )
        ]
    schema = dict(name=f.__name__, description=f.__doc__, parameters=parameters)
    if schema_name:
        schema["name"] = schema_name
    return schema


def is_noop_or_proxy_tracer_provider(tracer_provider) -> bool:
    
    opentelemetry = _import_opentelemetry_or_warn()
    ProxyTracerProvider = opentelemetry.trace.ProxyTracerProvider
    NoOpTracerProvider = opentelemetry.trace.NoOpTracerProvider
    return isinstance(tracer_provider, (NoOpTracerProvider, ProxyTracerProvider))


def dump_event_for_json(event: BaseModel) -> Dict[str, Any]:
    
    return json.loads(event.model_dump_json(exclude_none=True))


def _import_cloud_storage_or_raise() -> types.ModuleType:
    
    try:
        from google.cloud import storage
    except ImportError as e:
        raise ImportError(
            "Cloud Storage is not installed. Please call "
            "'pip install google-cloud-aiplatform[agent_engines]'."
        ) from e
    return storage


def _import_cloudpickle_or_raise() -> types.ModuleType:
    
    try:
        import cloudpickle  
    except ImportError as e:
        raise ImportError(
            "cloudpickle is not installed. Please call "
            "'pip install google-cloud-aiplatform[agent_engines]'."
        ) from e
    return cloudpickle


def _import_pydantic_or_raise() -> types.ModuleType:
    
    try:
        import pydantic

        _ = pydantic.Field
    except AttributeError:
        from pydantic import v1 as pydantic
    except ImportError as e:
        raise ImportError(
            "pydantic is not installed. Please call "
            "'pip install google-cloud-aiplatform[agent_engines]'."
        ) from e
    return pydantic


def _import_packaging_requirements_or_raise() -> types.ModuleType:
    
    try:
        from packaging import requirements
    except ImportError as e:
        raise ImportError(
            "packaging.requirements is not installed. Please call "
            "'pip install google-cloud-aiplatform[agent_engines]'."
        ) from e
    return requirements


def _import_packaging_version_or_raise() -> types.ModuleType:
    
    try:
        from packaging import version
    except ImportError as e:
        raise ImportError(
            "packaging.version is not installed. Please call "
            "'pip install google-cloud-aiplatform[agent_engines]'."
        ) from e
    return version


def _import_opentelemetry_or_warn() -> Optional[types.ModuleType]:
    
    try:
        import opentelemetry  

        return opentelemetry
    except ImportError:
        LOGGER.warning(
            "opentelemetry-sdk is not installed. Please call "
            "'pip install google-cloud-aiplatform[agent_engines]'."
        )
    return None


def _import_opentelemetry_sdk_trace_or_warn() -> Optional[types.ModuleType]:
    
    try:
        import opentelemetry.sdk.trace  

        return opentelemetry.sdk.trace
    except ImportError:
        LOGGER.warning(
            "opentelemetry-sdk is not installed. Please call "
            "'pip install google-cloud-aiplatform[agent_engines]'."
        )
    return None


def _import_cloud_trace_v2_or_warn() -> Optional[types.ModuleType]:
    
    try:
        import google.cloud.trace_v2

        return google.cloud.trace_v2
    except ImportError:
        LOGGER.warning(
            "google-cloud-trace is not installed. Please call "
            "'pip install google-cloud-aiplatform[agent_engines]'."
        )
    return None


def _import_cloud_trace_exporter_or_warn() -> Optional[types.ModuleType]:
    
    try:
        import opentelemetry.exporter.cloud_trace  

        return opentelemetry.exporter.cloud_trace
    except ImportError:
        LOGGER.warning(
            "opentelemetry-exporter-gcp-trace is not installed. Please "
            "call 'pip install google-cloud-aiplatform[agent_engines]'."
        )
    return None


def _import_openinference_langchain_or_warn() -> Optional[types.ModuleType]:
    
    try:
        import openinference.instrumentation.langchain  

        return openinference.instrumentation.langchain
    except ImportError:
        LOGGER.warning(
            "openinference-instrumentation-langchain is not installed. Please "
            "call 'pip install google-cloud-aiplatform[langchain]'."
        )
    return None


def _import_openinference_autogen_or_warn() -> Optional[types.ModuleType]:
    
    try:
        import openinference.instrumentation.autogen  

        return openinference.instrumentation.autogen
    except ImportError:
        LOGGER.warning(
            "openinference-instrumentation-autogen is not installed. Please "
            "call 'pip install google-cloud-aiplatform[ag2]'."
        )
    return None


def _import_autogen_tools_or_warn() -> Optional[types.ModuleType]:
    
    try:
        from autogen import tools

        return tools
    except ImportError:
        LOGGER.warning(
            "autogen.tools is not installed. Please "
            "call `pip install google-cloud-aiplatform[ag2]`."
        )
    return None


def validate_installation_scripts_or_raise(
    script_paths: Sequence[str],
    extra_packages: Sequence[str],
):
    
    for script_path in script_paths:
        if not script_path.startswith(_INSTALLATION_SUBDIR):
            LOGGER.warning(
                f"User-defined installation script '{script_path}' is not in "
                f"the expected '{_INSTALLATION_SUBDIR}' subdirectory. "
                f"Ensure it is placed in '{_INSTALLATION_SUBDIR}' within your "
                f"`extra_packages`."
            )
            raise ValueError(
                f"Required installation script '{script_path}' "
                f"is not under '{_INSTALLATION_SUBDIR}'"
            )

        if script_path not in extra_packages:
            LOGGER.warning(
                f"User-defined installation script '{script_path}' is not in "
                f"extra_packages. Ensure it is added to `extra_packages`."
            )
            raise ValueError(
                f"User-defined installation script '{script_path}' "
                f"does not exist in `extra_packages`"
            )

    for extra_package in extra_packages:
        if (
            extra_package.startswith(_INSTALLATION_SUBDIR)
            and extra_package not in script_paths
        ):
            LOGGER.warning(
                f"Extra package '{extra_package}' is in the installation "
                "scripts subdirectory, but is not specified as an installation "
                "script in `build_options`. "
                "Ensure it is added to installation_scripts for "
                "automatic execution."
            )
            raise ValueError(
                f"Extra package '{extra_package}' is in the installation "
                "scripts subdirectory, but is not specified as an installation "
                "script in `build_options`."
            )
    return
