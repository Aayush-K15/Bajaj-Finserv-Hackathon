
















import datetime
import importlib
import json
import logging
import os
import re
import typing
from typing import (
    Any,
    Callable,
    ClassVar,
    Dict,
    List,
    Literal,
    Optional,
    Tuple,
    TypeVar,
    Union,
)
from google.genai import _common
from google.genai import types as genai_types
from pydantic import (
    ConfigDict,
    Field,
    PrivateAttr,
    computed_field,
    field_validator,
    model_validator,
)
from typing_extensions import TypedDict

logger = logging.getLogger("vertexai_genai.types")

__all__ = ["PrebuiltMetric"]  


def __getattr__(name: str) -> typing.Any:
    if name == "PrebuiltMetric":
        module = importlib.import_module("._evals_utils", __package__)
        prebuilt_metric_obj = getattr(module, name)
        globals()[name] = prebuilt_metric_obj
        return prebuilt_metric_obj
    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")


if typing.TYPE_CHECKING:
    import pandas as pd

    PandasDataFrame = pd.DataFrame
else:
    try:
        import pandas as pd

        PandasDataFrame = pd.DataFrame
    except ImportError:
        pd = None
        PandasDataFrame = Any
if typing.TYPE_CHECKING:
    import yaml
else:
    try:
        import yaml
    except ImportError:
        yaml = None

logger = logging.getLogger("vertexai_genai.types")

MetricSubclass = TypeVar("MetricSubclass", bound="Metric")


class PairwiseChoice(_common.CaseInSensitiveEnum):
    

    PAIRWISE_CHOICE_UNSPECIFIED = "PAIRWISE_CHOICE_UNSPECIFIED"
    
    BASELINE = "BASELINE"
    
    CANDIDATE = "CANDIDATE"
    
    TIE = "TIE"
    


class Strategy(_common.CaseInSensitiveEnum):
    

    STRATEGY_UNSPECIFIED = "STRATEGY_UNSPECIFIED"
    
    ON_DEMAND = "ON_DEMAND"
    
    LOW_COST = "LOW_COST"
    
    STANDARD = "STANDARD"
    
    SPOT = "SPOT"
    
    FLEX_START = "FLEX_START"
    


class AcceleratorType(_common.CaseInSensitiveEnum):
    

    ACCELERATOR_TYPE_UNSPECIFIED = "ACCELERATOR_TYPE_UNSPECIFIED"
    
    NVIDIA_TESLA_K80 = "NVIDIA_TESLA_K80"
    
    NVIDIA_TESLA_P100 = "NVIDIA_TESLA_P100"
    
    NVIDIA_TESLA_V100 = "NVIDIA_TESLA_V100"
    
    NVIDIA_TESLA_P4 = "NVIDIA_TESLA_P4"
    
    NVIDIA_TESLA_T4 = "NVIDIA_TESLA_T4"
    
    NVIDIA_TESLA_A100 = "NVIDIA_TESLA_A100"
    
    NVIDIA_A100_80GB = "NVIDIA_A100_80GB"
    
    NVIDIA_L4 = "NVIDIA_L4"
    
    NVIDIA_H100_80GB = "NVIDIA_H100_80GB"
    
    NVIDIA_H100_MEGA_80GB = "NVIDIA_H100_MEGA_80GB"
    
    NVIDIA_H200_141GB = "NVIDIA_H200_141GB"
    
    NVIDIA_B200 = "NVIDIA_B200"
    
    TPU_V2 = "TPU_V2"
    
    TPU_V3 = "TPU_V3"
    
    TPU_V4_POD = "TPU_V4_POD"
    
    TPU_V5_LITEPOD = "TPU_V5_LITEPOD"
    


class Type(_common.CaseInSensitiveEnum):
    

    TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED"
    
    NO_RESERVATION = "NO_RESERVATION"
    
    ANY_RESERVATION = "ANY_RESERVATION"
    
    SPECIFIC_RESERVATION = "SPECIFIC_RESERVATION"
    


class JobState(_common.CaseInSensitiveEnum):
    

    JOB_STATE_UNSPECIFIED = "JOB_STATE_UNSPECIFIED"
    
    JOB_STATE_QUEUED = "JOB_STATE_QUEUED"
    
    JOB_STATE_PENDING = "JOB_STATE_PENDING"
    
    JOB_STATE_RUNNING = "JOB_STATE_RUNNING"
    
    JOB_STATE_SUCCEEDED = "JOB_STATE_SUCCEEDED"
    
    JOB_STATE_FAILED = "JOB_STATE_FAILED"
    
    JOB_STATE_CANCELLING = "JOB_STATE_CANCELLING"
    
    JOB_STATE_CANCELLED = "JOB_STATE_CANCELLED"
    
    JOB_STATE_PAUSED = "JOB_STATE_PAUSED"
    
    JOB_STATE_EXPIRED = "JOB_STATE_EXPIRED"
    
    JOB_STATE_UPDATING = "JOB_STATE_UPDATING"
    
    JOB_STATE_PARTIALLY_SUCCEEDED = "JOB_STATE_PARTIALLY_SUCCEEDED"
    


class Outcome(_common.CaseInSensitiveEnum):
    

    OUTCOME_UNSPECIFIED = "OUTCOME_UNSPECIFIED"
    
    OUTCOME_OK = "OUTCOME_OK"
    
    OUTCOME_FAILED = "OUTCOME_FAILED"
    
    OUTCOME_DEADLINE_EXCEEDED = "OUTCOME_DEADLINE_EXCEEDED"
    


class Language(_common.CaseInSensitiveEnum):
    

    LANGUAGE_UNSPECIFIED = "LANGUAGE_UNSPECIFIED"
    
    PYTHON = "PYTHON"
    


class RubricContentType(_common.CaseInSensitiveEnum):
    

    PROPERTY = "PROPERTY"
    
    NL_QUESTION_ANSWER = "NL_QUESTION_ANSWER"
    
    PYTHON_CODE_ASSERTION = "PYTHON_CODE_ASSERTION"
    


class Importance(_common.CaseInSensitiveEnum):
    

    IMPORTANCE_UNSPECIFIED = "IMPORTANCE_UNSPECIFIED"
    
    HIGH = "HIGH"
    
    MEDIUM = "MEDIUM"
    
    LOW = "LOW"
    


class GenerateMemoriesResponseGeneratedMemoryAction(_common.CaseInSensitiveEnum):
    

    ACTION_UNSPECIFIED = "ACTION_UNSPECIFIED"
    
    CREATED = "CREATED"
    
    UPDATED = "UPDATED"
    
    DELETED = "DELETED"
    


class BleuInstance(_common.BaseModel):
    

    prediction: Optional[str] = Field(
        default=None, description=
    )
    reference: Optional[str] = Field(
        default=None,
        description=,
    )


class BleuInstanceDict(TypedDict, total=False):
    

    prediction: Optional[str]
    

    reference: Optional[str]
    


BleuInstanceOrDict = Union[BleuInstance, BleuInstanceDict]


class BleuSpec(_common.BaseModel):
    

    use_effective_order: Optional[bool] = Field(
        default=None,
        description=,
    )


class BleuSpecDict(TypedDict, total=False):
    

    use_effective_order: Optional[bool]
    


BleuSpecOrDict = Union[BleuSpec, BleuSpecDict]


class BleuInput(_common.BaseModel):

    instances: Optional[list[BleuInstance]] = Field(
        default=None, description=
    )
    metric_spec: Optional[BleuSpec] = Field(
        default=None, description=
    )


class BleuInputDict(TypedDict, total=False):

    instances: Optional[list[BleuInstanceDict]]
    

    metric_spec: Optional[BleuSpecDict]
    


BleuInputOrDict = Union[BleuInput, BleuInputDict]


class ExactMatchInstance(_common.BaseModel):
    

    prediction: Optional[str] = Field(
        default=None, description=
    )
    reference: Optional[str] = Field(
        default=None,
        description=,
    )


class ExactMatchInstanceDict(TypedDict, total=False):
    

    prediction: Optional[str]
    

    reference: Optional[str]
    


ExactMatchInstanceOrDict = Union[ExactMatchInstance, ExactMatchInstanceDict]


class ExactMatchSpec(_common.BaseModel):
    

    pass


class ExactMatchSpecDict(TypedDict, total=False):
    

    pass


ExactMatchSpecOrDict = Union[ExactMatchSpec, ExactMatchSpecDict]


class ExactMatchInput(_common.BaseModel):

    instances: Optional[list[ExactMatchInstance]] = Field(
        default=None,
        description=,
    )
    metric_spec: Optional[ExactMatchSpec] = Field(
        default=None, description=
    )


class ExactMatchInputDict(TypedDict, total=False):

    instances: Optional[list[ExactMatchInstanceDict]]
    

    metric_spec: Optional[ExactMatchSpecDict]
    


ExactMatchInputOrDict = Union[ExactMatchInput, ExactMatchInputDict]


class RougeInstance(_common.BaseModel):
    

    prediction: Optional[str] = Field(
        default=None, description=
    )
    reference: Optional[str] = Field(
        default=None,
        description=,
    )


class RougeInstanceDict(TypedDict, total=False):
    

    prediction: Optional[str]
    

    reference: Optional[str]
    


RougeInstanceOrDict = Union[RougeInstance, RougeInstanceDict]


class RougeSpec(_common.BaseModel):
    

    rouge_type: Optional[str] = Field(
        default=None,
        description=,
    )
    split_summaries: Optional[bool] = Field(
        default=None,
        description=,
    )
    use_stemmer: Optional[bool] = Field(
        default=None,
        description=,
    )


class RougeSpecDict(TypedDict, total=False):
    

    rouge_type: Optional[str]
    

    split_summaries: Optional[bool]
    

    use_stemmer: Optional[bool]
    


RougeSpecOrDict = Union[RougeSpec, RougeSpecDict]


class RougeInput(_common.BaseModel):
    

    instances: Optional[list[RougeInstance]] = Field(
        default=None, description=
    )
    metric_spec: Optional[RougeSpec] = Field(
        default=None, description=
    )


class RougeInputDict(TypedDict, total=False):
    

    instances: Optional[list[RougeInstanceDict]]
    

    metric_spec: Optional[RougeSpecDict]
    


RougeInputOrDict = Union[RougeInput, RougeInputDict]


class ContentMap(_common.BaseModel):
    

    values: Optional[dict[str, "ContentMapContents"]] = Field(
        default=None, description=
    )


class ContentMapDict(TypedDict, total=False):
    

    values: Optional[dict[str, "ContentMapContents"]]
    


ContentMapOrDict = Union[ContentMap, ContentMapDict]


class PointwiseMetricInstance(_common.BaseModel):
    

    json_instance: Optional[str] = Field(
        default=None,
        description=,
    )
    content_map_instance: Optional[ContentMap] = Field(
        default=None,
        description=,
    )


class PointwiseMetricInstanceDict(TypedDict, total=False):
    

    json_instance: Optional[str]
    

    content_map_instance: Optional[ContentMapDict]
    


PointwiseMetricInstanceOrDict = Union[
    PointwiseMetricInstance, PointwiseMetricInstanceDict
]


class CustomOutputFormatConfig(_common.BaseModel):
    

    return_raw_output: Optional[bool] = Field(
        default=None, description=
    )


class CustomOutputFormatConfigDict(TypedDict, total=False):
    

    return_raw_output: Optional[bool]
    


CustomOutputFormatConfigOrDict = Union[
    CustomOutputFormatConfig, CustomOutputFormatConfigDict
]


class PointwiseMetricSpec(_common.BaseModel):
    

    metric_prompt_template: Optional[str] = Field(
        default=None,
        description=,
    )
    custom_output_format_config: Optional[CustomOutputFormatConfig] = Field(
        default=None,
        description=,
    )
    system_instruction: Optional[str] = Field(
        default=None,
        description=,
    )


class PointwiseMetricSpecDict(TypedDict, total=False):
    

    metric_prompt_template: Optional[str]
    

    custom_output_format_config: Optional[CustomOutputFormatConfigDict]
    

    system_instruction: Optional[str]
    


PointwiseMetricSpecOrDict = Union[PointwiseMetricSpec, PointwiseMetricSpecDict]


class PointwiseMetricInput(_common.BaseModel):
    

    instance: Optional[PointwiseMetricInstance] = Field(
        default=None, description=
    )
    metric_spec: Optional[PointwiseMetricSpec] = Field(
        default=None, description=
    )


class PointwiseMetricInputDict(TypedDict, total=False):
    

    instance: Optional[PointwiseMetricInstanceDict]
    

    metric_spec: Optional[PointwiseMetricSpecDict]
    


PointwiseMetricInputOrDict = Union[PointwiseMetricInput, PointwiseMetricInputDict]


class PairwiseMetricInstance(_common.BaseModel):
    

    json_instance: Optional[str] = Field(
        default=None,
        description=,
    )


class PairwiseMetricInstanceDict(TypedDict, total=False):
    

    json_instance: Optional[str]
    


PairwiseMetricInstanceOrDict = Union[PairwiseMetricInstance, PairwiseMetricInstanceDict]


class PairwiseMetricSpec(_common.BaseModel):
    

    metric_prompt_template: Optional[str] = Field(
        default=None,
        description=,
    )
    baseline_response_field_name: Optional[str] = Field(
        default=None,
        description=,
    )
    candidate_response_field_name: Optional[str] = Field(
        default=None,
        description=,
    )
    custom_output_format_config: Optional[CustomOutputFormatConfig] = Field(
        default=None,
        description=,
    )
    system_instruction: Optional[str] = Field(
        default=None,
        description=,
    )


class PairwiseMetricSpecDict(TypedDict, total=False):
    

    metric_prompt_template: Optional[str]
    

    baseline_response_field_name: Optional[str]
    

    candidate_response_field_name: Optional[str]
    

    custom_output_format_config: Optional[CustomOutputFormatConfigDict]
    

    system_instruction: Optional[str]
    


PairwiseMetricSpecOrDict = Union[PairwiseMetricSpec, PairwiseMetricSpecDict]


class PairwiseMetricInput(_common.BaseModel):
    

    instance: Optional[PairwiseMetricInstance] = Field(
        default=None, description=
    )
    metric_spec: Optional[PairwiseMetricSpec] = Field(
        default=None, description=
    )


class PairwiseMetricInputDict(TypedDict, total=False):
    

    instance: Optional[PairwiseMetricInstanceDict]
    

    metric_spec: Optional[PairwiseMetricSpecDict]
    


PairwiseMetricInputOrDict = Union[PairwiseMetricInput, PairwiseMetricInputDict]


class ToolCallValidInstance(_common.BaseModel):
    

    prediction: Optional[str] = Field(
        default=None, description=
    )
    reference: Optional[str] = Field(
        default=None,
        description=,
    )


class ToolCallValidInstanceDict(TypedDict, total=False):
    

    prediction: Optional[str]
    

    reference: Optional[str]
    


ToolCallValidInstanceOrDict = Union[ToolCallValidInstance, ToolCallValidInstanceDict]


class ToolCallValidSpec(_common.BaseModel):
    

    pass


class ToolCallValidSpecDict(TypedDict, total=False):
    

    pass


ToolCallValidSpecOrDict = Union[ToolCallValidSpec, ToolCallValidSpecDict]


class ToolCallValidInput(_common.BaseModel):
    

    instances: Optional[list[ToolCallValidInstance]] = Field(
        default=None,
        description=,
    )
    metric_spec: Optional[ToolCallValidSpec] = Field(
        default=None,
        description=,
    )


class ToolCallValidInputDict(TypedDict, total=False):
    

    instances: Optional[list[ToolCallValidInstanceDict]]
    

    metric_spec: Optional[ToolCallValidSpecDict]
    


ToolCallValidInputOrDict = Union[ToolCallValidInput, ToolCallValidInputDict]


class ToolNameMatchInstance(_common.BaseModel):
    

    prediction: Optional[str] = Field(
        default=None, description=
    )
    reference: Optional[str] = Field(
        default=None,
        description=,
    )


class ToolNameMatchInstanceDict(TypedDict, total=False):
    

    prediction: Optional[str]
    

    reference: Optional[str]
    


ToolNameMatchInstanceOrDict = Union[ToolNameMatchInstance, ToolNameMatchInstanceDict]


class ToolNameMatchSpec(_common.BaseModel):
    

    pass


class ToolNameMatchSpecDict(TypedDict, total=False):
    

    pass


ToolNameMatchSpecOrDict = Union[ToolNameMatchSpec, ToolNameMatchSpecDict]


class ToolNameMatchInput(_common.BaseModel):
    

    instances: Optional[list[ToolNameMatchInstance]] = Field(
        default=None,
        description=,
    )
    metric_spec: Optional[ToolNameMatchSpec] = Field(
        default=None,
        description=,
    )


class ToolNameMatchInputDict(TypedDict, total=False):
    

    instances: Optional[list[ToolNameMatchInstanceDict]]
    

    metric_spec: Optional[ToolNameMatchSpecDict]
    


ToolNameMatchInputOrDict = Union[ToolNameMatchInput, ToolNameMatchInputDict]


class ToolParameterKeyMatchInstance(_common.BaseModel):
    

    prediction: Optional[str] = Field(
        default=None, description=
    )
    reference: Optional[str] = Field(
        default=None,
        description=,
    )


class ToolParameterKeyMatchInstanceDict(TypedDict, total=False):
    

    prediction: Optional[str]
    

    reference: Optional[str]
    


ToolParameterKeyMatchInstanceOrDict = Union[
    ToolParameterKeyMatchInstance, ToolParameterKeyMatchInstanceDict
]


class ToolParameterKeyMatchSpec(_common.BaseModel):
    

    pass


class ToolParameterKeyMatchSpecDict(TypedDict, total=False):
    

    pass


ToolParameterKeyMatchSpecOrDict = Union[
    ToolParameterKeyMatchSpec, ToolParameterKeyMatchSpecDict
]


class ToolParameterKeyMatchInput(_common.BaseModel):
    

    instances: Optional[list[ToolParameterKeyMatchInstance]] = Field(
        default=None,
        description=,
    )
    metric_spec: Optional[ToolParameterKeyMatchSpec] = Field(
        default=None,
        description=,
    )


class ToolParameterKeyMatchInputDict(TypedDict, total=False):
    

    instances: Optional[list[ToolParameterKeyMatchInstanceDict]]
    

    metric_spec: Optional[ToolParameterKeyMatchSpecDict]
    


ToolParameterKeyMatchInputOrDict = Union[
    ToolParameterKeyMatchInput, ToolParameterKeyMatchInputDict
]


class ToolParameterKVMatchInstance(_common.BaseModel):
    

    prediction: Optional[str] = Field(
        default=None, description=
    )
    reference: Optional[str] = Field(
        default=None,
        description=,
    )


class ToolParameterKVMatchInstanceDict(TypedDict, total=False):
    

    prediction: Optional[str]
    

    reference: Optional[str]
    


ToolParameterKVMatchInstanceOrDict = Union[
    ToolParameterKVMatchInstance, ToolParameterKVMatchInstanceDict
]


class ToolParameterKVMatchSpec(_common.BaseModel):
    

    use_strict_string_match: Optional[bool] = Field(
        default=None,
        description=,
    )


class ToolParameterKVMatchSpecDict(TypedDict, total=False):
    

    use_strict_string_match: Optional[bool]
    


ToolParameterKVMatchSpecOrDict = Union[
    ToolParameterKVMatchSpec, ToolParameterKVMatchSpecDict
]


class ToolParameterKVMatchInput(_common.BaseModel):
    

    instances: Optional[list[ToolParameterKVMatchInstance]] = Field(
        default=None,
        description=,
    )
    metric_spec: Optional[ToolParameterKVMatchSpec] = Field(
        default=None,
        description=,
    )


class ToolParameterKVMatchInputDict(TypedDict, total=False):
    

    instances: Optional[list[ToolParameterKVMatchInstanceDict]]
    

    metric_spec: Optional[ToolParameterKVMatchSpecDict]
    


ToolParameterKVMatchInputOrDict = Union[
    ToolParameterKVMatchInput, ToolParameterKVMatchInputDict
]


class AutoraterConfig(_common.BaseModel):
    

    autorater_model: Optional[str] = Field(
        default=None,
        description=,
    )
    flip_enabled: Optional[bool] = Field(
        default=None,
        description=,
    )
    sampling_count: Optional[int] = Field(
        default=None,
        description=,
    )


class AutoraterConfigDict(TypedDict, total=False):
    

    autorater_model: Optional[str]
    

    flip_enabled: Optional[bool]
    

    sampling_count: Optional[int]
    


AutoraterConfigOrDict = Union[AutoraterConfig, AutoraterConfigDict]


class HttpRetryOptions(_common.BaseModel):
    

    attempts: Optional[int] = Field(
        default=None,
        description=,
    )
    initial_delay: Optional[float] = Field(
        default=None,
        description=,
    )
    max_delay: Optional[float] = Field(
        default=None,
        description=,
    )
    exp_base: Optional[float] = Field(
        default=None,
        description=,
    )
    jitter: Optional[float] = Field(
        default=None, description=
    )
    http_status_codes: Optional[list[int]] = Field(
        default=None,
        description=,
    )


class HttpRetryOptionsDict(TypedDict, total=False):
    

    attempts: Optional[int]
    

    initial_delay: Optional[float]
    

    max_delay: Optional[float]
    

    exp_base: Optional[float]
    

    jitter: Optional[float]
    

    http_status_codes: Optional[list[int]]
    


HttpRetryOptionsOrDict = Union[HttpRetryOptions, HttpRetryOptionsDict]


class HttpOptions(_common.BaseModel):
    

    base_url: Optional[str] = Field(
        default=None,
        description=,
    )
    api_version: Optional[str] = Field(
        default=None, description=
    )
    headers: Optional[dict[str, str]] = Field(
        default=None,
        description=,
    )
    timeout: Optional[int] = Field(
        default=None, description=
    )
    client_args: Optional[dict[str, Any]] = Field(
        default=None, description=
    )
    async_client_args: Optional[dict[str, Any]] = Field(
        default=None, description=
    )
    extra_body: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )
    retry_options: Optional[HttpRetryOptions] = Field(
        default=None, description=
    )


class HttpOptionsDict(TypedDict, total=False):
    

    base_url: Optional[str]
    

    api_version: Optional[str]
    

    headers: Optional[dict[str, str]]
    

    timeout: Optional[int]
    

    client_args: Optional[dict[str, Any]]
    

    async_client_args: Optional[dict[str, Any]]
    

    extra_body: Optional[dict[str, Any]]
    

    retry_options: Optional[HttpRetryOptionsDict]
    


HttpOptionsOrDict = Union[HttpOptions, HttpOptionsDict]


class EvaluateInstancesConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )


class EvaluateInstancesConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    


EvaluateInstancesConfigOrDict = Union[
    EvaluateInstancesConfig, EvaluateInstancesConfigDict
]


class RubricContentProperty(_common.BaseModel):
    

    description: Optional[str] = Field(
        default=None,
        description=,
    )


class RubricContentPropertyDict(TypedDict, total=False):
    

    description: Optional[str]
    


RubricContentPropertyOrDict = Union[RubricContentProperty, RubricContentPropertyDict]


class RubricContent(_common.BaseModel):
    

    property: Optional[RubricContentProperty] = Field(
        default=None,
        description=,
    )


class RubricContentDict(TypedDict, total=False):
    

    property: Optional[RubricContentPropertyDict]
    


RubricContentOrDict = Union[RubricContent, RubricContentDict]


class Rubric(_common.BaseModel):
    

    rubric_id: Optional[str] = Field(
        default=None,
        description=,
    )
    content: Optional[RubricContent] = Field(
        default=None,
        description=,
    )
    type: Optional[str] = Field(
        default=None,
        description=,
    )
    importance: Optional[Importance] = Field(
        default=None,
        description=,
    )


class RubricDict(TypedDict, total=False):
    

    rubric_id: Optional[str]
    

    content: Optional[RubricContentDict]
    

    type: Optional[str]
    

    importance: Optional[Importance]
    


RubricOrDict = Union[Rubric, RubricDict]


class RubricGenerationSpec(_common.BaseModel):
    

    prompt_template: Optional[str] = Field(
        default=None,
        description=,
    )
    generator_model_config: Optional[AutoraterConfig] = Field(
        default=None,
        description=,
    )
    rubric_content_type: Optional[RubricContentType] = Field(
        default=None,
        description=,
    )
    rubric_type_ontology: Optional[list[str]] = Field(
        default=None,
        description=,
    )


class RubricGenerationSpecDict(TypedDict, total=False):
    

    prompt_template: Optional[str]
    

    generator_model_config: Optional[AutoraterConfigDict]
    

    rubric_content_type: Optional[RubricContentType]
    

    rubric_type_ontology: Optional[list[str]]
    


RubricGenerationSpecOrDict = Union[RubricGenerationSpec, RubricGenerationSpecDict]


class RubricBasedMetricSpec(_common.BaseModel):
    

    metric_prompt_template: Optional[str] = Field(
        default=None,
        description=,
    )
    judge_autorater_config: Optional[AutoraterConfig] = Field(
        default=None,
        description=,
    )
    inline_rubrics: Optional[list[Rubric]] = Field(
        default=None,
        description=,
    )
    rubric_group_key: Optional[str] = Field(
        default=None,
        description=,
    )
    rubric_generation_spec: Optional[RubricGenerationSpec] = Field(
        default=None,
        description=,
    )


class RubricBasedMetricSpecDict(TypedDict, total=False):
    

    metric_prompt_template: Optional[str]
    

    judge_autorater_config: Optional[AutoraterConfigDict]
    

    inline_rubrics: Optional[list[RubricDict]]
    

    rubric_group_key: Optional[str]
    

    rubric_generation_spec: Optional[RubricGenerationSpecDict]
    


RubricBasedMetricSpecOrDict = Union[RubricBasedMetricSpec, RubricBasedMetricSpecDict]


class RubricEnhancedContents(_common.BaseModel):
    

    prompt: Optional[list[genai_types.Content]] = Field(
        default=None,
        description=,
    )
    rubric_groups: Optional[dict[str, "RubricGroup"]] = Field(
        default=None,
        description=,
    )
    response: Optional[list[genai_types.Content]] = Field(
        default=None,
        description=,
    )
    other_content: Optional[ContentMap] = Field(
        default=None,
        description=,
    )


class RubricEnhancedContentsDict(TypedDict, total=False):
    

    prompt: Optional[list[genai_types.Content]]
    

    rubric_groups: Optional[dict[str, "RubricGroup"]]
    

    response: Optional[list[genai_types.Content]]
    

    other_content: Optional[ContentMapDict]
    


RubricEnhancedContentsOrDict = Union[RubricEnhancedContents, RubricEnhancedContentsDict]


class RubricBasedMetricInstance(_common.BaseModel):
    

    json_instance: Optional[str] = Field(
        default=None,
        description=,
    )
    content_map_instance: Optional[ContentMap] = Field(
        default=None,
        description=,
    )
    rubric_enhanced_contents: Optional[RubricEnhancedContents] = Field(
        default=None,
        description=,
    )


class RubricBasedMetricInstanceDict(TypedDict, total=False):
    

    json_instance: Optional[str]
    

    content_map_instance: Optional[ContentMapDict]
    

    rubric_enhanced_contents: Optional[RubricEnhancedContentsDict]
    


RubricBasedMetricInstanceOrDict = Union[
    RubricBasedMetricInstance, RubricBasedMetricInstanceDict
]


class RubricBasedMetricInput(_common.BaseModel):
    

    metric_spec: Optional[RubricBasedMetricSpec] = Field(
        default=None,
        description=,
    )
    instance: Optional[RubricBasedMetricInstance] = Field(
        default=None, description=
    )


class RubricBasedMetricInputDict(TypedDict, total=False):
    

    metric_spec: Optional[RubricBasedMetricSpecDict]
    

    instance: Optional[RubricBasedMetricInstanceDict]
    


RubricBasedMetricInputOrDict = Union[RubricBasedMetricInput, RubricBasedMetricInputDict]


class _EvaluateInstancesRequestParameters(_common.BaseModel):
    

    bleu_input: Optional[BleuInput] = Field(default=None, description=)
    exact_match_input: Optional[ExactMatchInput] = Field(
        default=None, description=
    )
    rouge_input: Optional[RougeInput] = Field(default=None, description=)
    pointwise_metric_input: Optional[PointwiseMetricInput] = Field(
        default=None, description=
    )
    pairwise_metric_input: Optional[PairwiseMetricInput] = Field(
        default=None, description=
    )
    tool_call_valid_input: Optional[ToolCallValidInput] = Field(
        default=None, description=
    )
    tool_name_match_input: Optional[ToolNameMatchInput] = Field(
        default=None, description=
    )
    tool_parameter_key_match_input: Optional[ToolParameterKeyMatchInput] = Field(
        default=None, description=
    )
    tool_parameter_kv_match_input: Optional[ToolParameterKVMatchInput] = Field(
        default=None, description=
    )
    rubric_based_metric_input: Optional[RubricBasedMetricInput] = Field(
        default=None, description=
    )
    autorater_config: Optional[AutoraterConfig] = Field(
        default=None, description=
    )
    config: Optional[EvaluateInstancesConfig] = Field(default=None, description=)


class _EvaluateInstancesRequestParametersDict(TypedDict, total=False):
    

    bleu_input: Optional[BleuInputDict]
    

    exact_match_input: Optional[ExactMatchInputDict]
    

    rouge_input: Optional[RougeInputDict]
    

    pointwise_metric_input: Optional[PointwiseMetricInputDict]
    

    pairwise_metric_input: Optional[PairwiseMetricInputDict]
    

    tool_call_valid_input: Optional[ToolCallValidInputDict]
    

    tool_name_match_input: Optional[ToolNameMatchInputDict]
    

    tool_parameter_key_match_input: Optional[ToolParameterKeyMatchInputDict]
    

    tool_parameter_kv_match_input: Optional[ToolParameterKVMatchInputDict]
    

    rubric_based_metric_input: Optional[RubricBasedMetricInputDict]
    

    autorater_config: Optional[AutoraterConfigDict]
    

    config: Optional[EvaluateInstancesConfigDict]
    


_EvaluateInstancesRequestParametersOrDict = Union[
    _EvaluateInstancesRequestParameters, _EvaluateInstancesRequestParametersDict
]


class RubricVerdict(_common.BaseModel):
    

    evaluated_rubric: Optional[Rubric] = Field(
        default=None,
        description=,
    )
    verdict: Optional[bool] = Field(
        default=None,
        description=,
    )
    reasoning: Optional[str] = Field(
        default=None,
        description=,
    )


class RubricVerdictDict(TypedDict, total=False):
    

    evaluated_rubric: Optional[RubricDict]
    

    verdict: Optional[bool]
    

    reasoning: Optional[str]
    


RubricVerdictOrDict = Union[RubricVerdict, RubricVerdictDict]


class RubricBasedMetricResult(_common.BaseModel):
    

    score: Optional[float] = Field(
        default=None, description=
    )
    rubric_verdicts: Optional[list[RubricVerdict]] = Field(
        default=None,
        description=,
    )


class RubricBasedMetricResultDict(TypedDict, total=False):
    

    score: Optional[float]
    

    rubric_verdicts: Optional[list[RubricVerdictDict]]
    


RubricBasedMetricResultOrDict = Union[
    RubricBasedMetricResult, RubricBasedMetricResultDict
]


class BleuMetricValue(_common.BaseModel):
    

    score: Optional[float] = Field(
        default=None, description=
    )


class BleuMetricValueDict(TypedDict, total=False):
    

    score: Optional[float]
    


BleuMetricValueOrDict = Union[BleuMetricValue, BleuMetricValueDict]


class BleuResults(_common.BaseModel):
    

    bleu_metric_values: Optional[list[BleuMetricValue]] = Field(
        default=None, description=
    )


class BleuResultsDict(TypedDict, total=False):
    

    bleu_metric_values: Optional[list[BleuMetricValueDict]]
    


BleuResultsOrDict = Union[BleuResults, BleuResultsDict]


class CometResult(_common.BaseModel):
    

    score: Optional[float] = Field(
        default=None,
        description=,
    )


class CometResultDict(TypedDict, total=False):
    

    score: Optional[float]
    


CometResultOrDict = Union[CometResult, CometResultDict]


class ExactMatchMetricValue(_common.BaseModel):
    

    score: Optional[float] = Field(
        default=None, description=
    )


class ExactMatchMetricValueDict(TypedDict, total=False):
    

    score: Optional[float]
    


ExactMatchMetricValueOrDict = Union[ExactMatchMetricValue, ExactMatchMetricValueDict]


class ExactMatchResults(_common.BaseModel):
    

    exact_match_metric_values: Optional[list[ExactMatchMetricValue]] = Field(
        default=None, description=
    )


class ExactMatchResultsDict(TypedDict, total=False):
    

    exact_match_metric_values: Optional[list[ExactMatchMetricValueDict]]
    


ExactMatchResultsOrDict = Union[ExactMatchResults, ExactMatchResultsDict]


class MetricxResult(_common.BaseModel):
    

    score: Optional[float] = Field(
        default=None,
        description=,
    )


class MetricxResultDict(TypedDict, total=False):
    

    score: Optional[float]
    


MetricxResultOrDict = Union[MetricxResult, MetricxResultDict]


class RawOutput(_common.BaseModel):
    

    raw_output: Optional[list[str]] = Field(
        default=None, description=
    )


class RawOutputDict(TypedDict, total=False):
    

    raw_output: Optional[list[str]]
    


RawOutputOrDict = Union[RawOutput, RawOutputDict]


class CustomOutput(_common.BaseModel):
    

    raw_outputs: Optional[RawOutput] = Field(
        default=None, description=
    )


class CustomOutputDict(TypedDict, total=False):
    

    raw_outputs: Optional[RawOutputDict]
    


CustomOutputOrDict = Union[CustomOutput, CustomOutputDict]


class PairwiseMetricResult(_common.BaseModel):
    

    custom_output: Optional[CustomOutput] = Field(
        default=None, description=
    )
    explanation: Optional[str] = Field(
        default=None,
        description=,
    )
    pairwise_choice: Optional[PairwiseChoice] = Field(
        default=None, description=
    )


class PairwiseMetricResultDict(TypedDict, total=False):
    

    custom_output: Optional[CustomOutputDict]
    

    explanation: Optional[str]
    

    pairwise_choice: Optional[PairwiseChoice]
    


PairwiseMetricResultOrDict = Union[PairwiseMetricResult, PairwiseMetricResultDict]


class PointwiseMetricResult(_common.BaseModel):
    

    custom_output: Optional[CustomOutput] = Field(
        default=None, description=
    )
    explanation: Optional[str] = Field(
        default=None,
        description=,
    )
    score: Optional[float] = Field(
        default=None, description=
    )


class PointwiseMetricResultDict(TypedDict, total=False):
    

    custom_output: Optional[CustomOutputDict]
    

    explanation: Optional[str]
    

    score: Optional[float]
    


PointwiseMetricResultOrDict = Union[PointwiseMetricResult, PointwiseMetricResultDict]


class RougeMetricValue(_common.BaseModel):
    

    score: Optional[float] = Field(
        default=None, description=
    )


class RougeMetricValueDict(TypedDict, total=False):
    

    score: Optional[float]
    


RougeMetricValueOrDict = Union[RougeMetricValue, RougeMetricValueDict]


class RougeResults(_common.BaseModel):
    

    rouge_metric_values: Optional[list[RougeMetricValue]] = Field(
        default=None, description=
    )


class RougeResultsDict(TypedDict, total=False):
    

    rouge_metric_values: Optional[list[RougeMetricValueDict]]
    


RougeResultsOrDict = Union[RougeResults, RougeResultsDict]


class ToolCallValidMetricValue(_common.BaseModel):
    

    score: Optional[float] = Field(
        default=None, description=
    )


class ToolCallValidMetricValueDict(TypedDict, total=False):
    

    score: Optional[float]
    


ToolCallValidMetricValueOrDict = Union[
    ToolCallValidMetricValue, ToolCallValidMetricValueDict
]


class ToolCallValidResults(_common.BaseModel):
    

    tool_call_valid_metric_values: Optional[list[ToolCallValidMetricValue]] = Field(
        default=None,
        description=,
    )


class ToolCallValidResultsDict(TypedDict, total=False):
    

    tool_call_valid_metric_values: Optional[list[ToolCallValidMetricValueDict]]
    


ToolCallValidResultsOrDict = Union[ToolCallValidResults, ToolCallValidResultsDict]


class ToolNameMatchMetricValue(_common.BaseModel):
    

    score: Optional[float] = Field(
        default=None, description=
    )


class ToolNameMatchMetricValueDict(TypedDict, total=False):
    

    score: Optional[float]
    


ToolNameMatchMetricValueOrDict = Union[
    ToolNameMatchMetricValue, ToolNameMatchMetricValueDict
]


class ToolNameMatchResults(_common.BaseModel):
    

    tool_name_match_metric_values: Optional[list[ToolNameMatchMetricValue]] = Field(
        default=None,
        description=,
    )


class ToolNameMatchResultsDict(TypedDict, total=False):
    

    tool_name_match_metric_values: Optional[list[ToolNameMatchMetricValueDict]]
    


ToolNameMatchResultsOrDict = Union[ToolNameMatchResults, ToolNameMatchResultsDict]


class ToolParameterKeyMatchMetricValue(_common.BaseModel):
    

    score: Optional[float] = Field(
        default=None,
        description=,
    )


class ToolParameterKeyMatchMetricValueDict(TypedDict, total=False):
    

    score: Optional[float]
    


ToolParameterKeyMatchMetricValueOrDict = Union[
    ToolParameterKeyMatchMetricValue, ToolParameterKeyMatchMetricValueDict
]


class ToolParameterKeyMatchResults(_common.BaseModel):
    

    tool_parameter_key_match_metric_values: Optional[
        list[ToolParameterKeyMatchMetricValue]
    ] = Field(
        default=None,
        description=,
    )


class ToolParameterKeyMatchResultsDict(TypedDict, total=False):
    

    tool_parameter_key_match_metric_values: Optional[
        list[ToolParameterKeyMatchMetricValueDict]
    ]
    


ToolParameterKeyMatchResultsOrDict = Union[
    ToolParameterKeyMatchResults, ToolParameterKeyMatchResultsDict
]


class ToolParameterKVMatchMetricValue(_common.BaseModel):
    

    score: Optional[float] = Field(
        default=None,
        description=,
    )


class ToolParameterKVMatchMetricValueDict(TypedDict, total=False):
    

    score: Optional[float]
    


ToolParameterKVMatchMetricValueOrDict = Union[
    ToolParameterKVMatchMetricValue, ToolParameterKVMatchMetricValueDict
]


class ToolParameterKVMatchResults(_common.BaseModel):
    

    tool_parameter_kv_match_metric_values: Optional[
        list[ToolParameterKVMatchMetricValue]
    ] = Field(
        default=None,
        description=,
    )


class ToolParameterKVMatchResultsDict(TypedDict, total=False):
    

    tool_parameter_kv_match_metric_values: Optional[
        list[ToolParameterKVMatchMetricValueDict]
    ]
    


ToolParameterKVMatchResultsOrDict = Union[
    ToolParameterKVMatchResults, ToolParameterKVMatchResultsDict
]


class EvaluateInstancesResponse(_common.BaseModel):
    

    rubric_based_metric_result: Optional[RubricBasedMetricResult] = Field(
        default=None, description=
    )
    bleu_results: Optional[BleuResults] = Field(
        default=None, description=
    )
    comet_result: Optional[CometResult] = Field(
        default=None,
        description=,
    )
    exact_match_results: Optional[ExactMatchResults] = Field(
        default=None,
        description=,
    )
    metricx_result: Optional[MetricxResult] = Field(
        default=None, description=
    )
    pairwise_metric_result: Optional[PairwiseMetricResult] = Field(
        default=None, description=
    )
    pointwise_metric_result: Optional[PointwiseMetricResult] = Field(
        default=None,
        description=,
    )
    rouge_results: Optional[RougeResults] = Field(
        default=None, description=
    )
    tool_call_valid_results: Optional[ToolCallValidResults] = Field(
        default=None,
        description=,
    )
    tool_name_match_results: Optional[ToolNameMatchResults] = Field(
        default=None, description=
    )
    tool_parameter_key_match_results: Optional[ToolParameterKeyMatchResults] = Field(
        default=None,
        description=,
    )
    tool_parameter_kv_match_results: Optional[ToolParameterKVMatchResults] = Field(
        default=None,
        description=,
    )


class EvaluateInstancesResponseDict(TypedDict, total=False):
    

    rubric_based_metric_result: Optional[RubricBasedMetricResultDict]
    

    bleu_results: Optional[BleuResultsDict]
    

    comet_result: Optional[CometResultDict]
    

    exact_match_results: Optional[ExactMatchResultsDict]
    

    metricx_result: Optional[MetricxResultDict]
    

    pairwise_metric_result: Optional[PairwiseMetricResultDict]
    

    pointwise_metric_result: Optional[PointwiseMetricResultDict]
    

    rouge_results: Optional[RougeResultsDict]
    

    tool_call_valid_results: Optional[ToolCallValidResultsDict]
    

    tool_name_match_results: Optional[ToolNameMatchResultsDict]
    

    tool_parameter_key_match_results: Optional[ToolParameterKeyMatchResultsDict]
    

    tool_parameter_kv_match_results: Optional[ToolParameterKVMatchResultsDict]
    


EvaluateInstancesResponseOrDict = Union[
    EvaluateInstancesResponse, EvaluateInstancesResponseDict
]


class RubricGenerationConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )


class RubricGenerationConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    


RubricGenerationConfigOrDict = Union[RubricGenerationConfig, RubricGenerationConfigDict]


class _GenerateInstanceRubricsRequest(_common.BaseModel):
    

    contents: Optional[list[genai_types.Content]] = Field(
        default=None,
        description=,
    )
    rubric_generation_spec: Optional[RubricGenerationSpec] = Field(
        default=None,
        description=,
    )
    config: Optional[RubricGenerationConfig] = Field(default=None, description=)


class _GenerateInstanceRubricsRequestDict(TypedDict, total=False):
    

    contents: Optional[list[genai_types.Content]]
    

    rubric_generation_spec: Optional[RubricGenerationSpecDict]
    

    config: Optional[RubricGenerationConfigDict]
    


_GenerateInstanceRubricsRequestOrDict = Union[
    _GenerateInstanceRubricsRequest, _GenerateInstanceRubricsRequestDict
]


class GenerateInstanceRubricsResponse(_common.BaseModel):
    

    generated_rubrics: Optional[list[Rubric]] = Field(
        default=None, description=
    )


class GenerateInstanceRubricsResponseDict(TypedDict, total=False):
    

    generated_rubrics: Optional[list[RubricDict]]
    


GenerateInstanceRubricsResponseOrDict = Union[
    GenerateInstanceRubricsResponse, GenerateInstanceRubricsResponseDict
]


class OptimizeConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )


class OptimizeConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    


OptimizeConfigOrDict = Union[OptimizeConfig, OptimizeConfigDict]


class _OptimizeRequestParameters(_common.BaseModel):
    

    config: Optional[OptimizeConfig] = Field(default=None, description=)


class _OptimizeRequestParametersDict(TypedDict, total=False):
    

    config: Optional[OptimizeConfigDict]
    


_OptimizeRequestParametersOrDict = Union[
    _OptimizeRequestParameters, _OptimizeRequestParametersDict
]


class OptimizeResponse(_common.BaseModel):
    

    pass


class OptimizeResponseDict(TypedDict, total=False):
    

    pass


OptimizeResponseOrDict = Union[OptimizeResponse, OptimizeResponseDict]


class GcsDestination(_common.BaseModel):
    

    output_uri_prefix: Optional[str] = Field(
        default=None,
        description=,
    )


class GcsDestinationDict(TypedDict, total=False):
    

    output_uri_prefix: Optional[str]
    


GcsDestinationOrDict = Union[GcsDestination, GcsDestinationDict]


class DnsPeeringConfig(_common.BaseModel):
    

    domain: Optional[str] = Field(
        default=None,
        description=,
    )
    target_network: Optional[str] = Field(
        default=None,
        description=,
    )
    target_project: Optional[str] = Field(
        default=None,
        description=,
    )


class DnsPeeringConfigDict(TypedDict, total=False):
    

    domain: Optional[str]
    

    target_network: Optional[str]
    

    target_project: Optional[str]
    


DnsPeeringConfigOrDict = Union[DnsPeeringConfig, DnsPeeringConfigDict]


class PscInterfaceConfig(_common.BaseModel):
    

    dns_peering_configs: Optional[list[DnsPeeringConfig]] = Field(
        default=None,
        description=,
    )
    network_attachment: Optional[str] = Field(
        default=None,
        description=Configuration for PSC-I.Optional. DNS peering configurations. When specified, Vertex AI will attempt to configure DNS peering zones in the tenant project VPC to resolve the specified domains using the target network's Cloud DNS. The user must grant the dns.peer role to the Vertex AI Service Agent on the target project.Optional. The name of the Compute Engine [network attachment](https://cloud.google.com/vpc/docs/about-network-attachments) to attach to the resource within the region and user project. To specify this field, you must have already [created a network attachment] (https://cloud.google.com/vpc/docs/create-manage-network-attachments


PscInterfaceConfigOrDict = Union[PscInterfaceConfig, PscInterfaceConfigDict]


class Scheduling(_common.BaseModel):
    

    disable_retries: Optional[bool] = Field(
        default=None,
        description=,
    )
    max_wait_duration: Optional[str] = Field(
        default=None,
        description=,
    )
    restart_job_on_worker_restart: Optional[bool] = Field(
        default=None,
        description=,
    )
    strategy: Optional[Strategy] = Field(
        default=None,
        description=,
    )
    timeout: Optional[str] = Field(
        default=None,
        description=,
    )


class SchedulingDict(TypedDict, total=False):
    

    disable_retries: Optional[bool]
    

    max_wait_duration: Optional[str]
    

    restart_job_on_worker_restart: Optional[bool]
    

    strategy: Optional[Strategy]
    

    timeout: Optional[str]
    


SchedulingOrDict = Union[Scheduling, SchedulingDict]


class EnvVar(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    value: Optional[str] = Field(
        default=None,
        description=,
    )


class EnvVarDict(TypedDict, total=False):
    

    name: Optional[str]
    

    value: Optional[str]
    


EnvVarOrDict = Union[EnvVar, EnvVarDict]


class ContainerSpec(_common.BaseModel):
    

    args: Optional[list[str]] = Field(
        default=None,
        description=,
    )
    command: Optional[list[str]] = Field(
        default=None,
        description=,
    )
    env: Optional[list[EnvVar]] = Field(
        default=None,
        description=,
    )
    image_uri: Optional[str] = Field(
        default=None,
        description=,
    )


class ContainerSpecDict(TypedDict, total=False):
    

    args: Optional[list[str]]
    

    command: Optional[list[str]]
    

    env: Optional[list[EnvVarDict]]
    

    image_uri: Optional[str]
    


ContainerSpecOrDict = Union[ContainerSpec, ContainerSpecDict]


class DiskSpec(_common.BaseModel):
    

    boot_disk_size_gb: Optional[int] = Field(
        default=None,
        description=,
    )
    boot_disk_type: Optional[str] = Field(
        default=None,
        description=,
    )


class DiskSpecDict(TypedDict, total=False):
    

    boot_disk_size_gb: Optional[int]
    

    boot_disk_type: Optional[str]
    


DiskSpecOrDict = Union[DiskSpec, DiskSpecDict]


class ReservationAffinity(_common.BaseModel):
    

    key: Optional[str] = Field(
        default=None,
        description=,
    )
    reservation_affinity_type: Optional[Type] = Field(
        default=None,
        description=,
    )
    values: Optional[list[str]] = Field(
        default=None,
        description=,
    )


class ReservationAffinityDict(TypedDict, total=False):
    

    key: Optional[str]
    

    reservation_affinity_type: Optional[Type]
    

    values: Optional[list[str]]
    


ReservationAffinityOrDict = Union[ReservationAffinity, ReservationAffinityDict]


class MachineSpec(_common.BaseModel):
    

    accelerator_count: Optional[int] = Field(
        default=None,
        description=,
    )
    accelerator_type: Optional[AcceleratorType] = Field(
        default=None,
        description=,
    )
    machine_type: Optional[str] = Field(
        default=None,
        description=Optional. Immutable. The number of nodes per replica for multihost GPU deployments.Optional. Immutable. Configuration controlling how this resource pool consumes reservation.Immutable. The topology of the TPUs. Corresponds to the TPU topologies available from GKE. (Example: tpu_topology: "2x2x1").Specification of a single machine.The number of accelerators to attach to the machine.Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute

    multihost_gpu_node_count: Optional[int]
    

    reservation_affinity: Optional[ReservationAffinityDict]
    

    tpu_topology: Optional[str]
    


MachineSpecOrDict = Union[MachineSpec, MachineSpecDict]


class NfsMount(_common.BaseModel):
    

    mount_point: Optional[str] = Field(
        default=None,
        description=,
    )
    path: Optional[str] = Field(
        default=None,
        description=,
    )
    server: Optional[str] = Field(
        default=None, description=
    )


class NfsMountDict(TypedDict, total=False):
    

    mount_point: Optional[str]
    

    path: Optional[str]
    

    server: Optional[str]
    


NfsMountOrDict = Union[NfsMount, NfsMountDict]


class PythonPackageSpec(_common.BaseModel):
    

    args: Optional[list[str]] = Field(
        default=None,
        description=,
    )
    env: Optional[list[EnvVar]] = Field(
        default=None,
        description=,
    )
    executor_image_uri: Optional[str] = Field(
        default=None,
        description=,
    )
    package_uris: Optional[list[str]] = Field(
        default=None,
        description=,
    )
    python_module: Optional[str] = Field(
        default=None,
        description=,
    )


class PythonPackageSpecDict(TypedDict, total=False):
    

    args: Optional[list[str]]
    

    env: Optional[list[EnvVarDict]]
    

    executor_image_uri: Optional[str]
    

    package_uris: Optional[list[str]]
    

    python_module: Optional[str]
    


PythonPackageSpecOrDict = Union[PythonPackageSpec, PythonPackageSpecDict]


class WorkerPoolSpec(_common.BaseModel):
    

    container_spec: Optional[ContainerSpec] = Field(
        default=None, description=
    )
    disk_spec: Optional[DiskSpec] = Field(default=None, description=)
    machine_spec: Optional[MachineSpec] = Field(
        default=None,
        description=,
    )
    nfs_mounts: Optional[list[NfsMount]] = Field(
        default=None, description=
    )
    python_package_spec: Optional[PythonPackageSpec] = Field(
        default=None, description=
    )
    replica_count: Optional[int] = Field(
        default=None,
        description=,
    )


class WorkerPoolSpecDict(TypedDict, total=False):
    

    container_spec: Optional[ContainerSpecDict]
    

    disk_spec: Optional[DiskSpecDict]
    

    machine_spec: Optional[MachineSpecDict]
    

    nfs_mounts: Optional[list[NfsMountDict]]
    

    python_package_spec: Optional[PythonPackageSpecDict]
    

    replica_count: Optional[int]
    


WorkerPoolSpecOrDict = Union[WorkerPoolSpec, WorkerPoolSpecDict]


class CustomJobSpec(_common.BaseModel):
    

    base_output_directory: Optional[GcsDestination] = Field(
        default=None,
        description=,
    )
    enable_dashboard_access: Optional[bool] = Field(
        default=None,
        description=,
    )
    enable_web_access: Optional[bool] = Field(
        default=None,
        description=,
    )
    experiment: Optional[str] = Field(
        default=None,
        description=,
    )
    experiment_run: Optional[str] = Field(
        default=None,
        description=,
    )
    models: Optional[list[str]] = Field(
        default=None,
        description=,
    )
    network: Optional[str] = Field(
        default=None,
        description=Optional. The ID of the PersistentResource in the same Project and Location which to run If this is specified, the job will be run on existing machines held by the PersistentResource instead of on-demand short-live machines. The network and CMEK configs on the job should be consistent with those on the PersistentResource, otherwise, the job will be rejected.The ID of the location to store protected artifacts. e.g. us-central1. Populate only when the location is different than CustomJob location. List of supported locations: https://cloud.google.com/vertex-ai/docs/general/locationsOptional. Configuration for PSC-I for CustomJob.Optional. A list of names for the reserved ip ranges under the VPC network that can be used for this job. If set, we will deploy the job within the provided ip ranges. Otherwise, the job will be deployed to any ip ranges under the provided VPC network. Example: ['vertex-ai-ip-range'].Scheduling options for a CustomJob.Specifies the service account for workload run-as account. Users submitting jobs must have act-as permission on this run-as account. If unspecified, the [Vertex AI Custom Code Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control
    )
    tensorboard: Optional[str] = Field(
        default=None,
        description=,
    )
    worker_pool_specs: Optional[list[WorkerPoolSpec]] = Field(
        default=None,
        description=,
    )


class CustomJobSpecDict(TypedDict, total=False):
    

    base_output_directory: Optional[GcsDestinationDict]
    

    enable_dashboard_access: Optional[bool]
    

    enable_web_access: Optional[bool]
    

    experiment: Optional[str]
    

    experiment_run: Optional[str]
    

    models: Optional[list[str]]
    

    network: Optional[str]
    Optional. The ID of the PersistentResource in the same Project and Location which to run If this is specified, the job will be run on existing machines held by the PersistentResource instead of on-demand short-live machines. The network and CMEK configs on the job should be consistent with those on the PersistentResource, otherwise, the job will be rejected.The ID of the location to store protected artifacts. e.g. us-central1. Populate only when the location is different than CustomJob location. List of supported locations: https://cloud.google.com/vertex-ai/docs/general/locationsOptional. Configuration for PSC-I for CustomJob.Optional. A list of names for the reserved ip ranges under the VPC network that can be used for this job. If set, we will deploy the job within the provided ip ranges. Otherwise, the job will be deployed to any ip ranges under the provided VPC network. Example: ['vertex-ai-ip-range'].Scheduling options for a CustomJob.Specifies the service account for workload run-as account. Users submitting jobs must have act-as permission on this run-as account. If unspecified, the [Vertex AI Custom Code Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control

    tensorboard: Optional[str]
    

    worker_pool_specs: Optional[list[WorkerPoolSpecDict]]
    


CustomJobSpecOrDict = Union[CustomJobSpec, CustomJobSpecDict]


class EncryptionSpec(_common.BaseModel):
    

    kms_key_name: Optional[str] = Field(
        default=None,
        description=,
    )


class EncryptionSpecDict(TypedDict, total=False):
    

    kms_key_name: Optional[str]
    


EncryptionSpecOrDict = Union[EncryptionSpec, EncryptionSpecDict]


class GoogleRpcStatus(_common.BaseModel):
    

    code: Optional[int] = Field(
        default=None,
        description=,
    )
    details: Optional[list[dict[str, Any]]] = Field(
        default=None,
        description=,
    )
    message: Optional[str] = Field(
        default=None,
        description=,
    )


class GoogleRpcStatusDict(TypedDict, total=False):
    

    code: Optional[int]
    

    details: Optional[list[dict[str, Any]]]
    

    message: Optional[str]
    


GoogleRpcStatusOrDict = Union[GoogleRpcStatus, GoogleRpcStatusDict]


class CustomJob(_common.BaseModel):
    

    display_name: Optional[str] = Field(
        default=None,
        description=,
    )
    job_spec: Optional[CustomJobSpec] = Field(
        default=None, description=
    )
    create_time: Optional[datetime.datetime] = Field(
        default=None,
        description=,
    )
    encryption_spec: Optional[EncryptionSpec] = Field(
        default=None,
        description=,
    )
    end_time: Optional[datetime.datetime] = Field(
        default=None,
        description=,
    )
    error: Optional[GoogleRpcStatus] = Field(
        default=None,
        description=,
    )
    labels: Optional[dict[str, str]] = Field(
        default=None,
        description=,
    )
    name: Optional[str] = Field(
        default=None,
        description=,
    )
    satisfies_pzi: Optional[bool] = Field(
        default=None, description=
    )
    satisfies_pzs: Optional[bool] = Field(
        default=None, description=
    )
    start_time: Optional[datetime.datetime] = Field(
        default=None,
        description=,
    )
    state: Optional[JobState] = Field(
        default=None,
        description=,
    )
    update_time: Optional[datetime.datetime] = Field(
        default=None,
        description=,
    )
    web_access_uris: Optional[dict[str, str]] = Field(
        default=None,
        description=,
    )


class CustomJobDict(TypedDict, total=False):
    

    display_name: Optional[str]
    

    job_spec: Optional[CustomJobSpecDict]
    

    create_time: Optional[datetime.datetime]
    

    encryption_spec: Optional[EncryptionSpecDict]
    

    end_time: Optional[datetime.datetime]
    

    error: Optional[GoogleRpcStatusDict]
    

    labels: Optional[dict[str, str]]
    

    name: Optional[str]
    

    satisfies_pzi: Optional[bool]
    

    satisfies_pzs: Optional[bool]
    

    start_time: Optional[datetime.datetime]
    

    state: Optional[JobState]
    

    update_time: Optional[datetime.datetime]
    

    web_access_uris: Optional[dict[str, str]]
    


CustomJobOrDict = Union[CustomJob, CustomJobDict]


class BaseConfig(_common.BaseModel):

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )


class BaseConfigDict(TypedDict, total=False):

    http_options: Optional[HttpOptionsDict]
    


BaseConfigOrDict = Union[BaseConfig, BaseConfigDict]


class _CustomJobParameters(_common.BaseModel):
    

    custom_job: Optional[CustomJob] = Field(default=None, description=)
    config: Optional[BaseConfig] = Field(default=None, description=)


class _CustomJobParametersDict(TypedDict, total=False):
    

    custom_job: Optional[CustomJobDict]
    

    config: Optional[BaseConfigDict]
    


_CustomJobParametersOrDict = Union[_CustomJobParameters, _CustomJobParametersDict]


class _GetCustomJobParameters(_common.BaseModel):
    

    name: Optional[str] = Field(default=None, description=)
    config: Optional[BaseConfig] = Field(default=None, description=)


class _GetCustomJobParametersDict(TypedDict, total=False):
    

    name: Optional[str]
    

    config: Optional[BaseConfigDict]
    


_GetCustomJobParametersOrDict = Union[
    _GetCustomJobParameters, _GetCustomJobParametersDict
]


class SecretRef(_common.BaseModel):
    

    secret: Optional[str] = Field(
        default=None,
        description=,
    )
    version: Optional[str] = Field(
        default=None,
        description=,
    )


class SecretRefDict(TypedDict, total=False):
    

    secret: Optional[str]
    

    version: Optional[str]
    


SecretRefOrDict = Union[SecretRef, SecretRefDict]


class SecretEnvVar(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    secret_ref: Optional[SecretRef] = Field(
        default=None,
        description=,
    )


class SecretEnvVarDict(TypedDict, total=False):
    

    name: Optional[str]
    

    secret_ref: Optional[SecretRefDict]
    


SecretEnvVarOrDict = Union[SecretEnvVar, SecretEnvVarDict]


class ReasoningEngineSpecDeploymentSpec(_common.BaseModel):
    

    env: Optional[list[EnvVar]] = Field(
        default=None,
        description=,
    )
    secret_env: Optional[list[SecretEnvVar]] = Field(
        default=None,
        description=,
    )


class ReasoningEngineSpecDeploymentSpecDict(TypedDict, total=False):
    

    env: Optional[list[EnvVarDict]]
    

    secret_env: Optional[list[SecretEnvVarDict]]
    


ReasoningEngineSpecDeploymentSpecOrDict = Union[
    ReasoningEngineSpecDeploymentSpec, ReasoningEngineSpecDeploymentSpecDict
]


class ReasoningEngineSpecPackageSpec(_common.BaseModel):
    

    dependency_files_gcs_uri: Optional[str] = Field(
        default=None,
        description=,
    )
    pickle_object_gcs_uri: Optional[str] = Field(
        default=None,
        description=,
    )
    python_version: Optional[str] = Field(
        default=None,
        description=,
    )
    requirements_gcs_uri: Optional[str] = Field(
        default=None,
        description=,
    )


class ReasoningEngineSpecPackageSpecDict(TypedDict, total=False):
    

    dependency_files_gcs_uri: Optional[str]
    

    pickle_object_gcs_uri: Optional[str]
    

    python_version: Optional[str]
    

    requirements_gcs_uri: Optional[str]
    


ReasoningEngineSpecPackageSpecOrDict = Union[
    ReasoningEngineSpecPackageSpec, ReasoningEngineSpecPackageSpecDict
]


class ReasoningEngineSpec(_common.BaseModel):
    

    agent_framework: Optional[str] = Field(
        default=None,
        description=,
    )
    class_methods: Optional[list[dict[str, Any]]] = Field(
        default=None,
        description=,
    )
    deployment_spec: Optional[ReasoningEngineSpecDeploymentSpec] = Field(
        default=None,
        description=,
    )
    package_spec: Optional[ReasoningEngineSpecPackageSpec] = Field(
        default=None,
        description=,
    )


class ReasoningEngineSpecDict(TypedDict, total=False):
    

    agent_framework: Optional[str]
    

    class_methods: Optional[list[dict[str, Any]]]
    

    deployment_spec: Optional[ReasoningEngineSpecDeploymentSpecDict]
    

    package_spec: Optional[ReasoningEngineSpecPackageSpecDict]
    


ReasoningEngineSpecOrDict = Union[ReasoningEngineSpec, ReasoningEngineSpecDict]


class ReasoningEngineContextSpecMemoryBankConfigGenerationConfig(_common.BaseModel):
    

    model: Optional[str] = Field(
        default=None,
        description=,
    )


class ReasoningEngineContextSpecMemoryBankConfigGenerationConfigDict(
    TypedDict, total=False
):
    

    model: Optional[str]
    


ReasoningEngineContextSpecMemoryBankConfigGenerationConfigOrDict = Union[
    ReasoningEngineContextSpecMemoryBankConfigGenerationConfig,
    ReasoningEngineContextSpecMemoryBankConfigGenerationConfigDict,
]


class ReasoningEngineContextSpecMemoryBankConfigSimilaritySearchConfig(
    _common.BaseModel
):
    

    embedding_model: Optional[str] = Field(
        default=None,
        description=,
    )


class ReasoningEngineContextSpecMemoryBankConfigSimilaritySearchConfigDict(
    TypedDict, total=False
):
    

    embedding_model: Optional[str]
    


ReasoningEngineContextSpecMemoryBankConfigSimilaritySearchConfigOrDict = Union[
    ReasoningEngineContextSpecMemoryBankConfigSimilaritySearchConfig,
    ReasoningEngineContextSpecMemoryBankConfigSimilaritySearchConfigDict,
]


class ReasoningEngineContextSpecMemoryBankConfig(_common.BaseModel):
    

    generation_config: Optional[
        ReasoningEngineContextSpecMemoryBankConfigGenerationConfig
    ] = Field(
        default=None,
        description=,
    )
    similarity_search_config: Optional[
        ReasoningEngineContextSpecMemoryBankConfigSimilaritySearchConfig
    ] = Field(
        default=None,
        description=,
    )


class ReasoningEngineContextSpecMemoryBankConfigDict(TypedDict, total=False):
    

    generation_config: Optional[
        ReasoningEngineContextSpecMemoryBankConfigGenerationConfigDict
    ]
    

    similarity_search_config: Optional[
        ReasoningEngineContextSpecMemoryBankConfigSimilaritySearchConfigDict
    ]
    


ReasoningEngineContextSpecMemoryBankConfigOrDict = Union[
    ReasoningEngineContextSpecMemoryBankConfig,
    ReasoningEngineContextSpecMemoryBankConfigDict,
]


class ReasoningEngineContextSpec(_common.BaseModel):
    

    memory_bank_config: Optional[ReasoningEngineContextSpecMemoryBankConfig] = Field(
        default=None,
        description=,
    )


class ReasoningEngineContextSpecDict(TypedDict, total=False):
    

    memory_bank_config: Optional[ReasoningEngineContextSpecMemoryBankConfigDict]
    


ReasoningEngineContextSpecOrDict = Union[
    ReasoningEngineContextSpec, ReasoningEngineContextSpecDict
]


class CreateAgentEngineConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )
    display_name: Optional[str] = Field(
        default=None,
        description=,
    )
    description: Optional[str] = Field(
        default=None, description=
    )
    spec: Optional[ReasoningEngineSpec] = Field(
        default=None,
        description=,
    )
    context_spec: Optional[ReasoningEngineContextSpec] = Field(
        default=None,
        description=,
    )


class CreateAgentEngineConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    

    display_name: Optional[str]
    

    description: Optional[str]
    

    spec: Optional[ReasoningEngineSpecDict]
    

    context_spec: Optional[ReasoningEngineContextSpecDict]
    


CreateAgentEngineConfigOrDict = Union[
    CreateAgentEngineConfig, CreateAgentEngineConfigDict
]


class _CreateAgentEngineRequestParameters(_common.BaseModel):
    

    config: Optional[CreateAgentEngineConfig] = Field(default=None, description=)


class _CreateAgentEngineRequestParametersDict(TypedDict, total=False):
    

    config: Optional[CreateAgentEngineConfigDict]
    


_CreateAgentEngineRequestParametersOrDict = Union[
    _CreateAgentEngineRequestParameters, _CreateAgentEngineRequestParametersDict
]


class ReasoningEngine(_common.BaseModel):
    

    context_spec: Optional[ReasoningEngineContextSpec] = Field(
        default=None,
        description=,
    )
    create_time: Optional[datetime.datetime] = Field(
        default=None,
        description=,
    )
    description: Optional[str] = Field(
        default=None,
        description=,
    )
    display_name: Optional[str] = Field(
        default=None,
        description=,
    )
    etag: Optional[str] = Field(
        default=None,
        description=,
    )
    name: Optional[str] = Field(
        default=None,
        description=,
    )
    spec: Optional[ReasoningEngineSpec] = Field(
        default=None,
        description=,
    )
    update_time: Optional[datetime.datetime] = Field(
        default=None,
        description=,
    )


class ReasoningEngineDict(TypedDict, total=False):
    

    context_spec: Optional[ReasoningEngineContextSpecDict]
    

    create_time: Optional[datetime.datetime]
    

    description: Optional[str]
    

    display_name: Optional[str]
    

    etag: Optional[str]
    

    name: Optional[str]
    

    spec: Optional[ReasoningEngineSpecDict]
    

    update_time: Optional[datetime.datetime]
    


ReasoningEngineOrDict = Union[ReasoningEngine, ReasoningEngineDict]


class AgentEngineOperation(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    metadata: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )
    done: Optional[bool] = Field(
        default=None,
        description=,
    )
    error: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )
    response: Optional[ReasoningEngine] = Field(
        default=None, description=
    )


class AgentEngineOperationDict(TypedDict, total=False):
    

    name: Optional[str]
    

    metadata: Optional[dict[str, Any]]
    

    done: Optional[bool]
    

    error: Optional[dict[str, Any]]
    

    response: Optional[ReasoningEngineDict]
    


AgentEngineOperationOrDict = Union[AgentEngineOperation, AgentEngineOperationDict]


class AgentEngineMemoryConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )
    display_name: Optional[str] = Field(
        default=None, description=
    )
    description: Optional[str] = Field(
        default=None, description=
    )
    wait_for_completion: Optional[bool] = Field(
        default=True,
        description=,
    )


class AgentEngineMemoryConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    

    display_name: Optional[str]
    

    description: Optional[str]
    

    wait_for_completion: Optional[bool]
    


AgentEngineMemoryConfigOrDict = Union[
    AgentEngineMemoryConfig, AgentEngineMemoryConfigDict
]


class _CreateAgentEngineMemoryRequestParameters(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    fact: Optional[str] = Field(
        default=None,
        description=,
    )
    scope: Optional[dict[str, str]] = Field(
        default=None,
        description=,
    )
    config: Optional[AgentEngineMemoryConfig] = Field(default=None, description=)


class _CreateAgentEngineMemoryRequestParametersDict(TypedDict, total=False):
    

    name: Optional[str]
    

    fact: Optional[str]
    

    scope: Optional[dict[str, str]]
    

    config: Optional[AgentEngineMemoryConfigDict]
    


_CreateAgentEngineMemoryRequestParametersOrDict = Union[
    _CreateAgentEngineMemoryRequestParameters,
    _CreateAgentEngineMemoryRequestParametersDict,
]


class Memory(_common.BaseModel):
    

    create_time: Optional[datetime.datetime] = Field(
        default=None,
        description=,
    )
    description: Optional[str] = Field(
        default=None, description=
    )
    display_name: Optional[str] = Field(
        default=None, description=
    )
    fact: Optional[str] = Field(
        default=None,
        description=,
    )
    name: Optional[str] = Field(
        default=None,
        description=,
    )
    scope: Optional[dict[str, str]] = Field(
        default=None,
        description=,
    )
    update_time: Optional[datetime.datetime] = Field(
        default=None,
        description=,
    )


class MemoryDict(TypedDict, total=False):
    

    create_time: Optional[datetime.datetime]
    

    description: Optional[str]
    

    display_name: Optional[str]
    

    fact: Optional[str]
    

    name: Optional[str]
    

    scope: Optional[dict[str, str]]
    

    update_time: Optional[datetime.datetime]
    


MemoryOrDict = Union[Memory, MemoryDict]


class AgentEngineMemoryOperation(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    metadata: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )
    done: Optional[bool] = Field(
        default=None,
        description=,
    )
    error: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )
    response: Optional[Memory] = Field(
        default=None, description=
    )


class AgentEngineMemoryOperationDict(TypedDict, total=False):
    

    name: Optional[str]
    

    metadata: Optional[dict[str, Any]]
    

    done: Optional[bool]
    

    error: Optional[dict[str, Any]]
    

    response: Optional[MemoryDict]
    


AgentEngineMemoryOperationOrDict = Union[
    AgentEngineMemoryOperation, AgentEngineMemoryOperationDict
]


class DeleteAgentEngineConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )


class DeleteAgentEngineConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    


DeleteAgentEngineConfigOrDict = Union[
    DeleteAgentEngineConfig, DeleteAgentEngineConfigDict
]


class _DeleteAgentEngineRequestParameters(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None, description=
    )
    force: Optional[bool] = Field(
        default=False,
        description=,
    )
    config: Optional[DeleteAgentEngineConfig] = Field(default=None, description=)


class _DeleteAgentEngineRequestParametersDict(TypedDict, total=False):
    

    name: Optional[str]
    

    force: Optional[bool]
    

    config: Optional[DeleteAgentEngineConfigDict]
    


_DeleteAgentEngineRequestParametersOrDict = Union[
    _DeleteAgentEngineRequestParameters, _DeleteAgentEngineRequestParametersDict
]


class DeleteAgentEngineOperation(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    metadata: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )
    done: Optional[bool] = Field(
        default=None,
        description=,
    )
    error: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )


class DeleteAgentEngineOperationDict(TypedDict, total=False):
    

    name: Optional[str]
    

    metadata: Optional[dict[str, Any]]
    

    done: Optional[bool]
    

    error: Optional[dict[str, Any]]
    


DeleteAgentEngineOperationOrDict = Union[
    DeleteAgentEngineOperation, DeleteAgentEngineOperationDict
]


class DeleteAgentEngineMemoryConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )


class DeleteAgentEngineMemoryConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    


DeleteAgentEngineMemoryConfigOrDict = Union[
    DeleteAgentEngineMemoryConfig, DeleteAgentEngineMemoryConfigDict
]


class _DeleteAgentEngineMemoryRequestParameters(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    config: Optional[DeleteAgentEngineMemoryConfig] = Field(
        default=None, description=
    )


class _DeleteAgentEngineMemoryRequestParametersDict(TypedDict, total=False):
    

    name: Optional[str]
    

    config: Optional[DeleteAgentEngineMemoryConfigDict]
    


_DeleteAgentEngineMemoryRequestParametersOrDict = Union[
    _DeleteAgentEngineMemoryRequestParameters,
    _DeleteAgentEngineMemoryRequestParametersDict,
]


class DeleteAgentEngineMemoryOperation(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    metadata: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )
    done: Optional[bool] = Field(
        default=None,
        description=,
    )
    error: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )


class DeleteAgentEngineMemoryOperationDict(TypedDict, total=False):
    

    name: Optional[str]
    

    metadata: Optional[dict[str, Any]]
    

    done: Optional[bool]
    

    error: Optional[dict[str, Any]]
    


DeleteAgentEngineMemoryOperationOrDict = Union[
    DeleteAgentEngineMemoryOperation, DeleteAgentEngineMemoryOperationDict
]


class GenerateMemoriesRequestVertexSessionSource(_common.BaseModel):
    

    end_time: Optional[datetime.datetime] = Field(
        default=None,
        description=,
    )
    session: Optional[str] = Field(
        default=None,
        description=,
    )
    start_time: Optional[datetime.datetime] = Field(
        default=None,
        description=,
    )


class GenerateMemoriesRequestVertexSessionSourceDict(TypedDict, total=False):
    

    end_time: Optional[datetime.datetime]
    

    session: Optional[str]
    

    start_time: Optional[datetime.datetime]
    


GenerateMemoriesRequestVertexSessionSourceOrDict = Union[
    GenerateMemoriesRequestVertexSessionSource,
    GenerateMemoriesRequestVertexSessionSourceDict,
]


class CodeExecutionResult(_common.BaseModel):
    

    outcome: Optional[Outcome] = Field(
        default=None, description=
    )
    output: Optional[str] = Field(
        default=None,
        description=,
    )


class CodeExecutionResultDict(TypedDict, total=False):
    

    outcome: Optional[Outcome]
    

    output: Optional[str]
    


CodeExecutionResultOrDict = Union[CodeExecutionResult, CodeExecutionResultDict]


class ExecutableCode(_common.BaseModel):
    

    code: Optional[str] = Field(
        default=None, description=
    )
    language: Optional[Language] = Field(
        default=None,
        description=,
    )


class ExecutableCodeDict(TypedDict, total=False):
    

    code: Optional[str]
    

    language: Optional[Language]
    


ExecutableCodeOrDict = Union[ExecutableCode, ExecutableCodeDict]


class FileData(_common.BaseModel):
    

    display_name: Optional[str] = Field(
        default=None,
        description=,
    )
    file_uri: Optional[str] = Field(default=None, description=)
    mime_type: Optional[str] = Field(
        default=None,
        description=,
    )


class FileDataDict(TypedDict, total=False):
    

    display_name: Optional[str]
    

    file_uri: Optional[str]
    

    mime_type: Optional[str]
    


FileDataOrDict = Union[FileData, FileDataDict]


class FunctionCall(_common.BaseModel):
    

    args: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )
    id: Optional[str] = Field(
        default=None,
        description=,
    )
    name: Optional[str] = Field(
        default=None,
        description=,
    )


class FunctionCallDict(TypedDict, total=False):
    

    args: Optional[dict[str, Any]]
    

    id: Optional[str]
    

    name: Optional[str]
    


FunctionCallOrDict = Union[FunctionCall, FunctionCallDict]


class FunctionResponse(_common.BaseModel):
    

    id: Optional[str] = Field(
        default=None,
        description=,
    )
    name: Optional[str] = Field(
        default=None,
        description=,
    )
    response: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )


class FunctionResponseDict(TypedDict, total=False):
    

    id: Optional[str]
    

    name: Optional[str]
    

    response: Optional[dict[str, Any]]
    


FunctionResponseOrDict = Union[FunctionResponse, FunctionResponseDict]


class Blob(_common.BaseModel):
    

    data: Optional[bytes] = Field(default=None, description=)
    display_name: Optional[str] = Field(
        default=None,
        description=,
    )
    mime_type: Optional[str] = Field(
        default=None,
        description=,
    )


class BlobDict(TypedDict, total=False):
    

    data: Optional[bytes]
    

    display_name: Optional[str]
    

    mime_type: Optional[str]
    


BlobOrDict = Union[Blob, BlobDict]


class VideoMetadata(_common.BaseModel):
    

    end_offset: Optional[str] = Field(
        default=None, description=
    )
    start_offset: Optional[str] = Field(
        default=None, description=
    )


class VideoMetadataDict(TypedDict, total=False):
    

    end_offset: Optional[str]
    

    start_offset: Optional[str]
    


VideoMetadataOrDict = Union[VideoMetadata, VideoMetadataDict]


class Part(_common.BaseModel):
    

    code_execution_result: Optional[CodeExecutionResult] = Field(
        default=None,
        description=,
    )
    executable_code: Optional[ExecutableCode] = Field(
        default=None,
        description=,
    )
    file_data: Optional[FileData] = Field(
        default=None, description=
    )
    function_call: Optional[FunctionCall] = Field(
        default=None,
        description=,
    )
    function_response: Optional[FunctionResponse] = Field(
        default=None,
        description=,
    )
    inline_data: Optional[Blob] = Field(
        default=None, description=
    )
    text: Optional[str] = Field(
        default=None, description=
    )
    thought: Optional[bool] = Field(
        default=None,
        description=,
    )
    thought_signature: Optional[bytes] = Field(
        default=None,
        description=,
    )
    video_metadata: Optional[VideoMetadata] = Field(
        default=None,
        description=,
    )


class PartDict(TypedDict, total=False):
    

    code_execution_result: Optional[CodeExecutionResultDict]
    

    executable_code: Optional[ExecutableCodeDict]
    

    file_data: Optional[FileDataDict]
    

    function_call: Optional[FunctionCallDict]
    

    function_response: Optional[FunctionResponseDict]
    

    inline_data: Optional[BlobDict]
    

    text: Optional[str]
    

    thought: Optional[bool]
    

    thought_signature: Optional[bytes]
    

    video_metadata: Optional[VideoMetadataDict]
    


PartOrDict = Union[Part, PartDict]


class Content(_common.BaseModel):
    

    parts: Optional[list[Part]] = Field(
        default=None,
        description=,
    )
    role: Optional[str] = Field(
        default=None,
        description=,
    )


class ContentDict(TypedDict, total=False):
    

    parts: Optional[list[PartDict]]
    

    role: Optional[str]
    


ContentOrDict = Union[Content, ContentDict]


class GenerateMemoriesRequestDirectContentsSourceEvent(_common.BaseModel):
    

    content: Optional[Content] = Field(
        default=None,
        description=,
    )


class GenerateMemoriesRequestDirectContentsSourceEventDict(TypedDict, total=False):
    

    content: Optional[ContentDict]
    


GenerateMemoriesRequestDirectContentsSourceEventOrDict = Union[
    GenerateMemoriesRequestDirectContentsSourceEvent,
    GenerateMemoriesRequestDirectContentsSourceEventDict,
]


class GenerateMemoriesRequestDirectContentsSource(_common.BaseModel):
    

    events: Optional[list[GenerateMemoriesRequestDirectContentsSourceEvent]] = Field(
        default=None,
        description=,
    )


class GenerateMemoriesRequestDirectContentsSourceDict(TypedDict, total=False):
    

    events: Optional[list[GenerateMemoriesRequestDirectContentsSourceEventDict]]
    


GenerateMemoriesRequestDirectContentsSourceOrDict = Union[
    GenerateMemoriesRequestDirectContentsSource,
    GenerateMemoriesRequestDirectContentsSourceDict,
]


class GenerateAgentEngineMemoriesConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )
    disable_consolidation: Optional[bool] = Field(
        default=None,
        description=,
    )
    wait_for_completion: Optional[bool] = Field(
        default=True,
        description=,
    )


class GenerateAgentEngineMemoriesConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    

    disable_consolidation: Optional[bool]
    

    wait_for_completion: Optional[bool]
    


GenerateAgentEngineMemoriesConfigOrDict = Union[
    GenerateAgentEngineMemoriesConfig, GenerateAgentEngineMemoriesConfigDict
]


class _GenerateAgentEngineMemoriesRequestParameters(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    vertex_session_source: Optional[GenerateMemoriesRequestVertexSessionSource] = Field(
        default=None,
        description=,
    )
    direct_contents_source: Optional[
        GenerateMemoriesRequestDirectContentsSource
    ] = Field(
        default=None,
        description=,
    )
    scope: Optional[dict[str, str]] = Field(
        default=None,
        description=,
    )
    config: Optional[GenerateAgentEngineMemoriesConfig] = Field(
        default=None, description=
    )


class _GenerateAgentEngineMemoriesRequestParametersDict(TypedDict, total=False):
    

    name: Optional[str]
    

    vertex_session_source: Optional[GenerateMemoriesRequestVertexSessionSourceDict]
    

    direct_contents_source: Optional[GenerateMemoriesRequestDirectContentsSourceDict]
    

    scope: Optional[dict[str, str]]
    

    config: Optional[GenerateAgentEngineMemoriesConfigDict]
    


_GenerateAgentEngineMemoriesRequestParametersOrDict = Union[
    _GenerateAgentEngineMemoriesRequestParameters,
    _GenerateAgentEngineMemoriesRequestParametersDict,
]


class GenerateMemoriesResponseGeneratedMemory(_common.BaseModel):
    

    memory: Optional[Memory] = Field(
        default=None, description=
    )
    action: Optional[GenerateMemoriesResponseGeneratedMemoryAction] = Field(
        default=None, description=
    )


class GenerateMemoriesResponseGeneratedMemoryDict(TypedDict, total=False):
    

    memory: Optional[MemoryDict]
    

    action: Optional[GenerateMemoriesResponseGeneratedMemoryAction]
    


GenerateMemoriesResponseGeneratedMemoryOrDict = Union[
    GenerateMemoriesResponseGeneratedMemory,
    GenerateMemoriesResponseGeneratedMemoryDict,
]


class GenerateMemoriesResponse(_common.BaseModel):
    

    generated_memories: Optional[list[GenerateMemoriesResponseGeneratedMemory]] = Field(
        default=None, description=
    )


class GenerateMemoriesResponseDict(TypedDict, total=False):
    

    generated_memories: Optional[list[GenerateMemoriesResponseGeneratedMemoryDict]]
    


GenerateMemoriesResponseOrDict = Union[
    GenerateMemoriesResponse, GenerateMemoriesResponseDict
]


class AgentEngineGenerateMemoriesOperation(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    metadata: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )
    done: Optional[bool] = Field(
        default=None,
        description=,
    )
    error: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )
    response: Optional[GenerateMemoriesResponse] = Field(
        default=None, description=
    )


class AgentEngineGenerateMemoriesOperationDict(TypedDict, total=False):
    

    name: Optional[str]
    

    metadata: Optional[dict[str, Any]]
    

    done: Optional[bool]
    

    error: Optional[dict[str, Any]]
    

    response: Optional[GenerateMemoriesResponseDict]
    


AgentEngineGenerateMemoriesOperationOrDict = Union[
    AgentEngineGenerateMemoriesOperation,
    AgentEngineGenerateMemoriesOperationDict,
]


class GetAgentEngineConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )


class GetAgentEngineConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    


GetAgentEngineConfigOrDict = Union[GetAgentEngineConfig, GetAgentEngineConfigDict]


class _GetAgentEngineRequestParameters(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None, description=
    )
    config: Optional[GetAgentEngineConfig] = Field(default=None, description=)


class _GetAgentEngineRequestParametersDict(TypedDict, total=False):
    

    name: Optional[str]
    

    config: Optional[GetAgentEngineConfigDict]
    


_GetAgentEngineRequestParametersOrDict = Union[
    _GetAgentEngineRequestParameters, _GetAgentEngineRequestParametersDict
]


class GetAgentEngineMemoryConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )


class GetAgentEngineMemoryConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    


GetAgentEngineMemoryConfigOrDict = Union[
    GetAgentEngineMemoryConfig, GetAgentEngineMemoryConfigDict
]


class _GetAgentEngineMemoryRequestParameters(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None, description=
    )
    config: Optional[GetAgentEngineMemoryConfig] = Field(
        default=None, description=
    )


class _GetAgentEngineMemoryRequestParametersDict(TypedDict, total=False):
    

    name: Optional[str]
    

    config: Optional[GetAgentEngineMemoryConfigDict]
    


_GetAgentEngineMemoryRequestParametersOrDict = Union[
    _GetAgentEngineMemoryRequestParameters,
    _GetAgentEngineMemoryRequestParametersDict,
]


class ListAgentEngineConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )
    page_size: Optional[int] = Field(default=None, description=)
    page_token: Optional[str] = Field(default=None, description=)
    filter: Optional[str] = Field(
        default=None,
        description=,
    )


class ListAgentEngineConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    

    page_size: Optional[int]
    

    page_token: Optional[str]
    

    filter: Optional[str]
    


ListAgentEngineConfigOrDict = Union[ListAgentEngineConfig, ListAgentEngineConfigDict]


class _ListAgentEngineRequestParameters(_common.BaseModel):
    

    config: Optional[ListAgentEngineConfig] = Field(default=None, description=)


class _ListAgentEngineRequestParametersDict(TypedDict, total=False):
    

    config: Optional[ListAgentEngineConfigDict]
    


_ListAgentEngineRequestParametersOrDict = Union[
    _ListAgentEngineRequestParameters, _ListAgentEngineRequestParametersDict
]


class ListReasoningEnginesResponse(_common.BaseModel):
    

    next_page_token: Optional[str] = Field(default=None, description=)
    reasoning_engines: Optional[list[ReasoningEngine]] = Field(
        default=None,
        description=,
    )


class ListReasoningEnginesResponseDict(TypedDict, total=False):
    

    next_page_token: Optional[str]
    

    reasoning_engines: Optional[list[ReasoningEngineDict]]
    


ListReasoningEnginesResponseOrDict = Union[
    ListReasoningEnginesResponse, ListReasoningEnginesResponseDict
]


class ListAgentEngineMemoryConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )
    page_size: Optional[int] = Field(default=None, description=)
    page_token: Optional[str] = Field(default=None, description=)
    filter: Optional[str] = Field(
        default=None,
        description=,
    )


class ListAgentEngineMemoryConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    

    page_size: Optional[int]
    

    page_token: Optional[str]
    

    filter: Optional[str]
    


ListAgentEngineMemoryConfigOrDict = Union[
    ListAgentEngineMemoryConfig, ListAgentEngineMemoryConfigDict
]


class _ListAgentEngineMemoryRequestParameters(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None, description=
    )
    config: Optional[ListAgentEngineMemoryConfig] = Field(
        default=None, description=
    )


class _ListAgentEngineMemoryRequestParametersDict(TypedDict, total=False):
    

    name: Optional[str]
    

    config: Optional[ListAgentEngineMemoryConfigDict]
    


_ListAgentEngineMemoryRequestParametersOrDict = Union[
    _ListAgentEngineMemoryRequestParameters,
    _ListAgentEngineMemoryRequestParametersDict,
]


class ListReasoningEnginesMemoriesResponse(_common.BaseModel):
    

    next_page_token: Optional[str] = Field(default=None, description=)
    memories: Optional[list[Memory]] = Field(
        default=None, description=
    )


class ListReasoningEnginesMemoriesResponseDict(TypedDict, total=False):
    

    next_page_token: Optional[str]
    

    memories: Optional[list[MemoryDict]]
    


ListReasoningEnginesMemoriesResponseOrDict = Union[
    ListReasoningEnginesMemoriesResponse,
    ListReasoningEnginesMemoriesResponseDict,
]


class GetAgentEngineOperationConfig(_common.BaseModel):

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )


class GetAgentEngineOperationConfigDict(TypedDict, total=False):

    http_options: Optional[HttpOptionsDict]
    


GetAgentEngineOperationConfigOrDict = Union[
    GetAgentEngineOperationConfig, GetAgentEngineOperationConfigDict
]


class _GetAgentEngineOperationParameters(_common.BaseModel):
    

    operation_name: Optional[str] = Field(
        default=None,
        description=,
    )
    config: Optional[GetAgentEngineOperationConfig] = Field(
        default=None,
        description=,
    )


class _GetAgentEngineOperationParametersDict(TypedDict, total=False):
    

    operation_name: Optional[str]
    

    config: Optional[GetAgentEngineOperationConfigDict]
    


_GetAgentEngineOperationParametersOrDict = Union[
    _GetAgentEngineOperationParameters, _GetAgentEngineOperationParametersDict
]


class _GetAgentEngineMemoryOperationParameters(_common.BaseModel):
    

    operation_name: Optional[str] = Field(
        default=None,
        description=,
    )
    config: Optional[GetAgentEngineOperationConfig] = Field(
        default=None,
        description=,
    )


class _GetAgentEngineMemoryOperationParametersDict(TypedDict, total=False):
    

    operation_name: Optional[str]
    

    config: Optional[GetAgentEngineOperationConfigDict]
    


_GetAgentEngineMemoryOperationParametersOrDict = Union[
    _GetAgentEngineMemoryOperationParameters,
    _GetAgentEngineMemoryOperationParametersDict,
]


class _GetAgentEngineGenerateMemoriesOperationParameters(_common.BaseModel):
    

    operation_name: Optional[str] = Field(
        default=None,
        description=,
    )
    config: Optional[GetAgentEngineOperationConfig] = Field(
        default=None,
        description=,
    )


class _GetAgentEngineGenerateMemoriesOperationParametersDict(TypedDict, total=False):
    

    operation_name: Optional[str]
    

    config: Optional[GetAgentEngineOperationConfigDict]
    


_GetAgentEngineGenerateMemoriesOperationParametersOrDict = Union[
    _GetAgentEngineGenerateMemoriesOperationParameters,
    _GetAgentEngineGenerateMemoriesOperationParametersDict,
]


class QueryAgentEngineConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )
    class_method: Optional[str] = Field(
        default=None, description=
    )
    input: Optional[dict[str, Any]] = Field(
        default=None, description=
    )
    include_all_fields: Optional[bool] = Field(default=False, description=)


class QueryAgentEngineConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    

    class_method: Optional[str]
    

    input: Optional[dict[str, Any]]
    

    include_all_fields: Optional[bool]
    


QueryAgentEngineConfigOrDict = Union[QueryAgentEngineConfig, QueryAgentEngineConfigDict]


class _QueryAgentEngineRequestParameters(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None, description=
    )
    config: Optional[QueryAgentEngineConfig] = Field(default=None, description=)


class _QueryAgentEngineRequestParametersDict(TypedDict, total=False):
    

    name: Optional[str]
    

    config: Optional[QueryAgentEngineConfigDict]
    


_QueryAgentEngineRequestParametersOrDict = Union[
    _QueryAgentEngineRequestParameters, _QueryAgentEngineRequestParametersDict
]


class QueryReasoningEngineResponse(_common.BaseModel):
    

    output: Optional[Any] = Field(
        default=None,
        description=,
    )


class QueryReasoningEngineResponseDict(TypedDict, total=False):
    

    output: Optional[Any]
    


QueryReasoningEngineResponseOrDict = Union[
    QueryReasoningEngineResponse, QueryReasoningEngineResponseDict
]


class RetrieveMemoriesRequestSimilaritySearchParams(_common.BaseModel):
    

    search_query: Optional[str] = Field(
        default=None,
        description=,
    )
    top_k: Optional[int] = Field(
        default=None,
        description=,
    )


class RetrieveMemoriesRequestSimilaritySearchParamsDict(TypedDict, total=False):
    

    search_query: Optional[str]
    

    top_k: Optional[int]
    


RetrieveMemoriesRequestSimilaritySearchParamsOrDict = Union[
    RetrieveMemoriesRequestSimilaritySearchParams,
    RetrieveMemoriesRequestSimilaritySearchParamsDict,
]


class RetrieveMemoriesRequestSimpleRetrievalParams(_common.BaseModel):
    

    page_size: Optional[int] = Field(
        default=None,
        description=,
    )
    page_token: Optional[str] = Field(
        default=None,
        description=,
    )


class RetrieveMemoriesRequestSimpleRetrievalParamsDict(TypedDict, total=False):
    

    page_size: Optional[int]
    

    page_token: Optional[str]
    


RetrieveMemoriesRequestSimpleRetrievalParamsOrDict = Union[
    RetrieveMemoriesRequestSimpleRetrievalParams,
    RetrieveMemoriesRequestSimpleRetrievalParamsDict,
]


class RetrieveAgentEngineMemoriesConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )


class RetrieveAgentEngineMemoriesConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    


RetrieveAgentEngineMemoriesConfigOrDict = Union[
    RetrieveAgentEngineMemoriesConfig, RetrieveAgentEngineMemoriesConfigDict
]


class _RetrieveAgentEngineMemoriesRequestParameters(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    scope: Optional[dict[str, str]] = Field(
        default=None,
        description=,
    )
    similarity_search_params: Optional[
        RetrieveMemoriesRequestSimilaritySearchParams
    ] = Field(
        default=None,
        description=,
    )
    simple_retrieval_params: Optional[
        RetrieveMemoriesRequestSimpleRetrievalParams
    ] = Field(
        default=None,
        description=,
    )
    config: Optional[RetrieveAgentEngineMemoriesConfig] = Field(
        default=None, description=
    )


class _RetrieveAgentEngineMemoriesRequestParametersDict(TypedDict, total=False):
    

    name: Optional[str]
    

    scope: Optional[dict[str, str]]
    

    similarity_search_params: Optional[
        RetrieveMemoriesRequestSimilaritySearchParamsDict
    ]
    

    simple_retrieval_params: Optional[RetrieveMemoriesRequestSimpleRetrievalParamsDict]
    

    config: Optional[RetrieveAgentEngineMemoriesConfigDict]
    


_RetrieveAgentEngineMemoriesRequestParametersOrDict = Union[
    _RetrieveAgentEngineMemoriesRequestParameters,
    _RetrieveAgentEngineMemoriesRequestParametersDict,
]


class RetrieveMemoriesResponseRetrievedMemory(_common.BaseModel):
    

    distance: Optional[float] = Field(
        default=None,
        description=,
    )
    memory: Optional[Memory] = Field(
        default=None, description=
    )


class RetrieveMemoriesResponseRetrievedMemoryDict(TypedDict, total=False):
    

    distance: Optional[float]
    

    memory: Optional[MemoryDict]
    


RetrieveMemoriesResponseRetrievedMemoryOrDict = Union[
    RetrieveMemoriesResponseRetrievedMemory,
    RetrieveMemoriesResponseRetrievedMemoryDict,
]


class RetrieveMemoriesResponse(_common.BaseModel):
    

    next_page_token: Optional[str] = Field(
        default=None,
        description=,
    )
    retrieved_memories: Optional[list[RetrieveMemoriesResponseRetrievedMemory]] = Field(
        default=None, description=
    )


class RetrieveMemoriesResponseDict(TypedDict, total=False):
    

    next_page_token: Optional[str]
    

    retrieved_memories: Optional[list[RetrieveMemoriesResponseRetrievedMemoryDict]]
    


RetrieveMemoriesResponseOrDict = Union[
    RetrieveMemoriesResponse, RetrieveMemoriesResponseDict
]


class UpdateAgentEngineConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )
    display_name: Optional[str] = Field(
        default=None,
        description=,
    )
    description: Optional[str] = Field(
        default=None, description=
    )
    spec: Optional[ReasoningEngineSpec] = Field(
        default=None,
        description=,
    )
    context_spec: Optional[ReasoningEngineContextSpec] = Field(
        default=None,
        description=,
    )
    update_mask: Optional[str] = Field(
        default=None,
        description=Config for updating agent engine.Used to override HTTP request options.The user-defined name of the Agent Engine.

      The display name can be up to 128 characters long and can comprise any
      UTF-8 characters.
      The description of the Agent Engine.Optional. Configurations of the Agent Engine.Optional. The context spec to be used for the Agent Engine.The update mask to apply. For the `FieldMask` definition, see
      https://protobuf.dev/reference/protobuf/google.protobuf/


UpdateAgentEngineConfigOrDict = Union[
    UpdateAgentEngineConfig, UpdateAgentEngineConfigDict
]


class _UpdateAgentEngineRequestParameters(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None, description=
    )
    config: Optional[UpdateAgentEngineConfig] = Field(default=None, description=)


class _UpdateAgentEngineRequestParametersDict(TypedDict, total=False):
    

    name: Optional[str]
    

    config: Optional[UpdateAgentEngineConfigDict]
    


_UpdateAgentEngineRequestParametersOrDict = Union[
    _UpdateAgentEngineRequestParameters, _UpdateAgentEngineRequestParametersDict
]


class UpdateAgentEngineMemoryConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )
    display_name: Optional[str] = Field(
        default=None, description=
    )
    description: Optional[str] = Field(
        default=None, description=
    )
    wait_for_completion: Optional[bool] = Field(
        default=True,
        description=,
    )
    update_mask: Optional[str] = Field(
        default=None,
        description=Config for updating agent engine memory.Used to override HTTP request options.The display name of the memory.The description of the memory.Waits for the operation to complete before returning.The update mask to apply. For the `FieldMask` definition, see
      https://protobuf.dev/reference/protobuf/google.protobuf/


UpdateAgentEngineMemoryConfigOrDict = Union[
    UpdateAgentEngineMemoryConfig, UpdateAgentEngineMemoryConfigDict
]


class _UpdateAgentEngineMemoryRequestParameters(_common.BaseModel):
    

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    fact: Optional[str] = Field(
        default=None,
        description=,
    )
    scope: Optional[dict[str, str]] = Field(
        default=None,
        description=,
    )
    config: Optional[UpdateAgentEngineMemoryConfig] = Field(
        default=None, description=
    )


class _UpdateAgentEngineMemoryRequestParametersDict(TypedDict, total=False):
    

    name: Optional[str]
    

    fact: Optional[str]
    

    scope: Optional[dict[str, str]]
    

    config: Optional[UpdateAgentEngineMemoryConfigDict]
    


_UpdateAgentEngineMemoryRequestParametersOrDict = Union[
    _UpdateAgentEngineMemoryRequestParameters,
    _UpdateAgentEngineMemoryRequestParametersDict,
]


class PromptOptimizerVAPOConfig(_common.BaseModel):
    

    config_path: Optional[str] = Field(
        default=None,
        description=,
    )
    service_account: Optional[str] = Field(
        default=None,
        description=,
    )
    service_account_project_number: Optional[Union[int, str]] = Field(
        default=None,
        description=,
    )
    wait_for_completion: Optional[bool] = Field(
        default=True,
        description=,
    )
    optimizer_job_display_name: Optional[str] = Field(
        default=None,
        description=,
    )


class PromptOptimizerVAPOConfigDict(TypedDict, total=False):
    

    config_path: Optional[str]
    

    service_account: Optional[str]
    

    service_account_project_number: Optional[Union[int, str]]
    

    wait_for_completion: Optional[bool]
    

    optimizer_job_display_name: Optional[str]
    


PromptOptimizerVAPOConfigOrDict = Union[
    PromptOptimizerVAPOConfig, PromptOptimizerVAPOConfigDict
]


class PromptTemplate(_common.BaseModel):
    

    text: Optional[str] = Field(
        default=None, description=
    )
    _VARIABLE_NAME_REGEX: ClassVar[str] = r"\{([_a-zA-Z][_a-zA-Z0-9]*)\}"

    @field_validator("text")
    @classmethod
    def text_must_not_be_empty(cls, value: str) -> str:
        if not value.strip():
            raise ValueError(
                "Prompt template text cannot be empty or consist only of" " whitespace."
            )
        return value

    @computed_field  
    @property
    def variables(self) -> set[str]:
        return set(re.findall(self._VARIABLE_NAME_REGEX, self.text))

    def _split_template_by_variables(self) -> list[Tuple[str, str]]:
        parts = []
        last_end = 0
        for match in re.finditer(self._VARIABLE_NAME_REGEX, self.text):
            start, end = match.span()
            var_name = match.group(1)
            if start > last_end and self.text:
                parts.append(("text", self.text[last_end:start]))
            parts.append(("var", var_name))
            last_end = end
        if last_end < len(self.text) and self.text:
            parts.append(("text", self.text[last_end:]))
        return parts

    def _merge_adjacent_text_parts(
        self, parts: list[genai_types.Part]
    ) -> list[genai_types.Part]:
        if not parts:
            return []

        merged = []
        current_text_buffer = []

        for part in parts:
            is_purely_text = part.text is not None and all(
                getattr(part, field) is None
                for field in part.model_fields
                if field != "text"
            )

            if is_purely_text:
                current_text_buffer.append(part.text)
            else:
                if current_text_buffer:
                    merged.append(genai_types.Part(text="".join(current_text_buffer)))
                    current_text_buffer = []
                merged.append(part)

        if current_text_buffer:
            merged.append(genai_types.Part(text="".join(current_text_buffer)))

        return merged

    def _is_multimodal_json_string(
        self,
        value: Any,
    ) -> bool:
        
        if not isinstance(value, str):
            return False
        try:
            data = json.loads(value)
            
            
            if isinstance(data, dict):
                if "contents" in data and isinstance(data["contents"], list):
                    if not data["contents"]:
                        return False
                    first_content = data["contents"][0]
                    if isinstance(first_content, dict) and "parts" in first_content:
                        try:
                            genai_types.Content.model_validate(first_content)
                            return True
                        except ValueError:
                            return False
                
                elif "parts" in data and isinstance(data["parts"], list):
                    try:
                        genai_types.Content.model_validate(data)
                        return True
                    except ValueError:
                        return False
            return False
        except json.JSONDecodeError:
            return False

    def _parse_multimodal_json_string_into_parts(
        self,
        value: str,
    ) -> list[genai_types.Part]:
        
        try:
            content = genai_types.Content.model_validate_json(value)
            return content.parts if content.parts is not None else [genai_types.Part()]
        except Exception:
            return [genai_types.Part(text=value)]

    def assemble(self, **kwargs: Any) -> str:
        
        current_variables = self.variables
        for var_name_in_kwarg in kwargs:
            if var_name_in_kwarg not in current_variables:
                raise ValueError(
                    f"Invalid variable name '{var_name_in_kwarg}' provided to"
                    " assemble. Valid variables in template are:"
                    f" {current_variables}"
                )
        
        for tpl_var in current_variables:
            if tpl_var not in kwargs:
                raise ValueError(f"Missing value for template variable '{tpl_var}'.")

        template_segments = self._split_template_by_variables()

        raw_assembled_parts: list[genai_types.Part] = []
        contains_multimodal_variable_type = False

        for segment_type, segment_value in template_segments:
            if segment_type == "text":
                if segment_value:
                    raw_assembled_parts.append(genai_types.Part(text=segment_value))
            elif segment_type == "var":
                var_value = kwargs.get(segment_value)

                str_var_value = str(var_value)

                if self._is_multimodal_json_string(str_var_value):
                    multimodal_parts = self._parse_multimodal_json_string_into_parts(
                        str_var_value
                    )
                    if multimodal_parts:
                        contains_multimodal_variable_type = True
                        raw_assembled_parts.extend(multimodal_parts)
                    else:
                        raw_assembled_parts.append(genai_types.Part(text=str_var_value))
                else:
                    raw_assembled_parts.append(genai_types.Part(text=str_var_value))

        final_assembled_parts = self._merge_adjacent_text_parts(raw_assembled_parts)

        
        
        
        
        if (
            not contains_multimodal_variable_type
            and len(final_assembled_parts) == 1
            and final_assembled_parts[0].text is not None
            and all(
                getattr(final_assembled_parts[0], field) is None
                for field in final_assembled_parts[0].model_fields
                if field not in ["text", "role"]
            )
        ):
            return final_assembled_parts[0].text

        
        final_content_obj = genai_types.Content(parts=final_assembled_parts)
        return final_content_obj.model_dump_json(exclude_none=True)

    def __str__(self) -> str:
        return self.text if self.text else ""

    def __repr__(self) -> str:
        return f"PromptTemplate(text='{self.text}')"


class MetricPromptBuilder(PromptTemplate):
    

    criteria: Optional[dict[str, str]] = Field(
        None,
        description=,
    )

    rating_scores: Optional[dict[str, str]] = Field(
        None,
        description=,
    )

    @staticmethod
    def _get_default_instruction() -> str:
        
        return (
            "You are an expert evaluator. Your task is to evaluate the quality"
            " of the responses generated by AI models. We will provide you with"
            " the user prompt and an AI-generated responses.\nYou should first"
            " read the user input carefully for analyzing the task, and then"
            " evaluate the quality of the responses based on the Criteria"
            " provided in the Evaluation section below.\nYou will assign the"
            " response a rating following the Rating Scores and Evaluation"
            " Steps. Give step by step explanations for your rating, and only"
            " choose ratings from the Rating Scores."
        )

    instruction: Optional[str] = Field(
        default_factory=lambda: MetricPromptBuilder._get_default_instruction(),
        description=,
    )

    metric_definition: Optional[str] = Field(
        None,
        description=,
    )

    @staticmethod
    def _get_default_evaluation_steps() -> dict[str, str]:
        
        return {
            "Step 1": (
                "Assess the response in aspects of all criteria provided."
                " Provide assessment according to each criterion."
            ),
            "Step 2": (
                "Score based on the Rating Scores. Give a brief rationale to"
                " explain your evaluation considering each individual"
                " criterion."
            ),
        }

    evaluation_steps: Optional[dict[str, str]] = Field(
        default_factory=lambda: MetricPromptBuilder._get_default_evaluation_steps(),
        description=,
    )

    few_shot_examples: Optional[list[str]] = Field(
        None,
        description=,
    )

    @staticmethod
    def _serialize_dict_in_order(elements: Optional[dict[str, str]]) -> str:
        
        if elements is None:
            return ""
        return "\n".join(f"{key}: {value}" for key, value in sorted(elements.items()))

    @model_validator(mode="before")
    @classmethod
    def _prepare_fields_and_construct_text(cls, data: Any) -> Any:
        
        if not isinstance(data, dict):
            return data

        if "text" in data:
            raise ValueError(
                "The 'text' field is automatically constructed and should not"
                " be provided manually."
            )

        if data.get("criteria") is None or data.get("rating_scores") is None:
            raise ValueError(
                "Both 'criteria' and 'rating_scores' are required to construct"
                " theLLM-based metric prompt template text."
            )

        instruction = data.get("instruction", cls._get_default_instruction())
        metric_definition = data.get("metric_definition")
        evaluation_steps = data.get(
            "evaluation_steps", cls._get_default_evaluation_steps()
        )
        criteria = data.get("criteria")
        rating_scores = data.get("rating_scores")
        few_shot_examples = data.get("few_shot_examples")

        template_parts = [
            "
            instruction,
            "\n",
            "
        ]

        sections = {
            "Metric Definition": metric_definition,
            "Criteria": cls._serialize_dict_in_order(criteria),
            "Rating Scores": cls._serialize_dict_in_order(rating_scores),
            "Evaluation Steps": cls._serialize_dict_in_order(evaluation_steps),
            "Evaluation Examples": (
                "\n".join(few_shot_examples) if few_shot_examples else None
            ),
        }

        for title, content in sections.items():
            if content:
                template_parts.extend([f"

        template_parts.extend(
            [
                "\n",
                "
                "
                "<prompt>{prompt}</prompt>",
                "\n",
                "
                "<response>{response}</response>",
            ]
        )

        constructed_text = "\n".join(template_parts)

        data["text"] = constructed_text
        return data

    def __str__(self) -> str:
        
        return self.text if self.text else ""


class PromptTemplateDict(TypedDict, total=False):
    

    text: Optional[str]
    


PromptTemplateOrDict = Union[PromptTemplate, PromptTemplateDict]


class EvalRunInferenceConfig(_common.BaseModel):
    

    dest: Optional[str] = Field(
        default=None,
        description=,
    )
    prompt_template: Optional[Union[str, PromptTemplate]] = Field(
        default=None,
        description=,
    )
    generate_content_config: Optional[genai_types.GenerateContentConfig] = Field(
        default=None,
        description=,
    )


class EvalRunInferenceConfigDict(TypedDict, total=False):
    

    dest: Optional[str]
    

    prompt_template: Optional[Union[str, PromptTemplateDict]]
    

    generate_content_config: Optional[genai_types.GenerateContentConfig]
    


EvalRunInferenceConfigOrDict = Union[EvalRunInferenceConfig, EvalRunInferenceConfigDict]


class Metric(_common.BaseModel):
    

    name: Optional[str] = Field(default=None, description=)
    custom_function: Optional[Callable] = Field(
        default=None,
        description=,
    )
    prompt_template: Optional[str] = Field(
        default=None, description=
    )
    judge_model: Optional[str] = Field(
        default=None, description=
    )
    judge_model_sampling_count: Optional[int] = Field(
        default=None, description=
    )
    judge_model_system_instruction: Optional[str] = Field(
        default=None,
        description=,
    )
    return_raw_output: Optional[bool] = Field(
        default=None,
        description=,
    )
    parse_and_reduce_fn: Optional[Callable] = Field(
        default=None,
        description=,
    )
    aggregate_summary_fn: Optional[Callable] = Field(
        default=None,
        description=,
    )

    
    model_config = ConfigDict(extra="allow")

    _is_predefined: bool = PrivateAttr(default=False)
    

    _config_source: Optional[str] = PrivateAttr(default=None)
    

    _version: Optional[str] = PrivateAttr(default=None)
    

    @model_validator(mode="after")
    @classmethod
    def validate_name(cls, model: "Metric") -> "Metric":
        if not model.name:
            raise ValueError("Metric name cannot be empty.")
        model.name = model.name.lower()
        return model

    def to_yaml_file(self, file_path: str, version: Optional[str] = None) -> None:
        
        if yaml is None:
            raise ImportError(
                "YAML serialization requires the pyyaml library. Please install"
                " it using 'pip install google-cloud-aiplatform[evaluation]'."
            )

        fields_to_exclude_callables = set()
        for field_name, field_info in self.model_fields.items():
            annotation = field_info.annotation
            origin = typing.get_origin(annotation)

            is_field_callable_type = False
            if annotation is Callable or origin is Callable:
                is_field_callable_type = True
            elif origin is Union:
                args = typing.get_args(annotation)
                if any(
                    arg is Callable or typing.get_origin(arg) is Callable
                    for arg in args
                ):
                    is_field_callable_type = True

            if is_field_callable_type:
                fields_to_exclude_callables.add(field_name)

        data_to_dump = self.model_dump(
            exclude_unset=True,
            exclude_none=True,
            mode="json",
            exclude=fields_to_exclude_callables
            if fields_to_exclude_callables
            else None,
        )

        if version:
            data_to_dump["version"] = version

        with open(file_path, "w", encoding="utf-8") as f:
            yaml.dump(data_to_dump, f, sort_keys=False, allow_unicode=True)


class LLMMetric(Metric):
    

    rubric_group_name: Optional[str] = Field(
        default=None,
        description=,
    )

    @field_validator("prompt_template", mode="before")
    @classmethod
    def validate_prompt_template(cls, value: Union[str, "MetricPromptBuilder"]) -> str:
        
        if value is None:
            raise ValueError("Prompt template cannot be empty.")
        if isinstance(value, MetricPromptBuilder):
            value = str(value)
        if not value.strip():
            raise ValueError("Prompt template cannot be an empty string.")
        return value

    @field_validator("judge_model_sampling_count")
    @classmethod
    def validate_judge_model_sampling_count(cls, value: Optional[int]) -> Optional[int]:
        
        if value is not None and (value < 1 or value > 32):
            raise ValueError("judge_model_sampling_count must be between 1 and 32.")
        return value

    @classmethod
    def load(cls, config_path: str, client: Optional[Any] = None) -> "LLMMetric":
        
        file_extension = os.path.splitext(config_path)[1].lower()
        if file_extension not in [".yaml", ".yml", ".json"]:
            raise ValueError(
                "Unsupported file extension for metric config. Must be .yaml,"
                " .yml, or .json"
            )

        content_str: str
        if config_path.startswith("gs://"):
            try:
                from google.cloud import storage

                storage_client = storage.Client(
                    credentials=client._api_client._credentials if client else None
                )
                path_without_prefix = config_path[len("gs://") :]
                bucket_name, blob_path = path_without_prefix.split("/", 1)

                bucket = storage_client.bucket(bucket_name)
                blob = bucket.blob(blob_path)
                content_str = blob.download_as_bytes().decode("utf-8")
            except ImportError as e:
                raise ImportError(
                    "Reading from GCS requires the 'google-cloud-storage'"
                    " library. Please install it with 'pip install"
                    " google-cloud-aiplatform[evaluation]'."
                ) from e
            except Exception as e:
                raise IOError(f"Failed to read from GCS path {config_path}: {e}") from e
        else:
            try:
                with open(config_path, "r", encoding="utf-8") as f:
                    content_str = f.read()
            except FileNotFoundError:
                raise FileNotFoundError(
                    f"Local configuration file not found at: {config_path}"
                )
            except Exception as e:
                raise IOError(f"Failed to read local file {config_path}: {e}") from e

        data: Dict[str, Any]

        if file_extension in [".yaml", ".yml"]:
            if yaml is None:
                raise ImportError(
                    "YAML parsing requires the pyyaml library. Please install"
                    " it with 'pip install"
                    " google-cloud-aiplatform[evaluation]'."
                )
            data = yaml.safe_load(content_str)
        elif file_extension == ".json":
            data = json.loads(content_str)

        if not isinstance(data, dict):
            raise ValueError("Metric config content did not parse into a dictionary.")

        return cls.model_validate(data)


class MetricDict(TypedDict, total=False):
    

    name: Optional[str]
    

    custom_function: Optional[Callable]
    

    prompt_template: Optional[str]
    

    judge_model: Optional[str]
    

    judge_model_sampling_count: Optional[int]
    

    judge_model_system_instruction: Optional[str]
    

    return_raw_output: Optional[bool]
    

    parse_and_reduce_fn: Optional[Callable]
    

    aggregate_summary_fn: Optional[Callable]
    


MetricOrDict = Union[Metric, MetricDict]


class Message(_common.BaseModel):
    

    turn_id: Optional[str] = Field(
        default=None, description=
    )
    content: Optional[genai_types.Content] = Field(
        default=None,
        description=,
    )
    creation_timestamp: Optional[datetime.datetime] = Field(
        default=None,
        description=,
    )
    author: Optional[str] = Field(
        default=None,
        description=,
    )


class MessageDict(TypedDict, total=False):
    

    turn_id: Optional[str]
    

    content: Optional[genai_types.Content]
    

    creation_timestamp: Optional[datetime.datetime]
    

    author: Optional[str]
    


MessageOrDict = Union[Message, MessageDict]


class AgentData(_common.BaseModel):
    

    tool_use_trajectory: Optional[list[Message]] = Field(
        default=None,
        description=,
    )
    intermediate_responses: Optional[list[Message]] = Field(
        default=None,
        description=,
    )


class AgentDataDict(TypedDict, total=False):
    

    tool_use_trajectory: Optional[list[MessageDict]]
    

    intermediate_responses: Optional[list[MessageDict]]
    


AgentDataOrDict = Union[AgentData, AgentDataDict]


class ResponseCandidate(_common.BaseModel):
    

    response: Optional[genai_types.Content] = Field(
        default=None,
        description=,
    )
    agent_data: Optional[AgentData] = Field(
        default=None,
        description=,
    )


class ResponseCandidateDict(TypedDict, total=False):
    

    response: Optional[genai_types.Content]
    

    agent_data: Optional[AgentDataDict]
    


ResponseCandidateOrDict = Union[ResponseCandidate, ResponseCandidateDict]


class EvalCase(_common.BaseModel):
    

    prompt: Optional[genai_types.Content] = Field(
        default=None,
        description=,
    )
    responses: Optional[list[ResponseCandidate]] = Field(
        default=None,
        description=,
    )
    reference: Optional[ResponseCandidate] = Field(
        default=None,
        description=,
    )
    system_instruction: Optional[genai_types.Content] = Field(
        default=None, description=
    )
    conversation_history: Optional[list[Message]] = Field(
        default=None,
        description=,
    )
    eval_case_id: Optional[str] = Field(
        default=None,
        description=,
    )
    
    model_config = ConfigDict(frozen=True, extra="allow")


class EvalCaseDict(TypedDict, total=False):
    

    prompt: Optional[genai_types.Content]
    

    responses: Optional[list[ResponseCandidateDict]]
    

    reference: Optional[ResponseCandidateDict]
    

    system_instruction: Optional[genai_types.Content]
    

    conversation_history: Optional[list[MessageDict]]
    

    eval_case_id: Optional[str]
    


EvalCaseOrDict = Union[EvalCase, EvalCaseDict]


class GcsSource(_common.BaseModel):
    

    uris: Optional[list[str]] = Field(
        default=None,
        description=,
    )


class GcsSourceDict(TypedDict, total=False):
    

    uris: Optional[list[str]]
    


GcsSourceOrDict = Union[GcsSource, GcsSourceDict]


class BigQuerySource(_common.BaseModel):
    

    input_uri: Optional[str] = Field(
        default=None,
        description=,
    )


class BigQuerySourceDict(TypedDict, total=False):
    

    input_uri: Optional[str]
    


BigQuerySourceOrDict = Union[BigQuerySource, BigQuerySourceDict]


class EvaluationDataset(_common.BaseModel):
    

    eval_cases: Optional[list[EvalCase]] = Field(
        default=None, description=
    )
    eval_dataset_df: Optional[PandasDataFrame] = Field(
        default=None,
        description=,
    )
    candidate_name: Optional[str] = Field(
        default=None,
        description=,
    )
    gcs_source: Optional[GcsSource] = Field(
        default=None,
        description=,
    )
    bigquery_source: Optional[BigQuerySource] = Field(
        default=None,
        description=,
    )

    @model_validator(mode="before")
    @classmethod
    def _check_pandas_installed(cls, data: Any) -> Any:
        if isinstance(data, dict) and data.get("eval_dataset_df") is not None:
            if pd is None:
                logger.warning(
                    "Pandas is not installed, some evals features are not"
                    " available. Please install it with `pip install"
                    " google-cloud-aiplatform[evaluation]`."
                )
        return data

    def show(self) -> None:
        
        from . import _evals_visualization

        _evals_visualization.display_evaluation_dataset(self)


class EvaluationDatasetDict(TypedDict, total=False):
    

    eval_cases: Optional[list[EvalCaseDict]]
    

    eval_dataset_df: Optional[PandasDataFrame]
    

    candidate_name: Optional[str]
    

    gcs_source: Optional[GcsSourceDict]
    

    bigquery_source: Optional[BigQuerySourceDict]
    


EvaluationDatasetOrDict = Union[EvaluationDataset, EvaluationDatasetDict]


class WinRateStats(_common.BaseModel):
    

    win_rates: Optional[list[float]] = Field(
        default=None,
        description=,
    )
    tie_rate: Optional[float] = Field(
        default=None, description=
    )


class WinRateStatsDict(TypedDict, total=False):
    

    win_rates: Optional[list[float]]
    

    tie_rate: Optional[float]
    


WinRateStatsOrDict = Union[WinRateStats, WinRateStatsDict]


class EvalCaseMetricResult(_common.BaseModel):
    

    metric_name: Optional[str] = Field(
        default=None, description=
    )
    score: Optional[float] = Field(default=None, description=)
    explanation: Optional[str] = Field(
        default=None, description=
    )
    rubric_verdicts: Optional[list[RubricVerdict]] = Field(
        default=None,
        description=,
    )
    raw_output: Optional[list[str]] = Field(
        default=None, description=
    )
    error_message: Optional[str] = Field(
        default=None, description=
    )


class EvalCaseMetricResultDict(TypedDict, total=False):
    

    metric_name: Optional[str]
    

    score: Optional[float]
    

    explanation: Optional[str]
    

    rubric_verdicts: Optional[list[RubricVerdictDict]]
    

    raw_output: Optional[list[str]]
    

    error_message: Optional[str]
    


EvalCaseMetricResultOrDict = Union[EvalCaseMetricResult, EvalCaseMetricResultDict]


class ResponseCandidateResult(_common.BaseModel):
    

    response_index: Optional[int] = Field(
        default=None,
        description=,
    )
    metric_results: Optional[dict[str, EvalCaseMetricResult]] = Field(
        default=None,
        description=,
    )


class ResponseCandidateResultDict(TypedDict, total=False):
    

    response_index: Optional[int]
    

    metric_results: Optional[dict[str, EvalCaseMetricResultDict]]
    


ResponseCandidateResultOrDict = Union[
    ResponseCandidateResult, ResponseCandidateResultDict
]


class EvalCaseResult(_common.BaseModel):
    

    eval_case_index: Optional[int] = Field(
        default=None, description=
    )
    response_candidate_results: Optional[list[ResponseCandidateResult]] = Field(
        default=None,
        description=,
    )


class EvalCaseResultDict(TypedDict, total=False):
    

    eval_case_index: Optional[int]
    

    response_candidate_results: Optional[list[ResponseCandidateResultDict]]
    


EvalCaseResultOrDict = Union[EvalCaseResult, EvalCaseResultDict]


class AggregatedMetricResult(_common.BaseModel):
    

    metric_name: Optional[str] = Field(
        default=None, description=
    )
    num_cases_total: Optional[int] = Field(
        default=None, description=
    )
    num_cases_valid: Optional[int] = Field(
        default=None, description=
    )
    num_cases_error: Optional[int] = Field(
        default=None,
        description=,
    )
    mean_score: Optional[float] = Field(
        default=None, description=
    )
    stdev_score: Optional[float] = Field(
        default=None, description=
    )

    
    model_config = ConfigDict(extra="allow")


class AggregatedMetricResultDict(TypedDict, total=False):
    

    metric_name: Optional[str]
    

    num_cases_total: Optional[int]
    

    num_cases_valid: Optional[int]
    

    num_cases_error: Optional[int]
    

    mean_score: Optional[float]
    

    stdev_score: Optional[float]
    


AggregatedMetricResultOrDict = Union[AggregatedMetricResult, AggregatedMetricResultDict]


class EvaluationRunMetadata(_common.BaseModel):
    

    candidate_names: Optional[list[str]] = Field(
        default=None,
        description=,
    )
    dataset_name: Optional[str] = Field(
        default=None,
        description=,
    )
    dataset_id: Optional[str] = Field(
        default=None,
        description=,
    )
    creation_timestamp: Optional[datetime.datetime] = Field(
        default=None,
        description=,
    )


class EvaluationRunMetadataDict(TypedDict, total=False):
    

    candidate_names: Optional[list[str]]
    

    dataset_name: Optional[str]
    

    dataset_id: Optional[str]
    

    creation_timestamp: Optional[datetime.datetime]
    


EvaluationRunMetadataOrDict = Union[EvaluationRunMetadata, EvaluationRunMetadataDict]


class EvaluationResult(_common.BaseModel):
    

    eval_case_results: Optional[list[EvalCaseResult]] = Field(
        default=None,
        description=,
    )
    summary_metrics: Optional[list[AggregatedMetricResult]] = Field(
        default=None,
        description=,
    )
    win_rates: Optional[dict[str, WinRateStats]] = Field(
        default=None,
        description=,
    )
    evaluation_dataset: Optional[list[EvaluationDataset]] = Field(
        default=None,
        description=,
    )
    metadata: Optional[EvaluationRunMetadata] = Field(
        default=None, description=
    )

    def show(self, candidate_names: Optional[List[str]] = None) -> None:
        
        from . import _evals_visualization

        _evals_visualization.display_evaluation_result(self, candidate_names)


class EvaluationResultDict(TypedDict, total=False):
    

    eval_case_results: Optional[list[EvalCaseResultDict]]
    

    summary_metrics: Optional[list[AggregatedMetricResultDict]]
    

    win_rates: Optional[dict[str, WinRateStatsDict]]
    

    evaluation_dataset: Optional[list[EvaluationDatasetDict]]
    

    metadata: Optional[EvaluationRunMetadataDict]
    


EvaluationResultOrDict = Union[EvaluationResult, EvaluationResultDict]


class ContentMapContents(_common.BaseModel):
    

    contents: Optional[list[genai_types.Content]] = Field(
        default=None, description=
    )


class ContentMapContentsDict(TypedDict, total=False):
    

    contents: Optional[list[genai_types.Content]]
    


ContentMapContentsOrDict = Union[ContentMapContents, ContentMapContentsDict]


class EvaluateMethodConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )
    dataset_schema: Optional[Literal["GEMINI", "FLATTEN", "OPENAI"]] = Field(
        default=None,
        description=,
    )
    dest: Optional[str] = Field(
        default=None,
        description=,
    )


class EvaluateMethodConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    

    dataset_schema: Optional[Literal["GEMINI", "FLATTEN", "OPENAI"]]
    

    dest: Optional[str]
    


EvaluateMethodConfigOrDict = Union[EvaluateMethodConfig, EvaluateMethodConfigDict]


class OutputConfig(_common.BaseModel):
    

    gcs_destination: Optional[GcsDestination] = Field(
        default=None,
        description=,
    )


class OutputConfigDict(TypedDict, total=False):
    

    gcs_destination: Optional[GcsDestinationDict]
    


OutputConfigOrDict = Union[OutputConfig, OutputConfigDict]


class EvaluateDatasetConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )


class EvaluateDatasetConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    


EvaluateDatasetConfigOrDict = Union[EvaluateDatasetConfig, EvaluateDatasetConfigDict]


class EvaluateDatasetRequestParameters(_common.BaseModel):
    

    dataset: Optional[EvaluationDataset] = Field(default=None, description=)
    metrics: Optional[list[Metric]] = Field(default=None, description=)
    output_config: Optional[OutputConfig] = Field(default=None, description=)
    autorater_config: Optional[AutoraterConfig] = Field(
        default=None, description=
    )
    config: Optional[EvaluateDatasetConfig] = Field(default=None, description=)


class EvaluateDatasetRequestParametersDict(TypedDict, total=False):
    

    dataset: Optional[EvaluationDatasetDict]
    

    metrics: Optional[list[MetricDict]]
    

    output_config: Optional[OutputConfigDict]
    

    autorater_config: Optional[AutoraterConfigDict]
    

    config: Optional[EvaluateDatasetConfigDict]
    


EvaluateDatasetRequestParametersOrDict = Union[
    EvaluateDatasetRequestParameters, EvaluateDatasetRequestParametersDict
]


class EvaluateDatasetOperation(_common.BaseModel):

    name: Optional[str] = Field(
        default=None,
        description=,
    )
    metadata: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )
    done: Optional[bool] = Field(
        default=None,
        description=,
    )
    error: Optional[dict[str, Any]] = Field(
        default=None,
        description=,
    )
    response: Optional[EvaluationDataset] = Field(default=None, description=)


class EvaluateDatasetOperationDict(TypedDict, total=False):

    name: Optional[str]
    

    metadata: Optional[dict[str, Any]]
    

    done: Optional[bool]
    

    error: Optional[dict[str, Any]]
    

    response: Optional[EvaluationDatasetDict]
    


EvaluateDatasetOperationOrDict = Union[
    EvaluateDatasetOperation, EvaluateDatasetOperationDict
]


class RubricGroup(_common.BaseModel):
    

    group_id: Optional[str] = Field(
        default=None, description=
    )
    display_name: Optional[str] = Field(
        default=None,
        description=,
    )
    rubrics: Optional[list[Rubric]] = Field(
        default=None, description=
    )


class RubricGroupDict(TypedDict, total=False):
    

    group_id: Optional[str]
    

    display_name: Optional[str]
    

    rubrics: Optional[list[RubricDict]]
    


RubricGroupOrDict = Union[RubricGroup, RubricGroupDict]


class AgentEngine(_common.BaseModel):
    

    api_client: Optional[Any] = Field(
        default=None, description=
    )
    api_async_client: Optional[Any] = Field(
        default=None,
        description=,
    )
    api_resource: Optional[ReasoningEngine] = Field(
        default=None,
        description=,
    )

    
    model_config = ConfigDict(extra="allow")

    def __repr__(self) -> str:
        return (
            f"AgentEngine(api_resource.name='{self.api_resource.name}')"
            if self.api_resource is not None
            else "AgentEngine(api_resource.name=None)"
        )

    def operation_schemas(self) -> Optional[list[Dict[str, Any]]]:
        
        if not isinstance(self.api_resource, ReasoningEngine):
            raise ValueError("api_resource is not initialized.")
        if not self.api_resource.spec:
            raise ValueError("api_resource.spec is not initialized.")
        return self.api_resource.spec.class_methods

    def delete(
        self,
        force: bool = False,
        config: Optional[DeleteAgentEngineConfigOrDict] = None,
    ) -> None:
        
        if not isinstance(self.api_resource, ReasoningEngine):
            raise ValueError("api_resource is not initialized.")
        self.api_client.delete(name=self.api_resource.name, force=force, config=config)  


class AgentEngineDict(TypedDict, total=False):
    

    api_client: Optional[Any]
    

    api_async_client: Optional[Any]
    

    api_resource: Optional[ReasoningEngineDict]
    


AgentEngineOrDict = Union[AgentEngine, AgentEngineDict]


class AgentEngineConfig(_common.BaseModel):
    

    http_options: Optional[HttpOptions] = Field(
        default=None, description=
    )
    staging_bucket: Optional[str] = Field(
        default=None,
        description=,
    )
    requirements: Optional[Any] = Field(
        default=None,
        description=,
    )
    display_name: Optional[str] = Field(
        default=None,
        description=,
    )
    description: Optional[str] = Field(
        default=None, description=
    )
    gcs_dir_name: Optional[str] = Field(
        default=None,
        description=,
    )
    extra_packages: Optional[list[str]] = Field(
        default=None,
        description=,
    )
    env_vars: Optional[Any] = Field(
        default=None,
        description=,
    )
    context_spec: Optional[ReasoningEngineContextSpec] = Field(
        default=None,
        description=,
    )


class AgentEngineConfigDict(TypedDict, total=False):
    

    http_options: Optional[HttpOptionsDict]
    

    staging_bucket: Optional[str]
    

    requirements: Optional[Any]
    

    display_name: Optional[str]
    

    description: Optional[str]
    

    gcs_dir_name: Optional[str]
    

    extra_packages: Optional[list[str]]
    

    env_vars: Optional[Any]
    

    context_spec: Optional[ReasoningEngineContextSpecDict]
    


AgentEngineConfigOrDict = Union[AgentEngineConfig, AgentEngineConfigDict]
