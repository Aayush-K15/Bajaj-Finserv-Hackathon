from __future__ import annotations


__all__ = [
    'Recipient',
]


import enum
import functools
import logging
import weakref

from typing import (
        Any, Generic, List, Optional, Tuple, TYPE_CHECKING, Type, TypeVar, Union
    )

from .constants import MSG_PATH, OVERRIDE_CLASS
from .enums import ErrorBehavior, PropertiesType
from .exceptions import StandardViolationError
from .properties.properties_store import PropertiesStore
from .structures.entry_id import PermanentEntryID
from .utils import msgPathToString


if TYPE_CHECKING:
    from .msg_classes.msg import MSGFile

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

_T = TypeVar('_T')
_RT = TypeVar('_RT', bound = enum.IntEnum)


class Recipient(Generic[_RT]):
    

    def __init__(self, _dir: str, msg: MSGFile, recipientTypeClass: Type[_RT]):
        self.__msg = weakref.ref(msg) 
        self.__dir = _dir
        if not self.exists('__properties_version1.0'):
            if ErrorBehavior.STANDARDS_VIOLATION in msg.errorBehavior:
                logger.error('Recipients MUST have a property stream.')
            else:
                raise StandardViolationError('Recipients MUST have a property stream.') from None
        self.__props = PropertiesStore(self.getStream('__properties_version1.0'), PropertiesType.RECIPIENT)
        self.__email = self.getStringStream('__substg1.0_39FE')
        if not self.__email:
            self.__email = self.getStringStream('__substg1.0_3003')
        self.__name = self.getStringStream('__substg1.0_3001')
        self.__typeFlags = self.__props.getValue('0C150003', 0)
        self.__type = recipientTypeClass(0xF & self.__typeFlags)
        self.__formatted = f'{self.__name} <{self.__email}>'

    def exists(self, filename: MSG_PATH) -> bool:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Recipient instance has been garbage collected.')
        return msg.exists([self.__dir, msgPathToString(filename)])

    def sExists(self, filename: MSG_PATH) -> bool:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Recipient instance has been garbage collected.')
        return msg.sExists([self.__dir, msgPathToString(filename)])

    def existsTypedProperty(self, id, _type = None) -> Tuple[bool, int]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Recipient instance has been garbage collected.')
        return msg.existsTypedProperty(id, self.__dir, _type, True, self.__props)

    def getMultipleBinary(self, filename: MSG_PATH) -> Optional[List[bytes]]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Recipient instance has been garbage collected.')
        return msg.getMultipleBinary([self.__dir, msgPathToString(filename)])

    def getMultipleString(self, filename: MSG_PATH) -> Optional[List[str]]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Recipient instance has been garbage collected.')
        return msg.getMultipleString([self.__dir, msgPathToString(filename)])

    def getPropertyAs(self, propertyName: Union[int, str], overrideClass: OVERRIDE_CLASS[_T]) -> Optional[_T]:
        
        value = self.getPropertyVal(propertyName)

        if value is not None:
            value = overrideClass(value)

        return value

    def getPropertyVal(self, name: Union[int, str], default: _T = None) -> Union[Any, _T]:
        
        return self.props.getValue(name, default)

    def getSingleOrMultipleBinary(self, filename: MSG_PATH) -> Optional[Union[List[bytes], bytes]]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Recipient instance has been garbage collected.')
        return msg.getSingleOrMultipleBinary([self.__dir, msgPathToString(filename)])

    def getSingleOrMultipleString(self, filename: MSG_PATH) -> Optional[Union[List[str], str]]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Recipient instance has been garbage collected.')
        return msg.getSingleOrMultipleString([self.__dir, msgPathToString(filename)])

    def getStream(self, filename: MSG_PATH) -> Optional[bytes]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Recipient instance has been garbage collected.')
        return msg.getStream([self.__dir, msgPathToString(filename)])

    def getStreamAs(self, streamID: MSG_PATH, overrideClass: OVERRIDE_CLASS[_T]) -> Optional[_T]:
        
        value = self.getStream(streamID)

        if value is not None:
            value = overrideClass(value)

        return value

    def getStringStream(self, filename: MSG_PATH) -> Optional[str]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Recipient instance has been garbage collected.')
        return msg.getStringStream([self.__dir, msgPathToString(filename)])

    def getStringStreamAs(self, streamID: MSG_PATH, overrideClass: OVERRIDE_CLASS[_T]) -> Optional[_T]:
        
        value = self.getStream(streamID)

        if value is not None:
            value = overrideClass(value)

        return value

    def listDir(self, streams: bool = True, storages: bool = False) -> List[List[str]]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Recipient instance has been garbage collected.')
        return [path[1:] for path in msg.listDir(streams, storages, False)
                if len(path) > 1 and path[0] == self.__dir]

    def slistDir(self, streams: bool = True, storages: bool = False) -> List[str]:
        
        return ['/'.join(path) for path in self.listDir(streams, storages)]

    @functools.cached_property
    def account(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_3A00')

    @property
    def email(self) -> Optional[str]:
        
        return self.__email

    @functools.cached_property
    def entryID(self) -> Optional[PermanentEntryID]:
        
        return self.getStreamAs('__substg1.0_0FFF0102', PermanentEntryID)

    @property
    def formatted(self) -> str:
        
        return self.__formatted

    @functools.cached_property
    def instanceKey(self) -> Optional[bytes]:
        
        return self.getStream('__substg1.0_0FF60102')

    @property
    def name(self) -> Optional[str]:
        
        return self.__name

    @property
    def props(self) -> PropertiesStore:
        
        return self.__props

    @functools.cached_property
    def recordKey(self) -> Optional[bytes]:
        
        return self.getStream('__substg1.0_0FF90102')

    @functools.cached_property
    def searchKey(self) -> Optional[bytes]:
        
        return self.getStream('__substg1.0_300B0102')

    @functools.cached_property
    def smtpAddress(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_39FE')

    @functools.cached_property
    def transmittableDisplayName(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_3A20')

    @property
    def type(self) -> _RT:
        
        return self.__type

    @property
    def typeFlags(self) -> int:
        
        return self.__typeFlags
