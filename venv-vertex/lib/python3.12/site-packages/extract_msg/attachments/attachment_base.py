from __future__ import annotations


__all__ = [
    'AttachmentBase',
]


import abc
import datetime
import functools
import logging
import os
import pathlib
import weakref

from functools import cached_property
from typing import (
        Any, List, Optional, Tuple, Type, TYPE_CHECKING, TypeVar, Union
    )

from ..constants import MSG_PATH, OVERRIDE_CLASS, SAVE_TYPE
from ..enums import AttachmentType
from ..properties.named import NamedProperties
from ..properties.properties_store import PropertiesStore
from ..utils import (
        msgPathToString, tryGetMimetype, verifyPropertyId, verifyType
    )



if TYPE_CHECKING:
    from ..msg_classes.msg import MSGFile

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

_T = TypeVar('_T')


class AttachmentBase(abc.ABC):
    

    def __init__(self, msg: MSGFile, dir_: str, propStore: PropertiesStore):
        
        self.__msg = weakref.ref(msg)
        self.__dir = dir_
        self.__props = propStore
        self.__namedProperties = NamedProperties(msg.named, self)
        self.__treePath = msg.treePath + [weakref.ref(self)]

    def _getTypedAs(self, _id: str, overrideClass = None, preserveNone: bool = True):
        
        value = self._getTypedData(_id)
        
        if overrideClass is not None:
            if value is not None or not preserveNone:
                value = overrideClass(value)

        return value

    def _getTypedData(self, id, _type = None):
        
        verifyPropertyId(id)
        id = id.upper()
        found, result = self._getTypedStream('__substg1.0_' + id, _type)
        if found:
            return result
        else:
            found, result = self._getTypedProperty(id, _type)
            return result if found else None

    def _getTypedProperty(self, propertyID, _type = None) -> Tuple[bool, Optional[object]]:
        
        verifyPropertyId(propertyID)
        if _type:
            verifyType(_type)
            propertyID += _type

        notFound = object()
        ret = self.getPropertyVal(propertyID, notFound)
        if ret is notFound:
            return False, None

        return True, ret

    def _getTypedStream(self, filename: MSG_PATH, _type = None):
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
        return msg._getTypedStream([self.__dir, msgPathToString(filename)], True, _type)

    def _handleFnc(self, _zip, filename, customPath: pathlib.Path, kwargs) -> pathlib.Path:
        
        fullFilename = customPath / filename

        overwriteExisting = kwargs.get('overwriteExisting', False)

        if _zip:
            
            if not overwriteExisting:
                name, ext = os.path.splitext(filename)
                nameList = _zip.namelist()
                if str(fullFilename).replace('\\', '/') in nameList:
                    for i in range(2, 100):
                        testName = customPath / f'{name} ({i}){ext}'
                        if str(testName).replace('\\', '/') not in nameList:
                            return testName
                    else:
                        
                        raise FileExistsError(f'Could not create the specified file because it already exists ("{fullFilename}").')
        else:
            if not overwriteExisting and fullFilename.exists():
                
                name, ext = os.path.splitext(filename)
                
                for i in range(2, 100):
                    testName = customPath / f'{name} ({i}){ext}'
                    if not testName.exists():
                        return testName
                else:
                    
                    raise FileExistsError(f'Could not create the specified file because it already exists ("{fullFilename}").')

        return fullFilename

    def exists(self, filename: MSG_PATH) -> bool:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
        return msg.exists([self.__dir, msgPathToString(filename)])

    def sExists(self, filename: MSG_PATH) -> bool:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
        return msg.sExists([self.__dir, msgPathToString(filename)])

    def existsTypedProperty(self, id, _type = None) -> Tuple[bool, int]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
        return msg.existsTypedProperty(id, self.__dir, _type, True, self.__props)

    @abc.abstractmethod
    def getFilename(self, **kwargs) -> str:
        

    def getMultipleBinary(self, filename: MSG_PATH) -> Optional[List[bytes]]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
        return msg.getMultipleBinary([self.__dir, msgPathToString(filename)])

    def getMultipleString(self, filename: MSG_PATH) -> Optional[List[str]]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
        return msg.getMultipleString([self.__dir, msgPathToString(filename)])

    def getNamedAs(self, propertyName: str, guid: str, overrideClass: OVERRIDE_CLASS[_T]) -> Optional[_T]:
        
        value = self.getNamedProp(propertyName, guid)
        if value is not None:
            value = overrideClass(value)
        return value

    def getNamedProp(self, propertyName: str, guid: str, default: _T = None) -> Union[Any, _T]:
        
        return self.namedProperties.get((propertyName, guid), default)

    def getPropertyAs(self, propertyName: Union[int, str], overrideClass: OVERRIDE_CLASS[_T]) -> Optional[_T]:
        
        value = self.getPropertyVal(propertyName)

        if value is not None:
            value = overrideClass(value)

        return value

    def getPropertyVal(self, name: Union[int, str], default: _T = None) -> Union[Any, _T]:
        
        return self.props.getValue(name, default)

    def getSingleOrMultipleBinary(self, filename: MSG_PATH) -> Optional[Union[List[bytes], bytes]]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
        return msg.getSingleOrMultipleBinary([self.__dir, msgPathToString(filename)])

    def getSingleOrMultipleString(self, filename: MSG_PATH) -> Optional[Union[List[str], str]]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
        return msg.getSingleOrMultipleString([self.__dir, msgPathToString(filename)])

    def getStream(self, filename: MSG_PATH) -> Optional[bytes]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
        return msg.getStream([self.__dir, msgPathToString(filename)])

    def getStreamAs(self, streamID: MSG_PATH, overrideClass: OVERRIDE_CLASS[_T]) -> Optional[_T]:
        
        value = self.getStream(streamID)

        if value is not None:
            value = overrideClass(value)

        return value

    def getStringStream(self, filename: MSG_PATH) -> Optional[str]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
        return msg.getStringStream([self.__dir, msgPathToString(filename)])

    def getStringStreamAs(self, streamID: MSG_PATH, overrideClass: OVERRIDE_CLASS[_T]) -> Optional[_T]:
        
        value = self.getStream(streamID)

        if value is not None:
            value = overrideClass(value)

        return value

    def listDir(self, streams: bool = True, storages: bool = False) -> List[List[str]]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
        return [path[1:] for path in msg.listDir(streams, storages, False)
                if len(path) > 1 and path[0] == self.__dir]

    def slistDir(self, streams: bool = True, storages: bool = False) -> List[str]:
        
        return ['/'.join(path) for path in self.listDir(streams, storages)]

    @abc.abstractmethod
    def save(self, **kwargs) -> SAVE_TYPE:
        

    @cached_property
    def attachmentEncoding(self) -> Optional[bytes]:
        
        return self.getStream('__substg1.0_37020102')

    @cached_property
    def additionalInformation(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_370F')

    @cached_property
    def cid(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_3712')

    @cached_property
    def clsid(self) -> str:
        
        
        clsid = '00000000-0000-0000-0000-000000000000'
        dataStream = None

        if self.exists('__substg1.0_3701000D'):
            dataStream = [self.__dir, '__substg1.0_3701000D']
        elif self.exists('__substg1.0_37010102'):
            dataStream = [self.__dir, '__substg1.0_37010102']

        
        if dataStream:
            if (msg := self.__msg()) is None:
                raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
            clsid = msg._getOleEntry(dataStream).clsid or clsid

        return clsid

    @property
    def contentId(self) -> Optional[str]:
        
        return self.cid

    @property
    def createdAt(self) -> Optional[datetime.datetime]:
        
        return self.creationTime

    @cached_property
    def creationTime(self) -> Optional[datetime.datetime]:
        
        return self.getPropertyVal('30070040')

    @property
    @abc.abstractmethod
    def data(self) -> Optional[object]:
        

    @cached_property
    def dataType(self) -> Optional[Type[object]]:
        
        try:
            return None if self.data is None else self.data.__class__
        except Exception:
            
            return None

    @property
    def dir(self) -> str:
        
        return self.__dir

    @cached_property
    def displayName(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_3001')

    @cached_property
    def exceptionReplaceTime(self) -> Optional[datetime.datetime]:
        
        return self.getPropertyVal('7FF90040')

    @cached_property
    def extension(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_3703')

    @cached_property
    def hidden(self) -> bool:
        
        return bool(self.getPropertyVal('7FFE000B'))

    @cached_property
    def isAttachmentContactPhoto(self) -> bool:
        
        return bool(self.getPropertyVal('7FFF000B'))

    @cached_property
    def lastModificationTime(self) -> Optional[datetime.datetime]:
        
        return self.getPropertyVal('30080040')

    @cached_property
    def longFilename(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_3707')

    @cached_property
    def longPathname(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_370D')

    @cached_property
    def mimetype(self) -> Optional[str]:
        
        return tryGetMimetype(self, self.getStringStream('__substg1.0_370E'))

    @property
    def modifiedAt(self) -> Optional[datetime.datetime]:
        
        return self.lastModificationTime

    @property
    def msg(self) -> MSGFile:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Attachment instance has been garbage collected.')
        return msg

    @cached_property
    def name(self) -> Optional[str]:
        
        if self.type is AttachmentType.MSG:
            if self.displayName:
                return self.displayName + '.msg'
        return self.longFilename or self.shortFilename

    @property
    def namedProperties(self) -> NamedProperties:
        
        return self.__namedProperties

    @cached_property
    def payloadClass(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_371A')

    @property
    def props(self) -> PropertiesStore:
        
        return self.__props

    @cached_property
    def renderingPosition(self) -> Optional[int]:
        
        return self.getPropertyVal('370B0003')

    @cached_property
    def shortFilename(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_3704')

    @property
    def treePath(self) -> List[weakref.ReferenceType[Any]]:
        
        return self.__treePath

    @property
    @abc.abstractmethod
    def type(self) -> AttachmentType:
        
