from __future__ import annotations


__all__ = [
    'EmbeddedMsgAttachment',
]


import os
import pathlib
import zipfile

from typing import TYPE_CHECKING

from .. import constants
from .attachment_base import AttachmentBase
from ..enums import AttachmentType, SaveType
from ..open_msg import openMsg
from ..utils import createZipOpen, prepareFilename


if TYPE_CHECKING:
    from ..msg_classes import MSGFile
    from ..properties import PropertiesStore


_saveDoc = AttachmentBase.save.__doc__


class EmbeddedMsgAttachment(AttachmentBase):
    

    def __init__(self, msg: MSGFile, dir_: str, propStore: PropertiesStore):
        super().__init__(msg, dir_, propStore)
        self.__prefix = msg.prefixList + [dir_, '__substg1.0_3701000D']
        self.__data = openMsg(self.msg.path, prefix = self.__prefix, parentMsg = self.msg, treePath = self.treePath, **self.msg.kwargs)

    def getFilename(self, **kwargs) -> str:
        
        customFilename = kwargs.get('customFilename')
        if customFilename:
            customFilename = str(customFilename)
            
            
            if constants.re.INVALID_FILENAME_CHARS.search(customFilename):
                raise ValueError('Invalid character found in customFilename. Must not contain any of the following characters: \\/:*?"<>|')
            return customFilename
        else:
            return self.name

    def save(self, **kwargs) -> constants.SAVE_TYPE:
        
        
        if kwargs.get('skipEmbedded'):
            return (SaveType.NONE, None)

        
        if kwargs.get('extractEmbedded', False):
            
            filename = self.getFilename(**kwargs)

            
            
            filename = prepareFilename(filename)

            
            maxNameLength = kwargs.get('maxNameLength', 256)

            
            if len(filename) > maxNameLength:
                name, ext = os.path.splitext(filename)
                filename = name[:maxNameLength - len(ext)] + ext

            
            _zip = kwargs.get('zip')

            createdZip = False
            try:
                
                if _zip:
                    
                    if isinstance(_zip, (str, pathlib.Path)):
                        
                        _zip = zipfile.ZipFile(_zip, 'a', zipfile.ZIP_DEFLATED)
                        kwargs['zip'] = _zip
                        createdZip = True
                    
                    customPath = pathlib.Path(kwargs.get('customPath', ''))
                    
                    _open = createZipOpen(_zip.open)
                    
                    mode = 'w'
                else:
                    customPath = pathlib.Path(kwargs.get('customPath', '.')).absolute()
                    mode = 'wb'
                    _open = open

                fullFilename = self._handleFnc(_zip, filename, customPath, kwargs)

                with _open(str(fullFilename), mode) as f:
                    self.data.export(f)

                return (SaveType.FILE, str(fullFilename))
            finally:
                
                if _zip and createdZip:
                    _zip.close()
        else:
            
            
            return self.data.save(**kwargs)

    save.__doc__ = _saveDoc

    @property
    def data(self) -> MSGFile:
        
        return self.__data

    @property
    def type(self) -> AttachmentType:
        return AttachmentType.MSG