from __future__ import annotations


__all__ = [
    'CustomAttachment',
]


import os
import pathlib
import random
import string
import zipfile

from typing import Optional, TYPE_CHECKING

from .. import constants
from .attachment_base import AttachmentBase
from .custom_att_handler import CustomAttachmentHandler, getHandler
from ..enums import AttachmentType, SaveType
from ..utils import createZipOpen, inputToString, prepareFilename


if TYPE_CHECKING:
    from ..msg_classes import MSGFile
    from ..properties import PropertiesStore


_saveDoc = AttachmentBase.save.__doc__


class CustomAttachment(AttachmentBase):
    

    def __init__(self, msg: MSGFile, dir_: str, propStore: PropertiesStore):
        super().__init__(msg, dir_, propStore)

        self.__customHandler = getHandler(self)
        self.__data = self.__customHandler.data

    def getFilename(self, **kwargs) -> str:
        
        filename = None
        customFilename = kwargs.get('customFilename')
        if customFilename:
            customFilename = str(customFilename)
            
            
            if constants.re.INVALID_FILENAME_CHARS.search(customFilename):
                raise ValueError('Invalid character found in customFilename. Must not contain any of the following characters: \\/:*?"<>|')
            filename = customFilename
        else:
            
            
            if kwargs.get('contentId', False):
                filename = self.cid
            
            filename = self.customHandler.name
            
            if not filename:
                filename = self.name
            
            if not filename:
                return self.randomFilename

        return filename

    def regenerateRandomName(self) -> str:
        
        self.__randomName = 'UnknownFilename ' + \
                   ''.join(random.choice(string.ascii_uppercase + string.digits)
                           for _ in range(5)) + '.bin'

    def save(self, **kwargs) -> constants.SAVE_TYPE:
        
        if self.data is None:
            return (SaveType.NONE, None)

        
        filename = self.getFilename(**kwargs)

        
        
        filename = prepareFilename(inputToString(filename, self.msg.stringEncoding))

        
        maxNameLength = kwargs.get('maxNameLength', 256)

        
        if len(filename) > maxNameLength:
            name, ext = os.path.splitext(filename)
            filename = name[:maxNameLength - len(ext)] + ext

        
        _zip = kwargs.get('zip')

        createdZip = False
        try:
            
            if _zip:
                
                if isinstance(_zip, (str, pathlib.Path)):
                    
                    _zip = zipfile.ZipFile(_zip, 'a', zipfile.ZIP_DEFLATED)
                    kwargs['zip'] = _zip
                    createdZip = True
                
                customPath = pathlib.Path(kwargs.get('customPath', ''))
                
                _open = createZipOpen(_zip.open)
                
                mode = 'w'
            else:
                customPath = pathlib.Path(kwargs.get('customPath', '.')).absolute()
                mode = 'wb'
                _open = open

            fullFilename = self._handleFnc(_zip, filename, customPath, kwargs)

            with _open(str(fullFilename), mode) as f:
                f.write(self.__data)

            return (SaveType.FILE, str(fullFilename))
        finally:
            
            if _zip and createdZip:
                _zip.close()


    @property
    def customHandler(self) -> Optional[CustomAttachmentHandler]:
        
        return self.__customHandler

    @property
    def data(self) -> Optional[bytes]:
        
        return self.__data

    @property
    def randomFilename(self) -> str:
        
        try:
            return self.__randomName
        except AttributeError:
            self.regenerateRandomName()
            return self.__randomName

    @property
    def type(self) -> AttachmentType:
        return AttachmentType.CUSTOM
