from __future__ import annotations


__all__ = [
    'OutlookImageDIB',
]


import struct

from typing import Optional, TYPE_CHECKING

from . import registerHandler
from .custom_handler import CustomAttachmentHandler
from ...enums import DVAspect, ErrorBehavior, InsecureFeatures
from ...exceptions import DependencyError, SecurityError


if TYPE_CHECKING:
    from ..attachment_base import AttachmentBase

_ST_OLE = struct.Struct('<IIIII')
_ST_MAILSTREAM = struct.Struct('<III')


class OutlookImageDIB(CustomAttachmentHandler):
    

    def __init__(self, attachment: AttachmentBase):
        super().__init__(attachment)
        
        self.__data = self.getStream('CONTENTS')
        if not self.__data:
            raise ValueError('Bitmap data could not be read for Outlook signature.')

        
        stream = self.getStream('\x03MailStream')
        if stream:
            if len(stream) != 12:
                raise ValueError('MailStream is the wrong length.')
            
            
            vals = _ST_MAILSTREAM.unpack(stream)
            self.__dvaspect = DVAspect(vals[0])
            self.__x = vals[1]
            self.__y = vals[2]
        else:
            
            
            self.__dvaspect = DVAspect.CONTENT
            
            
            self.__x = 0
            self.__y = 0

        
        
        self.__xtwips = int(round(self.__x / 1.7639))
        self.__ytwips = int(round(self.__y / 1.7639))

        
        if ErrorBehavior.CUSTOM_ATTACH_TOLERANT not in attachment.msg.errorBehavior:
            
            oleStream = self.getStream('\x01Ole')
            if oleStream:
                
                
                
                if len(oleStream) < 20:
                    raise ValueError('OLE stream is too short.')
                
                vals = _ST_OLE.unpack(oleStream[:20])
                
                if vals[0] != 0x2000001:
                    raise ValueError('OLE stream has wrong version magic.')
                
                if vals[3] != 0:
                    raise ValueError('OLE stream has non-zero reserved int.')
            else:
                
                
                
                pass

    @classmethod
    def isCorrectHandler(cls, attachment: AttachmentBase) -> bool:
        if attachment.clsid != '00000316-0000-0000-C000-000000000046':
            return False

        
        if not attachment.exists('__substg1.0_3701000D/CONTENTS'):
            return False
        
        
        
        
        
        

        return True

    def generateRtf(self) -> Optional[bytes]:
        
        if InsecureFeatures.PIL_IMAGE_PARSING not in self.attachment.msg.insecureFeatures:
            raise SecurityError('Generating the RTF for a custom attachment requires the insecure feature PIL_IMAGE_PARSING.')

        try:
            import PIL.Image
        except ImportError:
            raise DependencyError('PIL or Pillow is required for inserting an Outlook Image into the body.')

        
        
        import io

        
        
        with PIL.Image.open(io.BytesIO(self.data)) as img:
            out = io.BytesIO()
            img.save(out, 'PNG')

        hexData = out.getvalue().hex()

        inject = '{\\*\\shppict\n{\\pict\\picscalex100\\picscaley100'
        inject += f'\\picw{img.width}\\pich{img.height}'
        inject += f'\\picwgoal{self.__xtwips}\\pichgoal{self.__ytwips}\n'
        inject += '\\pngblip ' + hexData + '}}'

        return inject.encode()

    @property
    def data(self) -> bytes:
        return self.__data

    @property
    def name(self) -> str:
        
        
        if not (name := self.attachment.name):
            name = f'attachment {int(self.attachment.dir[-8:], 16)}'
        return name + '.bmp'

    @property
    def obj(self) -> bytes:
        return self.data



registerHandler(OutlookImageDIB)
