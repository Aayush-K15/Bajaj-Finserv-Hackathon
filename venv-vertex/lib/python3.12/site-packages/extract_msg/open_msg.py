from __future__ import annotations


__all__ = [
    'openMsg',
    'openMsgBulk',
]


import glob
import logging

from typing import List, Optional, Tuple, TYPE_CHECKING, Union

from . import constants
from .exceptions import (
        InvalidFileFormatError, UnrecognizedMSGTypeError,
        UnsupportedMSGTypeError
    )


logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

if TYPE_CHECKING:
    from .msg_classes import MSGFile


def _getMsgClassInfo(classType: str) -> Tuple[bool, Optional[str]]:
    
    classType = classType.lower()
    if classType == 'ipm':
        return (True, None)

    for item in constants.KNOWN_CLASS_TYPES:
        if classType.startswith(item):
            
            for tup in constants.REFUSED_CLASS_TYPES:
                if tup[0] == item:
                    return (True, tup[1])
            else:
                return (True, None)

    return (False, None)


def openMsg(path, **kwargs) -> MSGFile:
    
    from .msg_classes import (
            AppointmentMeeting, Contact, Journal, MeetingCancellation,
            MeetingException, MeetingForwardNotification, MeetingRequest,
            MeetingResponse, Message, MSGFile, MessageSigned, Post, StickyNote,
            Task, TaskRequest
        )

    
    
    
    
    
    
    delayAttachments = kwargs.get('delayAttachments', False)
    kwargs['delayAttachments'] = True

    msg = MSGFile(path, **kwargs)

    
    try:
        ct = msg.classType
    except:
        
        msg.close()
        raise

    
    kwargs['delayAttachments'] = delayAttachments

    
    
    
    
    
    
    
    if not ct:
        if kwargs.get('strict', True):
            raise InvalidFileFormatError('File was confirmed to be an olefile, but was not an MSG file.')
        else:
            
            logger.critical('Received file that was an olefile but was not an MSG file. Returning MSGFile anyways because strict mode is off.')
            return msg
    classType = ct.lower()
    
    if classType.startswith('ipm.note') or classType.startswith('report') or classType.startswith('ipm.skypeteams.message'):
        msg.close()
        if classType.endswith('smime.multipartsigned') or classType.endswith('smime'):
            return MessageSigned(path, **kwargs)
        else:
            return Message(path, **kwargs)
    elif classType.startswith('ipm.activity'):
        msg.close()
        return Journal(path, **kwargs)
    elif classType.startswith('ipm.appointment'):
        msg.close()
        return AppointmentMeeting(path, **kwargs)
    elif classType.startswith('ipm.contact') or classType.startswith('ipm.distlist'):
        msg.close()
        return Contact(path, **kwargs)
    elif classType.startswith('ipm.post'):
        msg.close()
        return Post(path, **kwargs)
    elif classType.startswith('ipm.schedule.meeting.request'):
        msg.close()
        return MeetingRequest(path, **kwargs)
    elif classType.startswith('ipm.schedule.meeting.canceled'):
        msg.close()
        return MeetingCancellation(path, **kwargs)
    elif classType.startswith('ipm.schedule.meeting.notification.forward'):
        msg.close()
        return MeetingForwardNotification(path, **kwargs)
    elif classType.startswith('ipm.schedule.meeting.resp'):
        msg.close()
        return MeetingResponse(path, **kwargs)
    elif classType.startswith('ipm.stickynote'):
        msg.close()
        return StickyNote(path, **kwargs)
    elif classType.startswith('ipm.taskrequest'):
        msg.close()
        return TaskRequest(path, **kwargs)
    elif classType.startswith('ipm.task'):
        msg.close()
        return Task(path, **kwargs)
    elif classType.startswith('ipm.ole.class.{00061055-0000-0000-c000-000000000046}'):
        
        msg.close()
        return MeetingException(path, **kwargs)
    elif classType == 'ipm':
        
        
        if not delayAttachments:
            msg.attachments
        return msg
    elif kwargs.get('strict', True):
        
        msg.close()
        
        
        if (info := _getMsgClassInfo(classType))[0]:
            if info[1]:
                raise UnsupportedMSGTypeError(f'Support for MSG type "{ct}" has been refused. See {constants.REPOSITORY_URL}/issues/{info[1]} for more information.')
            raise UnsupportedMSGTypeError(f'MSG type "{ct}" currently is not supported by the module. If you would like support, please make a feature request.')
        raise UnrecognizedMSGTypeError(f'Could not recognize MSG class type "{ct}". As such, there is a high chance that support may be impossible, but you should contact the developers to find out more.')
    else:
        if (info := _getMsgClassInfo(classType))[0]:
            if info[1]:
                logger.error(f'Support for MSG type "{msg.classType}" has been refused. See {constants.REPOSITORY_URL}/issues/{info[1]} for more information.')
            else:
                logger.error(f'MSG type "{msg.classType}" currently is not supported by the module. If you would like support, please make a feature request.')
        logger.error(f'Could not recognize MSG class type "{msg.classType}". As such, there is a high chance that support may be impossible, but you should contact the developers to find out more.')
        if not delayAttachments:
            msg.attachments
        return msg


def openMsgBulk(path, **kwargs) -> Union[List[MSGFile], Tuple[Exception, Union[str, bytes]]]:
    
    files = []
    for x in glob.glob(str(path)):
        try:
            files.append(openMsg(x, **kwargs))
        except Exception as e:
            if not kwargs.get('ignoreFailures', False):
                for msg in files:
                    msg.close()
                return (e, x)

    return files