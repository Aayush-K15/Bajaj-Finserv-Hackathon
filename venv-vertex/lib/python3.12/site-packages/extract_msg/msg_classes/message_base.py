__all__ = [
    'MessageBase',
]


import base64
import datetime
import email.message
import email.utils
import enum
import functools
import html
import json
import logging
import os
import pathlib
import re
import subprocess
import zipfile

import bs4
import compressed_rtf
import RTFDE
import RTFDE.exceptions

from email import policy
from email.charset import Charset, QP
from email.message import EmailMessage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.parser import HeaderParser
from typing import Any, Callable, cast, Dict, List, Optional, Tuple, Type, Union

from .. import constants
from .._rtf.create_doc import createDocument
from .._rtf.inject_rtf import injectStartRTF
from ..enums import (
        BodyTypes, DeencapType, ErrorBehavior, RecipientType, SaveType
    )
from ..exceptions import (
        ConversionError, DataNotFoundError, DeencapMalformedData,
        DeencapNotEncapsulated, IncompatibleOptionsError, MimetypeFailureError,
        WKError
    )
from .msg import MSGFile
from ..structures.report_tag import ReportTag
from ..recipient import Recipient
from ..utils import (
        addNumToDir, addNumToZipDir, createZipOpen, decodeRfc2047, findWk,
        htmlSanitize, inputToBytes, inputToString, isEncapsulatedRtf,
        prepareFilename, rtfSanitizeHtml, rtfSanitizePlain, stripRtf,
        validateHtml
    )


logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())


class MessageBase(MSGFile):
    

    def __init__(self, path, **kwargs):
        
        super().__init__(path, **kwargs)
        
        
        try:
            self.__headerInit = False
            self.__recipientSeparator: str = kwargs.get('recipientSeparator', ';')
            self.__deencap = kwargs.get('deencapsulationFunc')
            self.header

            
            self._crlf = '\n'
            try:
                self.body
            except Exception as e:
                
                logger.exception('Critical error accessing the body. File opened but accessing the body will throw an exception.')
            self._htmlEncoding = None
        except:
            try:
                self.close()
            except:
                pass
            raise

    def _genRecipient(self, recipientStr: str, recipientType: RecipientType) -> Optional[str]:
        
        value = None
        
        if self.headerInit:
            value = cast(Optional[str], self.header[recipientStr])
            if value:
                value = decodeRfc2047(value)
                value = value.replace(',', self.__recipientSeparator)

        
        
        if not value:
            
            if self.headerInit:
                logger.info(f'Header found, but "{recipientStr}" is not included. Will be generated from other streams.')

            
            foundRecipients = tuple(recipient.formatted for recipient in self.recipients if recipient.type is recipientType)

            
            
            if len(foundRecipients) > 0:
                value = (self.__recipientSeparator + ' ').join(foundRecipients)

        
        
        
        
        if value:
            value = value.replace(' \r\n\t', ' ').replace('\r\n\t ', ' ').replace('\r\n\t', ' ')
            value = value.replace('\r\n', ' ').replace('\r', ' ').replace('\n', ' ')
            while value.find('  ') != -1:
                value = value.replace('  ', ' ')

        return value

    def _getHtmlEncoding(self, soup: bs4.BeautifulSoup) -> None:
        
        if not self._htmlEncoding:
            try:
                self._htmlEncoding = cast(Optional[str], soup.original_encoding or soup.declared_html_encoding)
            except AttributeError:
                pass

    def asEmailMessage(self) -> EmailMessage:
        
        ret = EmailMessage()

        
        for key, value in self.header.items():
            if key.lower() != 'content-type':
                ret[key] = value.replace('\r\n', '').replace('\n', '')

        ret['Content-Type'] = 'multipart/mixed'

        
        msgMain = MIMEMultipart('related')
        ret.attach(msgMain)
        bodyParts = MIMEMultipart('alternative')
        msgMain.attach(bodyParts)

        c = Charset('utf-8')
        c.body_encoding = QP

        if self.body:
            bodyParts.attach(MIMEText(self.body, 'plain', c))
        if self.htmlBody:
            bodyParts.attach(MIMEText(self.htmlBody.decode('utf-8'), 'html', c))

        
        for att in self.attachments:
            if att.dataType:
                if hasattr(att.dataType, 'asEmailMessage'):
                    
                    filename = att.name or ''
                    if filename.lower().endswith('.msg'):
                        filename = filename[:-4] + '.eml'
                    msgMain.attach(att.data.asEmailMessage())
                else:
                    if issubclass(att.dataType, bytes):
                        data = att.data
                    elif issubclass(att.dataType, MSGFile):
                        if hasattr(att.dataType, 'asBytes'):
                            data = att.asBytes
                        else:
                            data = att.data.exportBytes()
                    else:
                        raise ConversionError(f'Could not find a suitable method to attach attachment data type "{att.dataType}".')
                    mime = att.mimetype or 'application/octet-stream'
                    mainType, subType = mime.split('/')[0], mime.split('/')[-1]
                    
                    attachment = EmailMessage()
                    attachment.set_content(data,
                                           maintype = mainType,
                                           subtype = subType,
                                           cid = att.contentId)
                    
                    attachment['Content-Disposition'] = f'{"inline" if att.hidden else "attachment"}; filename="{att.getFilename()}"'

                    
                    msgMain.attach(attachment)

        return ret

    def deencapsulateBody(self, rtfBody: bytes, bodyType: DeencapType) -> Optional[Union[bytes, str]]:
        
        if rtfBody:
            bodyType = DeencapType(bodyType)
            if bodyType == DeencapType.PLAIN:
                if self.__deencap:
                    try:
                        return self.__deencap(rtfBody, DeencapType.PLAIN)
                    except DeencapMalformedData:
                        logger.exception('Custom deencapsulation function reported encapsulated data was malformed.')
                    except DeencapNotEncapsulated:
                        logger.exception('Custom deencapsulation function reported data is not encapsulated.')
                else:
                    if self.deencapsulatedRtf and self.deencapsulatedRtf.content_type == 'text':
                        return self.deencapsulatedRtf.text
            else:
                if self.__deencap:
                    try:
                        return self.__deencap(rtfBody, DeencapType.HTML)
                    except DeencapMalformedData:
                        logger.exception('Custom deencapsulation function reported encapsulated data was malformed.')
                    except DeencapNotEncapsulated:
                        logger.exception('Custom deencapsulation function reported data is not encapsulated.')
                else:
                    if self.deencapsulatedRtf and self.deencapsulatedRtf.content_type == 'html':
                        return self.deencapsulatedRtf.html

            if bodyType == DeencapType.PLAIN:
                logger.info('Could not deencapsulate plain text from RTF body.')
            else:
                logger.info('Could not deencapsulate HTML from RTF body.')
        else:
            logger.info('No RTF body to deencapsulate from.')
        return None

    def dump(self) -> None:
        
        print('Message')
        print('Subject:', self.subject)
        if self.date:
            print('Date:', self.date.__format__(self.datetimeFormat))
        print('Body:')
        print(self.body)

    def getInjectableHeader(self, prefix: str, joinStr: str, suffix: str, formatter: Callable[[str, str], str]) -> str:
        
        allProps = self.headerFormatProperties

        if allProps is None:
            return ''

        formattedProps = []

        for entry in allProps:
            isGroup = False
            entryUsed = False
            
            if isinstance(allProps[entry], dict):
                props = allProps[entry]
                isGroup = True
            else:
                props = {entry: allProps[entry]}

            for name in props:
                if props[name]:
                    if isinstance(props[name], tuple):
                        if props[name][1]:
                            value = props[name][0] or ''
                        elif props[name][0] is not None:
                            value = props[name][0]
                        else:
                            continue
                    else:
                        value = props[name]

                    entryUsed = True
                    formattedProps.append(formatter(name, value))

            
            
            
            if isGroup and entryUsed:
                formattedProps.append('')

        
        
        if formattedProps[-1] == '':
            formattedProps.pop()

        return prefix + joinStr.join(formattedProps) + suffix

    def getJson(self) -> str:
        
        return json.dumps({
            'from': self.sender,
            'to': self.to,
            'cc': self.cc,
            'bcc': self.bcc,
            'subject': self.subject,
            'date': self.date.__format__(self.datetimeFormat) if self.date else None,
            'body': self.body,
        })

    def getSaveBody(self, **_) -> bytes:
        
        
        crlf = inputToString(self.crlf, 'utf-8')

        prefix = ''
        suffix = crlf + '-----------------' + crlf + crlf
        joinStr = crlf
        formatter = (lambda name, value: f'{name}: {value}')

        header = self.getInjectableHeader(prefix, joinStr, suffix, formatter).encode('utf-8')
        return header + inputToBytes(self.body, 'utf-8')

    def getSaveHtmlBody(self, preparedHtml: bool = False, charset: str = 'utf-8', **_) -> bytes:
        
        if self.htmlBody:
            
            data = self.injectHtmlHeader(prepared = preparedHtml)

            
            if preparedHtml and charset:
                bs = bs4.BeautifulSoup(data, features = 'html.parser', from_encoding = self._htmlEncoding)
                self._getHtmlEncoding(bs)
                if not bs.find('meta', {'http-equiv': 'Content-Type'}):
                    
                    tagAttrs = {
                        'http-equiv': 'Content-Type',
                        'content': f'text/html; charset={charset}',
                    }
                    
                    tag = bs4.Tag(parser = bs, name = 'meta', attrs = tagAttrs, can_be_empty_element = True)
                    
                    if bs.find('head'):
                        bs.find('head').insert(0, tag)
                    else:
                        
                        
                        if bs.find('html'):
                            
                            head = bs4.Tag(parser = bs, name = 'head')
                            head.insert(0, tag)
                            bs.find('html').insert(0, head)

                    data = bs.encode('utf-8')

            return data
        else:
            return self.htmlBody or b''

    def getSavePdfBody(self, wkPath = None, wkOptions = None, **kwargs) -> bytes:
        
        
        wkPath = findWk(wkPath)

        
        if wkOptions:
            try:
                
                
                parsedWkOptions = [*wkOptions]
            except TypeError:
                raise TypeError(f':param wkOptions: must be an iterable, not {type(wkOptions)}.')
        else:
            parsedWkOptions = []

        
        
        if not all(isinstance(option, (str, bytes)) for option in parsedWkOptions):
            raise TypeError(':param wkOptions: must be an iterable of strings and bytes.')

        processArgs = [wkPath, *parsedWkOptions, '-', '-']
        
        logger.info(f'Converting to PDF with the following arguments: {processArgs}')

        
        htmlBody = self.getSaveHtmlBody(**kwargs)

        
        
        
        
        process = subprocess.run(processArgs, input = htmlBody, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
        
        

        
        if process.returncode != 0:
            raise WKError(process.stderr.decode('utf-8'))

        return process.stdout

    def getSaveRtfBody(self, **_) -> bytes:
        
        
        return self.injectRtfHeader()

    def injectHtmlHeader(self, prepared: bool = False) -> bytes:
        
        if not self.htmlBody:
            raise AttributeError('Cannot inject the HTML header without an HTML body attribute.')

        body = None

        
        if prepared:
            body = self.htmlBodyPrepared

            
            if not body:
                raise AttributeError('Cannot find a prepared HTML body to inject into.')
        else:
            body = self.htmlBody

        
        if not validateHtml(body, self._htmlEncoding):
            logger.warning('HTML body failed to validate. Code will attempt to correct it.')

            
            
            
            
            
            
            
            parser = bs4.BeautifulSoup(body, features = 'html.parser', from_encoding = self._htmlEncoding)
            self._getHtmlEncoding(parser)
            if not parser.find('html') and not parser.find('body'):
                if parser.find('head') or parser.find('footer'):
                    
                    correctedHtml = bs4.BeautifulSoup(b'<html></html>', features = 'html.parser')
                    htmlTag = correctedHtml.find('html')

                    
                    
                    bodyTag = parser.new_tag('body')
                    
                    
                    
                    
                    for tag in tuple(parser.children):
                        if tag.name.lower() in ('head', 'footer'):
                            correctedHtml.append(tag)
                        else:
                            bodyTag.append(tag)

                    
                    
                    if correctedHtml.find('head'):
                        correctedHtml.find('head').insert_after(bodyTag)
                    elif correctedHtml.find('footer'):
                        correctedHtml.find('footer').insert_before(bodyTag)
                    else:
                        
                        
                        htmlTag.append(bodyTag)
                else:
                    
                    
                    
                    body = b'<html><body>' + body + b'</body></html>'
            elif parser.find('html'):
                
                
                
                bodyTag = parser.new_tag('body')
                
                
                
                
                for tag in tuple(parser.find('html').children):
                    if tag.name and tag.name.lower() not in ('head', 'footer'):
                        bodyTag.append(tag)

                
                
                if parser.find('head'):
                    parser.find('head').insert_after(bodyTag)
                elif parser.find('footer'):
                    parser.find('footer').insert_before(bodyTag)
                else:
                    parser.find('html').insert(0, bodyTag)
            else:
                
                
                body = b'<html>' + body + b'</html>'

        def replace(bodyMarker):
            
            
            
            
            
            
            
            return bodyMarker.group() + self.htmlInjectableHeader.encode('utf-8')

        
        return constants.re.HTML_BODY_START.sub(replace, body, 1)

    def injectRtfHeader(self) -> bytes:
        
        if not self.rtfBody:
            raise AttributeError('Cannot inject the RTF header without an RTF body attribute.')

        
        
        if isEncapsulatedRtf(self.rtfBody):
            injectableHeader = self.rtfEncapInjectableHeader
        else:
            injectableHeader = self.rtfPlainInjectableHeader

        def replace(bodyMarker):
            
            return bodyMarker.group() + injectableHeader

        
        
        if isEncapsulatedRtf(self.rtfBody):
            data = constants.re.RTF_ENC_BODY_START.sub(replace, self.rtfBody, 1)
            if data != self.rtfBody:
                logger.debug('Successfully injected RTF header using encapsulation method.')
                return data
            logger.debug('RTF has encapsulated HTML, but injection method failed. It is likely dirty. Will use normal RTF injection method.')

        
        
        logger.debug('Using _rtf module to inject RTF text header.')
        return createDocument(injectStartRTF(self.rtfBody, injectableHeader))

    def save(self, **kwargs) -> constants.SAVE_TYPE:
        
        
        _json = kwargs.get('json', False)
        html = kwargs.get('html', False)
        rtf = kwargs.get('rtf', False)
        raw = kwargs.get('raw', False)
        pdf = kwargs.get('pdf', False)
        allowFallback = kwargs.get('allowFallback', False)
        _zip = kwargs.get('zip')
        maxNameLength = kwargs.get('maxNameLength', 256)

        
        customFilename = kwargs.get('customFilename')
        useMsgFilename = kwargs.get('useMsgFilename', False)
        

        
        attachOnly = kwargs.get('attachmentsOnly', False)
        
        skipAttachments = kwargs.get('skipAttachments', False)
        skipHidden = kwargs.get('skipHidden', False)
        
        
        skipBodyNotFound = kwargs.get('skipBodyNotFound', False)

        if pdf:
            kwargs['preparedHtml'] = True

        
        if not attachOnly:
            
            fext = 'json' if _json else 'txt'

            fallbackToPlain = False
            useHtml = False
            usePdf = False
            useRtf = False
            if html:
                if self.htmlBody:
                    useHtml = True
                    fext = 'html'
                elif not allowFallback:
                    if skipBodyNotFound:
                        fext = None
                    else:
                        raise DataNotFoundError('Could not find the htmlBody.')

            if pdf:
                if self.htmlBody:
                    usePdf = True
                    fext = 'pdf'
                elif not allowFallback:
                    if skipBodyNotFound:
                        fext = None
                    else:
                        raise DataNotFoundError('Count not find the htmlBody to convert to pdf.')

            if rtf or (html and not useHtml) or (pdf and not usePdf):
                if self.rtfBody:
                    useRtf = True
                    fext = 'rtf'
                elif not allowFallback:
                    if skipBodyNotFound:
                        fext = None
                    else:
                        raise DataNotFoundError('Could not find the rtfBody.')
                else:
                    
                    
                    fallbackToPlain = True

            
            
            if not (rtf or html or pdf) or fallbackToPlain:
                
                
                
                if self.body is None:
                    if skipBodyNotFound:
                        fext = None
                    else:
                        if allowFallback:
                            raise DataNotFoundError('Could not find a valid body using current options.')
                        else:
                            raise DataNotFoundError('Plain text body could not be found.')

        createdZip = False
        try:
            
            if _zip:
                
                if raw:
                    raise IncompatibleOptionsError('The options `raw` and `zip` are incompatible.')
                
                
                if isinstance(_zip, (str, pathlib.Path)):
                    
                    _zip = zipfile.ZipFile(_zip, 'a', zipfile.ZIP_DEFLATED)
                    kwargs['zip'] = _zip
                    createdZip = True
                
                
                path = pathlib.Path(kwargs.get('customPath', ''))
                
                _open = createZipOpen(_zip.open)
                
                mode = 'w'
            else:
                path = pathlib.Path(kwargs.get('customPath', '.')).absolute()
                mode = 'wb'
                _open = open

            
            kwargs['customFilename'] = None

            
            if _json + html + rtf + raw + attachOnly + pdf > 1:
                raise IncompatibleOptionsError('Only one of the following options may be used at a time: json, raw, html, rtf, attachmentsOnly, pdf.')

            
            

            if customFilename:
                
                
                if constants.re.INVALID_FILENAME_CHARS.search(customFilename):
                    raise ValueError('Invalid character found in customFilename. Must not contain any of the following characters: \\/:*?"<>|')
                
                
                customFilename = customFilename.strip()
                path /= customFilename[:maxNameLength]
            elif useMsgFilename:
                if not self.filename:
                    raise ValueError(':param useMsgFilename: is only available if you are using an MSG file on the disk or have provided a filename.')
                
                filename = os.path.split(self.filename)[1]
                
                filename = os.path.splitext(filename)[0]
                
                filename = prepareFilename(filename)
                
                filename = filename[:maxNameLength]
                
                if not filename:
                    raise ValueError(f'Invalid filename found in self.filename: "{self.filename}"')

                
                path /= filename[:maxNameLength]
            else:
                path /= self.defaultFolderName[:maxNameLength]

            
            if not _zip:
                try:
                    os.makedirs(path)
                except Exception:
                    newDirName = addNumToDir(path)
                    if newDirName:
                        path = newDirName
                    else:
                        raise OSError(f'Failed to create directory "{path}". Does it already exist?')
            else:
                
                
                pathCompare = str(path).replace('\\', '/').rstrip('/') + '/'
                if any(x.startswith(pathCompare) for x in _zip.namelist()):
                    newDirName = addNumToZipDir(path, _zip)
                    if newDirName:
                        path = newDirName
                    else:
                        raise Exception(f'Failed to create directory "{path}". Does it already exist?')

            
            kwargs['customPath'] = path

            if raw:
                self.saveRaw(path)
                return (SaveType.FOLDER, str(path))

            
            if kwargs.get('saveHeader', False):
                headerText = self.headerText
                if not headerText:
                    headerText = constants.HEADER_FORMAT.format(subject = self.subject, **self.header)

                with _open(str(path / 'header.txt'), mode) as f:
                    f.write(headerText.encode('utf-8'))


            if not skipAttachments:
                
                attachmentReturns = [attachment.save(**kwargs) for attachment in self.attachments if not (skipHidden and attachment.hidden)]
                
                attachmentNames = []
                for x in attachmentReturns:
                    if isinstance(x[1], str):
                        attachmentNames.append(x[1])
                    elif isinstance(x[1], list):
                        attachmentNames.extend(x[1])

            if not attachOnly and fext:
                with _open(str(path / ('message.' + fext)), mode) as f:
                    if _json:
                        emailObj = json.loads(self.getJson())
                        if not skipAttachments:
                            emailObj['attachments'] = attachmentNames

                        f.write(json.dumps(emailObj).encode('utf-8'))
                    elif useHtml:
                        f.write(self.getSaveHtmlBody(**kwargs))
                    elif usePdf:
                        f.write(self.getSavePdfBody(**kwargs))
                    elif useRtf:
                        f.write(self.getSaveRtfBody(**kwargs))
                    else:
                        f.write(self.getSaveBody(**kwargs))

            return (SaveType.FOLDER, str(path))
        finally:
            
            if _zip and createdZip:
                _zip.close()

    @functools.cached_property
    def bcc(self) -> Optional[str]:
        
        return self._genRecipient('bcc', RecipientType.BCC)

    @functools.cached_property
    def body(self) -> Optional[str]:
        
        
        if (body := self.getStringStream('__substg1.0_1000')) is not None:
            pass
        elif self.rtfBody:
            
            
            body = self.deencapsulateBody(self.rtfBody, DeencapType.PLAIN)

        if body:
            body = inputToString(body, 'utf-8')
            if re.search('\n', body) is not None:
                if re.search('\r\n', body) is not None:
                    self._crlf = '\r\n'

        return body

    @functools.cached_property
    def cc(self) -> Optional[str]:
        
        return self._genRecipient('cc', RecipientType.CC)

    @functools.cached_property
    def compressedRtf(self) -> Optional[bytes]:
        
        return self.getStream('__substg1.0_10090102')

    @property
    def crlf(self) -> str:
        
        return self._crlf

    @functools.cached_property
    def date(self) -> Optional[datetime.datetime]:
        
        return self.props.date if self.isSent else None

    @functools.cached_property
    def deencapsulatedRtf(self) -> Optional[RTFDE.DeEncapsulator]:
        
        if self.rtfBody:
            
            body = self.rtfBody
            
            
            
            while body and body[-1] != 125:
                body = body[:-1]

            
            
            
            body = stripRtf(body)

            try:
                deencapsultor = RTFDE.DeEncapsulator(body)
                deencapsultor.deencapsulate()
                return deencapsultor
            except RTFDE.exceptions.NotEncapsulatedRtf:
                logger.debug('RTF body is not encapsulated.')
            except RTFDE.exceptions.MalformedEncapsulatedRtf:
                if ErrorBehavior.RTFDE_MALFORMED not in self.errorBehavior:
                    raise
                logger.info('RTF body contains malformed encapsulated content.')
            except Exception:
                
                
                if ErrorBehavior.RTFDE_UNKNOWN_ERROR not in self.errorBehavior:
                    raise
                logger.exception('Unhandled error happened while using RTFDE. You have choosen to ignore these errors.')
        return None

    @property
    def defaultFolderName(self) -> str:
        
        try:
            return self._defaultFolderName
        except AttributeError:
            d = self.parsedDate or tuple([0] * 9)

            dirName = '{0:02d}-{1:02d}-{2:02d}_{3:02d}{4:02d}'.format(*d) if d else 'UnknownDate'
            dirName += ' ' + (prepareFilename(self.subject) if self.subject else '[No subject]')
            dirName = dirName.strip()

            self._defaultFolderName = dirName
            return dirName

    @functools.cached_property
    def detectedBodies(self) -> BodyTypes:
        
        bodies = BodyTypes.NONE
        if self.sExists('__substg1.0_1000'):
            bodies |= BodyTypes.PLAIN
        if self.exists('__substg1.0_10090102'):
            bodies |= BodyTypes.RTF
        if self.exists('__substg1.0_10130102'):
            bodies |= BodyTypes.HTML

        return bodies

    @functools.cached_property
    def header(self) -> email.message.Message:
        
        headerText = self.headerText
        if headerText:
            
            if headerText.startswith('Microsoft Mail Internet Headers Version 2.0'):
                headerText = headerText[43:].lstrip()
            header = HeaderParser(policy = policy.compat32).parsestr(headerText)
        else:
            logger.info('Header is empty or was not found. Header will be generated from other streams.')
            header = HeaderParser(policy = policy.compat32).parsestr('')
            if self.date:
                header.add_header('Date', email.utils.format_datetime(self.date))
            header.add_header('From', self.sender)
            header.add_header('To', self.to)
            header.add_header('Cc', self.cc)
            header.add_header('Bcc', self.bcc)
            header.add_header('Message-Id', self.messageId)
            
            header.add_header('Authentication-Results', None)

        self.__headerInit = True
        return header

    @functools.cached_property
    def headerDict(self) -> Dict[str, Any]:
        
        headerDict = {x: self.header[x] for x in self.header}
        try:
            headerDict.pop('Received')
        except KeyError:
            pass
        return headerDict

    @property
    def headerFormatProperties(self) -> constants.HEADER_FORMAT_TYPE:
        
        
        
        
        
        return {
            '-basic info-': {
                'From': self.sender,
                'Sent': self.date.__format__(self.datetimeFormat) if self.date else None,
                'To': self.to,
                'Cc': self.cc,
                'Bcc': self.bcc,
                'Subject': self.subject,
            },
            '-importance-': {
                'Importance': self.importanceString,
            },
        }

    @property
    def headerInit(self) -> bool:
        
        return self.__headerInit

    @functools.cached_property
    def headerText(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_007D')

    @functools.cached_property
    def htmlBody(self) -> Optional[bytes]:
        
        if (htmlBody := self.getStream('__substg1.0_10130102')) is not None:
            pass
        elif self.rtfBody:
            logger.info('HTML body was not found, attempting to generate from RTF.')
            htmlBody = cast(bytes, self.deencapsulateBody(self.rtfBody, DeencapType.HTML))
        
        
        if not htmlBody and self.body:
            
            logger.info('HTML body was not found, attempting to generate from plain text body.')
            correctedBody = html.escape(self.body).replace('\r', '').replace('\n', '<br />')
            htmlBody = f'<html><body>{correctedBody}</body></head>'.encode('ascii', 'xmlcharrefreplace')

        if not htmlBody:
            logger.info('HTML body could not be found nor generated.')

        return htmlBody

    @functools.cached_property
    def htmlBodyPrepared(self) -> Optional[bytes]:
        
        
        if not self.htmlBody:
            return self.htmlBody

        
        soup = bs4.BeautifulSoup(self.htmlBody, 'html.parser', from_encoding = self._htmlEncoding)
        self._getHtmlEncoding(soup)

        
        
        
        tags = (tag for tag in soup.findAll('img') if tag.get('src') and tag.get('src').startswith('cid:'))

        for tag in tags:
            
            cid = tag['src'][4:]
            att = next((attachment for attachment in self.attachments if hasattr(attachment, 'cid') and attachment.cid == cid), None)
            
            if att and isinstance(att.data, bytes):
                
                
                mime = att.mimetype
                if not mime:
                    ext = (att.name or '').split('.')[-1].lower()
                    if ext == 'png':
                        mime = 'image/png'
                    elif ext == 'jpg' or ext == 'jpeg':
                        mime = 'image/jpeg'
                    elif ext == 'gif':
                        mime = 'image/gif'
                    elif ext == 'tiff' or ext == 'tif':
                        mime = 'image/tif'
                    elif ext == 'bmp':
                        mime = 'image/bmp'
                    elif ext == 'svg':
                        mime = 'image/svg+xml'
                
                if mime:
                    tag['src'] = (b'data:' + mime.encode() + b';base64,' + base64.b64encode(att.data)).decode('utf-8')
                else:
                    
                    
                    raise MimetypeFailureError('Could not get the mimetype to use for htmlBodyPrepared.')

        return soup.encode('utf-8')

    @functools.cached_property
    def htmlInjectableHeader(self) -> str:
        
        prefix = '<div id="injectedHeader"><div><p class="MsoNormal">'
        suffix = '<o:p></o:p></p></div></div>'
        joinStr = '<br/>'
        formatter = (lambda name, value: f'<b>{name}:</b>&nbsp;{inputToString(htmlSanitize(value), self.stringEncoding).encode("ascii", "xmlcharrefreplace").decode()}')

        return self.getInjectableHeader(prefix, joinStr, suffix, formatter)

    @functools.cached_property
    def inReplyTo(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_1042')

    @functools.cached_property
    def isRead(self) -> bool:
        
        return bool(self.getPropertyVal('0E070003', 0) & 1)

    @functools.cached_property
    def isSent(self) -> bool:
        
        return not bool(self.getPropertyVal('0E070003', 0) & 8)

    @functools.cached_property
    def messageId(self) -> Optional[str]:
        headerResult = None
        if self.headerInit:
            headerResult = self.header['message-id']
        if headerResult is not None:
            return headerResult

        if self.headerInit:
            logger.info('Header found, but "Message-Id" is not included. Will be generated from other streams.')
        return self.getStringStream('__substg1.0_1035')

    @functools.cached_property
    def parsedDate(self) -> Optional[Tuple[int, int, int, int, int, int, int, int, int]]:
        
        return email.utils.parsedate(self.header['Date'])

    @functools.cached_property
    def receivedTime(self) -> Optional[datetime.datetime]:
        
        return self.getPropertyVal('0E060040')

    @property
    def recipientSeparator(self) -> str:
        return self.__recipientSeparator

    @functools.cached_property
    def recipients(self) -> List[Recipient]:
        
        recipientDirs = []
        prefixLen = self.prefixLen
        for dir_ in self.listDir():
            if dir_[prefixLen].startswith('__recip') and\
                    dir_[prefixLen] not in recipientDirs:
                recipientDirs.append(dir_[prefixLen])

        return [Recipient(recipientDir, self, self.recipientTypeClass) for recipientDir in recipientDirs]

    @property
    def recipientTypeClass(self) -> Type[enum.IntEnum]:
        
        return RecipientType

    @functools.cached_property
    def reportTag(self) -> Optional[ReportTag]:
        
        return self.getStreamAs('__substg1.0_00310102', ReportTag)

    @functools.cached_property
    def responseRequested(self) -> bool:
        
        return bool(self.getPropertyVal('0063000B'))

    @functools.cached_property
    def rtfBody(self) -> Optional[bytes]:
        
        return compressed_rtf.decompress(self.compressedRtf) if self.compressedRtf else None

    @functools.cached_property
    def rtfEncapInjectableHeader(self) -> bytes:
        
        prefix = r'\htmlrtf {\htmlrtf0 {\*\htmltag96 <div>}{\*\htmltag96 <div>}{\*\htmltag64 <p class=MsoNormal>}'
        suffix = r'{\*\htmltag244 <o:p>}{\*\htmlrag252 </o:p>}\htmlrtf \par\par\htmlrtf0 {\*\htmltag72 </p>}{\*\htmltag104 </div>}{\*\htmltag104 </div>}\htmlrtf }\htmlrtf0 '
        joinStr = r'{\*\htmltag116 <br />}\htmlrtf \line\htmlrtf0 '
        formatter = (lambda name, value: fr'\htmlrtf {{\b\htmlrtf0{{\*\htmltag84 <b>}}{name}: {{\*\htmltag92 </b>}}\htmlrtf \b0\htmlrtf0 {inputToString(rtfSanitizeHtml(value), self.stringEncoding)}\htmlrtf }}\htmlrtf0')

        return self.getInjectableHeader(prefix, joinStr, suffix, formatter).encode('utf-8')

    @functools.cached_property
    def rtfPlainInjectableHeader(self) -> bytes:
        
        prefix = '{'
        suffix = '\\par\\par}'
        joinStr = '\\line'
        formatter = (lambda name, value: fr'{{\b {name}: \b0 {inputToString(rtfSanitizePlain(value), self.stringEncoding)}}}')

        return self.getInjectableHeader(prefix, joinStr, suffix, formatter).encode('utf-8')

    @functools.cached_property
    def sender(self) -> Optional[str]:
        
        
        if self.headerInit:
            headerResult = self.header['from']
            if headerResult is not None:
                return decodeRfc2047(headerResult)
            logger.info('Header found, but "sender" is not included. Will be generated from other streams.')
        
        text = self.getStringStream('__substg1.0_0C1A')
        email = self.getStringStream('__substg1.0_5D01')
        
        
        result = None
        if text is None:
            result = email
        else:
            result = text
            if email is not None:
                result += ' <' + email + '>'

        return result

    @functools.cached_property
    def subject(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_0037')

    @functools.cached_property
    def to(self) -> Optional[str]:
        
        return self._genRecipient('to', RecipientType.TO)
