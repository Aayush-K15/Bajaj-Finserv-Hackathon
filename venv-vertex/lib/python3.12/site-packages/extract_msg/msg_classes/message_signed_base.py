__all__ = [
    'MessageSignedBase',
]


import functools
import html
import logging
import re

from typing import Generic, List, Optional, Type, TypeVar

from ..attachments import AttachmentBase, SignedAttachment
from ..enums import AttachmentType, DeencapType, ErrorBehavior
from ..exceptions import StandardViolationError
from .message_base import MessageBase
from ..utils import inputToBytes, inputToString, unwrapMultipart


logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

_T = TypeVar('_T')


class MessageSignedBase(MessageBase, Generic[_T]):
    

    def __init__(self, path, signedAttachmentClass: Type[_T] = SignedAttachment, **kwargs):
        
        self.__sAttCls = signedAttachmentClass
        super().__init__(path, **kwargs)

    @functools.cached_property
    def attachments(self) -> List[_T]:
        
        
        self._signedBody = None
        self._signedHtmlBody = None

        atts = self.rawAttachments

        if len(atts) != 1:
            if ErrorBehavior.STANDARDS_VIOLATION in self.errorBehavior:
                if len(atts) == 0:
                    logger.error('Standards Violation: Signed message has no attachments.')
                    return []
                
                
                logger.error('Standards Violation: Signed message has more than one attachment. Attempting to use first one.')
            else:
                raise StandardViolationError('Signed messages without exactly 1 (regular) attachment constitute a violation of the standard.')

        
        if atts[0].type is not AttachmentType.DATA:
            
            if ErrorBehavior.STANDARDS_VIOLATION in self.errorBehavior:
                logger.error('Standards Violation: Attachment on signed message is unacceptable (not binary).')
                return []
            raise StandardViolationError('Signed messages *must* have a binary attachment. Signed attachments cannot be parsed otherwise.')

        
        
        
        
            
            
        
            
            
            

        
        unwrapped = unwrapMultipart(atts[0].data)

        
        
        self._signedBody = unwrapped['plain_body']
        self._signedHtmlBody = inputToBytes(unwrapped['html_body'], 'utf-8')

        return [self.__sAttCls(self, **att) for att in unwrapped['attachments']]

    @functools.cached_property
    def body(self) -> Optional[str]:
        
        if (body := self.getStringStream('__substg1.0_1000')) is not None:
            pass
        elif self.signedBody:
            body = self.signedBody
        elif self.rtfBody:
            
            
            body = self.deencapsulateBody(self.rtfBody, DeencapType.PLAIN)

        if body:
            body = inputToString(body, 'utf-8')
            if re.search('\n', body):
                if re.search('\r\n', body):
                    self._crlf = '\r\n'

        return body

    @functools.cached_property
    def htmlBody(self) -> Optional[bytes]:
        
        if (htmlBody := self.getStream('__substg1.0_10130102')) is not None:
            pass
        elif self.signedHtmlBody:
            htmlBody = self.signedHtmlBody
        elif self.rtfBody:
            logger.info('HTML body was not found, attempting to generate from RTF.')
            htmlBody = self.deencapsulateBody(self.rtfBody, DeencapType.HTML)
        elif self.body:
            
            logger.info('HTML body was not found, attempting to generate from plain text body.')
            correctedBody = html.escape(self.body).replace('\r', '').replace('\n', '<br />')
            htmlBody = f'<html><body>{correctedBody}</body></head>'.encode('utf-8')
        else:
            logger.info('HTML body could not be found nor generated.')

        return htmlBody

    @functools.cached_property
    def rawAttachments(self) -> List[AttachmentBase]:
        
        return super().attachments

    @property
    def signedAttachmentClass(self) -> Type[_T]:
        
        return self.__sAttCls

    @functools.cached_property
    def signedBody(self) -> Optional[str]:
        
        self.attachments
        return self._signedBody

    @functools.cached_property
    def signedHtmlBody(self) -> Optional[bytes]:
        
        self.attachments
        return self._signedHtmlBody
