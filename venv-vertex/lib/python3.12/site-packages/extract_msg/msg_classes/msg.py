from __future__ import annotations


__all__ = [
    'MSGFile',
]


import codecs
import copy
import datetime
import functools
import io
import logging
import os
import pathlib
import weakref
import zipfile

import olefile

from typing import (
        Any, Callable, cast, Dict, List, Optional, Tuple, TypeVar, Union
    )

from .. import constants
from ..constants import (
        DATE_FORMAT, DT_FORMAT, MSG_PATH, OVERRIDE_CLASS, ps, SAVE_TYPE
    )
from ..attachments import (
        AttachmentBase, initStandardAttachment, SignedAttachment
    )
from ..encoding import lookupCodePage
from ..enums import (
        ErrorBehavior, InsecureFeatures, Importance, Priority, PropertiesType,
        RetentionFlags, SaveType, Sensitivity, SideEffect
    )
from ..exceptions import (
        ConversionError, InvalidFileFormatError, PrefixError,
        StandardViolationError
    )
from ..properties.named import Named, NamedProperties
from ..properties.properties_store import PropertiesStore
from ..structures.contact_link_entry import ContactLinkEntry
from ..utils import (
        divide, guessEncoding, inputToMsgPath, makeWeakRef, msgPathToString,
        parseType, verifyPropertyId, verifyType
    )


logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

_T = TypeVar('_T')


class MSGFile:
    

    filename: Optional[str]

    def __init__(self, path, **kwargs):
        
        
        self.__inscFeat: InsecureFeatures = kwargs.get('insecureFeatures', InsecureFeatures.NONE)
        prefix: str = cast(str, kwargs.get('prefix', ''))
        self.__parentMsg = makeWeakRef(cast(MSGFile, kwargs.get('parentMsg')))
        self.__treePath = kwargs.get('treePath', []) + [weakref.ref(self)]
        
        if self.__parentMsg and not isinstance(self.__parentMsg(), MSGFile):
            raise TypeError(':param parentMsg: must be an instance of MSGFile or a subclass.')
        filename = kwargs.get('filename')
        overrideEncoding = kwargs.get('overrideEncoding')

        
        self.__path = path
        self.__initAttachmentFunc = kwargs.get('initAttachment', initStandardAttachment)
        self.__attachmentsDelayed = bool(kwargs.get('delayAttachments', False))
        self.__attachmentsReady = False
        self.__errorBehavior = ErrorBehavior(kwargs.get('errorBehavior', ErrorBehavior.THROW))
        self.__dateFormat = kwargs.get('dateFormat', DATE_FORMAT)
        self.__dtFormat = kwargs.get('datetimeFormat', DT_FORMAT)

        self.__listDirRes: Dict[Tuple[bool, bool, bool], List[List[str]]] = {}

        if self.__parentMsg:
            
            
            if (msg := self.__parentMsg()) is not None:
                self.__ole = msg.__ole
                self.__oleOwner = False
            else:
                raise ReferenceError('Parent MSG was garbage collected during init of child msg.')
        else:
            
            
            if not path:
                raise ValueError(':param path: must be set and must not be empty.')
            try:
                if ErrorBehavior.OLE_DEFECT_INCORRECT in self.errorBehavior:
                    defect = olefile.DEFECT_FATAL
                else:
                    defect = olefile.DEFECT_INCORRECT
                self.__ole = olefile.OleFileIO(path, raise_defects = defect)
            except OSError as e:
                logger.error(e)
                if str(e) == 'not an OLE2 structured storage file':
                    raise InvalidFileFormatError(e)
                else:
                    raise
            
            
            self.__oleOwner = True

        self.__open = True

        
        try:
            kwargsCopy = copy.copy(kwargs)
            if 'prefix' in kwargsCopy:
                del kwargsCopy['prefix']
            if 'parentMsg' in kwargsCopy:
                del kwargsCopy['parentMsg']
            if 'filename' in kwargsCopy:
                del kwargsCopy['filename']
            if 'treePath' in kwargsCopy:
                del kwargsCopy['treePath']
            self.__kwargs = kwargsCopy

            prefixl = []
            if prefix:
                try:
                    prefixl = inputToMsgPath(prefix)
                    prefix = '/'.join(prefixl) + '/'
                except ConversionError:
                    raise PrefixError(f'The provided prefix could not be used: {prefix}')
            self.__prefix = prefix
            self.__prefixList = prefixl
            self.__prefixLen = len(prefixl)

            if overrideEncoding is not None:
                logger.warning('You have chosen to override the string encoding. Do not report encoding errors caused by this.')
                if overrideEncoding.lower() == 'chardet':
                    encoding = guessEncoding(self)
                    if encoding:
                        self.__stringEncoding = encoding.lower()
                    else:
                        logger.warning('Attempted to auto-detect encoding, but no consensus could be formed based on the top-level strings. Defaulting to normal detection methods.')
                else:
                    codecs.lookup(overrideEncoding)
                    self.__stringEncoding = overrideEncoding
            self.__overrideEncoding = overrideEncoding

            if prefix and not filename:
                
                msg = None
                parentNeedsClose = False
                if self.__parentMsg:
                    msg = self.__parentMsg()
                if msg is None:
                    
                    
                    
                    
                    msg = MSGFile(path, prefix = prefixl[:-2], delayAttachments = True)
                    parentNeedsClose = True
                
                filename = msg.getStringStream(prefixl[:-1] + ['__substg1.0_3001'], prefix = False)
                
                if parentNeedsClose:
                    msg.close()
            if filename:
                self.filename = filename
            elif hasattr(path, '__len__'):
                if len(path) < 1536:
                    self.filename = str(path)
                else:
                    self.filename = None
            elif isinstance(path, pathlib.Path):
                self.filename = str(path)
            else:
                self.filename = None

            
            if not self.__attachmentsDelayed:
                self.attachments
        except:
            
            try:
                self.close()
            except:
                pass
            
            raise

    def __bytes__(self) -> bytes:
        return self.exportBytes()

    def __enter__(self) -> MSGFile:
        self.__ole.__enter__()
        return self

    def __exit__(self, *_) -> None:
        self.close()

    def _getOleEntry(self, filename: MSG_PATH, prefix: bool = True) -> olefile.olefile.OleDirectoryEntry:
        
        sid = -1
        if filename == '/':
            if prefix and self.__prefix:
                sid = self.__ole._find(self.__prefixList)
            else:
                return self.__ole.direntries[0]
        else:
            sid = self.__ole._find(self.fixPath(filename, prefix))

        return self.__ole.direntries[sid]

    def _getTypedAs(self, _id: str, overrideClass = None, preserveNone: bool = True):
        
        value = self._getTypedData(_id)
        
        if overrideClass is not None:
            if value is not None or not preserveNone:
                value = overrideClass(value)

        return value

    def _getTypedData(self, _id: str, _type = None, prefix: bool = True):
        
        verifyPropertyId(_id)
        _id = _id.upper()
        found, result = self._getTypedStream('__substg1.0_' + _id, prefix, _type)
        if found:
            return result
        else:
            found, result = self._getTypedProperty(_id, _type)
            return result if found else None

    def _getTypedProperty(self, propertyID: str, _type = None) -> Tuple[bool, Optional[Any]]:
        
        verifyPropertyId(propertyID)
        if _type:
            verifyType(_type)
            propertyID += _type

        notFound = object()
        ret = self.getPropertyVal(propertyID, notFound)
        if ret is notFound:
            return False, None

        return True, ret

    def _getTypedStream(self, filename: MSG_PATH, prefix: bool = True, _type: Optional[str] = None) -> Tuple[bool, Optional[Any]]:
        
        verifyType(_type)
        filename = self.fixPath(filename, prefix)
        for x in (filename + _type,) if _type is not None else self.slistDir():
            if x.startswith(filename) and '-' not in x:
                if (contents := self.getStream(x, False)) is None:
                    continue
                if len(contents) == 0:
                    return True, None 
                extras: List[bytes]= []
                _type = x[-4:]
                if x[-4] == '1': 
                    if _type in ('101F', '101E'):
                        streams = len(contents) // 4 
                    elif _type == '1102':
                        streams = len(contents) // 8 
                    elif _type in ('1002', '1003', '1004', '1005', '1007', '1014', '1040', '1048'):
                        try:
                            streams = self.props[x[-8:]].realLength
                        except (KeyError, AttributeError):
                            logger.error(f'Could not find matching VariableLengthProp for stream {x}')
                            streams = len(contents) // (2 if _type in constants.MULTIPLE_2_BYTES else 4 if _type in constants.MULTIPLE_4_BYTES else 8 if _type in constants.MULTIPLE_8_BYTES else 16)
                    else:
                        raise NotImplementedError(f'The stream specified is of type {_type}. We don\'t currently understand exactly how this type works. If it is mandatory that you have the contents of this stream, please create an issue labeled "NotImplementedError: _getTypedStream {_type}".')
                    if _type in ('101F', '101E', '1102'):
                        if self.exists(x + '-00000000', False):
                            for y in range(streams):
                                if self.exists((name := f'{x}-{y:08X}'), False):
                                    extras.append(self.getStream(name, False))
                    elif _type in ('1002', '1003', '1004', '1005', '1007', '1014', '1040', '1048'):
                        extras = divide(contents, (2 if _type in constants.MULTIPLE_2_BYTES else 4 if _type in constants.MULTIPLE_4_BYTES else 8 if _type in constants.MULTIPLE_8_BYTES else 16))
                        contents = streams
                return True, parseType(int(_type, 16), contents, self.stringEncoding, extras)
        return False, None 

    def _oleListDir(self, streams: bool = True, storages: bool = False) -> List[List[str]]:
        
        return self.__ole.listdir(streams, storages)

    def close(self) -> None:
        if self.__open:
            if self.attachmentsReady:
                for attachment in self.attachments:
                    if attachment.type == 'msg':
                        attachment.data.close()

            if self.__oleOwner:
                self.__ole.close()

            self.__open = False

    def debug(self) -> None:
        for dir_ in self.listDir():
            if dir_[-1].endswith('001E') or dir_[-1].endswith('001F'):
                print('Directory: ' + str(dir_[:-1]))
                print(f'Contents: {self.getStream(dir_)}')

    def exists(self, filename: MSG_PATH, prefix: bool = True) -> bool:
        
        filename = self.fixPath(filename, prefix)
        return self.__ole.exists(filename)

    def sExists(self, filename: MSG_PATH, prefix: bool = True) -> bool:
        
        filename = self.fixPath(filename, prefix)
        return self.exists(filename + '001F') or self.exists(filename + '001E')

    def existsTypedProperty(self, _id: str, location = None, _type = None, prefix: bool = True, propertiesInstance: Optional[PropertiesStore] = None) -> Tuple[bool, int]:
        
        verifyPropertyId(_id)
        verifyType(_type)
        _id = _id.upper()
        if propertiesInstance is None:
            propertiesInstance = self.props
        prefixList = self.prefixList if prefix else []
        if location is not None:
            prefixList.append(location)
        prefixList = inputToMsgPath(prefixList)
        usableId = _id + _type if _type else _id
        foundNumber = 0
        foundStreams = []
        for item in self.listDir():
            if len(item) > self.__prefixLen:
                if item[self.__prefixLen].startswith('__substg1.0_' + usableId) and item[self.__prefixLen] not in foundStreams:
                    foundNumber += 1
                    foundStreams.append(item[self.__prefixLen])
        for x in propertiesInstance:
            if x.startswith(usableId):
                for y in foundStreams:
                    if y.endswith(x):
                        break
                else:
                    foundNumber += 1
        return (foundNumber > 0), foundNumber

    def export(self, path, allowBadEmbed: bool = False) -> None:
        
        from ..ole_writer import OleWriter

        
        writer = OleWriter()
        
        writer.fromMsg(self, allowBadEmbed = allowBadEmbed)
        writer.write(path)

    def exportBytes(self, allowBadEmbed: bool = False) -> bytes:
        
        out = io.BytesIO()
        self.export(out, allowBadEmbed)
        return out.getvalue()

    def fixPath(self, inp: MSG_PATH, prefix: bool = True) -> str:
        
        inp = msgPathToString(inp)
        if prefix:
            inp = self.__prefix + inp
        return inp

    def getMultipleBinary(self, filename: MSG_PATH, prefix: bool = True) -> Optional[List[bytes]]:
        
        filename = self.fixPath(filename, prefix) + '1102'
        multStream = self.getStream(filename)
        if multStream is None:
            return None

        if len(multStream) == 0:
            return []
        elif len(multStream) & 7 != 0:
            raise StandardViolationError(f'Length stream for multiple binary was not a multiple of 8.')
        else:
            ret = [self.getStream(filename + f'-{x:08X}') for x in range(len(multStream) // 8)]
            
            if (index := next((x for x in ret if x is None), -1)) != -1:
                logger.error('Unable to get the desired number of binary streams for multiple, not all streams were found.')
                return ret[:index]
            return ret

    def getMultipleString(self, filename: MSG_PATH, prefix: bool = True) -> Optional[List[str]]:
        
        filename = self.fixPath(filename, prefix) + '101F' if self.areStringsUnicode else '101E'
        multStream = self.getStream(filename)
        if multStream is None:
            return []

        if len(multStream) == 0:
            return []
        elif len(multStream) & 3 != 0:
            raise StandardViolationError(f'Length stream for multiple string was not a multiple of 4.')
        else:
            ret = [self.getStream(filename + f'-{x:08X}') for x in range(len(multStream) // 4)]
            
            for index, item in enumerate(ret):
                if item is None:
                    logger.error('Unable to get the desired number of string streams for multiple, not all streams were found.')
                    return ret[:index]
                
                ret[index] = item.decode(self.stringEncoding)[:-1]
            return ret

    def getNamedAs(self, propertyName: str, guid: str, overrideClass: OVERRIDE_CLASS[_T]) -> Optional[_T]:
        
        value = self.getNamedProp(propertyName, guid)
        if value is not None:
            value = overrideClass(value)
        return value

    def getNamedProp(self, propertyName: str, guid: str, default: _T = None) -> Union[Any, _T]:
        
        return self.namedProperties.get((propertyName, guid), default)

    def getPropertyAs(self, propertyName: Union[int, str], overrideClass: OVERRIDE_CLASS[_T]) -> Optional[_T]:
        
        value = self.getPropertyVal(propertyName)

        if value is not None:
            value = overrideClass(value)

        return value

    def getPropertyVal(self, name: Union[int, str], default: _T = None) -> Union[Any, _T]:
        
        return self.props.getValue(name, default)

    def getSingleOrMultipleBinary(self, filename: MSG_PATH, prefix: bool = True) -> Optional[Union[List[bytes], bytes]]:
        
        filename = self.fixPath(filename, prefix)
        
        if (ret := self.getStream(filename + '0102', False)) is not None:
            return ret
        
        
        return self.getMultipleBinary(filename, False)

    def getSingleOrMultipleString(self, filename: MSG_PATH, prefix: bool = True) -> Optional[Union[List[str], str]]:
        
        filename = self.fixPath(filename, prefix)
        
        if (ret := self.getStringStream(filename, False)) is not None:
            return ret
        
        
        return self.getMultipleString(filename, False)

    def getStream(self, filename: MSG_PATH, prefix: bool = True) -> Optional[bytes]:
        
        filename = self.fixPath(filename, prefix)
        if self.exists(filename, False):
            with self.__ole.openstream(filename) as stream:
                return stream.read() or b''
        else:
            logger.info(f'Stream "{filename}" was requested but could not be found. Returning `None`.')
            return None

    def getStreamAs(self, streamID: MSG_PATH, overrideClass: OVERRIDE_CLASS[_T]) -> Optional[_T]:
        
        value = self.getStream(streamID)

        if value is not None:
            value = overrideClass(value)

        return value

    def getStringStream(self, filename: MSG_PATH, prefix: bool = True) -> Optional[str]:
        
        filename = self.fixPath(filename, prefix)
        if self.areStringsUnicode:
            tmp = self.getStream(filename + '001F', prefix = False)
        else:
            tmp = self.getStream(filename + '001E', prefix = False)

        return None if tmp is None else tmp.decode(self.stringEncoding)

    def getStringStreamAs(self, streamID: MSG_PATH, overrideClass: OVERRIDE_CLASS[_T]) -> Optional[_T]:
        
        value = self.getStream(streamID)

        if value is not None:
            value = overrideClass(value)

        return value

    def listDir(self, streams: bool = True, storages: bool = False, includePrefix: bool = True) -> List[List[str]]:
        
        
        try:
            return self.__listDirRes[(streams, storages, includePrefix)]
        except KeyError:
            entries = self.__ole.listdir(streams, storages)
            if not self.__prefix:
                return entries
            prefix = self.__prefix.split('/')
            if prefix[-1] == '':
                prefix.pop()

            prefixLength = self.__prefixLen
            entries = [x for x in entries if len(x) > prefixLength and x[:prefixLength] == prefix]
            if not includePrefix:
                entries = [x[prefixLength:] for x in entries]
            self.__listDirRes[(streams, storages, includePrefix)] = entries

            return entries

    def slistDir(self, streams: bool = True, storages: bool = False, includePrefix: bool = True) -> List[str]:
        
        return [msgPathToString(x) for x in self.listDir(streams, storages, includePrefix)]

    def save(self, **kwargs) -> SAVE_TYPE:
        if kwargs.get('skipNotImplemented', False):
            return (SaveType.NONE, None)

        raise NotImplementedError(f'Saving is not yet supported for the {self.__class__.__name__} class.')

    def saveAttachments(self, skipHidden: bool = False, **kwargs) -> None:
        
        for attachment in self.attachments:
            if not (skipHidden and attachment.hidden):
                attachment.save(skipHidden = skipHidden, **kwargs)

    def saveRaw(self, path) -> None:
        
        path = pathlib.Path(path)
        
        os.makedirs(path, exist_ok = True)
        
        path /= 'raw.zip'
        if path.exists():
            raise FileExistsError(f'File "{path}" already exists.')
        with zipfile.ZipFile(path, 'w', zipfile.ZIP_DEFLATED) as zfile:
            
            for dir_ in self.listDir():
                sysdir = '/'.join(dir_)
                code = dir_[-1][-8:]
                if constants.PROPERTIES.get(code):
                    sysdir += ' - ' + constants.PROPERTIES[code]

                
                if dir_[-1].endswith('001E') or dir_[-1].endswith('001F'):
                    filename = 'contents.txt'
                else:
                    filename = 'contents.bin'

                
                with zfile.open(sysdir + '/' + filename, 'w') as f:
                    data = self.getStream(dir_)
                    
                    
                    if data is not None:
                        f.write(data)

    @functools.cached_property
    def areStringsUnicode(self) -> bool:
        
        val = self.getPropertyVal('340D0003')
        if val is None:
            
            if self.prefix:
                if self.__parentMsg and (msg := self.__parentMsg()) is not None:
                    return msg.areStringsUnicode

            
            return any(x[-1].upper().endswith('001F') for x in self.listDir())
        return (val & 0x40000) != 0

    @functools.cached_property
    def attachments(self) -> Union[List[AttachmentBase], List[SignedAttachment]]:
        
        
        attachmentDirs = []
        for dir_ in self.listDir(False, True, False):
            if dir_[0].startswith('__attach') and dir_[0] not in attachmentDirs:
                attachmentDirs.append(dir_[0])

        attachments = []

        for attachmentDir in attachmentDirs:
            attachments.append(self.initAttachmentFunc(self, attachmentDir))

        self.__attachmentsReady = True

        return attachments

    @property
    def attachmentsDelayed(self) -> bool:
        
        return self.__attachmentsDelayed

    @property
    def attachmentsReady(self) -> bool:
        
        return self.__attachmentsReady

    @functools.cached_property
    def classified(self) -> bool:
        
        return bool(self.getNamedProp('85B5', ps.PSETID_COMMON))

    @functools.cached_property
    def classType(self) -> Optional[str]:
        
        return self.getStringStream('__substg1.0_001A')

    @functools.cached_property
    def commonEnd(self) -> Optional[datetime.datetime]:
        
        return self.getNamedProp('8517', ps.PSETID_COMMON)

    @functools.cached_property
    def commonStart(self) -> Optional[datetime.datetime]:
        
        return self.getNamedProp('8516', ps.PSETID_COMMON)

    @functools.cached_property
    def contactLinkEntry(self) -> Optional[ContactLinkEntry]:
        
        return self.getNamedAs('8585', ps.PSETID_COMMON, ContactLinkEntry)

    @functools.cached_property
    def contacts(self) -> Optional[List[str]]:
        
        return self.getNamedProp('853A', ps.PSETID_COMMON)

    @functools.cached_property
    def currentVersion(self) -> Optional[int]:
        
        return self.getNamedProp('8552', ps.PSETID_COMMON)

    @functools.cached_property
    def currentVersionName(self) -> Optional[str]:
        
        return self.getNamedProp('8554', ps.PSETID_COMMON)

    @property
    def dateFormat(self) -> str:
        
        return self.__dateFormat

    @property
    def datetimeFormat(self) -> str:
        
        return self.__dtFormat

    @property
    def errorBehavior(self) -> ErrorBehavior:
        
        return self.__errorBehavior

    @functools.cached_property
    def importance(self) -> Optional[Importance]:
        
        return self.getPropertyAs('00170003', Importance)

    @property
    def importanceString(self) -> Union[str, None]:
        
        return {
            Importance.HIGH: 'High',
            Importance.MEDIUM: None,
            Importance.LOW: 'Low',
            None: None,
        }[self.importance]

    @property
    def initAttachmentFunc(self) -> Callable[[MSGFile, str], AttachmentBase]:
        
        return self.__initAttachmentFunc

    @property
    def insecureFeatures(self) -> InsecureFeatures:
        
        return self.__inscFeat

    @property
    def kwargs(self) -> Dict[str, Any]:
        
        return self.__kwargs

    @functools.cached_property
    def named(self) -> Named:
        
        
        if self.__parentMsg:
            
            
            if (msg := self.__parentMsg()) is None:
                raise ReferenceError('Parent MSGFile instance has been garbage collected.')
            return msg.named
        else:
            return Named(self)

    @functools.cached_property
    def namedProperties(self) -> NamedProperties:
        
        return NamedProperties(self.named, self)

    @property
    def overrideEncoding(self) -> Optional[str]:
        
        return self.__overrideEncoding

    @property
    def path(self):
        
        return self.__path

    @property
    def prefix(self) -> str:
        
        return self.__prefix

    @property
    def prefixLen(self) -> int:
        
        return self.__prefixLen

    @property
    def prefixList(self) -> List[str]:
        
        return copy.deepcopy(self.__prefixList)

    @functools.cached_property
    def priority(self) -> Optional[Priority]:
        
        return self.getPropertyAs('00260003', Priority)

    @functools.cached_property
    def props(self) -> PropertiesStore:
        
        if not (stream := self.getStream('__properties_version1.0')):
            if ErrorBehavior.STANDARDS_VIOLATION in self.__errorBehavior:
                logger.error('File does not contain a property stream.')
            else:
                
                
                raise StandardViolationError('File does not contain a property stream.') from None
        return PropertiesStore(stream,
                               PropertiesType.MESSAGE if not self.prefix else PropertiesType.MESSAGE_EMBED)

    @functools.cached_property
    def retentionDate(self) -> Optional[datetime.datetime]:
        
        return self.getPropertyVal('301C0040')

    @functools.cached_property
    def retentionFlags(self) -> Optional[RetentionFlags]:
        
        return self.getPropertyAs('301D0003', RetentionFlags)

    @functools.cached_property
    def sensitivity(self) -> Optional[Sensitivity]:
        
        return self.getPropertyAs('00360003', Sensitivity)

    @functools.cached_property
    def sideEffects(self) -> Optional[SideEffect]:
        
        return self.getNamedAs('8510', ps.PSETID_COMMON, SideEffect)

    @property
    def stringEncoding(self) -> str:
        try:
            return self.__stringEncoding
        except AttributeError:
            
            
            if self.areStringsUnicode:
                self.__stringEncoding = "utf-16-le"
            else:
                
                if '3FFD0003' not in self.props:
                    
                    
                    logger.warning('Encoding property not found. Defaulting to ISO-8859-15.')
                    self.__stringEncoding = 'iso-8859-15'
                else:
                    enc = cast(int, self.getPropertyVal('3FFD0003'))
                    
                    self.__stringEncoding = lookupCodePage(enc)
            return self.__stringEncoding

    @property
    def treePath(self) -> List[weakref.ReferenceType[Any]]:
        
        return self.__treePath
