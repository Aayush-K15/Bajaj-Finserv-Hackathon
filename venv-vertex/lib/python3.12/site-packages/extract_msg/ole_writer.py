from __future__ import annotations


__all__ = [
    'DirectoryEntry',
    'OleWriter',
]


import copy
import re

from typing import (
        Dict, Iterator, List, Optional, SupportsBytes, Tuple, TYPE_CHECKING,
        Union
    )

from . import constants
from .constants import MSG_PATH
from .enums import Color, DirectoryEntryType
from .exceptions import StandardViolationError, TooManySectorsError
from .utils import ceilDiv, dictGetCasedKey, inputToMsgPath
from olefile.olefile import OleDirectoryEntry, OleFileIO
from red_black_dict_mod import RedBlackTree



if TYPE_CHECKING:
    from .msg_classes import MSGFile


class DirectoryEntry:
    
    name: str = ''
    rightChild: Optional[DirectoryEntry] = None
    leftChild: Optional[DirectoryEntry] = None
    childTreeRoot: Optional[DirectoryEntry] = None
    stateBits: int = 0
    creationTime: int = 0
    modifiedTime: int = 0
    type: DirectoryEntryType = DirectoryEntryType.UNALLOCATED

    
    id: int = -1
    
    
    leftSiblingID: int = 0xFFFFFFFF
    rightSiblingID: int = 0xFFFFFFFF
    
    childID: int = 0xFFFFFFFF
    startingSectorLocation: int = 0
    color: Color = Color.BLACK

    clsid: bytes = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
    data: bytes = b''

    def __bytes__(self) -> bytes:
        return self.toBytes()

    def toBytes(self) -> bytes:
        
        
        if len(self.name) > 31:
            raise ValueError('Name is too long for directory entry.')
        if len(self.name) < 1:
            raise ValueError('Directory entry must have a name.')
        if re.search('/\\\\:!', self.name):
            raise ValueError('Directory entry name contains an illegal character.')

        nameBytes = self.name.encode('utf-16-le')

        return constants.st.ST_CF_DIR_ENTRY.pack(
                                              nameBytes,
                                              len(nameBytes) + 2,
                                              self.type,
                                              self.color,
                                              self.leftSiblingID,
                                              self.rightSiblingID,
                                              self.childID,
                                              self.clsid,
                                              self.stateBits,
                                              self.creationTime,
                                              self.modifiedTime,
                                              self.startingSectorLocation,
                                              getattr(self, 'streamSize', len(self.data)),
                                             )



class OleWriter:
    
    def __init__(self, rootClsid: bytes = constants.DEFAULT_CLSID):
        self.__rootEntry = DirectoryEntry()
        self.__rootEntry.name = "Root Entry"
        self.__rootEntry.type = DirectoryEntryType.ROOT_STORAGE
        self.__rootEntry.clsid = rootClsid
        
        self.__dirEntryCount = 1
        self.__dirEntries = {}
        self.__largeEntries: List[DirectoryEntry] = []
        self.__largeEntrySectors = 0
        self.__numMinifatSectors = 0

        
        self.__version = 3

    def __getContainingStorage(self, path: List[str], entryExists: bool = True, create: bool = False) -> Dict:
        
        if not path:
            raise OSError('Path cannot be empty.')

        
        if create and entryExists:
            raise ValueError(':param create: and :param entryExists: cannot both be True (an entry cannot exist if it is being created).')

        
        
        
        if any(x.startswith('::') for x in path):
            raise ValueError('Found internal name in path.')

        _dir = self.__dirEntries

        for index, name in enumerate(path[:-1]):
            
            
            if name.lower() not in map(str.lower, _dir.keys()):
                if create:
                    self.addEntry(path[:index + 1], storage = True)
                else:
                    raise OSError(f'Entry not found: {name}')
            _dir = _dir[dictGetCasedKey(_dir, name)]

            
            
            if not isinstance(_dir, dict):
                raise OSError('Attempted to access children of a stream.')

        if entryExists and path[-1].lower() not in map(str.lower, _dir.keys()):
            raise OSError(f'Entry not found: {path[-1]}')

        return _dir

    def __getEntry(self, path: List[str]) -> DirectoryEntry:
        
        _dir = self.__getContainingStorage(path)
        item = _dir[dictGetCasedKey(_dir, path[-1])]
        if isinstance(item, dict):
            return item['::DirectoryEntry']
        else:
            return item

    def __modifyEntry(self, entry: DirectoryEntry, **kwargs):
        
        
        data = kwargs.get('data')
        clsid = kwargs.get('clsid')
        creationTime = kwargs.get('creationTime')
        modifiedTime = kwargs.get('modifiedTime')
        stateBits = kwargs.get('stateBits')

        
        
        
        if data is not None:
            if entry.type is not DirectoryEntryType.STREAM:
                raise TypeError('Cannot set the data of a storage object.')
            if not isinstance(data, bytes):
                try:
                    data = bytes(data)
                except Exception:
                    raise ValueError('Data must be a bytes instance or convertable to bytes if set.')
            
            
            
            if len(data) > 0x80000000:
                raise ValueError('Current version of extract_msg does not support streams greater than 2 GB in OLE files.')

        if clsid is not None:
            if not isinstance(clsid, bytes):
                raise ValueError('CLSID must be bytes.')
            if len(clsid) != 16:
                raise ValueError('CLSID must be 16 bytes.')

        if creationTime is not None:
            if entry.type is DirectoryEntryType.STREAM:
                raise ValueError('Modification of creation time cannot be done on a stream.')
            if not isinstance(creationTime, int) or creationTime < 0 or creationTime > 0xFFFFFFFFFFFFFFFF:
                raise ValueError('Creation time must be a positive 8 byte int.')

        if modifiedTime is not None:
            if entry.type is DirectoryEntryType.STREAM:
                raise ValueError('Modification of modified time cannot be done on a stream.')
            if not isinstance(modifiedTime, int) or modifiedTime < 0 or modifiedTime > 0xFFFFFFFFFFFFFFFF:
                raise ValueError('Modified time must be a positive 8 byte int.')

        if stateBits is not None:
            if not isinstance(stateBits, int) or stateBits < 0 or stateBits > 0xFFFFFFFF:
                raise ValueError('State bits must be a positive 4 byte int.')

        
        if data is not None:
            entry.data = data
        if clsid is not None:
            entry.clsid = clsid
        if creationTime is not None:
            entry.creationTime = creationTime
        if modifiedTime is not None:
            entry.modifiedTime = modifiedTime
        if stateBits is not None:
            entry.stateBits = stateBits

    def __recalculateSectors(self) -> None:
        
        self.__dirEntryCount = 0
        self.__numMinifatSectors = 0
        self.__largeEntries.clear()
        self.__largeEntrySectors = 0

        for entry in self.__walkEntries():
            self.__dirEntryCount += 1
            if entry.type == DirectoryEntryType.STREAM:
                if len(entry.data) < 4096:
                    self.__numMinifatSectors += ceilDiv(len(entry.data), 64)
                else:
                    self.__largeEntries.append(entry)
                    self.__largeEntrySectors += ceilDiv(len(entry.data), self.__sectorSize)

    def __walkEntries(self) -> Iterator[DirectoryEntry]:
        
        toProcess = [self.__dirEntries]
        yield self.__rootEntry

        while len(toProcess) > 0:
            for name, item in toProcess.pop(0).items():
                if not name.startswith('::'):
                    if isinstance(item, dict):
                        yield item['::DirectoryEntry']
                        toProcess.append(item)
                    else:
                        yield item

    @property
    def __dirEntsPerSector(self) -> int:
        
        return self.__sectorSize // 128

    @property
    def __linksPerSector(self) -> int:
        
        return self.__sectorSize // 4

    @property
    def __miniSectorsPerSector(self) -> int:
        
        return self.__sectorSize // 64

    @property
    def __numberOfSectors(self) -> int:
        
        
        
        
        
        
        return ceilDiv(self.__dirEntryCount, 4) + \
               self.__numMinifat + \
               ceilDiv(self.__numMinifat, 16) + \
               self.__largeEntrySectors

    @property
    def __numMinifat(self) -> int:
        
        return ceilDiv(64 * self.__numMinifatSectors, self.__sectorSize)

    @property
    def __sectorSize(self) -> int:
        
        return 512 if self.__version == 3 else 4096

    def _cleanupEntries(self) -> None:
        
        self.__largeEntries.clear()
        for entry in self.__walkEntries():
            entry.id = -1
            entry.leftChild = None
            entry.rightChild = None
            entry.childTreeRoot = None
            entry.leftSiblingID = 0xFFFFFFFF
            entry.rightSiblingID = 0xFFFFFFFF
            entry.childID = 0xFFFFFFFF

    def _getFatSectors(self) -> Tuple[int, int, int]:
        
        
        numDifat = 0
        
        numFat = ceilDiv(self.__numberOfSectors or 1, self.__linksPerSector - 1)
        newNumFat = 1
        while numFat != newNumFat:
            numFat = newNumFat
            numDifat = ceilDiv(max(numFat - 109, 0), self.__linksPerSector - 1)
            newNumFat = ceilDiv(self.__numberOfSectors + numDifat, self.__linksPerSector - 1)

        return (numFat, numDifat, self.__numberOfSectors + numDifat + numFat)

    def _treeSort(self, startingSector: int) -> List[DirectoryEntry]:
        
        
        root = copy.copy(self.__rootEntry)

        
        root.startingSectorLocation = (startingSector + ceilDiv(self.__dirEntryCount, 4) + ceilDiv(self.__numMinifatSectors, self.__linksPerSector)) if self.__numMinifat > 0 else 0xFFFFFFFE
        root.streamSize = self.__numMinifatSectors * 64
        root.childTreeRoot = None
        root.childID = 0xFFFFFFFF
        entries = [root]

        toProcess = [(root, self.__dirEntries)]
        
        while toProcess:
            entry, currentItem = toProcess.pop()
            if not currentItem:
                continue
            
            
            
            
            
            tree = RedBlackTree()
            for name in currentItem:
                if not name.startswith('::'):
                    val = currentItem[name]
                    
                    
                    if isinstance(val, dict):
                        toProcess.append((val['::DirectoryEntry'], val))
                        val = val['::DirectoryEntry']

                    entries.append(val)

                    
                    tree.add((len(name), name.upper()), val)

            
            
            entry.childTreeRoot = tree.value

            
            
            for node in tree.in_order():
                item = node.value
                
                item.color = Color.BLACK if node.is_black else Color.RED

                if node.left:
                    item.leftChild = node.left.value
                else:
                    item.leftChild = None

                if node.right:
                    item.rightChild = node.right.value
                else:
                    item.rightChild = None

        
        
        for _id, entry in enumerate(entries):
            entry.id = _id

        for entry in entries:
            entry.leftSiblingID = entry.leftChild.id if entry.leftChild else 0xFFFFFFFF
            entry.childID = entry.childTreeRoot.id if entry.childTreeRoot else 0xFFFFFFFF
            entry.rightSiblingID = entry.rightChild.id if entry.rightChild else 0xFFFFFFFF

        
        

        
        miniFATLocation = 0

        for entry in entries:
            if len(entry.data) == 0 and entry != entries[0]:
                
                entry.startingSectorLocation = 0xFFFFFFFE
            elif entry.type == DirectoryEntryType.STREAM and len(entry.data) < 4096:
                entry.startingSectorLocation = miniFATLocation
                miniFATLocation += ceilDiv(len(entry.data), 64)

        return entries

    def _writeBeginning(self, f) -> int:
        
        
        self.__recalculateSectors()
        
        numFat, numDifat, totalSectors = self._getFatSectors()

        
        if totalSectors > 0xFFFFFFFB:
            raise TooManySectorsError('Data in OleWriter requires too many sectors to write to a version 3 file.')

        
        
        
        if self.__numMinifatSectors > 0x2000000:
            raise TooManySectorsError('Data is OleWriter requires too many MiniFAT sectors.')

        
        f.write(b'\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1')
        
        f.write(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
        
        f.write(b'\x3E\x00')
        
        
        f.write(b'\x03\x00' if self.__version == 3 else b'\x04\x00')
        
        f.write(b'\xFE\xFF')
        
        f.write(b'\x09\x00' if self.__version == 3 else b'\x0C\x00')
        
        f.write(b'\x06\x00')
        
        f.write(b'\x00\x00\x00\x00\x00\x00')
        
        f.write(constants.st.ST_LE_UI32.pack(0))
        
        f.write(constants.st.ST_LE_UI32.pack(numFat))
        
        
        f.write(constants.st.ST_LE_UI32.pack(numFat + numDifat))
        
        f.write(b'\x00\x00\x00\x00')
        
        f.write(b'\x00\x10\x00\x00')
        
        f.write(constants.st.ST_LE_UI32.pack((numFat + numDifat + ceilDiv(self.__dirEntryCount, 4)) if self.__numMinifat > 0 else 0xFFFFFFFE))
        
        f.write(constants.st.ST_LE_UI32.pack(ceilDiv(self.__numMinifatSectors, self.__linksPerSector)))
        
        
        f.write(constants.st.ST_LE_UI32.pack(0 if numDifat else 0xFFFFFFFE))
        
        f.write(constants.st.ST_LE_UI32.pack(numDifat))

        
        
        

        
        for x in range(numFat):
            
            
            if x == 109 and self.__version == 4:
                f.write(b'\x00' * 3584)
            
            if x > 109 and (x - 109) % (self.__linksPerSector - 1) == 0:
                
                f.write(constants.st.ST_LE_UI32.pack((x - 109) // (self.__linksPerSector - 1)))
            
            f.write(constants.st.ST_LE_UI32.pack(x + numDifat))

        
        if numFat > 109:
            f.write(b'\xFF\xFF\xFF\xFF' * ((self.__linksPerSector - 1) - ((numFat - 109) % (self.__linksPerSector - 1))))
            
            f.write(b'\xFE\xFF\xFF\xFF')
        else:
            f.write(b'\xFF\xFF\xFF\xFF' * (109 - numFat))

        

        
        
        f.write(b'\xFC\xFF\xFF\xFF' * numDifat)
        
        f.write(b'\xFD\xFF\xFF\xFF' * numFat)

        offset = numDifat + numFat

        
        for x in range(offset + 1, offset + ceilDiv(self.__dirEntryCount, self.__dirEntsPerSector)):
            f.write(constants.st.ST_LE_UI32.pack(x))

        
        f.write(b'\xFE\xFF\xFF\xFF')

        offset += ceilDiv(self.__dirEntryCount, self.__dirEntsPerSector)

        
        if self.__numMinifatSectors > 0:
            
            for x in range(offset + 1, offset + ceilDiv(self.__numMinifat, 16)):
                f.write(constants.st.ST_LE_UI32.pack(x))

            
            f.write(b'\xFE\xFF\xFF\xFF')

            offset += ceilDiv(self.__numMinifat, 16)

            
            for x in range(offset + 1, offset + self.__numMinifat):
                f.write(constants.st.ST_LE_UI32.pack(x))

            
            f.write(b'\xFE\xFF\xFF\xFF')

            offset += self.__numMinifat

        
        
        
        
        for entry in self.__largeEntries:
            size = ceilDiv(len(entry.data), self.__sectorSize)
            entry.startingSectorLocation = offset
            for x in range(offset + 1, offset + size):
                f.write(constants.st.ST_LE_UI32.pack(x))

            
            f.write(b'\xFE\xFF\xFF\xFF')

            offset += size

        
        freeSectors = totalSectors & (self.__linksPerSector - 1)
        if freeSectors:
            f.write(b'\xFF\xFF\xFF\xFF' * (self.__linksPerSector - freeSectors))

        
        return numDifat + numFat

    def _writeDirectoryEntries(self, f, startingSector: int) -> List[DirectoryEntry]:
        
        entries = self._treeSort(startingSector)
        for x in entries:
            self._writeDirectoryEntry(f, x)
        if len(entries) & 3:
            f.write(((b'\x00\x00' * 34) + (b'\xFF\xFF' * 6) + (b'\x00\x00' * 24)) * (4 - (len(entries) & 3)))

        return entries

    def _writeDirectoryEntry(self, f, entry: DirectoryEntry) -> None:
        
        f.write(bytes(entry))

    def _writeFinal(self, f) -> None:
        
        for x in self.__largeEntries:
            f.write(x.data)
            if len(x.data) & (self.__sectorSize - 1):
                f.write(b'\x00' * (self.__sectorSize - (len(x.data) & (self.__sectorSize - 1))))

    def _writeMini(self, f, entries: List[DirectoryEntry]) -> None:
        
        
        currentSector = 0
        for x in entries:
            if x.type == DirectoryEntryType.STREAM and len(x.data) < 4096:
                size = ceilDiv(len(x.data), 64)
                for x in range(currentSector + 1, currentSector + size):
                    f.write(constants.st.ST_LE_UI32.pack(x))
                if size > 0:
                    f.write(b'\xFE\xFF\xFF\xFF')
                currentSector += size

        
        if currentSector & (self.__linksPerSector - 1):
            f.write(b'\xFF\xFF\xFF\xFF' * (self.__linksPerSector - (currentSector & (self.__linksPerSector - 1))))

        
        for x in entries:
            if len(x.data) > 0 and len(x.data) < 4096:
                f.write(x.data)
                if len(x.data) & 63:
                    f.write(b'\x00' * (64 - (len(x.data) & 63)))

        
        if self.__numMinifatSectors & (self.__miniSectorsPerSector - 1):
            f.write((b'\x00' * 64) * (self.__miniSectorsPerSector - (self.__numMinifatSectors & (self.__miniSectorsPerSector - 1))))

    def addEntry(self, path: MSG_PATH, data: Optional[Union[bytes, SupportsBytes]] = None, storage: bool = False, **kwargs) -> None:
        
        path = inputToMsgPath(path)
        
        _dir = self.__getContainingStorage(path, False, True)
        
        
        if path[-1].lower() in map(str.lower, _dir.keys()):
            raise OSError('Cannot add an entry that already exists.')

        
        entry = DirectoryEntry()
        entry.type = DirectoryEntryType.STORAGE if storage else DirectoryEntryType.STREAM
        entry.name = path[-1]
        self.__modifyEntry(entry, data = data, **kwargs)
        if storage:
            _dir[path[-1]] = {'::DirectoryEntry': entry}
        else:
            _dir[path[-1]] = entry

    def addOleEntry(self, path: MSG_PATH, entry: OleDirectoryEntry, data: Optional[Union[bytes, SupportsBytes]] = None) -> None:
        
        path = inputToMsgPath(path)
        
        _dir = self.__getContainingStorage(path, False)
        
        
        if path[-1].lower() in map(str.lower, _dir.keys()):
            raise OSError('Cannot add an entry that already exists.')

        
        newEntry = DirectoryEntry()
        if entry.entry_type == DirectoryEntryType.STORAGE:
            
            
            newEntry.name = entry.name
            newEntry.type = DirectoryEntryType.STORAGE
            newEntry.clsid = _unClsid(entry.clsid)
            newEntry.stateBits = entry.dwUserFlags
            newEntry.creationTime = entry.createTime
            newEntry.modifiedTime = entry.modifyTime

            
            _dir[path[-1]] = {'::DirectoryEntry': newEntry}
        else:
            
            
            newEntry.name = entry.name
            newEntry.type = DirectoryEntryType.STREAM
            newEntry.clsid = _unClsid(entry.clsid)
            newEntry.stateBits = entry.dwUserFlags

            
            data = data or b''
            newEntry.data = bytes(data)
            if len(newEntry.data) > 0x80000000:
                raise ValueError('Current version of extract_msg does not support streams greater than 2 GB in OLE files.')

            
            _dir[path[-1]] = newEntry

        self.__dirEntryCount += 1

    def deleteEntry(self, path) -> None:
        
        path = inputToMsgPath(path)
        
        _dir = self.__getContainingStorage(path)

        
        
        
        
        del _dir[dictGetCasedKey(_dir, path[-1])]

    def editEntry(self, path: MSG_PATH, **kwargs) -> None:
        
        
        entry = self.__getEntry(inputToMsgPath(path))

        
        self.__modifyEntry(entry, **kwargs)

    def fromMsg(self, msg: MSGFile, allowBadEmbed: bool = False) -> None:
        
        
        self.__rootEntry.clsid = _unClsid(msg._getOleEntry('/').clsid)

        
        
        entries = msg.listDir(True, True, False)
        entries.sort(key = len)

        for x in entries:
            entry = msg._getOleEntry(x)
            data = msg.getStream(x) if entry.entry_type == DirectoryEntryType.STREAM else None
            
            
            
            
            
            if x[0] == '__properties_version1.0' and msg.prefixLen > 0:
                if len(data) % 16 != 0:
                    data = data[:24] + b'\x00\x00\x00\x00\x00\x00\x00\x00' + data[24:]
                elif not allowBadEmbed:
                    
                    raise StandardViolationError('Embedded msg file attempted to be extracted that contains a top level properties stream.')
                if allowBadEmbed:
                    
                    if msg.getPropertyVal('340D0003') is None:
                        if msg.areStringsUnicode:
                            
                                data += b'\x03\x00\x0D\x34\x02\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00'
            self.addOleEntry(x, entry, data)

        
        
        if msg.prefixLen > 0:
            
            
            
            try:
                self.addOleEntry('__nameid_version1.0', msg._getOleEntry('__nameid_version1.0', False), None)
            except OSError as e:
                if str(e).startswith('Cannot add an entry'):
                    if allowBadEmbed:
                        return
                    raise StandardViolationError('Embedded msg file attempted to be extracted that contains it\'s own named streams.')
                raise

            
            
            
            gen = (x for x in msg._oleListDir() if len(x) > 1 and x[0] == '__nameid_version1.0')
            for x in gen:
                self.addOleEntry(x, msg._getOleEntry(x, prefix = False), msg.getStream(x, prefix = False))

    def fromOleFile(self, ole: OleFileIO, rootPath: MSG_PATH = []) -> None:
        
        rootPath = inputToMsgPath(rootPath)

        
        if rootPath == []:
            
            self.__rootEntry.clsid = _unClsid(ole.direntries[0].clsid)
            paths = {tuple(x): (x, ole.direntries[ole._find(x)]) for x in ole.listdir(True, True)}
        else:
            
            
            try:
                entry = ole.direntries[ole._find(rootPath)]
                self.__rootEntry.clsid = _unClsid(entry.clsid)

            except OSError as e:
                if str(e) == 'file not found':
                    
                    
                    
                    context = e.__cause__ or e.__context__
                    raise OSError('Root path was not found in the OLE file.') from context
                else:
                    raise

            paths = {tuple(x[len(rootPath):]): (x, ole.direntries[ole._find(x)])
                     for x in ole.listdir(True, True) if len(x) > len(rootPath)}


        
        
        for x in sorted(paths.keys()):
            fullPath, entry = paths[x]

            if entry.entry_type == DirectoryEntryType.STREAM:
                with ole.openstream(fullPath) as f:
                    data = f.read()
            else:
                data = None

            self.addOleEntry(x, entry, data)

    def getEntry(self, path: MSG_PATH) -> DirectoryEntry:
        
        return copy.copy(self.__getEntry(inputToMsgPath(path)))

    def listItems(self, streams: bool = True, storages: bool = False) -> List[List[str]]:
        
        
        
        
        
        
        
        
        if not streams and not storages:
            return []

        paths = []
        for currentDir, stor, stre in self.walk():
            if storages:
                for name in stor:
                    paths.append(currentDir + [name])
            if streams:
                for name in stre:
                    paths.append(currentDir + [name])

        paths.sort()
        return paths

    def renameEntry(self, path: MSG_PATH, newName: str) -> None:
        
        
        if not isinstance(newName, str):
            raise ValueError('New name must be a string.')
        if constants.re.INVALID_OLE_PATH.search(newName):
            raise ValueError('Invalid character(s) in new name. Must not contain the following characters: \\//!:')
        if len(newName) > 31:
            raise ValueError('New name must be less than 32 characters.')

        
        _dir = self.__getContainingStorage(inputToMsgPath(path))

        
        if newName.lower() in map(str.lower, _dir.keys()):
            raise OSError('An entry with the new name already exists.')

        
        originalName = dictGetCasedKey(_dir, path[-1])

        
        entry = _dir[originalName]
        if isinstance(entry, dict):
            dirData = entry
            entry = entry['::DirectoryEntry']
        else:
            dirData = None

        
        entry.name = newName

        
        
        del _dir[originalName]

        if dirData is None:
            _dir[newName] = entry
        else:
            _dir[newName] = dirData

    def walk(self) -> Iterator[Tuple[List[str], List[str], List[str]]]:
        
        toProcess = [([], self.__dirEntries)]

        
        
        while toProcess:
            currentDir, dirDict = toProcess.pop()
            storages = []
            streams = []
            for name in sorted(dirDict.keys(), key = str.lower):
                if not name.startswith('::'):
                    if isinstance(dirDict[name], dict):
                        storages.append(name)
                        toProcess.append((currentDir + [name], dirDict[name]))
                    else:
                        streams.append(name)

            yield (currentDir, storages, streams)

    def write(self, path) -> None:
        
        opened = False

        
        if hasattr(path, 'write') and hasattr(path.write, '__call__'):
            f = path
        else:
            f = open(path, 'wb')
            opened = True

        
        
        try:
            
            
            offset = self._writeBeginning(f)
            entries = self._writeDirectoryEntries(f, offset)
            self._writeMini(f, entries)
            self._writeFinal(f)
        finally:
            self._cleanupEntries()

            if opened:
                f.close()



def _unClsid(clsid: str) -> bytes:
    
    if not clsid:
        return b''
    clsid = clsid.replace('-', '')
    try:
        return bytes((
            int(clsid[6:8], 16),
            int(clsid[4:6], 16),
            int(clsid[2:4], 16),
            int(clsid[0:2], 16),
            int(clsid[10:12], 16),
            int(clsid[8:10], 16),
            int(clsid[14:16], 16),
            int(clsid[12:14], 16),
            int(clsid[16:18], 16),
            int(clsid[18:20], 16),
            int(clsid[20:22], 16),
            int(clsid[22:24], 16),
            int(clsid[24:26], 16),
            int(clsid[26:28], 16),
            int(clsid[28:30], 16),
            int(clsid[30:32], 16),
        ))
    except Exception:
        raise
