

__all__ = [
    'variableByteDecode',
    'variableByteEncode',
]


import codecs

from typing import Dict, Tuple


def createVBEncoding(codecName: str, decodingTable: Dict[int, str]) -> codecs.CodecInfo:
    
    
    
    
    encodingTable = {
        value: bytes((key,)) if key < 256 else bytes((key >> 8, key & 0xFF))
        for key, value in reversed(decodingTable.items()) if value is not None
    }

    
    class Codec(codecs.Codec):
        def encode(self, text, errors='strict'):
            return variableByteEncode(codecName, text, errors, encodingTable)

        def decode(self, data, errors='strict'):
            return variableByteDecode(codecName, data, errors, decodingTable)

    class IncrementalEncoder(codecs.IncrementalEncoder):
        def encode(self, text, final=False):
            return variableByteEncode(codecName, text, self.errors, encodingTable)[0]

    class IncrementalDecoder(codecs.IncrementalDecoder):
        def decode(self, data, final=False):
            return variableByteDecode(codecName, data, self.errors, decodingTable)[0]

    class StreamWriter(Codec, codecs.StreamWriter):
        pass

    class StreamReader(Codec, codecs.StreamReader):
        pass

    
    return codecs.CodecInfo(
        name=codecName,
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamwriter=StreamWriter,
        streamreader=StreamReader,
    )


def createSBEncoding(codecName: str, decodingTable: Dict[int, str]) -> codecs.CodecInfo:
    
    
    
    
    encodingTable = {
        value: bytes((key,))
        for key, value in reversed(decodingTable.items()) if value is not None
    }

    
    class Codec(codecs.Codec):
        def encode(self, text, errors='strict'):
            return singleByteEncode(codecName, text, errors, encodingTable)

        def decode(self, data, errors='strict'):
            return singleByteDecode(codecName, data, errors, decodingTable)

    class IncrementalEncoder(codecs.IncrementalEncoder):
        def encode(self, text, final=False):
            return singleByteEncode(codecName, text, self.errors, encodingTable)[0]

    class IncrementalDecoder(codecs.IncrementalDecoder):
        def decode(self, data, final=False):
            return singleByteDecode(codecName, data, self.errors, decodingTable)[0]

    class StreamWriter(Codec, codecs.StreamWriter):
        pass

    class StreamReader(Codec, codecs.StreamReader):
        pass

    
    return codecs.CodecInfo(
        name=codecName,
        encode=Codec().encode,
        decode=Codec().decode,
        incrementalencoder=IncrementalEncoder,
        incrementaldecoder=IncrementalDecoder,
        streamwriter=StreamWriter,
        streamreader=StreamReader,
    )


def singleByteDecode(codecName: str, data, errors: str, decodeTable: Dict[int, str]) -> Tuple[str, int]:
    
    if len(data) == 0:
        return ('', 0)

    errorHandler = codecs.lookup_error(errors)
    output = ''

    iterator = enumerate(data)
    start = 0

    for start, byte in iterator:
        if byte in decodeTable:
            output += decodeTable[byte]
        else:
            err = UnicodeDecodeError(codecName,
                                     data,
                                     start,
                                     start + 1,
                                     'character maps to <undefined>',
                                     )
            rep = errorHandler(err)
            output += rep[0]
            for _ in range(rep[1] - start - 1):
                try:
                    next(iterator)
                except StopIteration:
                    break

    return (output, len(output))


def singleByteEncode(codecName: str, data, errors: str, encodeTable: Dict[str, bytes]) -> Tuple[bytes, int]:
    
    if len(data) == 0:
        return

    errorHandler = codecs.lookup_error(errors)
    output = b''
    iterator = enumerate(data)
    start = 0
    for start, char in iterator:
        if char in encodeTable:
            output += encodeTable[char]
        else:
            err = UnicodeEncodeError(codecName,
                                     data,
                                     start,
                                     start + 1,
                                     'illegal multibyte sequence',
                                     )
            rep = errorHandler(err)
            output += rep[0]
            
            for _ in range(rep[1] - start - 1):
                try:
                    next(iterator)
                except StopIteration:
                    break



def variableByteDecode(codecName: str, data, errors: str, decodeTable: Dict[int, str]) -> Tuple[str, int]:
    
    if len(data) == 0:
        return ('', 0)

    errorHandler = codecs.lookup_error(errors)
    output = ''

    iterator = enumerate(data)
    start = 0

    for start, byte in iterator:
        
        if byte < 0x80:
            if byte in decodeTable:
                output += decodeTable[byte]
            else:
                err = UnicodeDecodeError(codecName,
                                         data,
                                         start,
                                         start + 1,
                                         'character maps to <undefined>',
                                        )
                rep = errorHandler(err)
                output += rep[0]
                
                for _ in range(rep[1] - start - 1):
                    try:
                        next(iterator)
                    except StopIteration:
                        break
        elif byte not in decodeTable:
            err = UnicodeDecodeError(codecName,
                                     data,
                                     start,
                                     start + 1,
                                     'invalid start byte',
                                    )
            rep = errorHandler(err)
            output += rep[0]
            
            for _ in range(rep[1] - start - 1):
                try:
                    next(iterator)
                except StopIteration:
                    break

        else:
            try:
                byte = (byte << 8) | next(iterator)[1]
                if byte in decodeTable:
                    output += decodeTable[byte]
                else:
                    err = UnicodeDecodeError(codecName,
                                             data,
                                             start,
                                             start + 2,
                                             'character maps to <undefined>',
                                             )
                    rep = errorHandler(err)
                    output += rep[0]
                    
                    for _ in range(rep[1] - start - 1):
                        next(iterator)
            except StopIteration:
                err = UnicodeDecodeError(codecName,
                                         data,
                                         start,
                                         start + 1,
                                         'unexpected end of data',
                                         )
                rep = errorHandler(err)
                output += rep[0]
                break
                
    return (output, start)


def variableByteEncode(codecName: str, data, errors: str, encodeTable: Dict[str, bytes]) -> Tuple[bytes, int]:
    
    if len(data) == 0:
        return

    errorHandler = codecs.lookup_error(errors)
    output = b''
    iterator = enumerate(data)
    start = 0

    for start, char in iterator:
        if char in encodeTable:
            data += encodeTable[char]
        else:
            err = UnicodeEncodeError(codecName,
                                     data,
                                     start,
                                     start + 1,
                                     'illegal multibyte sequence',
                                     )
            rep = errorHandler(err)
            output += rep[0]
            
            for _ in range(rep[1] - start - 1):
                try:
                    next(iterator)
                except StopIteration:
                    break

    return (output, start + 1)
