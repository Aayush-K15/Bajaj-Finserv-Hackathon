from __future__ import annotations


__all__ = [
    'AddressBookEntryID',
    'ContactAddressEntryID',
    'EntryID',
    'FolderEntryID',
    'MessageEntryID',
    'NNTPNewsgroupFolderEntryID',
    'OneOffRecipient',
    'PermanentEntryID',
    'PersonalDistributionListEntryID',
    'StoreObjectEntryID',
    'WrappedEntryID',
]


import abc
import logging

from typing import Optional, Union

from ._helpers import BytesReader
from .. import constants
from ..enums import (
        AddressBookType, ContactAddressIndex, DisplayType, EntryIDType,
        MacintoshEncoding, MessageFormat, MessageType, OORBodyFormat,
        WrappedType
    )
from ..exceptions import FeatureNotImplemented
from ..utils import bitwiseAdjustedAnd, bytesToGuid


logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())



class EntryID(abc.ABC):
    

    @classmethod
    def autoCreate(cls, data: Optional[bytes]) -> Optional[EntryID]:
        
        if not data:
            return None

        if len(data) < 20:
            raise ValueError('Cannot create an EntryID with less than 20 bytes.')
        providerUID = data[4:20]
        try:
            providerUID = EntryIDType(providerUID)
        except ValueError:
            raise ValueError(f'Unrecognized UID "{"".join(f"{x:02X}" for x in providerUID)}". You should probably report this to the developers.') from None

        
        if providerUID == EntryIDType.ADDRESS_BOOK_RECIPIENT:
            return AddressBookEntryID(data)
        if providerUID == EntryIDType.CA_OR_PDL_RECIPIENT:
            
            if data[24:28] not in (b'\x04\x00\x00\x00', b'\x05\x00\x00\x00'):
                raise ValueError(f'Found Entry ID matching ContactAddress or PersonalDistributionList but the type was invalid ({data[24:28]}).')
            if data[24] == 4:
                return ContactAddressEntryID(data)
            else:
                return PersonalDistributionListEntryID(data)
        if providerUID == EntryIDType.NNTP_NEWSGROUP_FOLDER:
            
            
            
            if data[20] == 0xC:
                return NNTPNewsgroupFolderEntryID(data)
            else:
                return StoreObjectEntryID(data)
        if providerUID == EntryIDType.ONE_OFF_RECIPIENT:
            return OneOffRecipient(data)
        if providerUID == EntryIDType.PUBLIC_MESSAGE_STORE:
            if len(data) == 46:
                return FolderEntryID(data)
            else:
                return MessageEntryID(data)
        if providerUID == EntryIDType.WRAPPED:
            return WrappedEntryID(data)

        raise FeatureNotImplemented(f'UID for EntryID found in database, but no class was specified for it: {providerUID}')

    def __init__(self, data: bytes):
        self.__flags = data[:4]
        self.__providerUID = data[4:20]
        self.__rawData = data

    def __bytes__(self) -> bytes:
        return self.toBytes()

    def toBytes(self) -> bytes:
        return self.__rawData

    @property
    def flags(self) -> bytes:
        
        return self.__flags

    @property
    def entryIDType(self) -> Union[EntryIDType, bytes]:
        
        try:
            return EntryIDType(self.__providerUID)
        except ValueError:
            return self.__providerUID

    @property
    def longTerm(self) -> bool:
        
        return self.__flags == b'\x00\x00\x00\x00'

    @property
    @abc.abstractmethod
    def position(self) -> int:
        

    @property
    def providerUID(self) -> bytes:
        
        return self.__providerUID




class AddressBookEntryID(EntryID):
    

    def __init__(self, data: bytes):
        super().__init__(data)
        reader = BytesReader(data[20:])
        
        self.__version = reader.readUnsignedInt()
        if self.__version != 1:
            raise ValueError(f'Version must be 1 on address book entry IDs (got {self.__version}).')

        self.__type = AddressBookType(reader.readUnsignedInt())
        self.__X500DN = reader.readByteString()
        self.__position = reader.tell() + 20

    @property
    def position(self) -> int:
        return self.__position

    @property
    def type(self) -> AddressBookType:
        
        return self.__type

    @property
    def version(self) -> int:
        
        return self.__version

    @property
    def X5000DN(self) -> bytes:
        
        return self.__X500DN



class ContactAddressEntryID(EntryID):
    

    def __init__(self, data: bytes):
        super().__init__(data)
        reader = BytesReader(data[20:])
        if (version := reader.readUnsignedInt()) != 3:
            raise ValueError(f'Version must be 3 (got {version}).')
        if (type_ := reader.readUnsignedInt()) != 4:
            raise ValueError(f'Type must be 4 (got {type_}).')
        self.__index = ContactAddressIndex(reader.readUnsignedInt())
        self.__entryIdCount = reader.readUnsignedInt()
        self.__entryID = MessageEntryID(reader.read(self.__entryIdCount))
        self.__position = reader.tell() + 20

    @property
    def entryID(self) -> MessageEntryID:
        
        return self.__entryID

    @property
    def entryIDCount(self) -> int:
        
        return self.__entryIdCount

    @property
    def index(self) -> ContactAddressIndex:
        
        return self.__index

    @property
    def position(self) -> int:
        return self.__position



class FolderEntryID(EntryID):
    

    __SIZE__: int = 46

    def __init__(self, data: bytes):
        super().__init__(data)
        reader = BytesReader(data[20:])
        self.__folderType = MessageType(reader.readUnsignedShort())
        self.__databaseGuid = bytesToGuid(reader.read(16))
        
        self.__globalCounter = constants.st.ST_LE_UI64.unpack(reader.read(6) + b'\x00\x00')[0]
        reader.assertNull(2, 'Pad bytes were not 0.')

    @property
    def databaseGuid(self) -> str:
        
        return self.__databaseGuid

    @property
    def folderType(self) -> MessageType:
        
        return self.__folderType

    @property
    def globalCounter(self) -> int:
        
        return self.__globalCounter

    @property
    def position(self) -> int:
        return self.__SIZE__



class MessageEntryID(EntryID):
    

    __SIZE__: int = 70

    def __init__(self, data: bytes):
        super().__init__(data)
        reader = BytesReader(data[20:])
        self.__messageType = MessageType(reader.readUnsignedShort())
        self.__folderDatabaseGuid = bytesToGuid(reader.read(16))
        
        self.__folderGlobalCounter = constants.st.ST_LE_UI64.unpack(reader.read(6) + b'\x00\x00')[0]
        reader.assertNull(2, 'Pad bytes were not 0.')
        self.__messageDatabaseGuid = bytesToGuid(reader.read(16))
        
        self.__messageGlobalCounter = constants.st.ST_LE_UI64.unpack(reader.read(6) + b'\x00\x00')[0]
        reader.assertNull(2, 'Pad bytes were not 0.')
        
        
        

    @property
    def folderDatabaseGuid(self) -> str:
        
        return self.__folderDatabaseGuid

    @property
    def folderGlobalCounter(self) -> int:
        
        return self.__folderGlobalCounter

    @property
    def messageDatabaseGuid(self) -> str:
        
        return self.__messageDatabaseGuid

    @property
    def messageGlobalCounter(self) -> int:
        
        return self.__messageGlobalCounter

    @property
    def messageType(self) -> MessageType:
        
        return self.__messageType

    @property
    def position(self) -> int:
        return self.__SIZE__



class NNTPNewsgroupFolderEntryID(EntryID):
    

    def __init__(self, data: bytes):
        super().__init__(data)
        reader = BytesReader(data[20:])
        self.__folderType = reader.readUnsignedShort()
        if self.__folderType != 0x000C:
            raise ValueError(f'Folder type was not 0x000C (got {self.__folderType})')
        self.__newsgroupName = reader.readByteString()
        self.__position = reader.tell() + 20

    @property
    def folderType(self) -> int:
        
        return self.__folderType

    @property
    def newsgroupName(self) -> bytes:
        
        return self.__newsgroupName

    @property
    def position(self) -> int:
        return self.__position



class OneOffRecipient(EntryID):
    

    def __init__(self, data: bytes):
        super().__init__(data)
        
        reader = BytesReader(data[20:])
        self.__version = reader.readUnsignedShort()
        
        
        flagsThing = reader.readUnsignedShort()

        
        
        
        
        
        
        
        
        
        
        

        self.__macintoshEncoding = MacintoshEncoding(bitwiseAdjustedAnd(flagsThing, 0xC))
        self.__format = OORBodyFormat(bitwiseAdjustedAnd(flagsThing, 0x1E))
        
        
        self.__messageFormat = MessageFormat(bitwiseAdjustedAnd(flagsThing, 0x1))
        
        self.__stringFormatUnicode = bitwiseAdjustedAnd(flagsThing, 0x8000) == 1
        self.__canLookup = bitwiseAdjustedAnd(flagsThing, 0x1000) == 0
        if self.__stringFormatUnicode:
            self.__displayName = reader.readUtf16String()
            self.__addressType = reader.readUtf16String()
            self.__emailAddress = reader.readUtf16String()
        else:
            
            
            
            
            self.__displayName = reader.readByteString()
            self.__addressType = reader.readByteString()
            self.__emailAddress = reader.readByteString()

        self.__position = reader.tell() + 20

    @property
    def addressType(self) -> Union[str, bytes]:
        
        return self.__addressType

    @property
    def areStringUnicode(self) -> bool:
        
        return self.__stringFormatUnicode

    @property
    def canLookup(self) -> bool:
        
        return self.__canLookup

    @property
    def displayName(self) -> Union[str, bytes]:
        
        return self.__displayName

    @property
    def emailAddress(self) -> Union[str, bytes]:
        
        return self.__emailAddress

    @property
    def format(self) -> OORBodyFormat:
        
        return self.__format

    @property
    def macintoshEncoding(self) -> MacintoshEncoding:
        
        return self.__macintoshEncoding

    @property
    def messageFormat(self) -> MessageFormat:
        
        return self.__messageFormat

    @property
    def position(self) -> int:
        return self.__position



class PermanentEntryID(EntryID):
    

    def __init__(self, data: bytes):
        super().__init__(data)
        reader = BytesReader(data)
        unpacked = reader.readStruct(constants.st.ST_PEID)
        if unpacked[0] != 0:
            raise TypeError(f'Not a PermanentEntryID (expected 0, got {unpacked[0]}).')
        self.__displayTypeString = DisplayType(unpacked[2])
        self.__distinguishedName = reader.readAsciiString()
        self.__position = reader.tell()

    @property
    def displayTypeString(self) -> DisplayType:
        
        return self.__displayTypeString

    @property
    def distinguishedName(self) -> str:
        
        return self.__distinguishedName

    @property
    def position(self) -> int:
        return self.__position



class PersonalDistributionListEntryID(EntryID):
    

    def __init__(self, data: bytes):
        super().__init__(data)
        reader = BytesReader(data[20:])
        if (arg := reader.readUnsignedInt()) != 3:
            raise ValueError(f'Version must be 3 (got {arg}).')
        if (arg := reader.readUnsignedInt()) != 5:
            raise ValueError(f'Type must be 5 (got {arg}).')
        if (arg := reader.readUnsignedInt()) != 0xFF:
            raise ValueError(f'Index must be 255 (got {arg}).')
        self.__entryIdCount = reader.readUnsignedInt()
        self.__entryID = MessageEntryID(reader.read(self.__entryIdCount))
        self.__position = reader.tell() + 20

    @property
    def entryID(self) -> MessageEntryID:
        
        return self.__entryID

    @property
    def entryIDCount(self) -> int:
        
        return self.__entryIdCount

    @property
    def position(self) -> int:
        return self.__position



class StoreObjectEntryID(EntryID):
    

    def __init__(self, data: bytes):
        super().__init__(data)
        reader = BytesReader(data[20:])

        self.__version = reader.readUnsignedByte()
        if self.__version != 0:
            raise ValueError(f'Version was not set to 0 (got {self.__version}).')

        self.__flag = reader.readUnsignedByte()
        if self.__flag != 0:
            raise ValueError(f'Flag was not set to 0 (got {self.__flag}).')

        self.__dllFileName = reader.read(14)

        self.__wrappedFlags = reader.readUnsignedInt()
        if self.__wrappedFlags != 0:
            raise ValueError(f'Wrapped flags was not set to 0 (got {self.__wrappedFlags}).')

        self.__wrappedProviderUID = reader.read(16)
        self.__wrappedType = WrappedType(reader.readUnsignedInt())
        
        
        self.__serverShortname = reader.readByteString()
        if self.__wrappedProviderUID == b'\x1B\x55\xFA\x20\xAA\x66\x11\xCD\x9B\xC8\x00\xAA\x00\x2F\xC4\x5A':
            self.__mailboxDN = reader.readAsciiString()
        else:
            self.__mailboxDN = None

        self.__position = reader.tell() + 20

    @property
    def dllFileName(self) -> bytes:
        
        return self.__dllFileName

    @property
    def flag(self) -> int:
        return self.__flag

    @property
    def mailboxDN(self) -> Optional[str]:
        
        return self.__mailboxDN

    @property
    def position(self) -> int:
        return self.__position

    @property
    def serverShortname(self) -> bytes:
        
        return self.__serverShortname

    @property
    def version(self) -> int:
        return self.__version

    @property
    def wrappedProviderUID(self) -> bytes:
        return self.__wrappedProviderUID

    @property
    def wrappedType(self) -> WrappedType:
        
        return self.__wrappedType



class WrappedEntryID(EntryID):
    

    def __init__(self, data: bytes):
        super().__init__(data)
        
        self.__type = data[20]
        bits = self.__type & 0xF
        if bits == 0:
            self.__embeddedEntryID = OneOffRecipient(data[21:])
        elif bits == 3 or bits == 4:
            self.__embeddedEntryID = MessageEntryID(data[21:])
        elif bits == 5 or bits == 6:
            self.__embeddedEntryID = AddressBookEntryID(data[21:])
        else:
            raise ValueError(f'Found wrapped entry id with invalid type (type bits were {bits}).')

        self.__embeddedIsOneOff = self.__type & 0x80 == 0
        self.__position = 21 + self.__embeddedEntryID.position

    @property
    def embeddedEntryID(self) -> EntryID:
        
        return self.__embeddedEntryID

    @property
    def embeddedIsOneOff(self) -> bool:
        
        return self.__embeddedIsOneOff

    @property
    def position(self) -> int:
        return self.__position

    @property
    def type(self) -> int:
        
        return self.__type
