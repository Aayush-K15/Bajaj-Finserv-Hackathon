

__all__ = [
    'BytesReader',
]


import io
import struct

from typing import Any, Optional, Tuple, Type, TypeVar, Union

from .. import constants

_T = TypeVar('_T')


class BytesReader(io.BytesIO):
    

    def __init__(self, *args, littleEndian: bool = True, **kwargs):
        super().__init__(*args, **kwargs)
        self.__le = bool(littleEndian)
        if self.__le:
            self.__int8_t = constants.st.ST_LE_I8
            self.__int16_t = constants.st.ST_LE_I16
            self.__int32_t = constants.st.ST_LE_I32
            self.__int64_t = constants.st.ST_LE_I64
            self.__uint8_t = constants.st.ST_LE_UI8
            self.__uint16_t = constants.st.ST_LE_UI16
            self.__uint32_t = constants.st.ST_LE_UI32
            self.__uint64_t = constants.st.ST_LE_UI64
            self.__float_t = constants.st.ST_LE_F32
            self.__double_t = constants.st.ST_LE_F64
        else:
            self.__int8_t = constants.st.ST_BE_I8
            self.__int16_t = constants.st.ST_BE_I16
            self.__int32_t = constants.st.ST_BE_I32
            self.__int64_t = constants.st.ST_BE_I64
            self.__uint8_t = constants.st.ST_BE_UI8
            self.__uint16_t = constants.st.ST_BE_UI16
            self.__uint32_t = constants.st.ST_BE_UI32
            self.__uint64_t = constants.st.ST_BE_UI64
            self.__float_t = constants.st.ST_BE_F32
            self.__double_t = constants.st.ST_BE_F64

    def _readDecodedString(self, encoding: str, width: int = 1) -> str:
        
        position = self.tell()
        try:
            return self.readByteString(width).decode(encoding)
        except Exception:
            while self.tell() != position:
                self.seek(position)
            raise

    def assertNull(self, length: int, errorMsg: Optional[str] = None) -> bytes:
        
        
        if length == 0:
            return b''

        valueRead = self.tryReadBytes(length)
        if valueRead:
            if sum(valueRead) != 0:
                errorMsg = errorMsg or 'Bytes read were not all null.'
                raise ValueError(errorMsg)
        else:
            raise IOError('Not enough bytes left in buffer.')

        return valueRead

    def assertRead(self, value: bytes, errorMsg: Optional[str] = None) -> bytes:
        
        
        if len(value) == 0:
            return b''

        if not isinstance(value, bytes): 
            raise TypeError(':param value: was not bytes.')

        valueRead = self.tryReadBytes(len(value))
        if valueRead:
            if valueRead != value:
                errorMsg = errorMsg or 'Value did not match (expected {expected}, got {actual}).'
                raise ValueError(errorMsg.format(expected = value, actual = valueRead))
        else:
            raise IOError('Not enough bytes left in buffer.')

        return valueRead

    def readAnsiString(self) -> str:
        
        return self._readDecodedString('ansi')

    def readAsciiString(self) -> str:
        
        return self._readDecodedString('ascii')

    def readByte(self) -> int:
        
        value = self.tryReadBytes(1)
        if value:
            return self.__int8_t.unpack(value)[0]
        else:
            raise IOError('Not enough bytes left in buffer.')

    def readByteString(self, width: int = 1) -> bytes:
        
        if width < 1:
            raise ValueError('Character width must be at least 1.')

        position = self.tell()
        string = b''
        null = b'\x00' * width

        while True:
            nextChar = self.read(width)
            if nextChar == b'':
                
                
                while self.tell() != position:
                    self.seek(position)
                raise IOError('Could not find null character.')
            elif nextChar == null:
                
                return string
            else:
                
                string += nextChar

    def readClass(self, _class: Type[_T]) -> _T:
        
        if not hasattr(_class, '__SIZE__'):
            raise TypeError('Argument to readClass MUST have a __SIZE__ attribute.')
        value = self.tryReadBytes(_class.__SIZE__)
        if value:
            return _class(value)
        else:
            raise IOError('Not enough bytes left in buffer.')

    def readDouble(self) -> float:
        
        value = self.tryReadBytes(8)
        if value:
            return self.__double_t.unpack(value)[0]
        else:
            raise IOError('Not enough bytes left in buffer.')

    def readFloat(self) -> float:
        
        value = self.tryReadBytes(4)
        if value:
            return self.__float_t.unpack(value)[0]
        else:
            raise IOError('Not enough bytes left in buffer.')

    def readInt(self) -> int:
        
        value = self.tryReadBytes(4)
        if value:
            return self.__int32_t.unpack(value)[0]
        else:
            raise IOError('Not enough bytes left in buffer.')

    def readLong(self) -> int:
        
        value = self.tryReadBytes(8)
        if value:
            return self.__int64_t.unpack(value)[0]
        else:
            raise IOError('Not enough bytes left in buffer.')

    def readShort(self) -> int:
        
        value = self.tryReadBytes(2)
        if value:
            return self.__int16_t.unpack(value)[0]
        else:
            raise IOError('Not enough bytes left in buffer.')

    def readStruct(self, _struct: Union[struct.Struct, Any]) -> Tuple[Any, ...]:
        
        value = self.tryReadBytes(_struct.size)
        if value:
            return _struct.unpack(value)
        else:
            raise IOError('Not enough bytes left in buffer.')

    def readUnsignedByte(self) -> int:
        
        value = self.tryReadBytes(1)
        if value:
            return self.__uint8_t.unpack(value)[0]
        else:
            raise IOError('Not enough bytes left in buffer.')

    def readUnsignedInt(self) -> int:
        
        value = self.tryReadBytes(4)
        if value:
            return self.__uint32_t.unpack(value)[0]
        else:
            raise IOError('Not enough bytes left in buffer.')

    def readUnsignedLong(self) -> int:
        
        value = self.tryReadBytes(8)
        if value:
            return self.__uint64_t.unpack(value)[0]
        else:
            raise IOError('Not enough bytes left in buffer.')

    def readUnsignedShort(self) -> int:
        
        value = self.tryReadBytes(2)
        if value:
            return self.__uint16_t.unpack(value)[0]
        else:
            raise IOError('Not enough bytes left in buffer.')

    def readUtf8String(self) -> str:
        
        return self._readDecodedString('utf-8')

    def readUtf16String(self) -> str:
        
        return self._readDecodedString('utf-16-le' if self.__le else 'utf-16-be', 2)

    def readUtf32String(self) -> str:
        
        return self._readDecodedString('utf-32-le' if self.__le else 'utf-32-be', 4)

    def tryReadBytes(self, size: int) -> bytes:
        
        if size < 1:
            raise ValueError(':param size: must be at least 1.')
        position = self.tell()
        value = self.read(size)
        if len(value) == size:
            return value

        
        while self.tell() != position:
            self.seek(position)
        return b''
