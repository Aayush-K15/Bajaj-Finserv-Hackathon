from __future__ import annotations


__all__ = [
    'PropertiesStore',
]


import copy
import datetime
import logging
import pprint

from typing import (
        Any, Dict, Iterable, Iterator, List, Optional, Tuple, TypeVar, Union
    )

from .. import constants
from ..enums import PropertiesType
from ..exceptions import NotWritableError
from .prop import createProp, FixedLengthProp, PropBase
from ..utils import divide


logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

_T = TypeVar('_T')


class PropertiesStore:
    

    def __init__(self, data: Optional[bytes], type_: PropertiesType, writable: bool = False):
        
        if not isinstance(type_, PropertiesType):
            raise TypeError(':param type_: MUST be a value of PropertiesType.')

        self.__type = type_

        
        self.__props: Dict[str, PropBase] = {}
        
        
        self.__idMapping: Dict[str, List[str]] = {}
        self.__naid = None
        self.__nrid = None
        self.__ac = None
        self.__rc = None
        self.__writable = writable
        
        self.__isError = True

        
        if not data:
            
            
            
            if writable:
                self.__rawData = b''
                if type_ is not PropertiesType.ATTACHMENT:
                    self.__naid = 0
                    self.__nrid = 0
                    self.__ac = 0
                    self.__rc = 0
            return

        if not isinstance(data, bytes):
            raise TypeError(':param data: MUST be bytes or None.')
        self.__rawData = data

        if type_ == PropertiesType.MESSAGE:
            skip = 32
            self.__nrid, self.__naid, self.__rc, self.__ac = constants.st.ST_PROPSTORE_HEADER.unpack(data[:24])
        elif type_ == PropertiesType.MESSAGE_EMBED:
            skip = 24
            self.__nrid, self.__naid, self.__rc, self.__ac = constants.st.ST_PROPSTORE_HEADER.unpack(data[:24])
        else:
            skip = 8
        streams = divide(self.__rawData[skip:], 16)
        for st in streams:
            if len(st) == 16:
                prop = createProp(st)
                self.__props[prop.name] = prop

                
                id_ = prop.name[:4]
                if id_ not in self.__idMapping:
                    self.__idMapping[id_] = []
                self.__idMapping[id_].append(prop.name)
            else:
                logger.warning(f'Found stream from divide that was not 16 bytes: {st}. Ignoring.')
        self.__isError = False

    def __bytes__(self) -> bytes:
        return self.toBytes()

    def __contains__(self, key: Any) -> bool:
        return self.__props.__contains__(key)

    def __delitem__(self, key: str) -> None:
        

        if not isinstance(key, str):
            raise TypeError('Del operator can only remove a property by string.')

        key = key.upper()

        del self.__props[key]

        
        
        shortKey = key[:4]
        self.__idMapping[shortKey].remove(key)
        if len(self.__idMapping[shortKey]) == 0:
            del self.__idMapping[shortKey]

    def __getitem__(self, key: Union[str, int]) -> PropBase:
        if (found := self._mapId(key)):
            return self.__props.__getitem__(found)
        raise KeyError(key)

    def __iter__(self) -> Iterator[str]:
        return self.__props.__iter__()

    def __len__(self) -> int:
        
        return len(self.__props)

    def __repr__(self) -> str:
        return self.__props.__repr__()

    def _mapId(self, id_: Union[int, str]) -> str:
        
        
        
        if isinstance(id_, str):
            id_ = id_.upper()
            if len(id_) != 4:
                return id_
        elif isinstance(id_, int):
            if id_ >= 0x10000:
                return f'{id_:08X}'
            else:
                id_ = f'{id_:04X}'
        else:
            return ''

        return self.__idMapping.get(id_, ('',))[0]

    def addProperty(self, prop: PropBase, force: bool = False) -> None:
        
        if not (force or self.__writable):
            raise

        if prop.name in self.__props:
            raise KeyError('A property with that name already exists.')
        self.__props[prop.name.upper()] = prop
        self.__idMapping.setdefault(prop.name[:4], list()).append(prop.name.upper())

    def get(self, name: Union[str, int], default: _T = None) -> Union[PropBase, _T]:
        
        if (name := self._mapId(name)):
            return self.__props.get(name, default)
        else:
            return default

    def getProperties(self, id_: Union[str, int]) -> List[PropBase]:
        
        if isinstance(id_, int):
            if id_ >= 0x10000:
                return []
            else:
                id_ = f'{id_:04X}'
        elif isinstance(id_, str):
            if len(id_) == 4:
                id_ = id_.upper()
            else:
                return []

        return [self[x] for x in self.__idMapping.get(id_, [])]

    def getValue(self, name: Union[str, int], default: _T = None) -> Union[Any, _T]:
        
        if isinstance(name, int):
            if name >= 0x10000:
                name = f'{name:08X}'
            else:
                name = f'{name:04X}'
        if len(name) == 4:
            for prop in self.getProperties(name):
                if isinstance(prop, FixedLengthProp):
                    return prop.value
            return default
        elif len(name) == 8:
            if (prop := self.get(name)):
                if isinstance(prop, FixedLengthProp):
                    return prop.value
                else:
                    return default
            return default
        else:
            raise ValueError('Property name must be an int less than 0x100000000, a 4 character hex string, or an 8 character hex string.')

    def items(self) -> Iterable[Tuple[str, PropBase]]:
        return self.__props.items()

    def keys(self) -> Iterable[str]:
        return self.__props.keys()

    def makeWritable(self) -> PropertiesStore:
        
        if self.__writable:
            return self
        return PropertiesStore(self.__rawData, self.__type, True)

    def pprintKeys(self) -> None:
        
        pprint.pprint(sorted(self.__props.keys()))

    def removeProperty(self, nameOrProp: Union[str, PropBase]) -> None:
        
        if isinstance(nameOrProp, str):
            del self[nameOrProp]
        elif isinstance(nameOrProp, PropBase):
            del self[nameOrProp.name]
        else:
            raise TypeError(f'Cannot remove property using type {type(nameOrProp)}.')

    def toBytes(self) -> bytes:
        if self.__writable:
            
            ret = b'\x00' * 8

            
            if self.__type is not PropertiesType.ATTACHMENT:
                ret += constants.st.ST_PROPSTORE_HEADER.pack(self.__nrid, self.__naid, self.__rc, self.__ac)
                if self.__type is PropertiesType.MESSAGE:
                    ret += b'\x00' * 8

            
            ret += b''.join(bytes(prop) for prop in self.__props.values())

            return ret
        else:
            return self.__rawData

    def values(self) -> Iterable[PropBase]:
        return self.__props.values()

    items.__doc__ = dict.items.__doc__
    keys.__doc__ = dict.keys.__doc__
    values.__doc__ = dict.values.__doc__

    @property
    def attachmentCount(self) -> int:
        
        if self.__ac is None:
            raise TypeError('Attachment properties do not contain an attachment count.')
        return self.__ac

    @attachmentCount.setter
    def attachmentCount(self, value: int) -> None:
        if not self.__writable:
            raise NotWritableError('PropertiesStore object is not writable.')

        if not isinstance(value, int):
            raise TypeError(':property attachmentCount: must be an int.')

        if self.__ac is None:
            raise TypeError('Attachment properties do not contain an attachment count.')

        self.__ac = value

    @property
    def date(self) -> Optional[datetime.datetime]:
        
        try:
            return self.__date
        except AttributeError:
            self.__date = None
            if '00390040' in self:
                dateValue = self.getValue('00390040')
                
                
                if isinstance(dateValue, datetime.datetime):
                    self.__date = dateValue
            return self.__date

    @property
    def isError(self) -> bool:
        
        return self.__isError

    @property
    def nextAttachmentId(self) -> int:
        
        if self.__naid is None:
            raise TypeError('Attachment properties do not contain a next attachment ID.')
        return self.__naid

    @nextAttachmentId.setter
    def nextAttachmentId(self, value: int) -> None:
        if not self.__writable:
            raise NotWritableError('PropertiesStore object is not writable.')

        if not isinstance(value, int):
            raise TypeError(':property nextAttachmentId: must be an int.')

        if self.__ac is None:
            raise TypeError('Attachment properties do not contain a next attachment ID.')

        self.__naid = value

    @property
    def nextRecipientId(self) -> int:
        
        if self.__nrid is None:
            raise TypeError('Attachment properties do not contain a next recipient ID.')
        return self.__nrid

    @nextRecipientId.setter
    def nextRecipientId(self, value: int) -> None:
        if not self.__writable:
            raise NotWritableError('PropertiesStore object is not writable.')

        if not isinstance(value, int):
            raise TypeError(':property nextRecipientId: must be an int.')

        if self.__ac is None:
            raise TypeError('Attachment properties do not contain a next recipient ID.')

        self.__nrid = value

    @property
    def props(self) -> Dict[str, PropBase]:
        
        return copy.deepcopy(self.__props)

    @property
    def recipientCount(self) -> int:
        
        if self.__rc is None:
            raise TypeError('Attachment properties do not contain a recipient count.')
        return self.__rc

    @recipientCount.setter
    def recipientCount(self, value: int) -> None:
        if not self.__writable:
            raise NotWritableError('PropertiesStore object is not writable.')

        if not isinstance(value, int):
            raise TypeError(':property recipientCount: must be an int.')

        if self.__ac is None:
            raise TypeError('Attachment properties do not contain a recipient count.')

        self.__nrid = value

    @property
    def writable(self) -> bool:
        
        return self.__writable
