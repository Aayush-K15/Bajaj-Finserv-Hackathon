from __future__ import annotations


__all__ = [
    'Named',
    'NamedProperties',
    'NamedPropertyBase',
    'NumericalNamedProperty',
    'StringNamedProperty',
]


import abc
import copy
import logging
import pprint
import weakref

from typing import (
        Any, Dict, Iterable, Iterator, List, Optional, Tuple, TYPE_CHECKING,
        TypeVar, Union
    )

from .. import constants
from ..enums import ErrorBehavior, NamedPropertyType
from ..exceptions import InvalidPropertyIdError, StandardViolationError
from ..utils import bytesToGuid, divide, msgPathToString, verifyPropertyId
from compressed_rtf.crc32 import crc32



if TYPE_CHECKING:
    from ..msg_classes.msg import MSGFile
    from ..attachments.attachment_base import AttachmentBase

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

_T = TypeVar('_T')


class Named:
    

    __dir = '__nameid_version1.0'

    def __init__(self, msg: MSGFile):
        self.__msg = weakref.ref(msg)
        
        guidStream = self.getStream('__substg1.0_00020102')
        entryStream = self.getStream('__substg1.0_00030102')
        self.guidStream = guidStream
        self.entryStream = entryStream
        self.namesStream = self.getStream('__substg1.0_00040102')

        self.__propertiesDict: Dict[Tuple[str, str], NamedPropertyBase] = {}

        self.__streamIDDict: Dict[str, Tuple[str, str]] = {}

        if guidStream is None:
            if ErrorBehavior.STANDARDS_VIOLATION in msg.errorBehavior:
                logger.warning('Standards Violation: Guid stream missing from named properties.')
                guidStream = b''
            else:
                raise StandardViolationError('Guid stream missing from named properties.')

        if entryStream is None:
            if ErrorBehavior.STANDARDS_VIOLATION in msg.errorBehavior:
                logger.warning('Standards Violation: Entry stream missing from named properties.')
                entryStream = b''
            else:
                raise StandardViolationError('Entry stream missing from named properties.')

        if self.namesStream is None:
            if ErrorBehavior.STANDARDS_VIOLATION in msg.errorBehavior:
                logger.error('Standards Violation: Guid stream missing from named properties. Will not parse named properties.')
                
                return
            else:
                raise StandardViolationError('Guid stream missing from named properties.')

        
        if entryStream:
            guids = tuple([None, constants.ps.PS_MAPI, constants.ps.PS_PUBLIC_STRINGS] + [bytesToGuid(x) for x in divide(guidStream, 16)])
            entries: List[Dict[str, Any]]= []
            for rawStream in divide(entryStream, 8):
                tmp = constants.st.ST_NP_ENT.unpack(rawStream)
                entry = {
                    'id': tmp[0],
                    'pid': tmp[2],
                    'guid_index': tmp[1] >> 1,
                    'pkind': NamedPropertyType(tmp[1] & 1), 
                    'rawStream': rawStream,
                }
                entry['guid'] = guids[entry['guid_index']]
                entries.append(entry)

            properties: List[NamedPropertyBase] = []

            for entry in entries:
                if entry['pkind'] == NamedPropertyType.STRING_NAMED:
                    name = None
                    try:
                        name = self.__getName(entry['id'])
                    except ValueError as e:
                        if ErrorBehavior.NAMED_NAME_STREAM in msg.errorBehavior:
                            logger.error(f'Dropping named property because it failed to acquire name from name stream: {e}')
                        else:
                            raise

                    if name:
                        properties.append(StringNamedProperty(entry, name))
                else:
                    properties.append(NumericalNamedProperty(entry))

            for property in properties:
                id_ = property.identifier
                self.__propertiesDict[id_] = property
                self.__streamIDDict[property.propertyStreamID] = id_

    def __contains__(self, key) -> bool:
        return key in self.__propertiesDict

    def __getitem__(self, propertyName: Tuple[str, str]) -> NamedPropertyBase:
        
        if not hasattr(propertyName, '__len__') or len(propertyName) != 2:
            raise TypeError('Named property key must be a tuple of two strings.')

        
        propertyName = (propertyName[0].upper(), propertyName[1].upper())
        for key in self.__propertiesDict.keys():
             if propertyName == (key[0].upper(), key[1].upper()):
                    return self.__propertiesDict[key]

        raise KeyError(propertyName)

    def __iter__(self) -> Iterator[Tuple[str, str]]:
        return self.__propertiesDict.__iter__()

    def __len__(self) -> int:
        return self.__propertiesDict.__len__()

    def __getName(self, offset: int) -> str:
        
        
        
        
        if offset & 3 != 0:
            
            
            logger.warning(f'Malformed named properties detected due to bad offset ({offset}). Ignoring.')
        
        if offset > len(self.namesStream):
            raise ValueError('Failed to parse named property: offset was not in string stream.')

        
        length = constants.st.ST_LE_I32.unpack(self.namesStream[offset:offset + 4])[0]
        offset += 4

        
        
        if offset + length > len(self.namesStream):
            raise ValueError(f'Failed to parse named property: length ({length}) of string overflows the string stream. This is probably due to a bad offset.')

        return self.namesStream[offset:offset + length].decode('utf-16-le')

    def exists(self, filename: constants.MSG_PATH) -> bool:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Named instance has been garbage collected.')
        return msg.exists([self.__dir, msgPathToString(filename)], False)

    def get(self, propertyName: Tuple[str, str], default: _T = None) -> Union[NamedPropertyBase, _T]:
        
        try:
            return self[propertyName]
        except KeyError:
            return default

    def getPropNameByStreamID(self, streamID: Union[int, str]) -> Optional[Tuple[str, str]]:
        
        if isinstance(streamID, int):
            if streamID < 0x8000:
                
                
                return None
            if streamID > 0xFFFF:
                raise InvalidPropertyIdError('Stream ID is out of range.')
            streamID = f'{streamID:04X}'
        elif isinstance(streamID, str):
            verifyPropertyId(streamID)
        else:
            raise TypeError(':param streamID: MUST be an int or str.')

        return self.__streamIDDict.get(streamID)

    def getStream(self, filename: constants.MSG_PATH) -> Optional[bytes]:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Named instance has been garbage collected.')
        return msg.getStream([self.__dir, msgPathToString(filename)], False)

    def items(self) -> Iterable[Tuple[Tuple[str, str], NamedPropertyBase]]:
        return self.__propertiesDict.items()

    def keys(self) -> Iterable[Tuple[str, str]]:
        return self.__propertiesDict.keys()

    def pprintKeys(self) -> None:
        
        pprint.pprint(sorted(self.__propertiesDict.keys()))

    def values(self) -> Iterable[NamedPropertyBase]:
        return self.__propertiesDict.values()

    @property
    def dir(self):
        
        return self.__dir

    @property
    def msg(self) -> MSGFile:
        
        if (msg := self.__msg()) is None:
            raise ReferenceError('The MSGFile for this Named instance has been garbage collected.')
        return msg

    @property
    def namedProperties(self) -> Dict[Tuple[str, str], NamedPropertyBase]:
        
        return copy.deepcopy(self.__propertiesDict)



class NamedProperties:
    
    def __init__(self, named: Named, streamSource: Union[MSGFile, AttachmentBase]):
        
        self.__named = named
        self.__streamSource = weakref.ref(streamSource)

    def __getitem__(self, item: Union[Tuple[str, str], NamedPropertyBase]):
        
        if (source := self.__streamSource()) is None:
            raise ReferenceError('The stream source for the NamedProperties instance has been garbage collected.')
        if isinstance(item, NamedPropertyBase):
            return source._getTypedData(item.propertyStreamID)
        else:
            return source._getTypedData(self.__named[item].propertyStreamID)

    def get(self, item: Union[Tuple[str, str], NamedPropertyBase], default: _T = None) -> Union[Any, _T]:
        
        try:
            return self[item]
        except KeyError:
            return default



class NamedPropertyBase(abc.ABC):
    def __init__(self, entry: Dict[str, Any]):
        self.__entry = entry
        self.__guidIndex = entry['guid_index']
        self.__namedPropertyID = entry['pid']
        self.__guid = entry['guid']
        self.__propertyStreamID = f'{0x8000 + self.__namedPropertyID:04X}'

    @property
    def guid(self) -> str:
        
        return self.__guid

    @property
    def guidIndex(self) -> int:
        
        return self.__guidIndex

    @property
    @abc.abstractmethod
    def identifier(self) -> Tuple[str, str]:
        

    @property
    def namedPropertyID(self) -> int:
        
        return self.__namedPropertyID

    @property
    def propertyStreamID(self) -> str:
        
        return self.__propertyStreamID

    @property
    def rawEntry(self) -> Dict[str, Any]:
        return copy.deepcopy(self.__entry)

    @property
    def rawEntryStream(self) -> bytes:
        
        return self.__entry['rawStream']

    @property
    @abc.abstractmethod
    def type(self) -> NamedPropertyType:
        



class StringNamedProperty(NamedPropertyBase):
    def __init__(self, entry: Dict, name: str):
        super().__init__(entry)
        self.__name = name

        
        
        
        
        
        
        
        
        
        
        if self.guid == constants.ps.PS_INTERNET_HEADERS:
            
            
            
            
            
            
            
            
            
            
            self.__streamID = 0x1000 + (crc32(name.lower().encode('utf-16-le')) ^ (self.guidIndex << 1 | 1)) % 0x1F

        else:
            
            self.__streamID = 0x1000 + (crc32(name.encode('utf-16-le')) ^ (self.guidIndex << 1 | 1)) % 0x1F

    @property
    def identifier(self) -> Tuple[str, str]:
        return (self.name, self.guid)

    @property
    def name(self) -> str:
        
        return self.__name

    @property
    def streamID(self) -> int:
        
        return self.__streamID

    @property
    def type(self) -> NamedPropertyType:
        
        return NamedPropertyType.STRING_NAMED



class NumericalNamedProperty(NamedPropertyBase):
    def __init__(self, entry: Dict):
        super().__init__(entry)
        self.__propertyID = f'{entry["id"]:04X}'
        self.__streamID = 0x1000 + (entry['id'] ^ (self.guidIndex << 1)) % 0x1F

    @property
    def identifier(self) -> Tuple[str, str]:
        return (self.propertyID, self.guid)

    @property
    def propertyID(self) -> str:
        
        return self.__propertyID

    @property
    def streamID(self) -> int:
        
        return self.__streamID

    @property
    def type(self) -> NamedPropertyType:
        
        return NamedPropertyType.NUMERICAL_NAMED
