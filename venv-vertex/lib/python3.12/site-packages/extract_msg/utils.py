from __future__ import annotations





__all__ = [
    'addNumToDir',
    'addNumToZipDir',
    'bitwiseAdjust',
    'bitwiseAdjustedAnd',
    'bytesToGuid',
    'ceilDiv',
    'cloneOleFile',
    'createZipOpen',
    'decodeRfc2047',
    'dictGetCasedKey',
    'divide',
    'filetimeToDatetime',
    'filetimeToUtc',
    'findWk',
    'fromTimeStamp',
    'getCommandArgs',
    'guessEncoding',
    'htmlSanitize',
    'inputToBytes',
    'inputToMsgPath',
    'inputToString',
    'isEncapsulatedRtf',
    'makeWeakRef',
    'msgPathToString',
    'parseType',
    'prepareFilename',
    'roundUp',
    'rtfSanitizeHtml',
    'rtfSanitizePlain',
    'setupLogging',
    'stripRtf',
    'tryGetMimetype',
    'unsignedToSignedInt',
    'unwrapMsg',
    'unwrapMultipart',
    'validateHtml',
    'verifyPropertyId',
    'verifyType',
]


import argparse
import collections
import copy
import datetime
import decimal
import email.header
import email.message
import email.policy
import glob
import json
import logging
import logging.config
import os
import pathlib
import re
import shutil
import struct
import sys
import weakref
import zipfile

import bs4
import olefile
import tzlocal

from html import escape as htmlEscape
from typing import (
        Any, AnyStr, Callable, Dict, Iterable, List, Optional, Sequence,
        SupportsBytes, TypeVar, TYPE_CHECKING, Union
    )

from . import constants
from .enums import AttachmentType
from .exceptions import (
        ConversionError, DependencyError, ExecutableNotFound,
        IncompatibleOptionsError, InvalidPropertyIdError, TZError,
        UnknownTypeError
    )



if TYPE_CHECKING:
    from .msg_classes.msg import MSGFile
    from .attachments import AttachmentBase

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())
logging.addLevelName(5, 'DEVELOPER')

_T = TypeVar('_T')


def addNumToDir(dirName: pathlib.Path) -> Optional[pathlib.Path]:
    
    for i in range(2, 100):
        try:
            newDirName = dirName.with_name(dirName.name + f' ({i})')
            os.makedirs(newDirName)
            return newDirName
        except Exception as e:
            pass
    return None


def addNumToZipDir(dirName: pathlib.Path, _zip) -> Optional[pathlib.Path]:
    
    for i in range(2, 100):
        newDirName = dirName.with_name(dirName.name + f' ({i})')
        pathCompare = str(newDirName).rstrip('/') + '/'
        if not any(x.startswith(pathCompare) for x in _zip.namelist()):
            return newDirName
    return None


def bitwiseAdjust(inp: int, mask: int) -> int:
    
    if mask < 1:
        raise ValueError('Mask MUST be greater than 0')
    return inp >> bin(mask)[::-1].index('1')


def bitwiseAdjustedAnd(inp: int, mask: int) -> int:
    
    if mask < 1:
        raise ValueError('Mask MUST be greater than 0')
    return (inp & mask) >> bin(mask)[::-1].index('1')


def bytesToGuid(bytesInput: bytes) -> str:
    
    guidVals = constants.st.ST_GUID.unpack(bytesInput)
    return f'{{{guidVals[0]:08X}-{guidVals[1]:04X}-{guidVals[2]:04X}-{guidVals[3][:2].hex().upper()}-{guidVals[3][2:].hex().upper()}}}'


def ceilDiv(n: int, d: int) -> int:
    
    return -(n // -d)


def cloneOleFile(sourcePath, outputPath) -> None:
    
    from .ole_writer import OleWriter

    with olefile.OleFileIO(sourcePath) as f:
        writer = OleWriter()
        writer.fromOleFile(f)

    writer.write(outputPath)


def createZipOpen(func) -> Callable:
    
    def _open(name, mode = 'r', *args, **kwargs):
        if mode == 'w':
            name = zipfile.ZipInfo(name, datetime.datetime.now().timetuple()[:6])

        return func(name, mode, *args, **kwargs)

    return _open


def decodeRfc2047(encoded: str) -> str:
    
    
    encoded = encoded.replace('\r\n', '')

    
    
    
    
    
    return ''.join(
        x[0].decode(x[1] or 'raw-unicode-escape') if isinstance(x[0], bytes) else x[0]
        for x in email.header.decode_header(encoded)
    )


def dictGetCasedKey(_dict: Dict[str, Any], key: str) -> str:
    
    try:
        return next((x for x in _dict.keys() if x.lower() == key.lower()))
    except StopIteration:
        
        raise KeyError(key)


def divide(string: AnyStr, length: int) -> List[AnyStr]:
    
    return [string[length * x:length * (x + 1)] for x in range(ceilDiv(len(string), length))]


def filetimeToDatetime(rawTime: int) -> datetime.datetime:
    
    try:
        if rawTime < 116444736000000000:
            
            
            return olefile.olefile.filetime2datetime(rawTime)
        elif rawTime == 915151392000000000:
            
            
            
            
            
            from .null_date import NullDate
            date = NullDate(4500, 12, 31, 23, 59)
            date.filetime = rawTime
            return date
        elif rawTime == 915046235400000000:
            return constants.NULL_DATE
        elif rawTime > 915000000000000000:
            
            from .null_date import NullDate
            date = NullDate(1970, 1, 1, 1)
            try:
                date += datetime.timedelta(seconds = filetimeToUtc(rawTime))
            except OverflowError:
                
                
                
                m = date.max
                date = NullDate(m.year, m.month, m.day, m.hour, m.minute, m.second, m.microsecond)
            date.filetime = rawTime

            return date
        else:
            return fromTimeStamp(filetimeToUtc(rawTime))
    except TZError:
        
        raise
    except Exception:
        raise ValueError(f'Timestamp value of {filetimeToUtc(rawTime)} (raw: {rawTime}) caused an exception. This was probably caused by the time stamp being too far in the future.')


def filetimeToUtc(inp: int) -> float:
    
    return (inp - 116444736000000000) / 10000000.0


def findWk(path = None):
    
    if path:
        if os.path.isfile(path):
            
            if os.access(path, os.X_OK):
                return path
            else:
                raise ExecutableNotFound('Path provided was not a valid executable (execution bit not set).')
        else:
            raise ExecutableNotFound('Path provided was not a valid executable (not a file).')

    candidate = shutil.which('wkhtmltopdf')
    if candidate:
        return candidate

    raise ExecutableNotFound('Could not find wkhtmltopdf.')


def fromTimeStamp(stamp: float) -> datetime.datetime:
    
    try:
        tz = tzlocal.get_localzone()
    except Exception:
        
        
        
        raise TZError(f'Error occured using tzlocal. If you are seeing this, this is likely a problem with your installation ot tzlocal or tzdata.')
    return datetime.datetime.fromtimestamp(stamp, tz)


def getCommandArgs(args: Sequence[str]) -> argparse.Namespace:
    
    parser = argparse.ArgumentParser(description = constants.MAINDOC, prog = 'extract_msg')
    outFormat = parser.add_mutually_exclusive_group()
    inputFormat = parser.add_mutually_exclusive_group()
    inputType = parser.add_mutually_exclusive_group(required = True)
    
    parser.add_argument('--use-content-id', '--cid', dest='cid', action='store_true',
                        help='Save attachments by their Content ID, if they have one. Useful when working with the HTML body.')
    
    outFormat.add_argument('--json', dest='json', action='store_true',
                        help='Changes to write output files as json.')
    
    parser.add_argument('--file-logging', dest='fileLogging', action='store_true',
                        help='Enables file logging. Implies --verbose level 1.')
    
    parser.add_argument('-v', '--verbose', dest='verbose', action='count', default=0,
                        help='Turns on console logging. Specify more than once for higher verbosity.')
    
    parser.add_argument('--log', dest='log',
                        help='Set the path to write the file log to.')
    
    parser.add_argument('--config', dest='configPath',
                        help='Set the path to load the logging config from.')
    
    parser.add_argument('--out', dest='outPath',
                        help='Set the folder to use for the program output. (Default: Current directory)')
    
    parser.add_argument('--use-filename', dest='useFilename', action='store_true',
                        help='Sets whether the name of each output is based on the MSG filename.')
    
    parser.add_argument('--dump-stdout', dest='dumpStdout', action='store_true',
                        help='Tells the program to dump the message body (plain text) to stdout. Overrides saving arguments.')
    
    outFormat.add_argument('--html', dest='html', action='store_true',
                        help='Sets whether the output should be HTML. If this is not possible, will error.')
    
    outFormat.add_argument('--pdf', dest='pdf', action='store_true',
                           help='Saves the body as a PDF. If this is not possible, will error.')
    
    parser.add_argument('--wk-path', dest='wkPath',
                        help='Overrides the path for finding wkhtmltopdf.')
    
    parser.add_argument('--wk-options', dest='wkOptions', nargs='*',
                        help='Sets additional options to be used in wkhtmltopdf. Should be a series of options and values, replacing the - or -- in the beginning with + or ++, respectively. For example: --wk-options "+O Landscape"')
    
    parser.add_argument('--prepared-html', dest='preparedHtml', action='store_true',
                        help='When used in conjunction with --html, sets whether the HTML output should be prepared for embedded attachments.')
    
    parser.add_argument('--charset', dest='charset', default='utf-8',
                        help='Character set to use for the prepared HTML in the added tag. (Default: utf-8)')
    
    outFormat.add_argument('--raw', dest='raw', action='store_true',
                           help='Sets whether the output should be raw. If this is not possible, will error.')
    
    outFormat.add_argument('--rtf', dest='rtf', action='store_true',
                           help='Sets whether the output should be RTF. If this is not possible, will error.')
    
    parser.add_argument('--allow-fallback', dest='allowFallback', action='store_true',
                        help='Tells the program to fallback to a different save type if the selected one is not possible.')
    
    parser.add_argument('--skip-body-not-found', dest='skipBodyNotFound', action='store_true',
                        help='Skips saving the body if the body cannot be found, rather than throwing an error.')
    
    parser.add_argument('--zip', dest='zip',
                        help='Path to use for saving to a zip file.')
    
    parser.add_argument('--save-header', dest='saveHeader', action='store_true',
                        help='Store the header in a separate file.')
    
    outFormat.add_argument('--attachments-only', dest='attachmentsOnly', action='store_true',
                           help='Specify to only save attachments from an MSG file.')
    
    parser.add_argument('--skip-hidden', dest='skipHidden', action='store_true',
                        help='Skips any attachment marked as hidden (usually ones embedded in the body).')
    
    parser.add_argument('--no-folders', dest='noFolders', action='store_true',
                        help='Stores everything in the location specified by --out. Requires --attachments-only and is incompatible with --out-name.')
    
    parser.add_argument('--skip-embedded', dest='skipEmbedded', action='store_true',
                        help='Skips all embedded MSG files when saving attachments.')
    
    parser.add_argument('--extract-embedded', dest='extractEmbedded', action='store_true',
                        help='Extracts the embedded MSG files as MSG files instead of running their save functions.')
    
    parser.add_argument('--overwrite-existing', dest='overwriteExisting', action='store_true',
                        help='Disables filename conflict resolution code for attachments when saving a file, causing files to be overwriten if two attachments with the same filename are on an MSG file.')
    
    parser.add_argument('--skip-not-implemented', '--skip-ni', dest='skipNotImplemented', action='store_true',
                        help='Skips any attachments that are not implemented, allowing saving of the rest of the message.')
    
    inputFormat.add_argument('--out-name', dest='outName',
                        help='Name to be used with saving the file output. Cannot be used if you are saving more than one file.')
    
    inputFormat.add_argument('--glob', '--wildcard', dest='glob', action='store_true',
                        help='Interpret all paths as having wildcards. Incompatible with --out-name.')
    
    parser.add_argument('--ignore-rtfde', dest='ignoreRtfDeErrors', action='store_true',
                        help='Ignores all errors thrown from RTFDE when trying to save. Useful for allowing fallback to continue when an exception happens.')
    
    parser.add_argument('--progress', dest='progress', action='store_true',
                        help='Shows what file the program is currently working on during it\'s progress.')
    
    inputType.add_argument('-s', '--stdin', dest='stdin', action='store_true',
                        help='Read file from stdin (only works with one file at a time).')
    
    inputType.add_argument('msgs', metavar='msg', nargs='*', default=[],
                        help='An MSG file to be parsed.')

    options = parser.parse_args(args)

    if options.stdin:
        
        options.msgs.append(sys.stdin.buffer.read())

    if options.outName and options.noFolders:
        raise IncompatibleOptionsError('--out-name is not compatible with --no-folders.')

    if options.fileLogging:
        options.verbose = options.verbose or 1

    
    if options.wkOptions:
        wkOptions = []
        for option in options.wkOptions:
            if option.startswith('++'):
                option = '--' + option[2:]
            elif option.startswith('+'):
                option = '-' + option[1:]

            
            
            split = option.split(' ')
            if len(split) == 1:
                
                wkOptions.append(option)
            else:
                wkOptions.append(split[0])
                wkOptions.append(' '.join(split[1:]))

        options.wkOptions = wkOptions

    
    
    
    if options.dumpStdout:
        options.outPath = None
        options.json = False
        options.rtf = False
        options.html = False
        options.useFilename = False
        options.cid = False

    if options.glob:
        if options.outName:
            raise IncompatibleOptionsError('--out-name is not supported when using wildcards.')
        if options.stdin:
            raise IncompatibleOptionsError('--stdin is not supported with using wildcards.')
        fileLists = []
        for path in options.msgs:
            fileLists += glob.glob(path)

        if len(fileLists) == 0:
            raise ValueError('Could not find any MSG files using the specified wildcards.')
        options.msgs = fileLists

    
    if options.outName and len(options.msgs) > 1:
        raise IncompatibleOptionsError('--out-name is not supported when saving multiple MSG files.')

    
    if options.verbose == 0:
        options.logLevel = logging.ERROR
    elif options.verbose == 1:
        options.logLevel = logging.WARNING
    elif options.verbose == 2:
        options.logLevel = logging.INFO
    else:
        options.logLevel = 5

    
    if options.noFolders and not options.attachmentsOnly:
        raise ValueError('--no-folders requires the --attachments-only option.')

    return options


def guessEncoding(msg: MSGFile) -> Optional[str]:
    
    try:
        import chardet
    except ImportError:
        raise DependencyError('Cannot guess the encoding of an MSG file if chardet is not installed.')

    data = b''
    for name in (x[0] for x in msg.listDir(True, False, False) if len(x) == 1):
        if name.lower().endswith('001f'):
            
            return 'utf-16-le'
        elif name.lower().endswith('001e'):
            data += msg.getStream(name) + b'\n'

    try:
        if not data or (result := chardet.detect(data))['confidence'] < 0.5:
            return None

        return result['encoding']
    except Exception as e:
        raise DependencyError(f'Failed to detect encoding: {e}')


def htmlSanitize(inp: str) -> str:
    
    
    inp = htmlEscape(inp)

    
    inp = inp.replace('\r\n', '\n').replace('\n', '<br/>')

    
    inp = constants.re.HTML_SAN_SPACE.sub((lambda spaces: '&nbsp;' * len(spaces.group(0))),inp)

    return inp


def inputToBytes(obj: Union[bytes, None, str, SupportsBytes], encoding: str) -> bytes:
    
    if isinstance(obj, bytes):
        return obj
    if isinstance(obj, str):
        return obj.encode(encoding)
    if obj is None:
        return b''
    if hasattr(obj, '__bytes__'):
        return bytes(obj)

    raise ConversionError('Cannot convert to bytes.')


def inputToMsgPath(inp: constants.MSG_PATH) -> List[str]:
    
    if isinstance(inp, (list, tuple)):
        inp = '/'.join(inp)

    inp = inputToString(inp, 'utf-8')

    
    
    
    if ':' in inp or '!' in inp:
        raise ValueError('Illegal character ("!" or ":") found in MSG path.')

    ret = [x for x in inp.replace('\\', '/').split('/') if x]

    
    
    if any(len(x) > 31 for x in ret):
        raise ValueError('Path segments must not be greater than 31 characters.')
    return ret


def inputToString(bytesInputVar: Optional[Union[str, bytes]], encoding: str) -> str:
    
    if isinstance(bytesInputVar, str):
        return bytesInputVar
    elif isinstance(bytesInputVar, bytes):
        return bytesInputVar.decode(encoding)
    elif bytesInputVar is None:
        return ''
    else:
        raise ConversionError('Cannot convert to str type.')


def isEncapsulatedRtf(inp: bytes) -> bool:
    
    return b'\\fromhtml' in inp


def makeWeakRef(obj: Optional[_T]) -> Optional[weakref.ReferenceType[_T]]:
    
    if obj is None:
        return None
    else:
        return weakref.ref(obj)


def minutesToDurationStr(minutes: int) -> str:
    
    if minutes == 0:
        return '0 hours'
    elif minutes == 1:
        return '1 minute'
    elif minutes < 60:
        return f'{minutes} minutes'
    elif minutes == 60:
        return '1 hour'
    elif minutes % 60 == 0:
        return f'{minutes // 60} hours'
    elif minutes < 120:
        if minutes == 61:
            return f'1 hour 1 minute'
        else:
            return f'1 hour {minutes - 60} minutes'
    elif minutes % 60 == 1:
        return f'{minutes // 60} hours 1 minute'
    else:
        return f'{minutes // 60} hours {minutes % 60} minutes'


def msgPathToString(inp: Union[str, Iterable[str]]) -> str:
    
    if not isinstance(inp, str):
        inp = '/'.join(inp)
    return inp.replace('\\', '/')


def parseType(_type: int, stream: Union[int, bytes], encoding: str, extras: Sequence[bytes]):
    
    
    value = stream
    lengthExtras = len(extras)
    if _type == 0x0000:  
        pass
    elif _type == 0x0001:  
        if value != b'\x00\x00\x00\x00\x00\x00\x00\x00':
            
            logger.warning('Property type is PtypNull, but is not equal to 0.')
        return None
    elif _type == 0x0002:  
        return constants.st.ST_LE_UI16.unpack(value[:2])[0]
    elif _type == 0x0003:  
        return constants.st.ST_LE_UI32.unpack(value[:4])[0]
    elif _type == 0x0004:  
        return constants.st.ST_LE_F32.unpack(value[:4])[0]
    elif _type == 0x0005:  
        return constants.st.ST_LE_F64.unpack(value)[0]
    elif _type == 0x0006:  
        return decimal.Decimal((constants.st.ST_LE_I64.unpack(value))[0]) / 10000
    elif _type == 0x0007:  
        value = constants.st.ST_LE_F64.unpack(value)[0]
        return constants.PYTPFLOATINGTIME_START + datetime.timedelta(days = value)
    elif _type == 0x000A:  
        from .enums import ErrorCode, ErrorCodeType
        value = constants.st.ST_LE_UI32.unpack(value[:4])[0]
        try:
            value = ErrorCodeType(value)
        except ValueError:
            logger.warning(f'Error type found that was not from Additional Error Codes. Value was {value}. You should report this to the developers.')
            
            
            
            try:
                logger.warning(f'REPORT TO DEVELOPERS: Error type of {ErrorCode(value)} was found.')
            except ValueError:
                pass
        return value
    elif _type == 0x000B:  
        return constants.st.ST_LE_UI16.unpack(value[:2])[0] != 0
    elif _type == 0x000D:  
        
        
        
        
        raise NotImplementedError('Current version of extract-msg does not support the parsing of PtypObject/PtypEmbeddedTable in this function.')
    elif _type == 0x0014:  
        return constants.st.ST_LE_UI64.unpack(value)[0]
    elif _type == 0x001E:  
        return value.decode(encoding)
    elif _type == 0x001F:  
        return value.decode('utf-16-le')
    elif _type == 0x0040:  
        rawTime = constants.st.ST_LE_UI64.unpack(value)[0]
        return filetimeToDatetime(rawTime)
    elif _type == 0x0048:  
        return bytesToGuid(value)
    elif _type == 0x00FB:  
        count = constants.st.ST_LE_UI16.unpack(value[:2])[0]
        
        if value[3] == 1:
            from .structures.misc_id import ServerID
            return ServerID(value)
        else:
            return (count, value[2:count + 2])
    elif _type == 0x00FD:  
        
        raise NotImplementedError('Parsing for type 0x00FD (PtypRestriction) has not yet been implmented. If you need this type, please create a new issue labeled "NotImplementedError: parseType 0x00FD PtypRestriction".')
    elif _type == 0x00FE:  
        
        raise NotImplementedError('Parsing for type 0x00FE (PtypRuleAction) has not yet been implmented. If you need this type, please create a new issue labeled "NotImplementedError: parseType 0x00FE PtypRuleAction".')
    elif _type == 0x0102:  
        return value
    elif _type & 0x1000 == 0x1000:  
        
        if _type in (0x101F, 0x101E): 
            ret = [x.decode(encoding)[:-1] for x in extras]
            lengths = struct.unpack(f'<{len(ret)}i', stream)
            lengthLengths = len(lengths)
            if lengthLengths > lengthExtras:
                logger.warning(f'Error while parsing multiple type. Expected {lengthLengths} stream{"s" if lengthLengths != 1 else ""}, got {lengthExtras}. Ignoring.')
            for x, y in enumerate(extras):
                if lengths[x] != len(y):
                    logger.warning(f'Error while parsing multiple type. Expected length {lengths[x]}, got {len(y)}. Ignoring.')
            return ret
        elif _type == 0x1102: 
            ret = copy.deepcopy(extras)
            lengths = tuple(constants.st.ST_LE_UI32.unpack(stream[pos*8:pos*8+4])[0] for pos in range(len(stream) // 8))
            lengthLengths = len(lengths)
            if lengthLengths > lengthExtras:
                logger.warning(f'Error while parsing multiple type. Expected {lengthLengths} stream{"s" if lengthLengths != 1 else ""}, got {lengthExtras}. Ignoring.')
            for x, y in enumerate(extras):
                if lengths[x] != len(y):
                    logger.warning(f'Error while parsing multiple type. Expected length {lengths[x]}, got {len(y)}. Ignoring.')
            return ret
        elif _type in (0x1002, 0x1003, 0x1004, 0x1005, 0x1007, 0x1014, 0x1040, 0x1048):
            if stream != len(extras):
                logger.warning(f'Error while parsing multiple type. Expected {stream} entr{"y" if stream == 1 else "ies"}, got {len(extras)}. Ignoring.')
            if _type == 0x1002: 
                return tuple(constants.st.ST_LE_UI16.unpack(x)[0] for x in extras)
            if _type == 0x1003: 
                return tuple(constants.st.ST_LE_UI32.unpack(x)[0] for x in extras)
            if _type == 0x1004: 
                return tuple(constants.st.ST_LE_F32.unpack(x)[0] for x in extras)
            if _type == 0x1005: 
                return tuple(constants.st.ST_LE_F64.unpack(x)[0] for x in extras)
            if _type == 0x1007: 
                values = (constants.st.ST_LE_F64.unpack(x)[0] for x in extras)
                return tuple(constants.PYTPFLOATINGTIME_START + datetime.timedelta(days = amount) for amount in values)
            if _type == 0x1014: 
                return tuple(constants.st.ST_LE_UI64.unpack(x)[0] for x in extras)
            if _type == 0x1040: 
                return tuple(filetimeToUtc(constants.st.ST_LE_UI64.unpack(x)[0]) for x in extras)
            if _type == 0x1048: 
                return tuple(bytesToGuid(x) for x in extras)
        else:
            raise NotImplementedError(f'Parsing for type {_type} has not yet been implmented. If you need this type, please create a new issue labeled "NotImplementedError: parseType {_type}".')
    return value


def prepareFilename(filename: str) -> str:
    
    
    return ''.join(i for i in filename if i not in r'\/:*?"<>|' + '\x00').strip()


def roundUp(inp: int, mult: int) -> int:
    
    return inp + (mult - inp) % mult


def rtfSanitizeHtml(inp: str) -> str:
    
    if not inp:
        return ''
    output = ''
    for char in inp:
        
        if 32 <= ord(char) < 128:
            
            
            
            if char == '<':
                output += r'{\*\htmltag84 &lt;}\htmlrtf <\htmlrtf0 '
            elif char == '>':
                output += r'{\*\htmltag84 &gt;}\htmlrtf >\htmlrtf0'
            else:
                if char in ('\\', '{', '}'):
                    output += '\\'
                output += char
        elif ord(char) < 32 or 128 <= ord(char) <= 255:
            
            output += f"\\'{ord(char):02X}"
        else:
            
            enc = char.encode('utf-16-le')
            output += ''.join(f'\\u{x}?' for x in struct.unpack(f'<{len(enc) // 2}h', enc))

    return output


def rtfSanitizePlain(inp: str) -> str:
    
    if not inp:
        return ''
    output = ''
    for char in inp:
        
        if 32 <= ord(char) < 128:
            if char in ('\\', '{', '}'):
                output += '\\'
            output += char
        elif ord(char) < 32 or 128 <= ord(char) <= 255:
            
            output += f"\\'{ord(char):02X}"
        else:
            
            enc = char.encode('utf-16-le')
            output += ''.join(f'\\u{x}?' for x in struct.unpack(f'<{len(enc) // 2}h', enc))

    return output


def setupLogging(defaultPath = None, defaultLevel = logging.WARN, logfile = None, enableFileLogging: bool = False,
                  env_key = 'EXTRACT_MSG_LOG_CFG') -> bool:
    
    shippedConfig = pathlib.Path(__file__).parent / 'data' / 'logging-config'
    if os.name == 'nt':
        null = 'NUL'
        shippedConfig /= 'logging-nt.json'
    elif os.name == 'posix':
        null = '/dev/null'
        shippedConfig /= 'logging-posix.json'
    
    defaultPath = pathlib.Path(defaultPath) if defaultPath else shippedConfig

    paths = [
        defaultPath,
        pathlib.Path('logging.json'),
        pathlib.Path('../logging.json'),
        pathlib.Path('../../logging.json'),
        shippedConfig,
    ]

    path = None

    for configPath in paths:
        if configPath.exists():
            path = configPath
            break

    value = os.getenv(env_key, None)
    if value and os.path.exists(value) and os.path.isfile(value):
        path = pathlib.Path(value)

    if not path:
        print('Unable to find logging.json configuration file')
        print('Make sure a valid logging configuration file is referenced in the defaultPath'
              ' argument, is inside the extract_msg install location, or is available at one '
              'of the following file-paths:')
        print(str(paths[1:]))
        logging.basicConfig(level = defaultLevel)
        logging.warning('The extract_msg logging configuration was not found - using a basic configuration.'
                        f'Please check the extract_msg installation directory for "logging-{os.name}.json".')
        return False

    with open(path, 'rt') as f:
        config = json.load(f)

    for x in config['handlers']:
        if 'filename' in config['handlers'][x]:
            if enableFileLogging:
                config['handlers'][x]['filename'] = tmp = os.path.expanduser(
                    os.path.expandvars(logfile if logfile else config['handlers'][x]['filename']))
                tmp = pathlib.Path(tmp).parent
                if not tmp.exists:
                    os.makedirs(tmp)
            else:
                config['handlers'][x]['filename'] = null

    try:
        logging.config.dictConfig(config)
    except ValueError as e:
        print('Failed to configure the logger. Did your installation get messed up?')
        print(e)

    logging.getLogger().setLevel(defaultLevel)
    return True


def stripRtf(rtfBody: bytes) -> bytes:
    
    
    rtfBody = constants.re.RTF_BODY_STRIP_PRE_OPEN.sub(_stripRtfOpenHelper, rtfBody)
    rtfBody = constants.re.RTF_BODY_STRIP_PRE_CLOSE.sub(_stripRtfCloseHelper, rtfBody)
    
    rtfBody = constants.re.RTF_BODY_STRIP_INIT.sub(b'', rtfBody)
    
    
    
    rtfBody = constants.re.RTF_BODY_STRIP_INIT.sub(b'', rtfBody)

    

    return rtfBody

def _stripRtfCloseHelper(match: re.Match) -> bytes:
    if (ret := match.expand(b'\\g<0>')).count(b'\\htmlrtf0') > 1:
        return ret

    if b'\\f' in ret:
        return ret

    return b'\\htmlrtf}\\htmlrtf0 '


def _stripRtfOpenHelper(match: re.Match) -> bytes:
    if b'\\f' in (ret := match.expand(b'\\g<0>')):
        return ret

    return b'\\htmlrtf{\\htmlrtf0 '


def _stripRtfHelper(match: re.Match) -> bytes:
    res = match.string

    
    if res.count(b'{') != res.count(b'}') or res.count(b'{') == 0:
        return res

    
    if res.find(b'\\{') != -1 or res.find(b'\\}') != -1:
        return res

    
    
    

    return res




def tryGetMimetype(att: AttachmentBase, mimetype: Union[str, None]) -> Union[str, None]:
    
    if mimetype:
        return mimetype

    
    if att.dataType is bytes:
        
        try:
            import magic 

            if isinstance(att.data, (str, bytes)):
                return magic.from_buffer(att.data, mime = True)
        except ImportError:
            logger.info('Mimetype not found on attachment, and `mime` dependency not installed. Won\'t try to generate.')

        except Exception:
            logger.exception('Error occured while using python-magic. This error will be ignored.')

    return mimetype


def unsignedToSignedInt(uInt: int) -> int:
    
    if uInt > 0xFFFFFFFF:
        raise ValueError('Value is too large.')
    if uInt < 0:
        raise ValueError('Value is already signed.')
    return constants.st.ST_SBO_I32.unpack(constants.st.ST_SBO_UI32.pack(uInt))[0]


def unwrapMsg(msg: MSGFile) -> Dict[str, List]:
    
    from .msg_classes import MessageSignedBase

    
    attachments = []
    
    msgFiles = [msg]
    
    embedded = []
    
    raw = []

    
    
    
    
    
    
    
    toProcess = collections.deque((msg,))

    while len(toProcess) > 0:
        
        
        currentItem = toProcess.popleft()
        
        for att in currentItem.attachments:
            
            
            if att.type not in (AttachmentType.MSG, AttachmentType.SIGNED_EMBEDDED):
                attachments.append(att)
            else:
                
                
                
                
                
                embedded.append(att)
                msgFiles.append(att.data)
                toProcess.append(att.data)
        if isinstance(currentItem, MessageSignedBase):
            raw += currentItem.rawAttachments

    return {
        'attachments': attachments,
        'embedded': embedded,
        'msg': msgFiles,
        'raw_attachments': raw,
    }


def unwrapMultipart(mp: Union[bytes, str, email.message.Message]) -> Dict:
    
    
    genKwargs = {
        '_class': email.message.EmailMessage,
        'policy': email.policy.default,
    }
    
    if isinstance(mp, email.message.EmailMessage):
        if mp.policy == email.policy.default:
            mpMessage = mp
        else:
            mpMessage = email.message_from_bytes(mp.as_bytes(), **genKwargs)
    elif isinstance(mp, email.message.Message):
        mpMessage = email.message_from_bytes(mp.as_bytes(), **genKwargs)
    elif isinstance(mp, bytes):
        mpMessage = email.message_from_bytes(mp, **genKwargs)
    elif isinstance(mp, str):
        mpMessage = email.message_from_string(mp, **genKwargs)
    else:
        raise TypeError(f'Unsupported type "{type(mp)}" provided to unwrapMultipart.')

    
    
    
    
    
    
    
    dataNodes = []

    toProcess = collections.deque((mpMessage,))
    
    
    while len(toProcess) > 0:
        currentItem = toProcess.popleft()
        
        
        if currentItem.get_content_maintype() == 'multipart':
            payload = currentItem.get_payload()
            
            
            if isinstance(payload, list):
                toProcess.extend(payload)
            else:
                logging.warning('Found multipart node that did not return a list. Appending as a data node.')
                dataNodes.append(currentItem)
        else:
            
            
            dataNodes.append(currentItem)

    
    
    
    
    
    attachments = []
    plainBody = None
    htmlBody = None

    for node in dataNodes:
        
        attachment = {
            'data': None,
            'name': node.get_filename(),
            'mimetype': node.get_content_type(),
            'node': node,
        }

        
        
        data = node.get_content()
        if isinstance(data, bytes):
            
            pass
        elif isinstance(data, email.message.Message):
            
            data = data.as_bytes()
        elif isinstance(data, str):
            
            
            
            data = data.encode(node.get_content_charset('utf-8'))
        else:
            
            
            raise TypeError(f'Attempted to get bytes for attachment, but could not convert {type(data)} to bytes.')

        attachment['data'] = data

        
        if attachment['name']:
            attachments.append(attachment)
        elif attachment['mimetype'] == 'text/plain':
            if plainBody:
                logger.warning('Found multiple candidates for plain text body.')
            plainBody = data
        elif attachment['mimetype'] == 'text/html':
            if htmlBody:
                logger.warning('Found multiple candidates for HTML body.')
            htmlBody = data

    return {
        'attachments': attachments,
        'plain_body': plainBody,
        'html_body': htmlBody,
    }


def validateHtml(html: bytes, encoding: Optional[str]) -> bool:
    
    bs = bs4.BeautifulSoup(html, 'html.parser', from_encoding = encoding)
    if not bs.find('html') or not bs.find('body'):
        return False
    return True


def verifyPropertyId(id: str) -> None:
    
    if not isinstance(id, str):
        raise InvalidPropertyIdError('ID was not a 4 digit hexadecimal string')
    if len(id) != 4:
        raise InvalidPropertyIdError('ID was not a 4 digit hexadecimal string')
    try:
        int(id, 16)
    except ValueError:
        raise InvalidPropertyIdError('ID was not a 4 digit hexadecimal string')


def verifyType(_type: Optional[str]) -> None:
    
    if _type is not None:
        if (_type not in constants.VARIABLE_LENGTH_PROPS_STRING) and (_type not in constants.FIXED_LENGTH_PROPS_STRING):
            raise UnknownTypeError(f'Unknown type {_type}.')
