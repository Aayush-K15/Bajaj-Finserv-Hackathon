__all__ = [
    'tokenizeRTF',
]


import io

from typing import List, Optional, Tuple

from .token import Token, TokenType


_KNOWN_DESTINATIONS = (
    b'aftncn',
    b'aftnsep',
    b'aftnsepc',
    b'annotation',
    b'author',
    b'buptim',
    b'category',
    b'colortbl',
    b'comment',
    b'company',
    b'creatim',
    b'doccomm',
    b'dptxbxtext',
    b'factoidname',
    b'fonttbl',
    b'footer',
    b'footerf',
    b'footerl',
    b'footerr',
    b'ftncn',
    b'ftnsep',
    b'ftnsepc',
    b'header',
    b'headerf',
    b'headerl',
    b'headerr',
    b'hlinkbase',
    b'keywords',
    b'manager',
    b'operator',
    b'pict',
    b'printim',
    b'private',
    b'revtim',
    b'stylesheet',
    b'subject',
    b'title',
)


def _finishTag(startText: bytes, reader: io.BytesIO) -> Tuple[bytes, Optional[bytes], Optional[int], bytes]:
    
    
    
    
    
    
    name = startText[-1:]
    param = b''

    while (nextChar := reader.read(1)) != b'' and nextChar.isalpha():
        
        startText += nextChar
        name += nextChar

    
    if nextChar == b'-':
        
        nextNext = reader.read(1)
        if nextNext == b'':
            raise ValueError('Unexpected end of data.')
        elif nextNext.isdigit():
            startText += nextChar
            nextChar = nextNext

    if nextChar.isdigit():
        startText += nextChar
        param += nextChar
        while (nextChar := reader.read(1)) != b'' and nextChar.isdigit():
            startText += nextChar
            param += nextChar

        param = int(param)
    else:
        param = None

    
    
    if nextChar == b' ':
        nextChar = reader.read(1)

    return startText, name, param, nextChar


def _readControl(startChar: bytes, reader: io.BytesIO) -> Tuple[Tuple[Token, ...], bytes]:
    
    
    
    nextChar = reader.read(1)
    if nextChar == b'':
        raise ValueError('Unexpected end of data.')
    elif nextChar.isalpha():
        
        text, name, param, nextChar = _finishTag(startChar + nextChar, reader)
        
        
        if name == b'bin':
            if nextChar == b'':
                raise ValueError('Unexpected end of data.')
            binText = nextChar + reader.read(param - 1)
            if len(binText) != param:
                raise ValueError('Unexpected end of data.')
            return (Token(text, TokenType.CONTROL, name, param), Token(binText, TokenType.BINARY)), nextChar
        elif name in _KNOWN_DESTINATIONS:
            return (Token(text, TokenType.DESTINATION, name, param),), nextChar

        return (Token(text, TokenType.CONTROL, name, param),), nextChar
    else:
        
        
        startChar += nextChar
        if nextChar == b'*':
            
            if len(nextChar := reader.read(1)) != 1:
                raise ValueError('Unexpected end of data.')
            elif nextChar != b'\\':
                raise ValueError(f'Bad custom destination (expected a backslash, got {nextChar}).')

            startChar += nextChar

            
            if not (nextChar := reader.read(1)).isalpha():
                raise ValueError(f'Expected alpha character for destination, got {nextChar}.')

            startChar += nextChar

            
            text, name, param, nextChar = _finishTag(startChar, reader)
            return (Token(text, TokenType.IGNORABLE_DESTINATION, name, param),), nextChar
        elif nextChar == b'\'':
            
            hexChars = reader.read(2)
            if len(hexChars) != 2:
                raise ValueError('Unexpected end of data.')
            try:
                param = int(hexChars, 16)
            except ValueError as e:
                context = e.__cause__ or e.__context__
                raise ValueError(f'Hex data was not hexidecimal (got {hexChars}).') from context
            return (Token(startChar + hexChars, TokenType.SYMBOL, None, param),), reader.read(1)
        else:
            
            return (Token(startChar, TokenType.SYMBOL),), reader.read(1)


def _readText(startChar: bytes, reader: io.BytesIO) -> Tuple[Tuple[Token, ...], bytes]:
    
    chars = [startChar]
    
    
    
    while (nextChar := reader.read(1)) != b'' and nextChar not in (b'{', b'}', b'\\'):
        
        if nextChar not in (b'\r', b'\n'):
            chars.append(nextChar)

    
    

    return tuple(Token(x, TokenType.TEXT) for x in chars), nextChar


def tokenizeRTF(data: bytes, validateStart: bool = True) -> List[Token]:
    
    reader = io.BytesIO(data)
    if validateStart:
        
        
        
        
        
        start = reader.read(6)
        if start != b'{\\rtf1':
            raise TypeError('Data does not start with "{\\rtf1".')

        tokens = [
            Token(b'{', TokenType.GROUP_START),
            Token(b'\\rtf1', TokenType.CONTROL, b'rtf', 1),
        ]
        nextChar = reader.read(1)

        
        if nextChar == b' ':
            nextChar = reader.read(1)
    else:
        tokens = []
        nextChar = reader.read(1)

    
    
    
    while nextChar != b'':
        
        
        if nextChar in (b'\r', b'\n'):
            
            nextChar = reader.read(1)
            continue

        if nextChar == b'\\':
            newTokens, nextChar = _readControl(nextChar, reader)
        elif nextChar == b'{':
            
            
            nextChar = reader.read(1)
            newTokens = (Token(b'{', TokenType.GROUP_START),)
        elif nextChar == b'}':
            
            
            nextChar = reader.read(1)
            newTokens = (Token(b'}', TokenType.GROUP_END),)
        else:
            
            newTokens, nextChar = _readText(nextChar, reader)

        tokens.extend(newTokens)

    return tokens
