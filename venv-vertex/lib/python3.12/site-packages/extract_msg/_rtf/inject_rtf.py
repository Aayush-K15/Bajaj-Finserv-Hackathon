__all__ = [
    'injectStartRTF',
    'injectStartRTFTokenized',
]


from .token import Token, TokenType
from .tokenize_rtf import tokenizeRTF

from typing import List, Iterable, TypeVar, Union


_T = TypeVar('_T')



_HEADER_DESTINATIONS = (
    b'fonttbl',
    b'colortbl',
    b'stylesheet',
)


_HEADER_SKIPPABLE = (
    
    b'fbidis',
    
    b'ansi',
    b'mac',
    b'pc',
    b'pca',
    b'ansicpg',
    
    b'fromtext',
    b'fromhtml',
    
    b'deff',
    b'adeff',
    b'stshfdbch',
    b'stshfloch',
    b'stshfhich',
    b'stshfbi',
    
    b'deflang',
    b'deflangfe',
    b'adeflang',
)


def _listInsertMult(dest: List[_T], source: Iterable[_T], index: int = -1):
    
    if index == -1 or index >= len(dest):
        dest.extend(source)
    else:
        for offset, item in enumerate(source):
            dest.insert(index + offset, item)


def injectStartRTF(document: bytes, injectTokens: Union[bytes, List[Token]]) -> List[Token]:
    
    return injectStartRTFTokenized(tokenizeRTF(document), injectTokens)


def injectStartRTFTokenized(document: List[Token], injectTokens: Union[bytes, Iterable[Token]]) -> List[Token]:
    
    
    if isinstance(injectTokens, bytes):
        injectTokens = tokenizeRTF(injectTokens, False)

    
    
    
    
    
    

    
    if len(document) < 3:
        raise ValueError('RTF documents cannot be less than 3 tokens.')
    if document[0].type is not TokenType.GROUP_START or document[1].raw != b'\\rtf1':
        raise TypeError('RTF document *must* start with "{\\rtf1".')

    
    if sum(x.type == TokenType.GROUP_START for x in document) != sum(x.type == TokenType.GROUP_END for x in document):
        raise ValueError('Number of group opens did not match number of group closes.')

    
    if len(document) == 3:
        _listInsertMult(document, injectTokens, 2)
        return document

    
    
    currentInsertPos = 2
    
    groupCount = 1
    
    checkingDest = False

    for item in document[2:]:
        if groupCount == 1:
            if item.type is TokenType.GROUP_END:
                break
            elif item.type is TokenType.GROUP_START:
                groupCount += 1
                checkingDest = True
            elif item.type is TokenType.CONTROL and item.name in _HEADER_SKIPPABLE:
                
                currentInsertPos += 1
            else:
                
                break
        elif checkingDest:
            if item.type is TokenType.DESTINATION:
                
                
                if item.name in _HEADER_DESTINATIONS:
                    currentInsertPos += 2
                else:
                    break
            elif item.type is TokenType.IGNORABLE_DESTINATION:
                
                currentInsertPos += 2
            else:
                
                
                break
            checkingDest = False
        else:
            
            if item.type is TokenType.GROUP_START:
                groupCount += 1
            if item.type is TokenType.GROUP_END:
                groupCount -= 1
            currentInsertPos += 1

    _listInsertMult(document, injectTokens, currentInsertPos)
    return document
