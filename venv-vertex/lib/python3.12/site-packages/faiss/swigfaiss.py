





from sys import version_info as _swig_python_version_info

if __package__ or "." in __name__:
    from . import _swigfaiss
else:
    import _swigfaiss

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _swigfaiss.delete_SwigPyIterator

    def value(self):
        return _swigfaiss.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _swigfaiss.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _swigfaiss.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _swigfaiss.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _swigfaiss.SwigPyIterator_equal(self, x)

    def copy(self):
        return _swigfaiss.SwigPyIterator_copy(self)

    def next(self):
        return _swigfaiss.SwigPyIterator_next(self)

    def __next__(self):
        return _swigfaiss.SwigPyIterator___next__(self)

    def previous(self):
        return _swigfaiss.SwigPyIterator_previous(self)

    def advance(self, n):
        return _swigfaiss.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _swigfaiss.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _swigfaiss.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _swigfaiss.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _swigfaiss.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _swigfaiss.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _swigfaiss.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self


_swigfaiss.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _swigfaiss.SHARED_PTR_DISOWN
class Float32Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.Float32Vector_swiginit(self, _swigfaiss.new_Float32Vector())

    def push_back(self, arg2):
        return _swigfaiss.Float32Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.Float32Vector_clear(self)

    def data(self):
        return _swigfaiss.Float32Vector_data(self)

    def size(self):
        return _swigfaiss.Float32Vector_size(self)

    def at(self, n):
        return _swigfaiss.Float32Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.Float32Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.Float32Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_Float32Vector


_swigfaiss.Float32Vector_swigregister(Float32Vector)
class Float64Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.Float64Vector_swiginit(self, _swigfaiss.new_Float64Vector())

    def push_back(self, arg2):
        return _swigfaiss.Float64Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.Float64Vector_clear(self)

    def data(self):
        return _swigfaiss.Float64Vector_data(self)

    def size(self):
        return _swigfaiss.Float64Vector_size(self)

    def at(self, n):
        return _swigfaiss.Float64Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.Float64Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.Float64Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_Float64Vector


_swigfaiss.Float64Vector_swigregister(Float64Vector)
class Int8Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.Int8Vector_swiginit(self, _swigfaiss.new_Int8Vector())

    def push_back(self, arg2):
        return _swigfaiss.Int8Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.Int8Vector_clear(self)

    def data(self):
        return _swigfaiss.Int8Vector_data(self)

    def size(self):
        return _swigfaiss.Int8Vector_size(self)

    def at(self, n):
        return _swigfaiss.Int8Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.Int8Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.Int8Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_Int8Vector


_swigfaiss.Int8Vector_swigregister(Int8Vector)
class Int16Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.Int16Vector_swiginit(self, _swigfaiss.new_Int16Vector())

    def push_back(self, arg2):
        return _swigfaiss.Int16Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.Int16Vector_clear(self)

    def data(self):
        return _swigfaiss.Int16Vector_data(self)

    def size(self):
        return _swigfaiss.Int16Vector_size(self)

    def at(self, n):
        return _swigfaiss.Int16Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.Int16Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.Int16Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_Int16Vector


_swigfaiss.Int16Vector_swigregister(Int16Vector)
class Int32Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.Int32Vector_swiginit(self, _swigfaiss.new_Int32Vector())

    def push_back(self, arg2):
        return _swigfaiss.Int32Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.Int32Vector_clear(self)

    def data(self):
        return _swigfaiss.Int32Vector_data(self)

    def size(self):
        return _swigfaiss.Int32Vector_size(self)

    def at(self, n):
        return _swigfaiss.Int32Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.Int32Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.Int32Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_Int32Vector


_swigfaiss.Int32Vector_swigregister(Int32Vector)
class Int64Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.Int64Vector_swiginit(self, _swigfaiss.new_Int64Vector())

    def push_back(self, arg2):
        return _swigfaiss.Int64Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.Int64Vector_clear(self)

    def data(self):
        return _swigfaiss.Int64Vector_data(self)

    def size(self):
        return _swigfaiss.Int64Vector_size(self)

    def at(self, n):
        return _swigfaiss.Int64Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.Int64Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.Int64Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_Int64Vector


_swigfaiss.Int64Vector_swigregister(Int64Vector)
class UInt8Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.UInt8Vector_swiginit(self, _swigfaiss.new_UInt8Vector())

    def push_back(self, arg2):
        return _swigfaiss.UInt8Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.UInt8Vector_clear(self)

    def data(self):
        return _swigfaiss.UInt8Vector_data(self)

    def size(self):
        return _swigfaiss.UInt8Vector_size(self)

    def at(self, n):
        return _swigfaiss.UInt8Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.UInt8Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.UInt8Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_UInt8Vector


_swigfaiss.UInt8Vector_swigregister(UInt8Vector)
class UInt16Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.UInt16Vector_swiginit(self, _swigfaiss.new_UInt16Vector())

    def push_back(self, arg2):
        return _swigfaiss.UInt16Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.UInt16Vector_clear(self)

    def data(self):
        return _swigfaiss.UInt16Vector_data(self)

    def size(self):
        return _swigfaiss.UInt16Vector_size(self)

    def at(self, n):
        return _swigfaiss.UInt16Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.UInt16Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.UInt16Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_UInt16Vector


_swigfaiss.UInt16Vector_swigregister(UInt16Vector)
class UInt32Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.UInt32Vector_swiginit(self, _swigfaiss.new_UInt32Vector())

    def push_back(self, arg2):
        return _swigfaiss.UInt32Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.UInt32Vector_clear(self)

    def data(self):
        return _swigfaiss.UInt32Vector_data(self)

    def size(self):
        return _swigfaiss.UInt32Vector_size(self)

    def at(self, n):
        return _swigfaiss.UInt32Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.UInt32Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.UInt32Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_UInt32Vector


_swigfaiss.UInt32Vector_swigregister(UInt32Vector)
class UInt64Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.UInt64Vector_swiginit(self, _swigfaiss.new_UInt64Vector())

    def push_back(self, arg2):
        return _swigfaiss.UInt64Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.UInt64Vector_clear(self)

    def data(self):
        return _swigfaiss.UInt64Vector_data(self)

    def size(self):
        return _swigfaiss.UInt64Vector_size(self)

    def at(self, n):
        return _swigfaiss.UInt64Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.UInt64Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.UInt64Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_UInt64Vector


_swigfaiss.UInt64Vector_swigregister(UInt64Vector)
class Float32VectorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.Float32VectorVector_swiginit(self, _swigfaiss.new_Float32VectorVector())

    def push_back(self, arg2):
        return _swigfaiss.Float32VectorVector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.Float32VectorVector_clear(self)

    def data(self):
        return _swigfaiss.Float32VectorVector_data(self)

    def size(self):
        return _swigfaiss.Float32VectorVector_size(self)

    def at(self, n):
        return _swigfaiss.Float32VectorVector_at(self, n)

    def resize(self, n):
        return _swigfaiss.Float32VectorVector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.Float32VectorVector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_Float32VectorVector


_swigfaiss.Float32VectorVector_swigregister(Float32VectorVector)
class UInt8VectorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.UInt8VectorVector_swiginit(self, _swigfaiss.new_UInt8VectorVector())

    def push_back(self, arg2):
        return _swigfaiss.UInt8VectorVector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.UInt8VectorVector_clear(self)

    def data(self):
        return _swigfaiss.UInt8VectorVector_data(self)

    def size(self):
        return _swigfaiss.UInt8VectorVector_size(self)

    def at(self, n):
        return _swigfaiss.UInt8VectorVector_at(self, n)

    def resize(self, n):
        return _swigfaiss.UInt8VectorVector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.UInt8VectorVector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_UInt8VectorVector


_swigfaiss.UInt8VectorVector_swigregister(UInt8VectorVector)
class Int32VectorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.Int32VectorVector_swiginit(self, _swigfaiss.new_Int32VectorVector())

    def push_back(self, arg2):
        return _swigfaiss.Int32VectorVector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.Int32VectorVector_clear(self)

    def data(self):
        return _swigfaiss.Int32VectorVector_data(self)

    def size(self):
        return _swigfaiss.Int32VectorVector_size(self)

    def at(self, n):
        return _swigfaiss.Int32VectorVector_at(self, n)

    def resize(self, n):
        return _swigfaiss.Int32VectorVector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.Int32VectorVector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_Int32VectorVector


_swigfaiss.Int32VectorVector_swigregister(Int32VectorVector)
class Int64VectorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.Int64VectorVector_swiginit(self, _swigfaiss.new_Int64VectorVector())

    def push_back(self, arg2):
        return _swigfaiss.Int64VectorVector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.Int64VectorVector_clear(self)

    def data(self):
        return _swigfaiss.Int64VectorVector_data(self)

    def size(self):
        return _swigfaiss.Int64VectorVector_size(self)

    def at(self, n):
        return _swigfaiss.Int64VectorVector_at(self, n)

    def resize(self, n):
        return _swigfaiss.Int64VectorVector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.Int64VectorVector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_Int64VectorVector


_swigfaiss.Int64VectorVector_swigregister(Int64VectorVector)
class VectorTransformVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.VectorTransformVector_swiginit(self, _swigfaiss.new_VectorTransformVector())

    def push_back(self, arg2):
        return _swigfaiss.VectorTransformVector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.VectorTransformVector_clear(self)

    def data(self):
        return _swigfaiss.VectorTransformVector_data(self)

    def size(self):
        return _swigfaiss.VectorTransformVector_size(self)

    def at(self, n):
        return _swigfaiss.VectorTransformVector_at(self, n)

    def resize(self, n):
        return _swigfaiss.VectorTransformVector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.VectorTransformVector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_VectorTransformVector


_swigfaiss.VectorTransformVector_swigregister(VectorTransformVector)
class OperatingPointVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.OperatingPointVector_swiginit(self, _swigfaiss.new_OperatingPointVector())

    def push_back(self, arg2):
        return _swigfaiss.OperatingPointVector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.OperatingPointVector_clear(self)

    def data(self):
        return _swigfaiss.OperatingPointVector_data(self)

    def size(self):
        return _swigfaiss.OperatingPointVector_size(self)

    def at(self, n):
        return _swigfaiss.OperatingPointVector_at(self, n)

    def resize(self, n):
        return _swigfaiss.OperatingPointVector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.OperatingPointVector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_OperatingPointVector


_swigfaiss.OperatingPointVector_swigregister(OperatingPointVector)
class InvertedListsPtrVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.InvertedListsPtrVector_swiginit(self, _swigfaiss.new_InvertedListsPtrVector())

    def push_back(self, arg2):
        return _swigfaiss.InvertedListsPtrVector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.InvertedListsPtrVector_clear(self)

    def data(self):
        return _swigfaiss.InvertedListsPtrVector_data(self)

    def size(self):
        return _swigfaiss.InvertedListsPtrVector_size(self)

    def at(self, n):
        return _swigfaiss.InvertedListsPtrVector_at(self, n)

    def resize(self, n):
        return _swigfaiss.InvertedListsPtrVector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.InvertedListsPtrVector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_InvertedListsPtrVector


_swigfaiss.InvertedListsPtrVector_swigregister(InvertedListsPtrVector)
class RepeatVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.RepeatVector_swiginit(self, _swigfaiss.new_RepeatVector())

    def push_back(self, arg2):
        return _swigfaiss.RepeatVector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.RepeatVector_clear(self)

    def data(self):
        return _swigfaiss.RepeatVector_data(self)

    def size(self):
        return _swigfaiss.RepeatVector_size(self)

    def at(self, n):
        return _swigfaiss.RepeatVector_at(self, n)

    def resize(self, n):
        return _swigfaiss.RepeatVector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.RepeatVector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_RepeatVector


_swigfaiss.RepeatVector_swigregister(RepeatVector)
class ClusteringIterationStatsVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.ClusteringIterationStatsVector_swiginit(self, _swigfaiss.new_ClusteringIterationStatsVector())

    def push_back(self, arg2):
        return _swigfaiss.ClusteringIterationStatsVector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.ClusteringIterationStatsVector_clear(self)

    def data(self):
        return _swigfaiss.ClusteringIterationStatsVector_data(self)

    def size(self):
        return _swigfaiss.ClusteringIterationStatsVector_size(self)

    def at(self, n):
        return _swigfaiss.ClusteringIterationStatsVector_at(self, n)

    def resize(self, n):
        return _swigfaiss.ClusteringIterationStatsVector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.ClusteringIterationStatsVector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_ClusteringIterationStatsVector


_swigfaiss.ClusteringIterationStatsVector_swigregister(ClusteringIterationStatsVector)
class ParameterRangeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.ParameterRangeVector_swiginit(self, _swigfaiss.new_ParameterRangeVector())

    def push_back(self, arg2):
        return _swigfaiss.ParameterRangeVector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.ParameterRangeVector_clear(self)

    def data(self):
        return _swigfaiss.ParameterRangeVector_data(self)

    def size(self):
        return _swigfaiss.ParameterRangeVector_size(self)

    def at(self, n):
        return _swigfaiss.ParameterRangeVector_at(self, n)

    def resize(self, n):
        return _swigfaiss.ParameterRangeVector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.ParameterRangeVector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_ParameterRangeVector


_swigfaiss.ParameterRangeVector_swigregister(ParameterRangeVector)
class MaybeOwnedVectorUInt8Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.MaybeOwnedVectorUInt8Vector_swiginit(self, _swigfaiss.new_MaybeOwnedVectorUInt8Vector())

    def push_back(self, arg2):
        return _swigfaiss.MaybeOwnedVectorUInt8Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.MaybeOwnedVectorUInt8Vector_clear(self)

    def data(self):
        return _swigfaiss.MaybeOwnedVectorUInt8Vector_data(self)

    def size(self):
        return _swigfaiss.MaybeOwnedVectorUInt8Vector_size(self)

    def at(self, n):
        return _swigfaiss.MaybeOwnedVectorUInt8Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.MaybeOwnedVectorUInt8Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.MaybeOwnedVectorUInt8Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_MaybeOwnedVectorUInt8Vector


_swigfaiss.MaybeOwnedVectorUInt8Vector_swigregister(MaybeOwnedVectorUInt8Vector)
class MaybeOwnedVectorInt32Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.MaybeOwnedVectorInt32Vector_swiginit(self, _swigfaiss.new_MaybeOwnedVectorInt32Vector())

    def push_back(self, arg2):
        return _swigfaiss.MaybeOwnedVectorInt32Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.MaybeOwnedVectorInt32Vector_clear(self)

    def data(self):
        return _swigfaiss.MaybeOwnedVectorInt32Vector_data(self)

    def size(self):
        return _swigfaiss.MaybeOwnedVectorInt32Vector_size(self)

    def at(self, n):
        return _swigfaiss.MaybeOwnedVectorInt32Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.MaybeOwnedVectorInt32Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.MaybeOwnedVectorInt32Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_MaybeOwnedVectorInt32Vector


_swigfaiss.MaybeOwnedVectorInt32Vector_swigregister(MaybeOwnedVectorInt32Vector)
class MaybeOwnedVectorFloat32Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.MaybeOwnedVectorFloat32Vector_swiginit(self, _swigfaiss.new_MaybeOwnedVectorFloat32Vector())

    def push_back(self, arg2):
        return _swigfaiss.MaybeOwnedVectorFloat32Vector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.MaybeOwnedVectorFloat32Vector_clear(self)

    def data(self):
        return _swigfaiss.MaybeOwnedVectorFloat32Vector_data(self)

    def size(self):
        return _swigfaiss.MaybeOwnedVectorFloat32Vector_size(self)

    def at(self, n):
        return _swigfaiss.MaybeOwnedVectorFloat32Vector_at(self, n)

    def resize(self, n):
        return _swigfaiss.MaybeOwnedVectorFloat32Vector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.MaybeOwnedVectorFloat32Vector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_MaybeOwnedVectorFloat32Vector


_swigfaiss.MaybeOwnedVectorFloat32Vector_swigregister(MaybeOwnedVectorFloat32Vector)
class OnDiskOneListVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _swigfaiss.OnDiskOneListVector_swiginit(self, _swigfaiss.new_OnDiskOneListVector())

    def push_back(self, arg2):
        return _swigfaiss.OnDiskOneListVector_push_back(self, arg2)

    def clear(self):
        return _swigfaiss.OnDiskOneListVector_clear(self)

    def data(self):
        return _swigfaiss.OnDiskOneListVector_data(self)

    def size(self):
        return _swigfaiss.OnDiskOneListVector_size(self)

    def at(self, n):
        return _swigfaiss.OnDiskOneListVector_at(self, n)

    def resize(self, n):
        return _swigfaiss.OnDiskOneListVector_resize(self, n)

    def swap(self, other):
        return _swigfaiss.OnDiskOneListVector_swap(self, other)
    __swig_destroy__ = _swigfaiss.delete_OnDiskOneListVector


_swigfaiss.OnDiskOneListVector_swigregister(OnDiskOneListVector)

def simd_histogram_8(data, n, min, shift, hist):
    r
    return _swigfaiss.simd_histogram_8(data, n, min, shift, hist)

def simd_histogram_16(data, n, min, shift, hist):
    r
    return _swigfaiss.simd_histogram_16(data, n, min, shift, hist)
class PartitionStats(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    bissect_cycles = property(_swigfaiss.PartitionStats_bissect_cycles_get, _swigfaiss.PartitionStats_bissect_cycles_set)
    compress_cycles = property(_swigfaiss.PartitionStats_compress_cycles_get, _swigfaiss.PartitionStats_compress_cycles_set)

    def __init__(self):
        _swigfaiss.PartitionStats_swiginit(self, _swigfaiss.new_PartitionStats())

    def reset(self):
        return _swigfaiss.PartitionStats_reset(self)
    __swig_destroy__ = _swigfaiss.delete_PartitionStats


_swigfaiss.PartitionStats_swigregister(PartitionStats)

def bitvec_print(b, d):
    return _swigfaiss.bitvec_print(b, d)

def fvecs2bitvecs(x, b, d, n):
    return _swigfaiss.fvecs2bitvecs(x, b, d, n)

def bitvecs2fvecs(b, x, d, n):
    return _swigfaiss.bitvecs2fvecs(b, x, d, n)

def fvec2bitvec(x, b, d):
    return _swigfaiss.fvec2bitvec(x, b, d)

def bitvec_shuffle(n, da, db, order, a, b):
    r
    return _swigfaiss.bitvec_shuffle(n, da, db, order, a, b)
class BitstringWriter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code = property(_swigfaiss.BitstringWriter_code_get, _swigfaiss.BitstringWriter_code_set)
    code_size = property(_swigfaiss.BitstringWriter_code_size_get, _swigfaiss.BitstringWriter_code_size_set)
    i = property(_swigfaiss.BitstringWriter_i_get, _swigfaiss.BitstringWriter_i_set)

    def __init__(self, code, code_size):
        _swigfaiss.BitstringWriter_swiginit(self, _swigfaiss.new_BitstringWriter(code, code_size))

    def write(self, x, nbit):
        return _swigfaiss.BitstringWriter_write(self, x, nbit)
    __swig_destroy__ = _swigfaiss.delete_BitstringWriter


_swigfaiss.BitstringWriter_swigregister(BitstringWriter)
cvar = _swigfaiss.cvar

class BitstringReader(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code = property(_swigfaiss.BitstringReader_code_get, _swigfaiss.BitstringReader_code_set)
    code_size = property(_swigfaiss.BitstringReader_code_size_get, _swigfaiss.BitstringReader_code_size_set)
    i = property(_swigfaiss.BitstringReader_i_get, _swigfaiss.BitstringReader_i_set)

    def __init__(self, code, code_size):
        _swigfaiss.BitstringReader_swiginit(self, _swigfaiss.new_BitstringReader(code, code_size))

    def read(self, nbit):
        return _swigfaiss.BitstringReader_read(self, nbit)
    __swig_destroy__ = _swigfaiss.delete_BitstringReader


_swigfaiss.BitstringReader_swigregister(BitstringReader)

def hammings(a, b, na, nb, nbytespercode, dis):
    r
    return _swigfaiss.hammings(a, b, na, nb, nbytespercode, dis)

def hammings_knn_hc(*args):
    r
    return _swigfaiss.hammings_knn_hc(*args)

def hammings_knn(ha, a, b, nb, ncodes, ordered):
    return _swigfaiss.hammings_knn(ha, a, b, nb, ncodes, ordered)

def hammings_knn_mc(a, b, na, nb, k, ncodes, distances, labels, sel=None):
    r
    return _swigfaiss.hammings_knn_mc(a, b, na, nb, k, ncodes, distances, labels, sel)

def hamming_range_search(a, b, na, nb, radius, ncodes, result, sel=None):
    r
    return _swigfaiss.hamming_range_search(a, b, na, nb, radius, ncodes, result, sel)

def hamming_count_thres(bs1, bs2, n1, n2, ht, ncodes, nptr):
    return _swigfaiss.hamming_count_thres(bs1, bs2, n1, n2, ht, ncodes, nptr)

def match_hamming_thres(bs1, bs2, n1, n2, ht, ncodes, idx, dis):
    return _swigfaiss.match_hamming_thres(bs1, bs2, n1, n2, ht, ncodes, idx, dis)

def crosshamming_count_thres(dbs, n, ht, ncodes, nptr):
    return _swigfaiss.crosshamming_count_thres(dbs, n, ht, ncodes, nptr)

def generalized_hammings_knn_hc(ha, a, b, nb, code_size, ordered=1):
    r
    return _swigfaiss.generalized_hammings_knn_hc(ha, a, b, nb, code_size, ordered)

def pack_bitstrings(*args):
    r
    return _swigfaiss.pack_bitstrings(*args)

def unpack_bitstrings(*args):
    r
    return _swigfaiss.unpack_bitstrings(*args)

def popcount32(x):
    return _swigfaiss.popcount32(x)

def popcount64(x):
    return _swigfaiss.popcount64(x)

def get_num_gpus():
    return _swigfaiss.get_num_gpus()

def gpu_profiler_start():
    return _swigfaiss.gpu_profiler_start()

def gpu_profiler_stop():
    return _swigfaiss.gpu_profiler_stop()

def gpu_sync_all_devices():
    return _swigfaiss.gpu_sync_all_devices()

def get_compile_options():
    r
    return _swigfaiss.get_compile_options()

def get_version():
    return _swigfaiss.get_version()

def getmillisecs():
    r
    return _swigfaiss.getmillisecs()

def get_mem_usage_kb():
    r
    return _swigfaiss.get_mem_usage_kb()

def get_cycles():
    return _swigfaiss.get_cycles()

def reflection(u, x, n, d, nu):
    return _swigfaiss.reflection(u, x, n, d, nu)

def matrix_qr(m, n, a):
    r
    return _swigfaiss.matrix_qr(m, n, a)

def ranklist_handle_ties(k, idx, dis):
    r
    return _swigfaiss.ranklist_handle_ties(k, idx, dis)

def ranklist_intersection_size(k1, v1, k2, v2):
    r
    return _swigfaiss.ranklist_intersection_size(k1, v1, k2, v2)

def merge_result_table_with(n, k, I0, D0, I1, D1, keep_min=True, translation=0):
    r
    return _swigfaiss.merge_result_table_with(n, k, I0, D0, I1, D1, keep_min, translation)

def imbalance_factor(*args):
    r
    return _swigfaiss.imbalance_factor(*args)

def ivec_hist(n, v, vmax, hist):
    r
    return _swigfaiss.ivec_hist(n, v, vmax, hist)

def bincode_hist(n, nbits, codes, hist):
    r
    return _swigfaiss.bincode_hist(n, nbits, codes, hist)

def ivec_checksum(n, a):
    r
    return _swigfaiss.ivec_checksum(n, a)

def bvec_checksum(n, a):
    r
    return _swigfaiss.bvec_checksum(n, a)

def bvecs_checksum(n, d, a, cs):
    r
    return _swigfaiss.bvecs_checksum(n, d, a, cs)

def fvecs_maybe_subsample(d, n, nmax, x, verbose=False, seed=1234):
    r
    return _swigfaiss.fvecs_maybe_subsample(d, n, nmax, x, verbose, seed)

def binary_to_real(d, x_in, x_out):
    r
    return _swigfaiss.binary_to_real(d, x_in, x_out)

def real_to_binary(d, x_in, x_out):
    r
    return _swigfaiss.real_to_binary(d, x_in, x_out)

def hash_bytes(bytes, n):
    r
    return _swigfaiss.hash_bytes(bytes, n)

def check_openmp():
    r
    return _swigfaiss.check_openmp()
class CodeSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    d = property(_swigfaiss.CodeSet_d_get, _swigfaiss.CodeSet_d_set)
    s = property(_swigfaiss.CodeSet_s_get, _swigfaiss.CodeSet_s_set)

    def __init__(self, d):
        _swigfaiss.CodeSet_swiginit(self, _swigfaiss.new_CodeSet(d))

    def insert(self, n, codes, inserted):
        return _swigfaiss.CodeSet_insert(self, n, codes, inserted)
    __swig_destroy__ = _swigfaiss.delete_CodeSet


_swigfaiss.CodeSet_swigregister(CodeSet)
hamdis_tab_ham_bytes = cvar.hamdis_tab_ham_bytes

class CombinerRangeKNNfloat(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nq = property(_swigfaiss.CombinerRangeKNNfloat_nq_get, _swigfaiss.CombinerRangeKNNfloat_nq_set)
    k = property(_swigfaiss.CombinerRangeKNNfloat_k_get, _swigfaiss.CombinerRangeKNNfloat_k_set, doc=r)
    r2 = property(_swigfaiss.CombinerRangeKNNfloat_r2_get, _swigfaiss.CombinerRangeKNNfloat_r2_set, doc=r)
    keep_max = property(_swigfaiss.CombinerRangeKNNfloat_keep_max_get, _swigfaiss.CombinerRangeKNNfloat_keep_max_set, doc=r)

    def __init__(self, nq, k, r2, keep_max):
        r
        _swigfaiss.CombinerRangeKNNfloat_swiginit(self, _swigfaiss.new_CombinerRangeKNNfloat(nq, k, r2, keep_max))
    I = property(_swigfaiss.CombinerRangeKNNfloat_I_get, _swigfaiss.CombinerRangeKNNfloat_I_set, doc=r)
    D = property(_swigfaiss.CombinerRangeKNNfloat_D_get, _swigfaiss.CombinerRangeKNNfloat_D_set, doc=r)
    mask = property(_swigfaiss.CombinerRangeKNNfloat_mask_get, _swigfaiss.CombinerRangeKNNfloat_mask_set, doc=r)
    lim_remain = property(_swigfaiss.CombinerRangeKNNfloat_lim_remain_get, _swigfaiss.CombinerRangeKNNfloat_lim_remain_set, doc=r)
    D_remain = property(_swigfaiss.CombinerRangeKNNfloat_D_remain_get, _swigfaiss.CombinerRangeKNNfloat_D_remain_set, doc=r)
    I_remain = property(_swigfaiss.CombinerRangeKNNfloat_I_remain_get, _swigfaiss.CombinerRangeKNNfloat_I_remain_set, doc=r)
    L_res = property(_swigfaiss.CombinerRangeKNNfloat_L_res_get, _swigfaiss.CombinerRangeKNNfloat_L_res_set, doc=r)

    def compute_sizes(self, L_res):
        r
        return _swigfaiss.CombinerRangeKNNfloat_compute_sizes(self, L_res)

    def write_result(self, D_res, I_res):
        r
        return _swigfaiss.CombinerRangeKNNfloat_write_result(self, D_res, I_res)
    __swig_destroy__ = _swigfaiss.delete_CombinerRangeKNNfloat


_swigfaiss.CombinerRangeKNNfloat_swigregister(CombinerRangeKNNfloat)
class CombinerRangeKNNint16(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nq = property(_swigfaiss.CombinerRangeKNNint16_nq_get, _swigfaiss.CombinerRangeKNNint16_nq_set)
    k = property(_swigfaiss.CombinerRangeKNNint16_k_get, _swigfaiss.CombinerRangeKNNint16_k_set, doc=r)
    r2 = property(_swigfaiss.CombinerRangeKNNint16_r2_get, _swigfaiss.CombinerRangeKNNint16_r2_set, doc=r)
    keep_max = property(_swigfaiss.CombinerRangeKNNint16_keep_max_get, _swigfaiss.CombinerRangeKNNint16_keep_max_set, doc=r)

    def __init__(self, nq, k, r2, keep_max):
        r
        _swigfaiss.CombinerRangeKNNint16_swiginit(self, _swigfaiss.new_CombinerRangeKNNint16(nq, k, r2, keep_max))
    I = property(_swigfaiss.CombinerRangeKNNint16_I_get, _swigfaiss.CombinerRangeKNNint16_I_set, doc=r)
    D = property(_swigfaiss.CombinerRangeKNNint16_D_get, _swigfaiss.CombinerRangeKNNint16_D_set, doc=r)
    mask = property(_swigfaiss.CombinerRangeKNNint16_mask_get, _swigfaiss.CombinerRangeKNNint16_mask_set, doc=r)
    lim_remain = property(_swigfaiss.CombinerRangeKNNint16_lim_remain_get, _swigfaiss.CombinerRangeKNNint16_lim_remain_set, doc=r)
    D_remain = property(_swigfaiss.CombinerRangeKNNint16_D_remain_get, _swigfaiss.CombinerRangeKNNint16_D_remain_set, doc=r)
    I_remain = property(_swigfaiss.CombinerRangeKNNint16_I_remain_get, _swigfaiss.CombinerRangeKNNint16_I_remain_set, doc=r)
    L_res = property(_swigfaiss.CombinerRangeKNNint16_L_res_get, _swigfaiss.CombinerRangeKNNint16_L_res_set, doc=r)

    def compute_sizes(self, L_res):
        r
        return _swigfaiss.CombinerRangeKNNint16_compute_sizes(self, L_res)

    def write_result(self, D_res, I_res):
        r
        return _swigfaiss.CombinerRangeKNNint16_write_result(self, D_res, I_res)
    __swig_destroy__ = _swigfaiss.delete_CombinerRangeKNNint16


_swigfaiss.CombinerRangeKNNint16_swigregister(CombinerRangeKNNint16)

def fvec_L2sqr(x, y, d):
    r
    return _swigfaiss.fvec_L2sqr(x, y, d)

def fvec_inner_product(x, y, d):
    r
    return _swigfaiss.fvec_inner_product(x, y, d)

def fvec_L1(x, y, d):
    r
    return _swigfaiss.fvec_L1(x, y, d)

def fvec_Linf(x, y, d):
    r
    return _swigfaiss.fvec_Linf(x, y, d)

def fvec_inner_product_batch_4(x, y0, y1, y2, y3, d, dis0, dis1, dis2, dis3):
    r
    return _swigfaiss.fvec_inner_product_batch_4(x, y0, y1, y2, y3, d, dis0, dis1, dis2, dis3)

def fvec_L2sqr_batch_4(x, y0, y1, y2, y3, d, dis0, dis1, dis2, dis3):
    r
    return _swigfaiss.fvec_L2sqr_batch_4(x, y0, y1, y2, y3, d, dis0, dis1, dis2, dis3)

def pairwise_L2sqr(d, nq, xq, nb, xb, dis, ldq=-1, ldb=-1, ldd=-1):
    r
    return _swigfaiss.pairwise_L2sqr(d, nq, xq, nb, xb, dis, ldq, ldb, ldd)

def fvec_inner_products_ny(ip, x, y, d, ny):
    return _swigfaiss.fvec_inner_products_ny(ip, x, y, d, ny)

def fvec_L2sqr_ny(dis, x, y, d, ny):
    return _swigfaiss.fvec_L2sqr_ny(dis, x, y, d, ny)

def fvec_L2sqr_ny_transposed(dis, x, y, y_sqlen, d, d_offset, ny):
    return _swigfaiss.fvec_L2sqr_ny_transposed(dis, x, y, y_sqlen, d, d_offset, ny)

def fvec_L2sqr_ny_nearest(distances_tmp_buffer, x, y, d, ny):
    return _swigfaiss.fvec_L2sqr_ny_nearest(distances_tmp_buffer, x, y, d, ny)

def fvec_L2sqr_ny_nearest_y_transposed(distances_tmp_buffer, x, y, y_sqlen, d, d_offset, ny):
    return _swigfaiss.fvec_L2sqr_ny_nearest_y_transposed(distances_tmp_buffer, x, y, y_sqlen, d, d_offset, ny)

def fvec_norm_L2sqr(x, d):
    r
    return _swigfaiss.fvec_norm_L2sqr(x, d)

def fvec_norms_L2(norms, x, d, nx):
    r
    return _swigfaiss.fvec_norms_L2(norms, x, d, nx)

def fvec_norms_L2sqr(norms, x, d, nx):
    r
    return _swigfaiss.fvec_norms_L2sqr(norms, x, d, nx)

def fvec_renorm_L2(d, nx, x):
    return _swigfaiss.fvec_renorm_L2(d, nx, x)

def inner_product_to_L2sqr(dis, nr1, nr2, n1, n2):
    return _swigfaiss.inner_product_to_L2sqr(dis, nr1, nr2, n1, n2)

def fvec_add(*args):
    r
    return _swigfaiss.fvec_add(*args)

def fvec_sub(d, a, b, c):
    r
    return _swigfaiss.fvec_sub(d, a, b, c)

def fvec_inner_products_by_idx(ip, x, y, ids, d, nx, ny):
    r
    return _swigfaiss.fvec_inner_products_by_idx(ip, x, y, ids, d, nx, ny)

def fvec_L2sqr_by_idx(dis, x, y, ids, d, nx, ny):
    r
    return _swigfaiss.fvec_L2sqr_by_idx(dis, x, y, ids, d, nx, ny)

def pairwise_indexed_L2sqr(d, n, x, ix, y, iy, dis):
    r
    return _swigfaiss.pairwise_indexed_L2sqr(d, n, x, ix, y, iy, dis)

def pairwise_indexed_inner_product(d, n, x, ix, y, iy, dis):
    r
    return _swigfaiss.pairwise_indexed_inner_product(d, n, x, ix, y, iy, dis)

def knn_inner_product(*args):
    r
    return _swigfaiss.knn_inner_product(*args)

def knn_L2sqr(*args):
    r
    return _swigfaiss.knn_L2sqr(*args)

def knn_inner_products_by_idx(x, y, subset, d, nx, ny, nsubset, k, vals, ids, ld_ids=-1):
    r
    return _swigfaiss.knn_inner_products_by_idx(x, y, subset, d, nx, ny, nsubset, k, vals, ids, ld_ids)

def knn_L2sqr_by_idx(x, y, subset, d, nx, ny, nsubset, k, vals, ids, ld_subset=-1):
    r
    return _swigfaiss.knn_L2sqr_by_idx(x, y, subset, d, nx, ny, nsubset, k, vals, ids, ld_subset)

def range_search_L2sqr(x, y, d, nx, ny, radius, result, sel=None):
    r
    return _swigfaiss.range_search_L2sqr(x, y, d, nx, ny, radius, result, sel)

def range_search_inner_product(x, y, d, nx, ny, radius, result, sel=None):
    r
    return _swigfaiss.range_search_inner_product(x, y, d, nx, ny, radius, result, sel)

def compute_PQ_dis_tables_dsub2(d, ksub, centroids, nx, x, is_inner_product, dis_tables):
    r
    return _swigfaiss.compute_PQ_dis_tables_dsub2(d, ksub, centroids, nx, x, is_inner_product, dis_tables)

def fvec_madd(n, a, bf, b, c):
    r
    return _swigfaiss.fvec_madd(n, a, bf, b, c)

def fvec_madd_and_argmin(n, a, bf, b, c):
    r
    return _swigfaiss.fvec_madd_and_argmin(n, a, bf, b, c)
class RandomGenerator(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    mt = property(_swigfaiss.RandomGenerator_mt_get, _swigfaiss.RandomGenerator_mt_set)

    def rand_int64(self):
        r
        return _swigfaiss.RandomGenerator_rand_int64(self)

    def rand_int(self, *args):
        r
        return _swigfaiss.RandomGenerator_rand_int(self, *args)

    def rand_float(self):
        r
        return _swigfaiss.RandomGenerator_rand_float(self)

    def rand_double(self):
        return _swigfaiss.RandomGenerator_rand_double(self)

    def __init__(self, seed=1234):
        _swigfaiss.RandomGenerator_swiginit(self, _swigfaiss.new_RandomGenerator(seed))
    __swig_destroy__ = _swigfaiss.delete_RandomGenerator


_swigfaiss.RandomGenerator_swigregister(RandomGenerator)
class SplitMix64RandomGenerator(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    state = property(_swigfaiss.SplitMix64RandomGenerator_state_get, _swigfaiss.SplitMix64RandomGenerator_state_set)

    def rand_int64(self):
        r
        return _swigfaiss.SplitMix64RandomGenerator_rand_int64(self)

    def rand_int(self, *args):
        r
        return _swigfaiss.SplitMix64RandomGenerator_rand_int(self, *args)

    def rand_float(self):
        r
        return _swigfaiss.SplitMix64RandomGenerator_rand_float(self)

    def rand_double(self):
        return _swigfaiss.SplitMix64RandomGenerator_rand_double(self)

    def __init__(self, seed=1234):
        _swigfaiss.SplitMix64RandomGenerator_swiginit(self, _swigfaiss.new_SplitMix64RandomGenerator(seed))

    def next(self):
        return _swigfaiss.SplitMix64RandomGenerator_next(self)
    __swig_destroy__ = _swigfaiss.delete_SplitMix64RandomGenerator


_swigfaiss.SplitMix64RandomGenerator_swigregister(SplitMix64RandomGenerator)

def float_rand(x, n, seed):
    return _swigfaiss.float_rand(x, n, seed)

def float_randn(x, n, seed):
    return _swigfaiss.float_randn(x, n, seed)

def int64_rand(x, n, seed):
    return _swigfaiss.int64_rand(x, n, seed)

def byte_rand(x, n, seed):
    return _swigfaiss.byte_rand(x, n, seed)

def int64_rand_max(x, n, max, seed):
    return _swigfaiss.int64_rand_max(x, n, max, seed)

def rand_perm(perm, n, seed):
    return _swigfaiss.rand_perm(perm, n, seed)

def rand_perm_splitmix64(perm, n, seed):
    return _swigfaiss.rand_perm_splitmix64(perm, n, seed)

def rand_smooth_vectors(n, d, x, seed):
    return _swigfaiss.rand_smooth_vectors(n, d, x, seed)

def fvec_argsort(n, vals, perm):
    r
    return _swigfaiss.fvec_argsort(n, vals, perm)

def fvec_argsort_parallel(n, vals, perm):
    r
    return _swigfaiss.fvec_argsort_parallel(n, vals, perm)

def bucket_sort(nval, vals, nbucket, lims, perm, nt=0):
    r
    return _swigfaiss.bucket_sort(nval, vals, nbucket, lims, perm, nt)

def matrix_bucket_sort_inplace(*args):
    r
    return _swigfaiss.matrix_bucket_sort_inplace(*args)

def hashtable_int64_to_int64_init(log2_capacity, tab):
    r
    return _swigfaiss.hashtable_int64_to_int64_init(log2_capacity, tab)

def hashtable_int64_to_int64_add(log2_capacity, tab, n, keys, vals):
    return _swigfaiss.hashtable_int64_to_int64_add(log2_capacity, tab, n, keys, vals)

def hashtable_int64_to_int64_lookup(log2_capacity, tab, n, keys, vals):
    return _swigfaiss.hashtable_int64_to_int64_lookup(log2_capacity, tab, n, keys, vals)
METRIC_INNER_PRODUCT = _swigfaiss.METRIC_INNER_PRODUCT
r
METRIC_L2 = _swigfaiss.METRIC_L2
r
METRIC_L1 = _swigfaiss.METRIC_L1
r
METRIC_Linf = _swigfaiss.METRIC_Linf
r
METRIC_Lp = _swigfaiss.METRIC_Lp
r
METRIC_Canberra = _swigfaiss.METRIC_Canberra
r
METRIC_BrayCurtis = _swigfaiss.METRIC_BrayCurtis
METRIC_JensenShannon = _swigfaiss.METRIC_JensenShannon
METRIC_Jaccard = _swigfaiss.METRIC_Jaccard
r
METRIC_NaNEuclidean = _swigfaiss.METRIC_NaNEuclidean
r
METRIC_ABS_INNER_PRODUCT = _swigfaiss.METRIC_ABS_INNER_PRODUCT
r

def is_similarity_metric(metric_type):
    r
    return _swigfaiss.is_similarity_metric(metric_type)
FAISS_VERSION_MAJOR = _swigfaiss.FAISS_VERSION_MAJOR
FAISS_VERSION_MINOR = _swigfaiss.FAISS_VERSION_MINOR
FAISS_VERSION_PATCH = _swigfaiss.FAISS_VERSION_PATCH
VERSION_STRING = _swigfaiss.VERSION_STRING
class SearchParameters(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sel = property(_swigfaiss.SearchParameters_sel_get, _swigfaiss.SearchParameters_sel_set, doc=r)
    __swig_destroy__ = _swigfaiss.delete_SearchParameters

    def __init__(self):
        _swigfaiss.SearchParameters_swiginit(self, _swigfaiss.new_SearchParameters())


_swigfaiss.SearchParameters_swigregister(SearchParameters)
class Index(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    d = property(_swigfaiss.Index_d_get, _swigfaiss.Index_d_set, doc=r)
    ntotal = property(_swigfaiss.Index_ntotal_get, _swigfaiss.Index_ntotal_set, doc=r)
    verbose = property(_swigfaiss.Index_verbose_get, _swigfaiss.Index_verbose_set, doc=r)
    is_trained = property(_swigfaiss.Index_is_trained_get, _swigfaiss.Index_is_trained_set, doc=r)
    metric_type = property(_swigfaiss.Index_metric_type_get, _swigfaiss.Index_metric_type_set, doc=r)
    metric_arg = property(_swigfaiss.Index_metric_arg_get, _swigfaiss.Index_metric_arg_set, doc=r)
    __swig_destroy__ = _swigfaiss.delete_Index

    def train(self, n, x):
        r
        return _swigfaiss.Index_train(self, n, x)

    def add(self, n, x):
        r
        return _swigfaiss.Index_add(self, n, x)

    def add_with_ids(self, n, x, xids):
        r
        return _swigfaiss.Index_add_with_ids(self, n, x, xids)

    def search(self, n, x, k, distances, labels, params=None):
        r
        return _swigfaiss.Index_search(self, n, x, k, distances, labels, params)

    def range_search(self, n, x, radius, result, params=None):
        r
        return _swigfaiss.Index_range_search(self, n, x, radius, result, params)

    def assign(self, n, x, labels, k=1):
        r
        return _swigfaiss.Index_assign(self, n, x, labels, k)

    def reset(self):
        r
        return _swigfaiss.Index_reset(self)

    def remove_ids(self, sel):
        r
        return _swigfaiss.Index_remove_ids(self, sel)

    def reconstruct(self, key, recons):
        r
        return _swigfaiss.Index_reconstruct(self, key, recons)

    def reconstruct_batch(self, n, keys, recons):
        r
        return _swigfaiss.Index_reconstruct_batch(self, n, keys, recons)

    def reconstruct_n(self, i0, ni, recons):
        r
        return _swigfaiss.Index_reconstruct_n(self, i0, ni, recons)

    def search_and_reconstruct(self, n, x, k, distances, labels, recons, params=None):
        r
        return _swigfaiss.Index_search_and_reconstruct(self, n, x, k, distances, labels, recons, params)

    def compute_residual(self, x, residual, key):
        r
        return _swigfaiss.Index_compute_residual(self, x, residual, key)

    def compute_residual_n(self, n, xs, residuals, keys):
        r
        return _swigfaiss.Index_compute_residual_n(self, n, xs, residuals, keys)

    def get_distance_computer(self):
        r
        return _swigfaiss.Index_get_distance_computer(self)

    def sa_code_size(self):
        r
        return _swigfaiss.Index_sa_code_size(self)

    def sa_encode(self, n, x, bytes):
        r
        return _swigfaiss.Index_sa_encode(self, n, x, bytes)

    def sa_decode(self, n, bytes, x):
        r
        return _swigfaiss.Index_sa_decode(self, n, bytes, x)

    def merge_from(self, otherIndex, add_id=0):
        r
        return _swigfaiss.Index_merge_from(self, otherIndex, add_id)

    def check_compatible_for_merge(self, otherIndex):
        r
        return _swigfaiss.Index_check_compatible_for_merge(self, otherIndex)

    def add_sa_codes(self, n, codes, xids):
        r
        return _swigfaiss.Index_add_sa_codes(self, n, codes, xids)


_swigfaiss.Index_swigregister(Index)
class DistanceComputer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_query(self, x):
        r
        return _swigfaiss.DistanceComputer_set_query(self, x)

    def __call__(self, i):
        r
        return _swigfaiss.DistanceComputer___call__(self, i)

    def distances_batch_4(self, idx0, idx1, idx2, idx3, dis0, dis1, dis2, dis3):
        r
        return _swigfaiss.DistanceComputer_distances_batch_4(self, idx0, idx1, idx2, idx3, dis0, dis1, dis2, dis3)

    def symmetric_dis(self, i, j):
        r
        return _swigfaiss.DistanceComputer_symmetric_dis(self, i, j)
    __swig_destroy__ = _swigfaiss.delete_DistanceComputer


_swigfaiss.DistanceComputer_swigregister(DistanceComputer)
class NegativeDistanceComputer(DistanceComputer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    basedis = property(_swigfaiss.NegativeDistanceComputer_basedis_get, _swigfaiss.NegativeDistanceComputer_basedis_set, doc=r)

    def __init__(self, basedis):
        _swigfaiss.NegativeDistanceComputer_swiginit(self, _swigfaiss.new_NegativeDistanceComputer(basedis))

    def set_query(self, x):
        return _swigfaiss.NegativeDistanceComputer_set_query(self, x)

    def __call__(self, i):
        r
        return _swigfaiss.NegativeDistanceComputer___call__(self, i)

    def distances_batch_4(self, idx0, idx1, idx2, idx3, dis0, dis1, dis2, dis3):
        return _swigfaiss.NegativeDistanceComputer_distances_batch_4(self, idx0, idx1, idx2, idx3, dis0, dis1, dis2, dis3)

    def symmetric_dis(self, i, j):
        r
        return _swigfaiss.NegativeDistanceComputer_symmetric_dis(self, i, j)
    __swig_destroy__ = _swigfaiss.delete_NegativeDistanceComputer


_swigfaiss.NegativeDistanceComputer_swigregister(NegativeDistanceComputer)
class FlatCodesDistanceComputer(DistanceComputer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    codes = property(_swigfaiss.FlatCodesDistanceComputer_codes_get, _swigfaiss.FlatCodesDistanceComputer_codes_set)
    code_size = property(_swigfaiss.FlatCodesDistanceComputer_code_size_get, _swigfaiss.FlatCodesDistanceComputer_code_size_set)

    def __call__(self, i):
        return _swigfaiss.FlatCodesDistanceComputer___call__(self, i)

    def distance_to_code(self, code):
        r
        return _swigfaiss.FlatCodesDistanceComputer_distance_to_code(self, code)
    __swig_destroy__ = _swigfaiss.delete_FlatCodesDistanceComputer


_swigfaiss.FlatCodesDistanceComputer_swigregister(FlatCodesDistanceComputer)
class IOReader(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    name = property(_swigfaiss.IOReader_name_get, _swigfaiss.IOReader_name_set)

    def __call__(self, ptr, size, nitems):
        return _swigfaiss.IOReader___call__(self, ptr, size, nitems)

    def filedescriptor(self):
        return _swigfaiss.IOReader_filedescriptor(self)
    __swig_destroy__ = _swigfaiss.delete_IOReader


_swigfaiss.IOReader_swigregister(IOReader)
class IOWriter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    name = property(_swigfaiss.IOWriter_name_get, _swigfaiss.IOWriter_name_set)

    def __call__(self, ptr, size, nitems):
        return _swigfaiss.IOWriter___call__(self, ptr, size, nitems)

    def filedescriptor(self):
        return _swigfaiss.IOWriter_filedescriptor(self)
    __swig_destroy__ = _swigfaiss.delete_IOWriter


_swigfaiss.IOWriter_swigregister(IOWriter)
class VectorIOReader(IOReader):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data = property(_swigfaiss.VectorIOReader_data_get, _swigfaiss.VectorIOReader_data_set)
    rp = property(_swigfaiss.VectorIOReader_rp_get, _swigfaiss.VectorIOReader_rp_set)

    def __call__(self, ptr, size, nitems):
        return _swigfaiss.VectorIOReader___call__(self, ptr, size, nitems)

    def __init__(self):
        _swigfaiss.VectorIOReader_swiginit(self, _swigfaiss.new_VectorIOReader())
    __swig_destroy__ = _swigfaiss.delete_VectorIOReader


_swigfaiss.VectorIOReader_swigregister(VectorIOReader)
class VectorIOWriter(IOWriter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data = property(_swigfaiss.VectorIOWriter_data_get, _swigfaiss.VectorIOWriter_data_set)

    def __call__(self, ptr, size, nitems):
        return _swigfaiss.VectorIOWriter___call__(self, ptr, size, nitems)

    def __init__(self):
        _swigfaiss.VectorIOWriter_swiginit(self, _swigfaiss.new_VectorIOWriter())
    __swig_destroy__ = _swigfaiss.delete_VectorIOWriter


_swigfaiss.VectorIOWriter_swigregister(VectorIOWriter)
class FileIOReader(IOReader):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    f = property(_swigfaiss.FileIOReader_f_get, _swigfaiss.FileIOReader_f_set)
    need_close = property(_swigfaiss.FileIOReader_need_close_get, _swigfaiss.FileIOReader_need_close_set)

    def __init__(self, *args):
        _swigfaiss.FileIOReader_swiginit(self, _swigfaiss.new_FileIOReader(*args))
    __swig_destroy__ = _swigfaiss.delete_FileIOReader

    def __call__(self, ptr, size, nitems):
        return _swigfaiss.FileIOReader___call__(self, ptr, size, nitems)

    def filedescriptor(self):
        return _swigfaiss.FileIOReader_filedescriptor(self)


_swigfaiss.FileIOReader_swigregister(FileIOReader)
class FileIOWriter(IOWriter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    f = property(_swigfaiss.FileIOWriter_f_get, _swigfaiss.FileIOWriter_f_set)
    need_close = property(_swigfaiss.FileIOWriter_need_close_get, _swigfaiss.FileIOWriter_need_close_set)

    def __init__(self, *args):
        _swigfaiss.FileIOWriter_swiginit(self, _swigfaiss.new_FileIOWriter(*args))
    __swig_destroy__ = _swigfaiss.delete_FileIOWriter

    def __call__(self, ptr, size, nitems):
        return _swigfaiss.FileIOWriter___call__(self, ptr, size, nitems)

    def filedescriptor(self):
        return _swigfaiss.FileIOWriter_filedescriptor(self)


_swigfaiss.FileIOWriter_swigregister(FileIOWriter)
class BufferedIOReader(IOReader):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    reader = property(_swigfaiss.BufferedIOReader_reader_get, _swigfaiss.BufferedIOReader_reader_set)
    bsz = property(_swigfaiss.BufferedIOReader_bsz_get, _swigfaiss.BufferedIOReader_bsz_set)
    ofs = property(_swigfaiss.BufferedIOReader_ofs_get, _swigfaiss.BufferedIOReader_ofs_set, doc=r)
    ofs2 = property(_swigfaiss.BufferedIOReader_ofs2_get, _swigfaiss.BufferedIOReader_ofs2_set, doc=r)
    b0 = property(_swigfaiss.BufferedIOReader_b0_get, _swigfaiss.BufferedIOReader_b0_set, doc=r)
    b1 = property(_swigfaiss.BufferedIOReader_b1_get, _swigfaiss.BufferedIOReader_b1_set)
    buffer = property(_swigfaiss.BufferedIOReader_buffer_get, _swigfaiss.BufferedIOReader_buffer_set)

    def __init__(self, *args):
        r
        _swigfaiss.BufferedIOReader_swiginit(self, _swigfaiss.new_BufferedIOReader(*args))

    def __call__(self, ptr, size, nitems):
        return _swigfaiss.BufferedIOReader___call__(self, ptr, size, nitems)
    __swig_destroy__ = _swigfaiss.delete_BufferedIOReader


_swigfaiss.BufferedIOReader_swigregister(BufferedIOReader)
class BufferedIOWriter(IOWriter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    writer = property(_swigfaiss.BufferedIOWriter_writer_get, _swigfaiss.BufferedIOWriter_writer_set)
    bsz = property(_swigfaiss.BufferedIOWriter_bsz_get, _swigfaiss.BufferedIOWriter_bsz_set)
    ofs = property(_swigfaiss.BufferedIOWriter_ofs_get, _swigfaiss.BufferedIOWriter_ofs_set)
    ofs2 = property(_swigfaiss.BufferedIOWriter_ofs2_get, _swigfaiss.BufferedIOWriter_ofs2_set, doc=r)
    b0 = property(_swigfaiss.BufferedIOWriter_b0_get, _swigfaiss.BufferedIOWriter_b0_set, doc=r)
    buffer = property(_swigfaiss.BufferedIOWriter_buffer_get, _swigfaiss.BufferedIOWriter_buffer_set)

    def __init__(self, *args):
        _swigfaiss.BufferedIOWriter_swiginit(self, _swigfaiss.new_BufferedIOWriter(*args))

    def __call__(self, ptr, size, nitems):
        return _swigfaiss.BufferedIOWriter___call__(self, ptr, size, nitems)
    __swig_destroy__ = _swigfaiss.delete_BufferedIOWriter


_swigfaiss.BufferedIOWriter_swigregister(BufferedIOWriter)

def fourcc(*args):
    r
    return _swigfaiss.fourcc(*args)

def fourcc_inv(*args):
    return _swigfaiss.fourcc_inv(*args)

def fourcc_inv_printable(x):
    return _swigfaiss.fourcc_inv_printable(x)
class MaybeOwnedVectorOwner(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _swigfaiss.delete_MaybeOwnedVectorOwner

    def __init__(self):
        _swigfaiss.MaybeOwnedVectorOwner_swiginit(self, _swigfaiss.new_MaybeOwnedVectorOwner())


_swigfaiss.MaybeOwnedVectorOwner_swigregister(MaybeOwnedVectorOwner)
class MmappedFileMappingOwner(MaybeOwnedVectorOwner):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _swigfaiss.MmappedFileMappingOwner_swiginit(self, _swigfaiss.new_MmappedFileMappingOwner(*args))
    __swig_destroy__ = _swigfaiss.delete_MmappedFileMappingOwner

    def data(self):
        return _swigfaiss.MmappedFileMappingOwner_data(self)

    def size(self):
        return _swigfaiss.MmappedFileMappingOwner_size(self)


_swigfaiss.MmappedFileMappingOwner_swigregister(MmappedFileMappingOwner)
class MappedFileIOReader(IOReader):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    mmap_owner = property(_swigfaiss.MappedFileIOReader_mmap_owner_get, _swigfaiss.MappedFileIOReader_mmap_owner_set)
    pos = property(_swigfaiss.MappedFileIOReader_pos_get, _swigfaiss.MappedFileIOReader_pos_set)

    def __init__(self, owner):
        _swigfaiss.MappedFileIOReader_swiginit(self, _swigfaiss.new_MappedFileIOReader(owner))

    def __call__(self, ptr, size, nitems):
        return _swigfaiss.MappedFileIOReader___call__(self, ptr, size, nitems)

    def mmap(self, ptr, size, nitems):
        return _swigfaiss.MappedFileIOReader_mmap(self, ptr, size, nitems)

    def filedescriptor(self):
        return _swigfaiss.MappedFileIOReader_filedescriptor(self)
    __swig_destroy__ = _swigfaiss.delete_MappedFileIOReader


_swigfaiss.MappedFileIOReader_swigregister(MappedFileIOReader)
class ZeroCopyIOReader(IOReader):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data_ = property(_swigfaiss.ZeroCopyIOReader_data__get, _swigfaiss.ZeroCopyIOReader_data__set)
    rp_ = property(_swigfaiss.ZeroCopyIOReader_rp__get, _swigfaiss.ZeroCopyIOReader_rp__set)
    total_ = property(_swigfaiss.ZeroCopyIOReader_total__get, _swigfaiss.ZeroCopyIOReader_total__set)

    def __init__(self, data, size):
        _swigfaiss.ZeroCopyIOReader_swiginit(self, _swigfaiss.new_ZeroCopyIOReader(data, size))
    __swig_destroy__ = _swigfaiss.delete_ZeroCopyIOReader

    def reset(self):
        return _swigfaiss.ZeroCopyIOReader_reset(self)

    def get_data_view(self, ptr, size, nitems):
        return _swigfaiss.ZeroCopyIOReader_get_data_view(self, ptr, size, nitems)

    def __call__(self, ptr, size, nitems):
        return _swigfaiss.ZeroCopyIOReader___call__(self, ptr, size, nitems)

    def filedescriptor(self):
        return _swigfaiss.ZeroCopyIOReader_filedescriptor(self)


_swigfaiss.ZeroCopyIOReader_swigregister(ZeroCopyIOReader)
class IndexFlatCodes(Index):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code_size = property(_swigfaiss.IndexFlatCodes_code_size_get, _swigfaiss.IndexFlatCodes_code_size_set)
    codes = property(_swigfaiss.IndexFlatCodes_codes_get, _swigfaiss.IndexFlatCodes_codes_set, doc=r)

    def __init__(self, *args):
        _swigfaiss.IndexFlatCodes_swiginit(self, _swigfaiss.new_IndexFlatCodes(*args))

    def add(self, n, x):
        r
        return _swigfaiss.IndexFlatCodes_add(self, n, x)

    def reset(self):
        return _swigfaiss.IndexFlatCodes_reset(self)

    def reconstruct_n(self, i0, ni, recons):
        return _swigfaiss.IndexFlatCodes_reconstruct_n(self, i0, ni, recons)

    def reconstruct(self, key, recons):
        return _swigfaiss.IndexFlatCodes_reconstruct(self, key, recons)

    def sa_code_size(self):
        return _swigfaiss.IndexFlatCodes_sa_code_size(self)

    def remove_ids(self, sel):
        r
        return _swigfaiss.IndexFlatCodes_remove_ids(self, sel)

    def get_FlatCodesDistanceComputer(self):
        r
        return _swigfaiss.IndexFlatCodes_get_FlatCodesDistanceComputer(self)

    def get_distance_computer(self):
        return _swigfaiss.IndexFlatCodes_get_distance_computer(self)

    def search(self, n, x, k, distances, labels, params=None):
        r
        return _swigfaiss.IndexFlatCodes_search(self, n, x, k, distances, labels, params)

    def range_search(self, n, x, radius, result, params=None):
        return _swigfaiss.IndexFlatCodes_range_search(self, n, x, radius, result, params)

    def get_CodePacker(self):
        return _swigfaiss.IndexFlatCodes_get_CodePacker(self)

    def check_compatible_for_merge(self, otherIndex):
        return _swigfaiss.IndexFlatCodes_check_compatible_for_merge(self, otherIndex)

    def merge_from(self, otherIndex, add_id=0):
        return _swigfaiss.IndexFlatCodes_merge_from(self, otherIndex, add_id)

    def add_sa_codes(self, n, x, xids):
        return _swigfaiss.IndexFlatCodes_add_sa_codes(self, n, x, xids)

    def permute_entries(self, perm):
        return _swigfaiss.IndexFlatCodes_permute_entries(self, perm)
    __swig_destroy__ = _swigfaiss.delete_IndexFlatCodes


_swigfaiss.IndexFlatCodes_swigregister(IndexFlatCodes)
class IndexFlat(IndexFlatCodes):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def search(self, n, x, k, distances, labels, params=None):
        return _swigfaiss.IndexFlat_search(self, n, x, k, distances, labels, params)

    def range_search(self, n, x, radius, result, params=None):
        return _swigfaiss.IndexFlat_range_search(self, n, x, radius, result, params)

    def reconstruct(self, key, recons):
        return _swigfaiss.IndexFlat_reconstruct(self, key, recons)

    def compute_distance_subset(self, n, x, k, distances, labels):
        r
        return _swigfaiss.IndexFlat_compute_distance_subset(self, n, x, k, distances, labels)

    def get_xb(self, *args):
        return _swigfaiss.IndexFlat_get_xb(self, *args)

    def __init__(self, *args):
        _swigfaiss.IndexFlat_swiginit(self, _swigfaiss.new_IndexFlat(*args))

    def get_FlatCodesDistanceComputer(self):
        return _swigfaiss.IndexFlat_get_FlatCodesDistanceComputer(self)

    def sa_encode(self, n, x, bytes):
        return _swigfaiss.IndexFlat_sa_encode(self, n, x, bytes)

    def sa_decode(self, n, bytes, x):
        return _swigfaiss.IndexFlat_sa_decode(self, n, bytes, x)
    __swig_destroy__ = _swigfaiss.delete_IndexFlat


_swigfaiss.IndexFlat_swigregister(IndexFlat)
class IndexFlatIP(IndexFlat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _swigfaiss.IndexFlatIP_swiginit(self, _swigfaiss.new_IndexFlatIP(*args))
    __swig_destroy__ = _swigfaiss.delete_IndexFlatIP


_swigfaiss.IndexFlatIP_swigregister(IndexFlatIP)
class IndexFlatL2(IndexFlat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cached_l2norms = property(_swigfaiss.IndexFlatL2_cached_l2norms_get, _swigfaiss.IndexFlatL2_cached_l2norms_set)

    def __init__(self, *args):
        r
        _swigfaiss.IndexFlatL2_swiginit(self, _swigfaiss.new_IndexFlatL2(*args))

    def get_FlatCodesDistanceComputer(self):
        return _swigfaiss.IndexFlatL2_get_FlatCodesDistanceComputer(self)

    def sync_l2norms(self):
        return _swigfaiss.IndexFlatL2_sync_l2norms(self)

    def clear_l2norms(self):
        return _swigfaiss.IndexFlatL2_clear_l2norms(self)
    __swig_destroy__ = _swigfaiss.delete_IndexFlatL2


_swigfaiss.IndexFlatL2_swigregister(IndexFlatL2)
class IndexFlat1D(IndexFlatL2):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    continuous_update = property(_swigfaiss.IndexFlat1D_continuous_update_get, _swigfaiss.IndexFlat1D_continuous_update_set, doc=r)
    perm = property(_swigfaiss.IndexFlat1D_perm_get, _swigfaiss.IndexFlat1D_perm_set, doc=r)

    def __init__(self, continuous_update=True):
        _swigfaiss.IndexFlat1D_swiginit(self, _swigfaiss.new_IndexFlat1D(continuous_update))

    def update_permutation(self):
        r
        return _swigfaiss.IndexFlat1D_update_permutation(self)

    def add(self, n, x):
        return _swigfaiss.IndexFlat1D_add(self, n, x)

    def reset(self):
        return _swigfaiss.IndexFlat1D_reset(self)

    def search(self, n, x, k, distances, labels, params=None):
        r
        return _swigfaiss.IndexFlat1D_search(self, n, x, k, distances, labels, params)
    __swig_destroy__ = _swigfaiss.delete_IndexFlat1D


_swigfaiss.IndexFlat1D_swigregister(IndexFlat1D)
class ClusteringParameters(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    niter = property(_swigfaiss.ClusteringParameters_niter_get, _swigfaiss.ClusteringParameters_niter_set, doc=r)
    nredo = property(_swigfaiss.ClusteringParameters_nredo_get, _swigfaiss.ClusteringParameters_nredo_set, doc=r)
    verbose = property(_swigfaiss.ClusteringParameters_verbose_get, _swigfaiss.ClusteringParameters_verbose_set)
    spherical = property(_swigfaiss.ClusteringParameters_spherical_get, _swigfaiss.ClusteringParameters_spherical_set, doc=r)
    int_centroids = property(_swigfaiss.ClusteringParameters_int_centroids_get, _swigfaiss.ClusteringParameters_int_centroids_set, doc=r)
    update_index = property(_swigfaiss.ClusteringParameters_update_index_get, _swigfaiss.ClusteringParameters_update_index_set, doc=r)
    frozen_centroids = property(_swigfaiss.ClusteringParameters_frozen_centroids_get, _swigfaiss.ClusteringParameters_frozen_centroids_set, doc=r)
    min_points_per_centroid = property(_swigfaiss.ClusteringParameters_min_points_per_centroid_get, _swigfaiss.ClusteringParameters_min_points_per_centroid_set, doc=r)
    max_points_per_centroid = property(_swigfaiss.ClusteringParameters_max_points_per_centroid_get, _swigfaiss.ClusteringParameters_max_points_per_centroid_set, doc=r)
    seed = property(_swigfaiss.ClusteringParameters_seed_get, _swigfaiss.ClusteringParameters_seed_set, doc=r)
    decode_block_size = property(_swigfaiss.ClusteringParameters_decode_block_size_get, _swigfaiss.ClusteringParameters_decode_block_size_set, doc=r)
    check_input_data_for_NaNs = property(_swigfaiss.ClusteringParameters_check_input_data_for_NaNs_get, _swigfaiss.ClusteringParameters_check_input_data_for_NaNs_set, doc=r)
    use_faster_subsampling = property(_swigfaiss.ClusteringParameters_use_faster_subsampling_get, _swigfaiss.ClusteringParameters_use_faster_subsampling_set, doc=r)

    def __init__(self):
        _swigfaiss.ClusteringParameters_swiginit(self, _swigfaiss.new_ClusteringParameters())
    __swig_destroy__ = _swigfaiss.delete_ClusteringParameters


_swigfaiss.ClusteringParameters_swigregister(ClusteringParameters)
class ClusteringIterationStats(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    obj = property(_swigfaiss.ClusteringIterationStats_obj_get, _swigfaiss.ClusteringIterationStats_obj_set, doc=r)
    time = property(_swigfaiss.ClusteringIterationStats_time_get, _swigfaiss.ClusteringIterationStats_time_set, doc=r)
    time_search = property(_swigfaiss.ClusteringIterationStats_time_search_get, _swigfaiss.ClusteringIterationStats_time_search_set, doc=r)
    imbalance_factor = property(_swigfaiss.ClusteringIterationStats_imbalance_factor_get, _swigfaiss.ClusteringIterationStats_imbalance_factor_set, doc=r)
    nsplit = property(_swigfaiss.ClusteringIterationStats_nsplit_get, _swigfaiss.ClusteringIterationStats_nsplit_set, doc=r)

    def __init__(self):
        _swigfaiss.ClusteringIterationStats_swiginit(self, _swigfaiss.new_ClusteringIterationStats())
    __swig_destroy__ = _swigfaiss.delete_ClusteringIterationStats


_swigfaiss.ClusteringIterationStats_swigregister(ClusteringIterationStats)
class Clustering(ClusteringParameters):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    d = property(_swigfaiss.Clustering_d_get, _swigfaiss.Clustering_d_set, doc=r)
    k = property(_swigfaiss.Clustering_k_get, _swigfaiss.Clustering_k_set, doc=r)
    centroids = property(_swigfaiss.Clustering_centroids_get, _swigfaiss.Clustering_centroids_set, doc=r)
    iteration_stats = property(_swigfaiss.Clustering_iteration_stats_get, _swigfaiss.Clustering_iteration_stats_set, doc=r)

    def __init__(self, *args):
        _swigfaiss.Clustering_swiginit(self, _swigfaiss.new_Clustering(*args))

    def train(self, n, x, index, x_weights=None):
        r
        return _swigfaiss.Clustering_train(self, n, x, index, x_weights)

    def train_encoded(self, nx, x_in, codec, index, weights=None):
        r
        return _swigfaiss.Clustering_train_encoded(self, nx, x_in, codec, index, weights)

    def post_process_centroids(self):
        r
        return _swigfaiss.Clustering_post_process_centroids(self)
    __swig_destroy__ = _swigfaiss.delete_Clustering


_swigfaiss.Clustering_swigregister(Clustering)
class Clustering1D(Clustering):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _swigfaiss.Clustering1D_swiginit(self, _swigfaiss.new_Clustering1D(*args))

    def train_exact(self, n, x):
        return _swigfaiss.Clustering1D_train_exact(self, n, x)
    __swig_destroy__ = _swigfaiss.delete_Clustering1D


_swigfaiss.Clustering1D_swigregister(Clustering1D)
class ProgressiveDimClusteringParameters(ClusteringParameters):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    progressive_dim_steps = property(_swigfaiss.ProgressiveDimClusteringParameters_progressive_dim_steps_get, _swigfaiss.ProgressiveDimClusteringParameters_progressive_dim_steps_set, doc=r)
    apply_pca = property(_swigfaiss.ProgressiveDimClusteringParameters_apply_pca_get, _swigfaiss.ProgressiveDimClusteringParameters_apply_pca_set, doc=r)

    def __init__(self):
        _swigfaiss.ProgressiveDimClusteringParameters_swiginit(self, _swigfaiss.new_ProgressiveDimClusteringParameters())
    __swig_destroy__ = _swigfaiss.delete_ProgressiveDimClusteringParameters


_swigfaiss.ProgressiveDimClusteringParameters_swigregister(ProgressiveDimClusteringParameters)
class ProgressiveDimIndexFactory(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __call__(self, dim):
        r
        return _swigfaiss.ProgressiveDimIndexFactory___call__(self, dim)
    __swig_destroy__ = _swigfaiss.delete_ProgressiveDimIndexFactory

    def __init__(self):
        _swigfaiss.ProgressiveDimIndexFactory_swiginit(self, _swigfaiss.new_ProgressiveDimIndexFactory())


_swigfaiss.ProgressiveDimIndexFactory_swigregister(ProgressiveDimIndexFactory)
class ProgressiveDimClustering(ProgressiveDimClusteringParameters):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    d = property(_swigfaiss.ProgressiveDimClustering_d_get, _swigfaiss.ProgressiveDimClustering_d_set, doc=r)
    k = property(_swigfaiss.ProgressiveDimClustering_k_get, _swigfaiss.ProgressiveDimClustering_k_set, doc=r)
    centroids = property(_swigfaiss.ProgressiveDimClustering_centroids_get, _swigfaiss.ProgressiveDimClustering_centroids_set, doc=r)
    iteration_stats = property(_swigfaiss.ProgressiveDimClustering_iteration_stats_get, _swigfaiss.ProgressiveDimClustering_iteration_stats_set, doc=r)

    def __init__(self, *args):
        _swigfaiss.ProgressiveDimClustering_swiginit(self, _swigfaiss.new_ProgressiveDimClustering(*args))

    def train(self, n, x, factory):
        return _swigfaiss.ProgressiveDimClustering_train(self, n, x, factory)
    __swig_destroy__ = _swigfaiss.delete_ProgressiveDimClustering


_swigfaiss.ProgressiveDimClustering_swigregister(ProgressiveDimClustering)

def kmeans_clustering(d, n, k, x, centroids):
    r
    return _swigfaiss.kmeans_clustering(d, n, k, x, centroids)

def pairwise_extra_distances(d, nq, xq, nb, xb, mt, metric_arg, dis, ldq=-1, ldb=-1, ldd=-1):
    return _swigfaiss.pairwise_extra_distances(d, nq, xq, nb, xb, mt, metric_arg, dis, ldq, ldb, ldd)

def knn_extra_metrics(x, y, d, nx, ny, mt, metric_arg, k, distances, indexes):
    return _swigfaiss.knn_extra_metrics(x, y, d, nx, ny, mt, metric_arg, k, distances, indexes)

def get_extra_distance_computer(d, mt, metric_arg, nb, xb):
    r
    return _swigfaiss.get_extra_distance_computer(d, mt, metric_arg, nb, xb)
class Quantizer(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    d = property(_swigfaiss.Quantizer_d_get, _swigfaiss.Quantizer_d_set, doc=r)
    code_size = property(_swigfaiss.Quantizer_code_size_get, _swigfaiss.Quantizer_code_size_set, doc=r)

    def train(self, n, x):
        r
        return _swigfaiss.Quantizer_train(self, n, x)

    def compute_codes(self, x, codes, n):
        r
        return _swigfaiss.Quantizer_compute_codes(self, x, codes, n)

    def decode(self, code, x, n):
        r
        return _swigfaiss.Quantizer_decode(self, code, x, n)
    __swig_destroy__ = _swigfaiss.delete_Quantizer


_swigfaiss.Quantizer_swigregister(Quantizer)
class ProductQuantizer(Quantizer):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    M = property(_swigfaiss.ProductQuantizer_M_get, _swigfaiss.ProductQuantizer_M_set, doc=r)
    nbits = property(_swigfaiss.ProductQuantizer_nbits_get, _swigfaiss.ProductQuantizer_nbits_set, doc=r)
    dsub = property(_swigfaiss.ProductQuantizer_dsub_get, _swigfaiss.ProductQuantizer_dsub_set, doc=r)
    ksub = property(_swigfaiss.ProductQuantizer_ksub_get, _swigfaiss.ProductQuantizer_ksub_set, doc=r)
    verbose = property(_swigfaiss.ProductQuantizer_verbose_get, _swigfaiss.ProductQuantizer_verbose_set, doc=r)
    Train_default = _swigfaiss.ProductQuantizer_Train_default
    Train_hot_start = _swigfaiss.ProductQuantizer_Train_hot_start
    r
    Train_shared = _swigfaiss.ProductQuantizer_Train_shared
    r
    Train_hypercube = _swigfaiss.ProductQuantizer_Train_hypercube
    r
    Train_hypercube_pca = _swigfaiss.ProductQuantizer_Train_hypercube_pca
    r
    train_type = property(_swigfaiss.ProductQuantizer_train_type_get, _swigfaiss.ProductQuantizer_train_type_set)
    cp = property(_swigfaiss.ProductQuantizer_cp_get, _swigfaiss.ProductQuantizer_cp_set, doc=r)
    assign_index = property(_swigfaiss.ProductQuantizer_assign_index_get, _swigfaiss.ProductQuantizer_assign_index_set, doc=r)
    centroids = property(_swigfaiss.ProductQuantizer_centroids_get, _swigfaiss.ProductQuantizer_centroids_set, doc=r)
    transposed_centroids = property(_swigfaiss.ProductQuantizer_transposed_centroids_get, _swigfaiss.ProductQuantizer_transposed_centroids_set, doc=r)
    centroids_sq_lengths = property(_swigfaiss.ProductQuantizer_centroids_sq_lengths_get, _swigfaiss.ProductQuantizer_centroids_sq_lengths_set, doc=r)

    def get_centroids(self, m, i):
        r
        return _swigfaiss.ProductQuantizer_get_centroids(self, m, i)

    def train(self, n, x):
        return _swigfaiss.ProductQuantizer_train(self, n, x)

    def __init__(self, *args):
        _swigfaiss.ProductQuantizer_swiginit(self, _swigfaiss.new_ProductQuantizer(*args))

    def set_derived_values(self):
        r
        return _swigfaiss.ProductQuantizer_set_derived_values(self)

    def set_params(self, centroids, m):
        r
        return _swigfaiss.ProductQuantizer_set_params(self, centroids, m)

    def compute_code(self, x, code):
        r
        return _swigfaiss.ProductQuantizer_compute_code(self, x, code)

    def compute_codes(self, x, codes, n):
        r
        return _swigfaiss.ProductQuantizer_compute_codes(self, x, codes, n)

    def compute_codes_with_assign_index(self, x, codes, n):
        r
        return _swigfaiss.ProductQuantizer_compute_codes_with_assign_index(self, x, codes, n)

    def decode(self, *args):
        r
        return _swigfaiss.ProductQuantizer_decode(self, *args)

    def compute_code_from_distance_table(self, tab, code):
        r
        return _swigfaiss.ProductQuantizer_compute_code_from_distance_table(self, tab, code)

    def compute_distance_table(self, x, dis_table):
        r
        return _swigfaiss.ProductQuantizer_compute_distance_table(self, x, dis_table)

    def compute_inner_prod_table(self, x, dis_table):
        return _swigfaiss.ProductQuantizer_compute_inner_prod_table(self, x, dis_table)

    def compute_distance_tables(self, nx, x, dis_tables):
        r
        return _swigfaiss.ProductQuantizer_compute_distance_tables(self, nx, x, dis_tables)

    def compute_inner_prod_tables(self, nx, x, dis_tables):
        return _swigfaiss.ProductQuantizer_compute_inner_prod_tables(self, nx, x, dis_tables)

    def search(self, x, nx, codes, ncodes, res, init_finalize_heap=True):
        r
        return _swigfaiss.ProductQuantizer_search(self, x, nx, codes, ncodes, res, init_finalize_heap)

    def search_ip(self, x, nx, codes, ncodes, res, init_finalize_heap=True):
        r
        return _swigfaiss.ProductQuantizer_search_ip(self, x, nx, codes, ncodes, res, init_finalize_heap)
    sdc_table = property(_swigfaiss.ProductQuantizer_sdc_table_get, _swigfaiss.ProductQuantizer_sdc_table_set, doc=r)

    def compute_sdc_table(self):
        return _swigfaiss.ProductQuantizer_compute_sdc_table(self)

    def search_sdc(self, qcodes, nq, bcodes, ncodes, res, init_finalize_heap=True):
        return _swigfaiss.ProductQuantizer_search_sdc(self, qcodes, nq, bcodes, ncodes, res, init_finalize_heap)

    def sync_transposed_centroids(self):
        r
        return _swigfaiss.ProductQuantizer_sync_transposed_centroids(self)

    def clear_transposed_centroids(self):
        r
        return _swigfaiss.ProductQuantizer_clear_transposed_centroids(self)
    __swig_destroy__ = _swigfaiss.delete_ProductQuantizer


_swigfaiss.ProductQuantizer_swigregister(ProductQuantizer)
class PQEncoderGeneric(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code = property(_swigfaiss.PQEncoderGeneric_code_get, _swigfaiss.PQEncoderGeneric_code_set, doc=r)
    offset = property(_swigfaiss.PQEncoderGeneric_offset_get, _swigfaiss.PQEncoderGeneric_offset_set)
    nbits = property(_swigfaiss.PQEncoderGeneric_nbits_get, doc=r)
    reg = property(_swigfaiss.PQEncoderGeneric_reg_get, _swigfaiss.PQEncoderGeneric_reg_set)

    def __init__(self, code, nbits, offset=0):
        _swigfaiss.PQEncoderGeneric_swiginit(self, _swigfaiss.new_PQEncoderGeneric(code, nbits, offset))

    def encode(self, x):
        return _swigfaiss.PQEncoderGeneric_encode(self, x)
    __swig_destroy__ = _swigfaiss.delete_PQEncoderGeneric


_swigfaiss.PQEncoderGeneric_swigregister(PQEncoderGeneric)
class PQEncoder8(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code = property(_swigfaiss.PQEncoder8_code_get, _swigfaiss.PQEncoder8_code_set)

    def __init__(self, code, nbits):
        _swigfaiss.PQEncoder8_swiginit(self, _swigfaiss.new_PQEncoder8(code, nbits))

    def encode(self, x):
        return _swigfaiss.PQEncoder8_encode(self, x)
    __swig_destroy__ = _swigfaiss.delete_PQEncoder8


_swigfaiss.PQEncoder8_swigregister(PQEncoder8)
class PQEncoder16(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code = property(_swigfaiss.PQEncoder16_code_get, _swigfaiss.PQEncoder16_code_set)

    def __init__(self, code, nbits):
        _swigfaiss.PQEncoder16_swiginit(self, _swigfaiss.new_PQEncoder16(code, nbits))

    def encode(self, x):
        return _swigfaiss.PQEncoder16_encode(self, x)
    __swig_destroy__ = _swigfaiss.delete_PQEncoder16


_swigfaiss.PQEncoder16_swigregister(PQEncoder16)
class PQDecoderGeneric(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code = property(_swigfaiss.PQDecoderGeneric_code_get, _swigfaiss.PQDecoderGeneric_code_set)
    offset = property(_swigfaiss.PQDecoderGeneric_offset_get, _swigfaiss.PQDecoderGeneric_offset_set)
    nbits = property(_swigfaiss.PQDecoderGeneric_nbits_get)
    mask = property(_swigfaiss.PQDecoderGeneric_mask_get)
    reg = property(_swigfaiss.PQDecoderGeneric_reg_get, _swigfaiss.PQDecoderGeneric_reg_set)

    def __init__(self, code, nbits):
        _swigfaiss.PQDecoderGeneric_swiginit(self, _swigfaiss.new_PQDecoderGeneric(code, nbits))

    def decode(self):
        return _swigfaiss.PQDecoderGeneric_decode(self)
    __swig_destroy__ = _swigfaiss.delete_PQDecoderGeneric


_swigfaiss.PQDecoderGeneric_swigregister(PQDecoderGeneric)
class PQDecoder8(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nbits = _swigfaiss.PQDecoder8_nbits
    code = property(_swigfaiss.PQDecoder8_code_get, _swigfaiss.PQDecoder8_code_set)

    def __init__(self, code, nbits):
        _swigfaiss.PQDecoder8_swiginit(self, _swigfaiss.new_PQDecoder8(code, nbits))

    def decode(self):
        return _swigfaiss.PQDecoder8_decode(self)
    __swig_destroy__ = _swigfaiss.delete_PQDecoder8


_swigfaiss.PQDecoder8_swigregister(PQDecoder8)
class PQDecoder16(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nbits = _swigfaiss.PQDecoder16_nbits
    code = property(_swigfaiss.PQDecoder16_code_get, _swigfaiss.PQDecoder16_code_set)

    def __init__(self, code, nbits):
        _swigfaiss.PQDecoder16_swiginit(self, _swigfaiss.new_PQDecoder16(code, nbits))

    def decode(self):
        return _swigfaiss.PQDecoder16_decode(self)
    __swig_destroy__ = _swigfaiss.delete_PQDecoder16


_swigfaiss.PQDecoder16_swigregister(PQDecoder16)
class AdditiveQuantizer(Quantizer):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    M = property(_swigfaiss.AdditiveQuantizer_M_get, _swigfaiss.AdditiveQuantizer_M_set, doc=r)
    nbits = property(_swigfaiss.AdditiveQuantizer_nbits_get, _swigfaiss.AdditiveQuantizer_nbits_set, doc=r)
    codebooks = property(_swigfaiss.AdditiveQuantizer_codebooks_get, _swigfaiss.AdditiveQuantizer_codebooks_set, doc=r)
    codebook_offsets = property(_swigfaiss.AdditiveQuantizer_codebook_offsets_get, _swigfaiss.AdditiveQuantizer_codebook_offsets_set, doc=r)
    tot_bits = property(_swigfaiss.AdditiveQuantizer_tot_bits_get, _swigfaiss.AdditiveQuantizer_tot_bits_set, doc=r)
    norm_bits = property(_swigfaiss.AdditiveQuantizer_norm_bits_get, _swigfaiss.AdditiveQuantizer_norm_bits_set, doc=r)
    total_codebook_size = property(_swigfaiss.AdditiveQuantizer_total_codebook_size_get, _swigfaiss.AdditiveQuantizer_total_codebook_size_set, doc=r)
    only_8bit = property(_swigfaiss.AdditiveQuantizer_only_8bit_get, _swigfaiss.AdditiveQuantizer_only_8bit_set, doc=r)
    verbose = property(_swigfaiss.AdditiveQuantizer_verbose_get, _swigfaiss.AdditiveQuantizer_verbose_set, doc=r)
    is_trained = property(_swigfaiss.AdditiveQuantizer_is_trained_get, _swigfaiss.AdditiveQuantizer_is_trained_set, doc=r)
    norm_tabs = property(_swigfaiss.AdditiveQuantizer_norm_tabs_get, _swigfaiss.AdditiveQuantizer_norm_tabs_set, doc=r)
    qnorm = property(_swigfaiss.AdditiveQuantizer_qnorm_get, _swigfaiss.AdditiveQuantizer_qnorm_set, doc=r)

    def compute_codebook_tables(self):
        return _swigfaiss.AdditiveQuantizer_compute_codebook_tables(self)
    centroid_norms = property(_swigfaiss.AdditiveQuantizer_centroid_norms_get, _swigfaiss.AdditiveQuantizer_centroid_norms_set, doc=r)
    codebook_cross_products = property(_swigfaiss.AdditiveQuantizer_codebook_cross_products_get, _swigfaiss.AdditiveQuantizer_codebook_cross_products_set, doc=r)
    max_mem_distances = property(_swigfaiss.AdditiveQuantizer_max_mem_distances_get, _swigfaiss.AdditiveQuantizer_max_mem_distances_set, doc=r)

    def encode_norm(self, norm):
        r
        return _swigfaiss.AdditiveQuantizer_encode_norm(self, norm)

    def encode_qcint(self, x):
        r
        return _swigfaiss.AdditiveQuantizer_encode_qcint(self, x)

    def decode_qcint(self, c):
        r
        return _swigfaiss.AdditiveQuantizer_decode_qcint(self, c)
    ST_decompress = _swigfaiss.AdditiveQuantizer_ST_decompress
    r
    ST_LUT_nonorm = _swigfaiss.AdditiveQuantizer_ST_LUT_nonorm
    r
    ST_norm_from_LUT = _swigfaiss.AdditiveQuantizer_ST_norm_from_LUT
    r
    ST_norm_float = _swigfaiss.AdditiveQuantizer_ST_norm_float
    r
    ST_norm_qint8 = _swigfaiss.AdditiveQuantizer_ST_norm_qint8
    r
    ST_norm_qint4 = _swigfaiss.AdditiveQuantizer_ST_norm_qint4
    ST_norm_cqint8 = _swigfaiss.AdditiveQuantizer_ST_norm_cqint8
    r
    ST_norm_cqint4 = _swigfaiss.AdditiveQuantizer_ST_norm_cqint4
    ST_norm_lsq2x4 = _swigfaiss.AdditiveQuantizer_ST_norm_lsq2x4
    r
    ST_norm_rq2x4 = _swigfaiss.AdditiveQuantizer_ST_norm_rq2x4
    r

    def set_derived_values(self):
        r
        return _swigfaiss.AdditiveQuantizer_set_derived_values(self)

    def train_norm(self, n, norms):
        return _swigfaiss.AdditiveQuantizer_train_norm(self, n, norms)

    def compute_codes(self, x, codes, n):
        return _swigfaiss.AdditiveQuantizer_compute_codes(self, x, codes, n)

    def compute_codes_add_centroids(self, x, codes, n, centroids=None):
        r
        return _swigfaiss.AdditiveQuantizer_compute_codes_add_centroids(self, x, codes, n, centroids)

    def pack_codes(self, n, codes, packed_codes, ld_codes=-1, norms=None, centroids=None):
        r
        return _swigfaiss.AdditiveQuantizer_pack_codes(self, n, codes, packed_codes, ld_codes, norms, centroids)

    def decode(self, codes, x, n):
        r
        return _swigfaiss.AdditiveQuantizer_decode(self, codes, x, n)

    def decode_unpacked(self, codes, x, n, ld_codes=-1):
        r
        return _swigfaiss.AdditiveQuantizer_decode_unpacked(self, codes, x, n, ld_codes)
    search_type = property(_swigfaiss.AdditiveQuantizer_search_type_get, _swigfaiss.AdditiveQuantizer_search_type_set, doc=r)
    norm_min = property(_swigfaiss.AdditiveQuantizer_norm_min_get, _swigfaiss.AdditiveQuantizer_norm_min_set, doc=r)
    norm_max = property(_swigfaiss.AdditiveQuantizer_norm_max_get, _swigfaiss.AdditiveQuantizer_norm_max_set)

    def decode_64bit(self, n, x):
        r
        return _swigfaiss.AdditiveQuantizer_decode_64bit(self, n, x)

    def compute_LUT(self, n, xq, LUT, alpha=1.0, ld_lut=-1):
        r
        return _swigfaiss.AdditiveQuantizer_compute_LUT(self, n, xq, LUT, alpha, ld_lut)

    def knn_centroids_inner_product(self, n, xq, k, distances, labels):
        r
        return _swigfaiss.AdditiveQuantizer_knn_centroids_inner_product(self, n, xq, k, distances, labels)

    def compute_centroid_norms(self, norms):
        r
        return _swigfaiss.AdditiveQuantizer_compute_centroid_norms(self, norms)

    def knn_centroids_L2(self, n, xq, k, distances, labels, centroid_norms):
        r
        return _swigfaiss.AdditiveQuantizer_knn_centroids_L2(self, n, xq, k, distances, labels, centroid_norms)
    __swig_destroy__ = _swigfaiss.delete_AdditiveQuantizer


_swigfaiss.AdditiveQuantizer_swigregister(AdditiveQuantizer)

def beam_search_encode_step(*args):
    r
    return _swigfaiss.beam_search_encode_step(*args)

def beam_search_encode_step_tab(*args):
    r
    return _swigfaiss.beam_search_encode_step_tab(*args)
class RefineBeamMemoryPool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    new_codes = property(_swigfaiss.RefineBeamMemoryPool_new_codes_get, _swigfaiss.RefineBeamMemoryPool_new_codes_set)
    new_residuals = property(_swigfaiss.RefineBeamMemoryPool_new_residuals_get, _swigfaiss.RefineBeamMemoryPool_new_residuals_set)
    residuals = property(_swigfaiss.RefineBeamMemoryPool_residuals_get, _swigfaiss.RefineBeamMemoryPool_residuals_set)
    codes = property(_swigfaiss.RefineBeamMemoryPool_codes_get, _swigfaiss.RefineBeamMemoryPool_codes_set)
    distances = property(_swigfaiss.RefineBeamMemoryPool_distances_get, _swigfaiss.RefineBeamMemoryPool_distances_set)

    def __init__(self):
        _swigfaiss.RefineBeamMemoryPool_swiginit(self, _swigfaiss.new_RefineBeamMemoryPool())
    __swig_destroy__ = _swigfaiss.delete_RefineBeamMemoryPool


_swigfaiss.RefineBeamMemoryPool_swigregister(RefineBeamMemoryPool)

def refine_beam_mp(rq, n, beam_size, x, out_beam_size, out_codes, out_residuals, out_distances, pool):
    return _swigfaiss.refine_beam_mp(rq, n, beam_size, x, out_beam_size, out_codes, out_residuals, out_distances, pool)
class RefineBeamLUTMemoryPool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    new_codes = property(_swigfaiss.RefineBeamLUTMemoryPool_new_codes_get, _swigfaiss.RefineBeamLUTMemoryPool_new_codes_set)
    new_distances = property(_swigfaiss.RefineBeamLUTMemoryPool_new_distances_get, _swigfaiss.RefineBeamLUTMemoryPool_new_distances_set)
    codes = property(_swigfaiss.RefineBeamLUTMemoryPool_codes_get, _swigfaiss.RefineBeamLUTMemoryPool_codes_set)
    distances = property(_swigfaiss.RefineBeamLUTMemoryPool_distances_get, _swigfaiss.RefineBeamLUTMemoryPool_distances_set)

    def __init__(self):
        _swigfaiss.RefineBeamLUTMemoryPool_swiginit(self, _swigfaiss.new_RefineBeamLUTMemoryPool())
    __swig_destroy__ = _swigfaiss.delete_RefineBeamLUTMemoryPool


_swigfaiss.RefineBeamLUTMemoryPool_swigregister(RefineBeamLUTMemoryPool)

def refine_beam_LUT_mp(rq, n, query_norms, query_cp, out_beam_size, out_codes, out_distances, pool):
    return _swigfaiss.refine_beam_LUT_mp(rq, n, query_norms, query_cp, out_beam_size, out_codes, out_distances, pool)
class ComputeCodesAddCentroidsLUT0MemoryPool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    codes = property(_swigfaiss.ComputeCodesAddCentroidsLUT0MemoryPool_codes_get, _swigfaiss.ComputeCodesAddCentroidsLUT0MemoryPool_codes_set)
    norms = property(_swigfaiss.ComputeCodesAddCentroidsLUT0MemoryPool_norms_get, _swigfaiss.ComputeCodesAddCentroidsLUT0MemoryPool_norms_set)
    distances = property(_swigfaiss.ComputeCodesAddCentroidsLUT0MemoryPool_distances_get, _swigfaiss.ComputeCodesAddCentroidsLUT0MemoryPool_distances_set)
    residuals = property(_swigfaiss.ComputeCodesAddCentroidsLUT0MemoryPool_residuals_get, _swigfaiss.ComputeCodesAddCentroidsLUT0MemoryPool_residuals_set)
    refine_beam_pool = property(_swigfaiss.ComputeCodesAddCentroidsLUT0MemoryPool_refine_beam_pool_get, _swigfaiss.ComputeCodesAddCentroidsLUT0MemoryPool_refine_beam_pool_set)

    def __init__(self):
        _swigfaiss.ComputeCodesAddCentroidsLUT0MemoryPool_swiginit(self, _swigfaiss.new_ComputeCodesAddCentroidsLUT0MemoryPool())
    __swig_destroy__ = _swigfaiss.delete_ComputeCodesAddCentroidsLUT0MemoryPool


_swigfaiss.ComputeCodesAddCentroidsLUT0MemoryPool_swigregister(ComputeCodesAddCentroidsLUT0MemoryPool)

def compute_codes_add_centroids_mp_lut0(rq, x, codes_out, n, centroids, pool):
    return _swigfaiss.compute_codes_add_centroids_mp_lut0(rq, x, codes_out, n, centroids, pool)
class ComputeCodesAddCentroidsLUT1MemoryPool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    codes = property(_swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_codes_get, _swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_codes_set)
    distances = property(_swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_distances_get, _swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_distances_set)
    query_norms = property(_swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_query_norms_get, _swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_query_norms_set)
    query_cp = property(_swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_query_cp_get, _swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_query_cp_set)
    residuals = property(_swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_residuals_get, _swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_residuals_set)
    refine_beam_lut_pool = property(_swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_refine_beam_lut_pool_get, _swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_refine_beam_lut_pool_set)

    def __init__(self):
        _swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_swiginit(self, _swigfaiss.new_ComputeCodesAddCentroidsLUT1MemoryPool())
    __swig_destroy__ = _swigfaiss.delete_ComputeCodesAddCentroidsLUT1MemoryPool


_swigfaiss.ComputeCodesAddCentroidsLUT1MemoryPool_swigregister(ComputeCodesAddCentroidsLUT1MemoryPool)

def compute_codes_add_centroids_mp_lut1(rq, x, codes_out, n, centroids, pool):
    return _swigfaiss.compute_codes_add_centroids_mp_lut1(rq, x, codes_out, n, centroids, pool)
class ResidualQuantizer(AdditiveQuantizer):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    train_type = property(_swigfaiss.ResidualQuantizer_train_type_get, _swigfaiss.ResidualQuantizer_train_type_set, doc=r)
    Train_default = _swigfaiss.ResidualQuantizer_Train_default
    r
    Train_progressive_dim = _swigfaiss.ResidualQuantizer_Train_progressive_dim
    r
    Train_refine_codebook = _swigfaiss.ResidualQuantizer_Train_refine_codebook
    r
    niter_codebook_refine = property(_swigfaiss.ResidualQuantizer_niter_codebook_refine_get, _swigfaiss.ResidualQuantizer_niter_codebook_refine_set, doc=r)
    Train_top_beam = _swigfaiss.ResidualQuantizer_Train_top_beam
    r
    Skip_codebook_tables = _swigfaiss.ResidualQuantizer_Skip_codebook_tables
    r
    max_beam_size = property(_swigfaiss.ResidualQuantizer_max_beam_size_get, _swigfaiss.ResidualQuantizer_max_beam_size_set, doc=r)
    use_beam_LUT = property(_swigfaiss.ResidualQuantizer_use_beam_LUT_get, _swigfaiss.ResidualQuantizer_use_beam_LUT_set, doc=r)
    approx_topk_mode = property(_swigfaiss.ResidualQuantizer_approx_topk_mode_get, _swigfaiss.ResidualQuantizer_approx_topk_mode_set, doc=r)
    cp = property(_swigfaiss.ResidualQuantizer_cp_get, _swigfaiss.ResidualQuantizer_cp_set, doc=r)
    assign_index_factory = property(_swigfaiss.ResidualQuantizer_assign_index_factory_get, _swigfaiss.ResidualQuantizer_assign_index_factory_set, doc=r)

    def __init__(self, *args):
        _swigfaiss.ResidualQuantizer_swiginit(self, _swigfaiss.new_ResidualQuantizer(*args))

    def train(self, n, x):
        r
        return _swigfaiss.ResidualQuantizer_train(self, n, x)

    def initialize_from(self, other, skip_M=0):
        r
        return _swigfaiss.ResidualQuantizer_initialize_from(self, other, skip_M)

    def retrain_AQ_codebook(self, n, x):
        r
        return _swigfaiss.ResidualQuantizer_retrain_AQ_codebook(self, n, x)

    def compute_codes_add_centroids(self, x, codes, n, centroids=None):
        r
        return _swigfaiss.ResidualQuantizer_compute_codes_add_centroids(self, x, codes, n, centroids)

    def refine_beam(self, n, beam_size, residuals, new_beam_size, new_codes, new_residuals=None, new_distances=None):
        r
        return _swigfaiss.ResidualQuantizer_refine_beam(self, n, beam_size, residuals, new_beam_size, new_codes, new_residuals, new_distances)

    def refine_beam_LUT(self, n, query_norms, query_cp, new_beam_size, new_codes, new_distances=None):
        return _swigfaiss.ResidualQuantizer_refine_beam_LUT(self, n, query_norms, query_cp, new_beam_size, new_codes, new_distances)

    def memory_per_point(self, beam_size=-1):
        r
        return _swigfaiss.ResidualQuantizer_memory_per_point(self, beam_size)
    __swig_destroy__ = _swigfaiss.delete_ResidualQuantizer


_swigfaiss.ResidualQuantizer_swigregister(ResidualQuantizer)
class LocalSearchQuantizer(AdditiveQuantizer):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    K = property(_swigfaiss.LocalSearchQuantizer_K_get, _swigfaiss.LocalSearchQuantizer_K_set, doc=r)
    train_iters = property(_swigfaiss.LocalSearchQuantizer_train_iters_get, _swigfaiss.LocalSearchQuantizer_train_iters_set, doc=r)
    encode_ils_iters = property(_swigfaiss.LocalSearchQuantizer_encode_ils_iters_get, _swigfaiss.LocalSearchQuantizer_encode_ils_iters_set, doc=r)
    train_ils_iters = property(_swigfaiss.LocalSearchQuantizer_train_ils_iters_get, _swigfaiss.LocalSearchQuantizer_train_ils_iters_set, doc=r)
    icm_iters = property(_swigfaiss.LocalSearchQuantizer_icm_iters_get, _swigfaiss.LocalSearchQuantizer_icm_iters_set, doc=r)
    p = property(_swigfaiss.LocalSearchQuantizer_p_get, _swigfaiss.LocalSearchQuantizer_p_set, doc=r)
    lambd = property(_swigfaiss.LocalSearchQuantizer_lambd_get, _swigfaiss.LocalSearchQuantizer_lambd_set, doc=r)
    chunk_size = property(_swigfaiss.LocalSearchQuantizer_chunk_size_get, _swigfaiss.LocalSearchQuantizer_chunk_size_set, doc=r)
    random_seed = property(_swigfaiss.LocalSearchQuantizer_random_seed_get, _swigfaiss.LocalSearchQuantizer_random_seed_set, doc=r)
    nperts = property(_swigfaiss.LocalSearchQuantizer_nperts_get, _swigfaiss.LocalSearchQuantizer_nperts_set, doc=r)
    icm_encoder_factory = property(_swigfaiss.LocalSearchQuantizer_icm_encoder_factory_get, _swigfaiss.LocalSearchQuantizer_icm_encoder_factory_set)
    update_codebooks_with_double = property(_swigfaiss.LocalSearchQuantizer_update_codebooks_with_double_get, _swigfaiss.LocalSearchQuantizer_update_codebooks_with_double_set)

    def __init__(self, *args):
        _swigfaiss.LocalSearchQuantizer_swiginit(self, _swigfaiss.new_LocalSearchQuantizer(*args))
    __swig_destroy__ = _swigfaiss.delete_LocalSearchQuantizer

    def train(self, n, x):
        return _swigfaiss.LocalSearchQuantizer_train(self, n, x)

    def compute_codes_add_centroids(self, x, codes, n, centroids=None):
        r
        return _swigfaiss.LocalSearchQuantizer_compute_codes_add_centroids(self, x, codes, n, centroids)

    def update_codebooks(self, x, codes, n):
        r
        return _swigfaiss.LocalSearchQuantizer_update_codebooks(self, x, codes, n)

    def icm_encode(self, codes, x, n, ils_iters, gen):
        r
        return _swigfaiss.LocalSearchQuantizer_icm_encode(self, codes, x, n, ils_iters, gen)

    def icm_encode_impl(self, codes, x, unaries, gen, n, ils_iters, verbose):
        return _swigfaiss.LocalSearchQuantizer_icm_encode_impl(self, codes, x, unaries, gen, n, ils_iters, verbose)

    def icm_encode_step(self, codes, unaries, binaries, n, n_iters):
        return _swigfaiss.LocalSearchQuantizer_icm_encode_step(self, codes, unaries, binaries, n, n_iters)

    def perturb_codes(self, codes, n, gen):
        r
        return _swigfaiss.LocalSearchQuantizer_perturb_codes(self, codes, n, gen)

    def perturb_codebooks(self, T, stddev, gen):
        r
        return _swigfaiss.LocalSearchQuantizer_perturb_codebooks(self, T, stddev, gen)

    def compute_binary_terms(self, binaries):
        r
        return _swigfaiss.LocalSearchQuantizer_compute_binary_terms(self, binaries)

    def compute_unary_terms(self, x, unaries, n):
        r
        return _swigfaiss.LocalSearchQuantizer_compute_unary_terms(self, x, unaries, n)

    def evaluate(self, codes, x, n, objs=None):
        r
        return _swigfaiss.LocalSearchQuantizer_evaluate(self, codes, x, n, objs)


_swigfaiss.LocalSearchQuantizer_swigregister(LocalSearchQuantizer)
class IcmEncoder(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    binaries = property(_swigfaiss.IcmEncoder_binaries_get, _swigfaiss.IcmEncoder_binaries_set)
    verbose = property(_swigfaiss.IcmEncoder_verbose_get, _swigfaiss.IcmEncoder_verbose_set)
    lsq = property(_swigfaiss.IcmEncoder_lsq_get, _swigfaiss.IcmEncoder_lsq_set)

    def __init__(self, lsq):
        _swigfaiss.IcmEncoder_swiginit(self, _swigfaiss.new_IcmEncoder(lsq))
    __swig_destroy__ = _swigfaiss.delete_IcmEncoder

    def set_binary_term(self):
        return _swigfaiss.IcmEncoder_set_binary_term(self)

    def encode(self, codes, x, gen, n, ils_iters):
        r
        return _swigfaiss.IcmEncoder_encode(self, codes, x, gen, n, ils_iters)


_swigfaiss.IcmEncoder_swigregister(IcmEncoder)
class IcmEncoderFactory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def get(self, lsq):
        return _swigfaiss.IcmEncoderFactory_get(self, lsq)
    __swig_destroy__ = _swigfaiss.delete_IcmEncoderFactory

    def __init__(self):
        _swigfaiss.IcmEncoderFactory_swiginit(self, _swigfaiss.new_IcmEncoderFactory())


_swigfaiss.IcmEncoderFactory_swigregister(IcmEncoderFactory)
class LSQTimer(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    t = property(_swigfaiss.LSQTimer_t_get, _swigfaiss.LSQTimer_t_set)

    def __init__(self):
        _swigfaiss.LSQTimer_swiginit(self, _swigfaiss.new_LSQTimer())

    def get(self, name):
        return _swigfaiss.LSQTimer_get(self, name)

    def add(self, name, delta):
        return _swigfaiss.LSQTimer_add(self, name, delta)

    def reset(self):
        return _swigfaiss.LSQTimer_reset(self)
    __swig_destroy__ = _swigfaiss.delete_LSQTimer


_swigfaiss.LSQTimer_swigregister(LSQTimer)
class LSQTimerScope(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    t0 = property(_swigfaiss.LSQTimerScope_t0_get, _swigfaiss.LSQTimerScope_t0_set)
    timer = property(_swigfaiss.LSQTimerScope_timer_get, _swigfaiss.LSQTimerScope_timer_set)
    name = property(_swigfaiss.LSQTimerScope_name_get, _swigfaiss.LSQTimerScope_name_set)
    finished = property(_swigfaiss.LSQTimerScope_finished_get, _swigfaiss.LSQTimerScope_finished_set)

    def __init__(self, timer, name):
        _swigfaiss.LSQTimerScope_swiginit(self, _swigfaiss.new_LSQTimerScope(timer, name))

    def finish(self):
        return _swigfaiss.LSQTimerScope_finish(self)
    __swig_destroy__ = _swigfaiss.delete_LSQTimerScope


_swigfaiss.LSQTimerScope_swigregister(LSQTimerScope)
class ProductAdditiveQuantizer(AdditiveQuantizer):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nsplits = property(_swigfaiss.ProductAdditiveQuantizer_nsplits_get, _swigfaiss.ProductAdditiveQuantizer_nsplits_set, doc=r)
    quantizers = property(_swigfaiss.ProductAdditiveQuantizer_quantizers_get, _swigfaiss.ProductAdditiveQuantizer_quantizers_set)

    def __init__(self, *args):
        r
        _swigfaiss.ProductAdditiveQuantizer_swiginit(self, _swigfaiss.new_ProductAdditiveQuantizer(*args))
    __swig_destroy__ = _swigfaiss.delete_ProductAdditiveQuantizer

    def init(self, d, aqs, search_type):
        return _swigfaiss.ProductAdditiveQuantizer_init(self, d, aqs, search_type)

    def subquantizer(self, m):
        r
        return _swigfaiss.ProductAdditiveQuantizer_subquantizer(self, m)

    def train(self, n, x):
        return _swigfaiss.ProductAdditiveQuantizer_train(self, n, x)

    def compute_codes_add_centroids(self, x, codes, n, centroids=None):
        r
        return _swigfaiss.ProductAdditiveQuantizer_compute_codes_add_centroids(self, x, codes, n, centroids)

    def compute_unpacked_codes(self, x, codes, n, centroids=None):
        return _swigfaiss.ProductAdditiveQuantizer_compute_unpacked_codes(self, x, codes, n, centroids)

    def decode_unpacked(self, codes, x, n, ld_codes=-1):
        r
        return _swigfaiss.ProductAdditiveQuantizer_decode_unpacked(self, codes, x, n, ld_codes)

    def decode(self, codes, x, n):
        r
        return _swigfaiss.ProductAdditiveQuantizer_decode(self, codes, x, n)

    def compute_LUT(self, n, xq, LUT, alpha=1.0, ld_lut=-1):
        r
        return _swigfaiss.ProductAdditiveQuantizer_compute_LUT(self, n, xq, LUT, alpha, ld_lut)


_swigfaiss.ProductAdditiveQuantizer_swigregister(ProductAdditiveQuantizer)
class ProductLocalSearchQuantizer(ProductAdditiveQuantizer):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r
        _swigfaiss.ProductLocalSearchQuantizer_swiginit(self, _swigfaiss.new_ProductLocalSearchQuantizer(*args))
    __swig_destroy__ = _swigfaiss.delete_ProductLocalSearchQuantizer


_swigfaiss.ProductLocalSearchQuantizer_swigregister(ProductLocalSearchQuantizer)
class ProductResidualQuantizer(ProductAdditiveQuantizer):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r
        _swigfaiss.ProductResidualQuantizer_swiginit(self, _swigfaiss.new_ProductResidualQuantizer(*args))
    __swig_destroy__ = _swigfaiss.delete_ProductResidualQuantizer


_swigfaiss.ProductResidualQuantizer_swigregister(ProductResidualQuantizer)
class CodePacker(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    code_size = property(_swigfaiss.CodePacker_code_size_get, _swigfaiss.CodePacker_code_size_set)
    nvec = property(_swigfaiss.CodePacker_nvec_get, _swigfaiss.CodePacker_nvec_set)
    block_size = property(_swigfaiss.CodePacker_block_size_get, _swigfaiss.CodePacker_block_size_set)

    def pack_1(self, flat_code, offset, block):
        return _swigfaiss.CodePacker_pack_1(self, flat_code, offset, block)

    def unpack_1(self, block, offset, flat_code):
        return _swigfaiss.CodePacker_unpack_1(self, block, offset, flat_code)

    def pack_all(self, flat_codes, block):
        return _swigfaiss.CodePacker_pack_all(self, flat_codes, block)

    def unpack_all(self, block, flat_codes):
        return _swigfaiss.CodePacker_unpack_all(self, block, flat_codes)
    __swig_destroy__ = _swigfaiss.delete_CodePacker


_swigfaiss.CodePacker_swigregister(CodePacker)
class CodePackerFlat(CodePacker):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, code_size):
        _swigfaiss.CodePackerFlat_swiginit(self, _swigfaiss.new_CodePackerFlat(code_size))

    def pack_1(self, flat_code, offset, block):
        return _swigfaiss.CodePackerFlat_pack_1(self, flat_code, offset, block)

    def unpack_1(self, block, offset, flat_code):
        return _swigfaiss.CodePackerFlat_unpack_1(self, block, offset, flat_code)

    def pack_all(self, flat_codes, block):
        return _swigfaiss.CodePackerFlat_pack_all(self, flat_codes, block)

    def unpack_all(self, block, flat_codes):
        return _swigfaiss.CodePackerFlat_unpack_all(self, block, flat_codes)
    __swig_destroy__ = _swigfaiss.delete_CodePackerFlat


_swigfaiss.CodePackerFlat_swigregister(CodePackerFlat)
class VectorTransform(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    d_in = property(_swigfaiss.VectorTransform_d_in_get, _swigfaiss.VectorTransform_d_in_set)
    d_out = property(_swigfaiss.VectorTransform_d_out_get, _swigfaiss.VectorTransform_d_out_set, doc=r)
    is_trained = property(_swigfaiss.VectorTransform_is_trained_get, _swigfaiss.VectorTransform_is_trained_set, doc=r)

    def train(self, n, x):
        r
        return _swigfaiss.VectorTransform_train(self, n, x)

    def apply(self, n, x):
        r
        return _swigfaiss.VectorTransform_apply(self, n, x)

    def apply_noalloc(self, n, x, xt):
        r
        return _swigfaiss.VectorTransform_apply_noalloc(self, n, x, xt)

    def reverse_transform(self, n, xt, x):
        r
        return _swigfaiss.VectorTransform_reverse_transform(self, n, xt, x)

    def check_identical(self, other):
        return _swigfaiss.VectorTransform_check_identical(self, other)
    __swig_destroy__ = _swigfaiss.delete_VectorTransform


_swigfaiss.VectorTransform_swigregister(VectorTransform)
class LinearTransform(VectorTransform):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    have_bias = property(_swigfaiss.LinearTransform_have_bias_get, _swigfaiss.LinearTransform_have_bias_set)
    is_orthonormal = property(_swigfaiss.LinearTransform_is_orthonormal_get, _swigfaiss.LinearTransform_is_orthonormal_set, doc=r)
    A = property(_swigfaiss.LinearTransform_A_get, _swigfaiss.LinearTransform_A_set, doc=r)
    b = property(_swigfaiss.LinearTransform_b_get, _swigfaiss.LinearTransform_b_set, doc=r)

    def __init__(self, d_in=0, d_out=0, have_bias=False):
        r
        _swigfaiss.LinearTransform_swiginit(self, _swigfaiss.new_LinearTransform(d_in, d_out, have_bias))

    def apply_noalloc(self, n, x, xt):
        r
        return _swigfaiss.LinearTransform_apply_noalloc(self, n, x, xt)

    def transform_transpose(self, n, y, x):
        r
        return _swigfaiss.LinearTransform_transform_transpose(self, n, y, x)

    def reverse_transform(self, n, xt, x):
        r
        return _swigfaiss.LinearTransform_reverse_transform(self, n, xt, x)

    def set_is_orthonormal(self):
        r
        return _swigfaiss.LinearTransform_set_is_orthonormal(self)
    verbose = property(_swigfaiss.LinearTransform_verbose_get, _swigfaiss.LinearTransform_verbose_set)

    def print_if_verbose(self, name, mat, n, d):
        return _swigfaiss.LinearTransform_print_if_verbose(self, name, mat, n, d)

    def check_identical(self, other):
        return _swigfaiss.LinearTransform_check_identical(self, other)
    __swig_destroy__ = _swigfaiss.delete_LinearTransform


_swigfaiss.LinearTransform_swigregister(LinearTransform)
class RandomRotationMatrix(LinearTransform):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def init(self, seed):
        r
        return _swigfaiss.RandomRotationMatrix_init(self, seed)

    def train(self, n, x):
        return _swigfaiss.RandomRotationMatrix_train(self, n, x)

    def __init__(self, *args):
        r
        _swigfaiss.RandomRotationMatrix_swiginit(self, _swigfaiss.new_RandomRotationMatrix(*args))
    __swig_destroy__ = _swigfaiss.delete_RandomRotationMatrix


_swigfaiss.RandomRotationMatrix_swigregister(RandomRotationMatrix)
class PCAMatrix(LinearTransform):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    eigen_power = property(_swigfaiss.PCAMatrix_eigen_power_get, _swigfaiss.PCAMatrix_eigen_power_set, doc=r)
    epsilon = property(_swigfaiss.PCAMatrix_epsilon_get, _swigfaiss.PCAMatrix_epsilon_set, doc=r)
    random_rotation = property(_swigfaiss.PCAMatrix_random_rotation_get, _swigfaiss.PCAMatrix_random_rotation_set, doc=r)
    max_points_per_d = property(_swigfaiss.PCAMatrix_max_points_per_d_get, _swigfaiss.PCAMatrix_max_points_per_d_set, doc=rtry to distribute output eigenvectors in this many binsMean, size d_ineigenvalues of covariance matrix (= squared singular values)PCA matrix, size d_in * d_in
        train on n vectors. If n < d_in then the eigenvector matrix
        will be completed with 0s
        copy pre-trained PCA matrixcalled after mean, PCAMat and eigenvalues are computed
     ITQ implementation from

        Iterative quantization: A procrustean approach to learning binary codes
        for large-scale image retrieval,

    Yunchao Gong, Svetlana Lazebnik, Albert Gordo, Florent Perronnin,
    PAMI'12.
    The full ITQ transform, including normalizations and PCA transformationmax training points per dimension
     Applies a rotation to align the dimensions with a PQ to minimize
     the reconstruction error. Can be used before an IndexPQ or an
     IndexIVFPQ. The method is the non-parametric version described in:

    "Optimized Product Quantization for Approximate Nearest Neighbor Search"
    Tiezheng Ge, Kaiming He, Qifa Ke, Jian Sun, CVPR'13
    nb of subquantizersNumber of outer training iterationsNumber of training iterations for the PQsame, for the first outer iterationif there are too many training points, resample
    if non-NULL, use this product quantizer for training
    should be constructed with (d_out, M, _)
    if d2 != -1, output vectors of this dimension
     remap dimensions for intput vectors, possibly inserting 0s
    strictly speaking this is also a linear transform but we don't want
    to compute it with matrix multiplies
    
    map from output dimension to input, size d_out
    -1 -> set output to 0
    reverse transform correct only when the mapping is a permutation
        *Overload 1:*
        remap input to output, skipping or inserting dimensions as needed
        if uniform: distribute dimensions uniformly
        otherwise just take the d_out first ones.

        |

        *Overload 2:*
        remap input to output, skipping or inserting dimensions as needed
        if uniform: distribute dimensions uniformly
        otherwise just take the d_out first ones.
        per-vector normalizationIdentity transform since norm is not revertibleSubtract the mean of each component from the vectors.Mean, size d_in = d_outtrain on n vectors.subtract the meanadd the mean
    Index that applies a LinearTransform transform on vectors before
    handing them over to a sub-index
    chain of transformsthe sub-index
        *Overload 1:*
        whether pointers are deleted in destructor

        |

        *Overload 2:*
         ltrans is the last transform before the index
        removes IDs from the index. Not supported by all indexes.
        apply the transforms in the chain. The returned float * may be
        equal to x, otherwise it should be deallocated.
        
        Reverse the transforms in the chain. May not be implemented for
        all transforms in the chain or may return approximate results.
        
    Index that queries in a base_index (a fast one) and refines the
    results with an exact search, hopefully improving the results.
    faster index to pre-select the vectors that should be filteredrefinement indexshould the base index be deallocated?same with the refinement index
    factor between k requested in search and the k requested from
    the base_index (should be >= 1)
    initialize from empty index
        The sa_decode decodes from the index_refine, which is assumed to be more
        accurate
        
     Version where the refinement index is an IndexFlat. It has one additional
    constructor that takes a table of elements to add to the flat refinement
    index
    The sign of each vector component is put in a binary signaturenb of bits per vectorwhether to apply a random rotation to inputwhether we train thresholds or use 0optional random rotationthresholds to compare with
         Preprocesses and resizes the input to the size required to
        binarize the data

        :type x: float
        :param x: input vectors, size n * d
        :rtype: float
        :return: output vectors, size n * bits. May be the same pointer
                    as x, otherwise it should be deleted by the caller
        
        transfer the thresholds to a pre-processing stage (and unset
        train_thresholds)
        parameters used for the simulated annealing methodabstract class for the loss function"real" corrected distances (size n^2)wanted distances (size n^2)weights for each distance (size n^2)Simulated annealing optimization algorithm for permutations.size of the permutationlogs values of the cost functionremember initial cost of optimizationoptimizes the order of indices in a ProductQuantizerdefault
    same as _2, but use rank of y+ - rank of
    y-
    
     use 1/4 of the training points for the optimization, with
    max. ntrain_permutation. If ntrain_permutation == 0: train on
    centroids
    decay of exp that weights distance lossrefuse to train if it would require more than that amount of RAM
        reorder the centroids so that the Hamming distance becomes a
        good approximation of the SDC distance (called by train)
        called by optimize_pq_for_hammingcalled by optimize_pq_for_hammingmake sure we don't blow up the memory
     Index based on a product quantizer. Stored vectors are
    approximated by PQ codes.
    The product quantizer used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type M: int
        :param M:      number of subquantizers
        :type nbits: int
        :param nbits:  number of bit per subvector index
        false = standard PQparameters used for the polysemous trainingasymmetric product quantizer (default)Hamming distance on codesnb of same codessymmetric product quantizer (SDC)HE filter (using ht) + PQ combinationFilter on generalized HammingHamming threshold used for polysemy
        prepare query for a polysemous search, but instead of
        computing the result, just get the histogram of Hamming
        distances. May be computed on a provided dataset if xb != NULL
        :type dist_histogram: int
        :param dist_histogram: (M * nbits + 1)
        
         compute pairwise distances between queries and database

        :type n: int
        :param n:    nb of query vectors
        :type x: float
        :param x:    query vector, size n * d
        :type dis: int
        :param dis:  output distances, size n * ntotal
        override search parameters from the class
    statistics are robust to internal threading, but not if
    IndexPQ::search is called by multiple threads
    
    Quantizer where centroids are virtual: they are the Cartesian
    product of sub-centroids.
    add and reset will crash at runtime
         number of bit per subvector index
        :type d: int
        :param d: dimension of the input vectors
        :type M: int
        :param M: number of subquantizers
        MultiIndexQuantizer where the PQ assignmnet is performed by sub-indexesM Indexes on d / M dimensionsAbstract class for additive quantizers. The search functions are in common.
     Index based on a residual quantizer. Stored vectors are
    approximated by residual quantization codes.
    Can also be used as a codec
    The residual quantizer used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type M: int
        :param M:      number of subquantizers
        :type nbits: int
        :param nbits:  number of bit per subvector index

        :type d: int
        :param d: dimensionality of the input vectors
        :type M: int
        :param M: number of subquantizers
        :type nbits: int
        :param nbits: number of bit per subvector index
        
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type M: int
        :param M:      number of subquantizers
        :type nbits: int
        :param nbits:  number of bit per subvector index

        :type d: int
        :param d: dimensionality of the input vectors
        :type M: int
        :param M: number of subquantizers
        :type nbits: int
        :param nbits: number of bit per subvector index
        Index based on a product residual quantizer.The product residual quantizer used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type nsplits: int
        :param nsplits:  number of residual quantizers
        :type Msub: int
        :param Msub:      number of subquantizers per RQ
        :type nbits: int
        :param nbits:  number of bit per subvector index

        :type d: int
        :param d: dimensionality of the input vectors
        :type nsplits: int
        :param nsplits: number of residual quantizers
        :type Msub: int
        :param Msub: number of subquantizers per RQ
        :type nbits: int
        :param nbits: number of bit per subvector index
        Index based on a product local search quantizer.The product local search quantizer used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type nsplits: int
        :param nsplits:  number of local search quantizers
        :type Msub: int
        :param Msub:     number of subquantizers per LSQ
        :type nbits: int
        :param nbits:  number of bit per subvector index

        :type d: int
        :param d: dimensionality of the input vectors
        :type nsplits: int
        :param nsplits: number of local search quantizers
        :type Msub: int
        :param Msub: number of subquantizers per LSQ
        :type nbits: int
        :param nbits: number of bit per subvector index
        
     A "virtual" index where the elements are the residual quantizer centroids.

    Intended for use as a coarse quantizer in an IndexIVF.
    norms of centroids, useful for knn-searchN/AN/A
     The ResidualCoarseQuantizer is a bit specialized compared to the
    default AdditiveCoarseQuantizer because it can use a beam search
    at search time (slow but may be useful for very large vocabularies)
    The residual quantizer used to encode the vectors
    factor between the beam size and the search k
    if negative, use exact search-to-centroid
    computes centroid norms if required
         Copy the M first codebook levels from other. Useful to crop a
        ResidualQuantizer to its first M quantizers.
        
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type M: int
        :param M:      number of subquantizers
        :type nbits: int
        :param nbits:  number of bit per subvector index

        :type d: int
        :param d: dimensionality of the input vectors
        :type M: int
        :param M: number of subquantizers
        :type nbits: int
        :param nbits: number of bit per subvector index
        The residual quantizer used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type M: int
        :param M:      number of subquantizers
        :type nbits: int
        :param nbits:  number of bit per subvector index

        :type d: int
        :param d: dimensionality of the input vectors
        :type M: int
        :param M: number of subquantizers
        :type nbits: int
        :param nbits: number of bit per subvector index
        
    Definition of inverted lists + a few common classes that implement
    the interface.
    
     Table of inverted lists
    multithreading rules:
    - concurrent read accesses are allowed
    - concurrent update accesses are allowed
    - for resize and add_entries, only concurrent access to different lists
      are allowed
    number of possible key valuescode size per vector in bytesrequest to use iterator rather than get_codes / get_ids
    used for BlockInvertedLists, where the codes are packed into groups
    and the individual code size is meaningless
    get the size of a list
         get the codes for an inverted list
        must be released by release_codes

        :rtype: uint8_t
        :return: codes    size list_size * code_size
        
         get the ids for an inverted list
        must be released by release_ids

        :rtype: int
        :return: ids      size list_size
        release codes returned by get_codes (default implementation is noprelease ids returned by get_ids
        :rtype: int
        :return: a single id in an inverted list
        
        :rtype: uint8_t
        :return: a single code in an inverted list
            (should be deallocated with release_codes)
        
        prepare the following lists (default does nothing)
        a list can be -1 hence the signed long
        check if the list is emptyget iterable for lists that use_iteratoradd one entry to an inverted listmove all entries from oivf (empty on output)
         copy a subset of the entries index to the other index
        :rtype: int
        :return: number of entries copied
        1= perfectly balanced, >1: imbalanceddisplay some stats about the inverted listssum up list sizessimple (default) implementation as an array of inverted listsInverted lists for indexespermute the inverted lists, map maps new_id to old_idinvlists that fail for all write functionsHorizontal stack of inverted listsbuild InvertedLists by concatenating nil of themvertical slice of indexes in another InvertedListsbuild InvertedLists by concatenating nil of them
     use the first inverted lists if they are non-empty otherwise use the second

    This is useful if il1 has a few inverted lists that are too long,
    and that il0 has replacement lists for those, with empty lists for
    the others.
    
    if the inverted list in il is smaller than maxsize then return it,
    otherwise return an empty invlist
    
     Callbacks to handle other types of InvertedList objects.

    The callbacks should be registered with add_callback before calling
    read_index or read_InvertedLists. The callbacks for
    OnDiskInvertedLists are registrered by default. The invlist type is
    identified by:

    - the key (a fourcc) at read time
    - the class name (as given by typeid.name) at write time
    string version of the fourcctypeid.namewrite the index to the IOWriter (including the fourcc)called when the fourcc matches this class's fourcc
         read from a ArrayInvertedLists into this invertedlist type.
        For this to work, the callback has to be enabled and the io_flag has to
        be set to IO_FLAG_SKIP_IVF_DATA | (16 upper bits of the fourcc)

        (default implementation fails)
        
     Inverted Lists that are organized by blocks.

    Different from the regular inverted lists, the codes are organized by blocks
    of size block_size bytes that reprsent a set of n_per_block. Therefore, code
    allocations are always rounded up to block_size bytes. The codes are also
    aligned on 32-byte boundaries for use with SIMD.

    To avoid misinterpretations, the code_size is set to (size_t)(-1), even if
    arguably the amount of memory consumed by code is block_size / n_per_block.

    The writing functions add_entries and update_entries operate on block-aligned
    data.
    remove ids from the InvertedListsnot implementedDirect map: a way to map back from ids to inverted listsmap for direct access to the elements. Map ids to LO-encoded entries.set type and initializeget an entryfor quick checks
        update the direct_map

         throw if Array and ids is not NULL
        non thread-safe versionremove all entries
        operations on inverted lists that require translation with a DirectMap

         remove ids from the InvertedLists, possibly using the direct map
        update entries, using the direct mapThread-safe way of updating the direct_mapadd vector i (with id xids[i]) at list_no and offset
     Encapsulates a quantizer object for the IndexIVF

    The class isolates the fields that are independent of the storage
    of the lists (especially training)
    quantizer that maps vectors to inverted listsnumber of inverted lists
    = 0: use the quantizer as index in a kmeans training
    = 1: just pass on the training set to the train() of the quantizer
    = 2: kmeans training on a flat index + add the centroids to the quantizer
    whether object owns the quantizerto override default clustering paramsto override index used during clusteringTrains the quantizer and calls train_residual to train sub-quantizerscompute the number of bytes required to store list idsnumber of probes at query timemax nb of codes to visit to do a querycontext object to pass to InvertedListsnumber of probes at query timemax nb of codes to visit to do a query
         search a set of vectors, that are pre-quantized by the IVF
         quantizer. Fill in the corresponding heaps with the query
         results. The default implementation uses InvertedListScanners
         to do the search.

        :type n: int
        :param n:      nb of vectors to query
        :type x: float
        :param x:      query vectors, size nx * d
        :type assign: int
        :param assign: coarse quantization indices, size nx * nprobe
        :type centroid_dis: float
        :param centroid_dis:
                          distances to coarse centroids, size nx * nprobe
        :param distance:
                          output distances, size n * k
        :type labels: int
        :param labels: output labels, size n * k
        :type store_pairs: boolean
        :param store_pairs: store inv list index + inv list offset
                                instead in upper/lower 32 bit of result,
                                instead of ids (used for reranking).
        :type params: :py:class:`IVFSearchParameters`, optional
        :param params: used to override the object's search parameters
        :type stats: :py:class:`IndexIVFStats`, optional
        :param stats:  search stats to be updated (can be null)
        
         Range search a set of vectors, that are pre-quantized by the IVF
         quantizer. Fill in the RangeSearchResults results. The default
        implementation uses InvertedListScanners to do the search.

        :param n:      nb of vectors to query
        :type x: float
        :param x:      query vectors, size nx * d
        :param assign: coarse quantization indices, size nx * nprobe
        :param centroid_dis:
                          distances to coarse centroids, size nx * nprobe
        :type result: :py:class:`RangeSearchResult`
        :param result: Output results
        :type store_pairs: boolean, optional
        :param store_pairs: store inv list index + inv list offset
                                instead in upper/lower 32 bit of result,
                                instead of ids (used for reranking).
        :type params: :py:class:`IVFSearchParameters`, optional
        :param params: used to override the object's search parameters
        :type stats: :py:class:`IndexIVFStats`, optional
        :param stats:  search stats to be updated (can be null)
        
     Index based on a inverted file (IVF)

    In the inverted file, the quantizer (an Index instance) provides a
    quantization index for each vector to be added. The quantization
    index maps to a list (aka inverted list or posting list), where the
    id of the vector is stored.

    The inverted list object is required only after trainng. If none is
    set externally, an ArrayInvertedLists is used automatically.

    At search time, the vector to be searched is also quantized, and
    only the list corresponding to the quantization index is
    searched. This speeds up the search by making it
    non-exhaustive. This can be relaxed using multi-probe search: a few
    (nprobe) quantization indices are selected and several inverted
    lists are visited.

    Sub-classes implement a post-filtering of the index that refines
    the distance estimation from the query to databse vectors.
    Access to the actual datacode size per vector in bytes
     Parallel mode determines how queries are parallelized with OpenMP

    0 (default): split over queries
    1: parallelize over inverted lists
    2: parallelize over both
    3: split over queries with a finer granularity

    PARALLEL_MODE_NO_HEAP_INIT: binary or with the previous to
    prevent the heap to be initialized and finalized
    
    optional map that maps back ids to invlist entries. This
    enables reconstruct()
    
    do the codes in the invlists encode the vectors relative to the
    centroids?
    Trains the quantizer and calls train_encoder to train sub-quantizersCalls add_with_ids with NULL idsdefault implementation that calls encode_vectors
         Implementation of vector addition where the vector assignments are
        predefined. The default implementation hands over the code extraction to
        encode_vectors.

        :type precomputed_idx: int
        :param precomputed_idx:    quantization indices for the input vectors
            (size n)
        
         Encodes a set of vectors as they would appear in the inverted lists

        :type list_nos: int
        :param list_nos:   inverted list ids as returned by the
                              quantizer (size n). -1s are ignored.
        :type codes: uint8_t
        :param codes:      output codes, size n * code_size
        :type include_listno: boolean, optional
        :param include_listno:
                              include the list ids in the code (in this case add
                              ceil(log8(nlist)) to the code size)
        
         Add vectors that are computed with the standalone codec

        :type codes: uint8_t
        :param codes:  codes to add size n * sa_code_size()
        :type xids: int
        :param xids:   corresponding ids, size n
        
         Train the encoder for the vectors.

        If by_residual then it is called with residuals and corresponding assign
        array, otherwise x is the raw training vectors and assign=nullptr
        
        can be redefined by subclasses to indicate how many training vectors
        they need
        assign the vectors, then call search_preassign
         Get a scanner for this index (store_pairs means ignore labels)

        The default search implementation uses this to compute the distances.
        Use sel instead of params->sel, because sel is initialized with
        params->sel, but may get overridden by IndexIVF's internal logic.
        reconstruct a vector. Works only if maintain_direct_map is set to 1 or 2
         Update a subset of vectors.

        The index must have a direct_map

        :type nv: int
        :param nv:     nb of vectors to update
        :type idx: int
        :param idx:    vector indices to update, size nv
        :type v: float
        :param v:      vectors of new values, size nv*d
        
         Reconstruct a subset of the indexed vectors.

        Overrides default implementation to bypass reconstruct() which requires
        direct_map to be maintained.

        :type i0: int
        :param i0:     first vector to reconstruct
        :type ni: int
        :param ni:     nb of vectors to reconstruct
        :type recons: float
        :param recons: output array of reconstructed vectors, size ni * d
        
         Similar to search, but also reconstructs the stored vectors (or an
        approximation in the case of lossy coding) for the search results.

        Overrides default implementation to avoid having to maintain direct_map
        and instead fetch the code offsets through the `store_pairs` flag in
        search_preassigned().

        :type recons: float
        :param recons:      reconstructed vectors size (n, k, d)
        
         Similar to search, but also returns the codes corresponding to the
        stored vectors for the search results.

        :param codes:      codes (n, k, code_size)
        :type include_listno: boolean, optional
        :param include_listno:
                              include the list ids in the code (in this case add
                              ceil(log8(nlist)) to the code size)
        
         Reconstruct a vector given the location in terms of (inv list index +
        inv list offset) instead of the id.

        Useful for reconstructing when the direct_map is not maintained and
        the inv list offset is computed by search_preassigned() with
        `store_pairs` set.
        Dataset manipulation functions
         copy a subset of the entries index to the other index
        see Invlists::copy_subset_to for the meaning of subset_type
        are the ids sorted?
         initialize a direct map

        :type new_maintain_direct_map: boolean, optional
        :param new_maintain_direct_map:    if true, create a direct map,
                                              else clear it
        replace the inverted lists, old one is deallocated if own_invlists
         encode a set of vectors
        sa_encode will call encode_vectors with include_listno=true
        :type n: int
        :param n:      nb of vectors to encode
        :type x: float
        :param x:      the vectors to encode
        :type bytes: uint8_t
        :param bytes:  output array for the codes
        :rtype: void
        :return: nb of bytes written to codes
        
     Object that handles a query. The inverted lists to scan are
    provided externally. The object has a lot of state, but
    distance_to_code and scan_codes can be called in multiple
    threads
    remember current listkeep maximum instead of minimumstore positions in invlists rather than labelssearch in this subset of idsused in default implementation of scan_codesfrom now on we handle this query.following codes come from this inverted listcompute a single query-to-code distance
         scan a set of codes, compute distances to current query and
        update heap of results if necessary. Default implementation
        calls distance_to_code.

        :type n: int
        :param n:      number of codes to scan
        :type codes: uint8_t
        :param codes:  codes to scan (n * code_size)
        :type ids: int
        :param ids:        corresponding ids (ignored if store_pairs)
        :type distances: float
        :param distances:  heap distances (size k)
        :type labels: int
        :param labels:     heap labels (size k)
        :type k: int
        :param k:          heap size
        :rtype: int
        :return: number of heap updates performed
        
         scan a set of codes, compute distances to current query and
        update results if distances are below radius

        (default implementation fails)
        
     check if two indexes have the same parameters and are trained in
    the same way, otherwise throw.
    
     get an IndexIVF from an index. The index may be an IndexIVF or
    some wrapper class that encloses an IndexIVF

    throws an exception if this is not the case.
    same as above but returns nullptr instead of throwing on failure
     Merge index1 into index0. Works on IndexIVF's and IndexIVF's
     embedded in a IndexPreTransform. On output, the index1 is empty.

    :type shift_ids: boolean
    :param shift_ids:: translate the ids from index1 to index0->prev_ntotal
    
     A set of IndexIVFs concatenated together in a FIFO fashion.
    at each "step", the oldest index slice is removed and a new index is added.
    common index that contains the sliding windowInvertedLists of indexnumber of slices currently in indexsame as index->nlistcumulative list sizes at each sliceindex should be initially empty and trained
         Add one index to the current index and remove the oldest one.

        :type sub_index: :py:class:`Index`
        :param sub_index:        slice to swap in (can be NULL)
        :type remove_oldest: boolean
        :param remove_oldest:    if true, remove the oldest slices
        Get a subset of inverted lists [i0, i1)Set a subset of inverted lists
     search an IndexIVF, possibly embedded in an IndexPreTransform with
    given parameters. This is a way to set the nprobe and get
    statdistics in a thread-safe way.

    Optionally returns (if non-nullptr):
    - nb_dis: number of distances computed
    - ms_per_stage: [0]: preprocessing time
                    [1]: coarse quantization,
                    [2]: list scanning
    same as search_with_parameters but for range search
     Build an IndexIVFResidualQuantizer from an ResidualQuantizer, using the
    nlevel first components as coarse quantizer and the rest as codes in invlists
    
     add from codes. NB that the norm component is not used, so the code_size can
    be provided.

    :type ivfrq: :py:class:`IndexIVFResidualQuantizer`
    :param ivfrq:      index to populate with the codes
    :type codes: uint8_t
    :param codes:      codes to add, size (ncode, code_size)
    :type code_size: int, optional
    :param code_size:  override the ivfrq's code_size, useful if the norm encoding
                          is different
    
    Shards an IVF index centroids by the given sharding function, and writes
    the index to the path given by filename_generator. The centroids must already
    be added to the index quantizer.

    :type index: :py:class:`IndexIVF`
    :param index:             The IVF index containing centroids to shard.
    :type shard_count: int, optional
    :param shard_count:       Number of shards.
    :type filename_template: string, optional
    :param filename_template: Template for shard filenames.
    :type sharding_function: :py:class:`ShardingFunction`, optional
    :param sharding_function: The function to shard by. The default is ith vector
                                 mod shard_count.
    :type generate_ids: boolean, optional
    :param generate_ids:      Generates ids using IndexIDMap2. If true, ids will
                                 match the default ids in the unsharded index.
    :rtype: void
    :return: The number of shards written.
    
    The uniform quantizer has a range [vmin, vmax]. The range can be
    the same for all dimensions (uniform) or specific per dimension
    (default).
    8 bits per component4 bits per componentsame, shared range for all dimensionsfast indexing of uint8s6 bits per component
    fast indexing of signed int8s ranging from
    [-128 to 127]
    [min - rs*(max-min), max + rs*(max-min)][mean - std * rs, mean + std * rs][Q(rs), Q(1-rs)]alternate optimization of reconstruction errorbits per scalar codetrained values (including the range)updates internal values based on qtype and d
         Encode a set of vectors

        :type x: float
        :param x:      vectors to encode, size n * d
        :type codes: uint8_t
        :param codes:  output codes, size n * code_size
        
         Decode a set of vectors

        :param codes:  codes to decode, size n * code_size
        :type x: float
        :param x:      output vectors, size n * d
        Flat index built on a scalar quantizer.Used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :param M:      number of subquantizers
        :param nbits:  number of bit per subvector index
        
     An IVF implementation where the components of the residuals are
    encoded with a scalar quantizer. All distance computations
    are asymmetric, so the encoded vectors are decoded and approximate
    distances are computed.
    
     Inverted list that stores binary codes of size nbit. Before the
    binary conversion, the dimension of the vectors is transformed from
    dim d into dim nbit by vt (a random rotation by default).

    Each coordinate is subtracted from a value determined by
    threshold_type, and split into intervals of size period. Half of
    the interval is a 0 bit, the other half a 1.
    transformation from d to nbit dimown the vtnb of bits of the binary signatureinterval size for 0s and 1sglobal threshold at 0compare to centroidcentral interval around centroidmedian of training set
    Trained threshold.
    size nlist * nbit or 0 if Thresh_global
    
        *Overload 1:*
         replace the vector transform for an empty (and possibly untrained) index

        |

        *Overload 2:*
         convenience function to get the VT from an index constucted by an
        index_factory (should end in "LSH")

        |

        *Overload 3:*
         convenience function to get the VT from an index constucted by an
        index_factory (should end in "LSH")
        
    Abstract class for IVF additive quantizers.
    The search functions are in common.
    
     IndexIVF based on a residual quantizer. Stored vectors are
    approximated by residual quantization codes.
    The residual quantizer used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :param M:      number of subquantizers
        :type nbits: std::vector< size_t >
        :param nbits:  number of bit per subvector index
        
     IndexIVF based on a residual quantizer. Stored vectors are
    approximated by residual quantization codes.
    The LSQ quantizer used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type M: int
        :param M:      number of subquantizers
        :type nbits: int
        :param nbits:  number of bit per subvector index
        
     IndexIVF based on a product residual quantizer. Stored vectors are
    approximated by product residual quantization codes.
    The product residual quantizer used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type nsplits: int
        :param nsplits:  number of residual quantizers
        :type Msub: int
        :param Msub:   number of subquantizers per RQ
        :type nbits: int
        :param nbits:  number of bit per subvector index
        
     IndexIVF based on a product local search quantizer. Stored vectors are
    approximated by product local search quantization codes.
    The product local search quantizer used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type nsplits: int
        :param nsplits:  number of local search quantizers
        :type Msub: int
        :param Msub:   number of subquantizers per LSQ
        :type nbits: int
        :param nbits:  number of bit per subvector index
        assignment probability to each layer (sum=1)
    number of neighbors stored per layer (cumulative), should not
    be changed after first add
    level of each vector (base level = 1), size = ntotal
    offsets[i] is the offset in the neighbors array where vector i is stored
    size ntotal + 1
    
    neighbors[offsets[i]:offsets[i+1]] is the list of neighbors of vector i
    for all levels. this is where all storage goes.
    
    entry point in the search structure (one of the points with maximum
    level
    maximum levelexpansion factor at construction timeexpansion factor at search time
    during search: do we check whether the next best distance is good
    enough?
    use bounded queue during exploration
        initialize the assign_probas and cum_nneighbor_per_level to
        have 2*M links on level 0 and M links on levels > 0
        set nb of neighbors for this level (before adding anything)nb of neighbors for this levelcumumlative nb up to (and excluding) this levelrange of entries in the neighbors table of vertex no at layer_noonly mandatory parameter: nb of neighborspick a random level for a new pointadd n random levels to table (for debugging...)
         add point pt_id on all levels <= pt_level and build the link
        structure for them.
        search interface for 1 point, single threadsearch only in level 0 from a given vertexnumber of vectors searchednumber of queries for which the candidate list is exhaustednumber of distances computednumber of hops aka number of edges traversed
     The HNSW index is a normal random-access index with a HNSW
    link structure built on top
    Trains the storage if neededentry point for search
         Perform search only on level 0, given the starting points for
        each vertex.

        :type search_type: int, optional
        :param search_type: 1:perform one search per nprobe, 2: enqueue
                               all entry points
        alternative graph buildingalternative graph building
    Flat index topped with with a HNSW structure to access elements
    more efficiently.
    
    PQ index topped with with a HNSW structure to access elements
    more efficiently.
    
    SQ index topped with a HNSW structure to access elements
    more efficiently.
    2-level code structure with fast random accessentry point for search
    When set to true, the index is immutable.
    This option is used to copy the knn graph from GpuIndexCagra
    to the base level of IndexHNSWCagra without adding upper levels.
    Doing so enables to search the HNSW index, but removes the
    ability to add vectors.
    
    When `base_level_only` is set to `True`, the search function
    searches only the base level knn graph of the HNSW index.
    This parameter selects the entry point by randomly selecting
    some points and using the best one.
    entry point for search
     SMAWK algorithm. Find the row minima of a monotone matrix.

    Expose this for testing.

    :type nrows: int
    :param nrows:    number of rows
    :type ncols: int
    :param ncols:    number of columns
    :type x: float
    :param x:        input matrix, size (nrows, ncols)
    :type argmins: int
    :param argmins:  argmin of each row
    
     Exact 1D K-Means by dynamic programming

    From  "Fast Exact k-Means, k-Medians and Bregman Divergence Clustering in 1D"
    Allan Grønlund, Kasper Green Larsen, Alexander Mathiasen, Jesper Sindahl
    Nielsen, Stefan Schneider, Mingzhou Song, ArXiV'17

    Section 2.2

    https://arxiv.org/abs/1701.07204

    :type x: float
    :param x:          input 1D array
    :type n: int
    :param n:          input array length
    :type nclusters: int
    :param nclusters:  number of clusters
    :type centroids: float
    :param centroids:  output centroids, size nclusters
    :rtype: float
    :return: imbalancce factor
    Initialize the KNN graph randomlyPerform NNDescent algorithmPerform local join on each nodeSample new neighbors for each node to peform local join laterSample a small number of points to evaluate the quality of KNNG builtEvaluate the quality of KNNG built
     The NNDescent index is a normal random-access index with an NNDescent
    link structure built on top
    Faiss results are 64-bitTrains the storage if neededentry point for search
    Flat index topped with with a NNDescent structure to access elements
    more efficiently.
    
     Inverted file with stored vectors. Here the inverted file
    pre-selects the vectors to be searched, but they are not otherwise
    encoded, the code array just contains the raw float entries.
    
    Maps ids stored in the index to the ids of vectors that are
    the same. When a vector is unique, it does not appear in the
    instances map
    also dedups the training setimplemented for all IndexIVF* classesnot implementednot implementednot implementednb of nodesnb of neighbors per nodelength of the search path at construction timecandidate pool size at construction timelength of the search pathenterpointNSG graph structureNSG is built or notrandom generatorthe flattened adjacency matrix, size N-by-Knb of neighbors per nodetotal nb of nodesthe underlying data owned by itself or not
     The NSG index is a normal random-access index with a NSG
    link structure built on top
    the link structurethe sequential storagethe index is built or notK of KNN graph for building
    indicate how to build a knn graph
    - 0: build NSG with brute force search
    - 1: build NSG with NNDescent
    parameters for nndescentTrains the storage if neededentry point for search
    Flat index topped with with a NSG structure to access elements
    more efficiently.
    
    PQ index topped with with a NSG structure to access elements
    more efficiently.
    
    SQ index topped with with a NSG structure to access elements
    more efficiently.
    
     On-disk storage of inverted lists.

    The data is stored in a mmapped chunk of memory (base pointer ptr,
    size totsize). Each list is a range of memory that contains (object
    List) that contains:

    - uint8_t codes[capacity * code_size]
    - followed by idx_t ids[capacity]

    in each of the arrays, the size <= capacity first elements are
    used, the rest is not initialized.

    Addition and resize are supported by:
    - roundind up the capacity of the lists to a power of two
    - maintaining a list of empty slots, sorted by size.
    - resizing the mmapped block is adjusted as needed.

    An OnDiskInvertedLists is compact if the size == capacity for all
    lists and there are no available slots.

    Addition to the invlists is slow. For incremental add it is better
    to use a default ArrayInvertedLists object and convert it to an
    OnDisk with merge_from.

    When it is known that a set of lists will be accessed, it is useful
    to call prefetch_lists, that launches a set of threads to read the
    lists in parallel.
    same as merge_from for a single invlistrestrict the inverted lists to l0:l1 without touching the mmapped regionoverride all list sizes and make a packed storageare inverted lists mapped read-only
     returns the nearest vertex in the sphere to a query. Returns only
    the coordinates, not an id.

    Algorithm: all points are derived from a one atom vector up to a
    permutation and sign changes. The search function finds the most
    appropriate atom and transformation.
    size dim * ntatom
        *Overload 1:*
        find nearest centroid. x does not need to be normalized

        |

        *Overload 2:*
        full call. Requires externally-allocated temp space

        |

        *Overload 3:*
        full call. Requires externally-allocated temp space
        size of the collectionencode a vector from a collectiondecode it
    Repeats: used to encode a vector that has n occurrences of
    val. Encodes the signs and permutation of the vector. Useful for
    atoms.
    
     codec that can return ids for the encoded vectors

    uses the ZnSphereSearch to encode the vector by encoding the
    permutation and signs. Depends on ZnSphereSearch because it uses
    the atom numbers
    takes vectors that do not need to be centroids
     recursive sphere codec

    Uses a recursive decomposition on the dimensions to encode
    centroids found by the ZnSphereSearch. The codes are *not*
    compatible with the ones of ZnSpehreCodec
    
        vectors need to be centroids (does not work on arbitrary
        vectors)
        
     Codec that uses the recursive codec if dim is a power of 2 and
    the regular one otherwise
    Index that encodes a vector with a series of Zn lattice quantizersnumber of sub-vectorsdimension of sub-vectorsthe lattice quantizernb bits used to encode the scale, per subvectormins and maxes of the vector norms, per subquantizeruse table computation or on-the-fly?Hamming thresh for polysemous filtering
     Inverted file with Product Quantizer encoding. Each residual
    vector is encoded as a product quantizer code.
    produces the codesreorder PQ centroids after training?if NULL, use defaultuse table computation or on-the-fly?Hamming thresh for polysemous filtering
     Precompute table that speed up query preprocessing at some
    memory cost (used only for by_residual with L2 metric)
    
    if use_precompute_table
    size nlist * pq.M * pq.ksub
    
        same as add_core, also:
        - output 2nd level residuals if residuals_2 != NULL
        - accepts precomputed_idx = nullptr
        trains the product quantizer
         Find exact duplicates in the dataset.

        the duplicates are returned in pre-allocated arrays (see the
        max sizes).

        :type lims: int
        :param lims:   limits between groups of duplicates
                           (max size ntotal / 2 + 1)
        :type ids: int
        :param ids:    ids[lims[i]] : ids[lims[i+1]-1] is a group of
                           duplicates (max size ntotal)
        :rtype: int
        :return: n      number of groups found
        
         Encode multiple vectors

        :type n: int
        :param n:       nb vectors to encode
        :type keys: int
        :param keys:    posting list ids for those vectors (size n)
        :type x: float
        :param x:       vectors (size n * d)
        :type codes: uint8_t
        :param codes:   output codes (size n * code_size)
        :type compute_keys: boolean, optional
        :param compute_keys:  if false, assume keys are precomputed,
                                 otherwise compute them
        inverse of encode_multiplebuild precomputed table
     Pre-compute distance tables for IVFPQ with by-residual and METRIC_L2

    :type use_precomputed_table: int
    :param use_precomputed_table: (I/O)
               =-1: force disable
               =0: decide heuristically (default: use tables only if they are
                   < precomputed_tables_max_bytes), set use_precomputed_table on
        output =1: tables that work for all quantizers (size 256 * nlist * M) =2:
        specific version for MultiIndexQuantizer (much more compact)
    :type precomputed_table: faiss::AlignedTable< float,32 >
    :param precomputed_table: precomputed table to initialize
    
    statistics are robust to internal threading, but not if
    IndexIVFPQ::search_preassigned is called by multiple threads
    nb of refines (IVFPQR)nb of passed Hamming distance tests (for polysemous)only for IVFPQRIndex with an additional level of PQ refinement3rd level quantizercorresponding codesfactor between k requested in search and the k requested from the IVFPQtrains the two product quantizerssame as add_with_ids, but optionally use the precomputed list ids
     Same as an IndexIVFPQ without the inverted lists: codes are stored
    sequentially

    The class is mainly inteded to store encoded vectors that can be
    accessed randomly, the search function is not implemented.
    first level quantizersecond level quantizer is always a PQsize of the code for the first level (ceil(log8(q1.nlist)))size of the code for the second levelnot implementedtransfer the flat codes to an IVFPQ index
     Fast scan version of IndexPQ and IndexAQ. Works for 4-bit PQ and AQ for now.

    The codes are not stored sequentially but grouped in blocks of size bbs.
    This makes it possible to compute distances quickly with SIMD instructions.
    The trailing codes (padding codes that are added to complete the last code)
    are garbage.

    Implementations:
    12: blocked loop with internal loop on Q with qbs
    13: same with reservoir accumulator to store results
    14: no qbs with heap accumulator
    15: no qbs with reservoir accumulator
    standalone codes interface (but the codes are flattened)
     Fast scan version of IndexAQ. Works for 4-bit AQ for now.

    The codes are not stored sequentially but grouped in blocks of size bbs.
    This makes it possible to compute distances quickly with SIMD instructions.

    Implementations:
    12: blocked loop with internal loop on Q with qbs
    13: same with reservoir accumulator to store results
    14: no qbs with heap accumulator
    15: no qbs with reservoir accumulator
    
        *Overload 1:*
        build from an existing IndexAQ

        |

        *Overload 2:*
        build from an existing IndexAQ
        
         Decode a set of vectors.

         NOTE: The codes in the IndexAdditiveQuantizerFastScan object are non-
               contiguous. But this method requires a contiguous representation.

        :type n: int
        :param n:       number of vectors
        :type bytes: uint8_t
        :param bytes:   input encoded vectors, size n * code_size
        :type x: float
        :param x:       output vectors, size n * d
        
     Index based on a residual quantizer. Stored vectors are
    approximated by residual quantization codes.
    Can also be used as a codec
    The residual quantizer used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type M: int
        :param M:      number of subquantizers
        :type nbits: int
        :param nbits:  number of bit per subvector index
        :type metric: int, optional
        :param metric:  metric type
        :type search_type: int, optional
        :param search_type: AQ search type

        :type d: int
        :param d: dimensionality of the input vectors
        :type M: int
        :param M: number of subquantizers
        :type nbits: int
        :param nbits: number of bit per subvector index
        
     Index based on a local search quantizer. Stored vectors are
    approximated by local search quantization codes.
    Can also be used as a codec
    
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type M: int
        :param M:      number of subquantizers
        :type nbits: int
        :param nbits:  number of bit per subvector index
        :type metric: int, optional
        :param metric:  metric type
        :type search_type: int, optional
        :param search_type: AQ search type

        :type d: int
        :param d: dimensionality of the input vectors
        :type M: int
        :param M: number of subquantizers
        :type nbits: int
        :param nbits: number of bit per subvector index
        
     Index based on a product residual quantizer. Stored vectors are
    approximated by product residual quantization codes.
    Can also be used as a codec
    The product residual quantizer used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type nsplits: int
        :param nsplits:  number of residual quantizers
        :type Msub: int
        :param Msub:     number of subquantizers per RQ
        :type nbits: int
        :param nbits:  number of bit per subvector index
        :type metric: int, optional
        :param metric:  metric type
        :type search_type: int, optional
        :param search_type: AQ search type

        :type d: int
        :param d: dimensionality of the input vectors
        :type nsplits: int
        :param nsplits: number of residual quantizers
        :type Msub: int
        :param Msub: number of subquantizers per RQ
        :type nbits: int
        :param nbits: number of bit per subvector index
        
     Index based on a product local search quantizer. Stored vectors are
    approximated by product local search quantization codes.
    Can also be used as a codec
    The product local search quantizer used to encode the vectors
         Constructor.

        :type d: int
        :param d:      dimensionality of the input vectors
        :type nsplits: int
        :param nsplits:  number of local search quantizers
        :type Msub: int
        :param Msub:     number of subquantizers per LSQ
        :type nbits: int
        :param nbits:  number of bit per subvector index
        :type metric: int, optional
        :param metric:  metric type
        :type search_type: int, optional
        :param search_type: AQ search type

        :type d: int
        :param d: dimensionality of the input vectors
        :type nsplits: int
        :param nsplits: number of local search quantizers
        :type Msub: int
        :param Msub: number of subquantizers per LSQ
        :type nbits: int
        :param nbits: number of bit per subvector index
        
     Fast scan version of IndexPQ. Works for 4-bit PQ for now.

    The codes are not stored sequentially but grouped in blocks of size bbs.
    This makes it possible to compute distances quickly with SIMD instructions.

    Implementations:
    12: blocked loop with internal loop on Q with qbs
    13: same with reservoir accumulator to store results
    14: no qbs with heap accumulator
    15: no qbs with reservoir accumulator
    
        *Overload 1:*
        build from an existing IndexPQ

        |

        *Overload 2:*
        build from an existing IndexPQ
        This file contains callbacks for kernels that compute distances.
        called when 32 distances are computed and provided in two
        simd16uint16. (q, b) indicate which entry it is in the block.
        set the sub-matrix that is being computedthese fields are used mainly for the IVF variants (with_id_map=true)
     Dummy structure that just computes a chqecksum on results
    (to avoid the computation to be optimized away)
    
     memorize results in a nq-by-nb matrix.

    j0 is the current upper-left block of the matrix
    
     Fast scan version of IVFPQ and IVFAQ. Works for 4-bit PQ/AQ for now.

    The codes in the inverted lists are not stored sequentially but
    grouped in blocks of size bbs. This makes it possible to very quickly
    compute distances with SIMD instructions.

    Implementations (implem):
    0: auto-select implementation (default)
    1: orig's search, re-implemented
    2: orig's search, re-ordered by invlist
    10: optimizer int16 search, collect results in heap, no qbs
    11: idem, collect results in reservoir
    12: optimizer int16 search, collect results in heap, uses qbs
    13: idem, collect results in reservoir
    14: internally multithreaded implem over nq * nprobe
    15: same with reservoir

    For range search, only 10 and 12 are supported.
    add 100 to the implem to force single-thread scanning (the coarse quantizer
    may still use multiple threads).
    called by implementationsorig's inverted lists (for debugging)
         Decode a set of vectors.

         NOTE: The codes in the IndexFastScan object are non-contiguous.
               But this method requires a contiguous representation.

        :type n: int
        :param n:       number of vectors
        :type bytes: uint8_t
        :param bytes:   input encoded vectors, size n * code_size
        :type x: float
        :param x:       output vectors, size n * d
        
     Fast scan version of IVFAQ. Works for 4-bit AQ for now.

    The codes in the inverted lists are not stored sequentially but
    grouped in blocks of size bbs. This makes it possible to very quickly
    compute distances with SIMD instructions.

    Implementations (implem):
    0: auto-select implementation (default)
    1: orig's search, re-implemented
    2: orig's search, re-ordered by invlist
    10: optimizer int16 search, collect results in heap, no qbs
    11: idem, collect results in reservoir
    12: optimizer int16 search, collect results in heap, uses qbs
    13: idem, collect results in reservoir
    
        same as the regular IVFAQ encoder. The codes are not reorganized by
        blocks a that point
        
     An IVF index with a quantizer that has a different input dimension from the
    payload size. The vectors to encode are obtained from the input vectors by a
    VectorTransform.
    quantizer is fed directly with the input vectorstransform before the IVF vectors are appliedthe IVF index, controls nlist and nprobewhether *this owns the 3 fields
     Fast scan version of IVFPQ. Works for 4-bit PQ for now.

    The codes in the inverted lists are not stored sequentially but
    grouped in blocks of size bbs. This makes it possible to very quickly
    compute distances with SIMD instructions.

    Implementations (implem):
    0: auto-select implementation (default)
    1: orig's search, re-implemented
    2: orig's search, re-ordered by invlist
    10: optimizer int16 search, collect results in heap, no qbs
    11: idem, collect results in reservoir
    12: optimizer int16 search, collect results in heap, uses qbs
    13: idem, collect results in reservoir
    produces the codesprecomputed tables managementif use_precompute_table size (nlist, pq.M, pq.ksub)build precomputed table, possibly updating use_precomputed_table
        same as the regular IVFPQ encoder. The codes are not reorganized by
        blocks a that point
        
     Functions to quantize PQ floating-point Look Up Tables (LUT) to uint8, and
    biases to uint16. The accumulation is supposed to take place in uint16.
    The quantization coefficients are float (a, b) such that

         original_value = quantized_value * a / b

    The hardest part of the quantization is with multiple LUTs that need to be
    added up together. In that case, coefficient a has to be chosen so that
    the sum fits in a uint16 accumulator.
    
     LUT quantization to uint8 and bias to uint16.

    (nprobe, M, ksub, lut_is_3d) determine the size of the the LUT

     LUT input:
     - 2D size (M, ksub): single matrix per probe (lut_is_3d=false)
     - 3D size (nprobe, M, ksub): separate LUT per probe (lut_is_3d=true)
     bias input:
     - nullptr: bias is 0
     - size (nprobe): one bias per probe
     Output:
     - LUTq uint8 version of the LUT (M size is rounded up to M2)
     - biasq (or nullptr): uint16 version of the LUT
     - a, b: scalars to approximate the true distance
    
     Abstract structure for a binary index.

    Supports adding vertices and searching them.

    All queries are symmetric because there is no distinction between codes and
    vectors.
    vector dimensionnumber of bytes per vector ( = d / 8 )total nb of indexed vectorsverbosity level
    set if the Index does not require training, or if training is done
    already
    type of metric this index uses for search
         Perform training on a representative set of vectors.

        :type n: int
        :param n:      nb of training vectors
        :type x: uint8_t
        :param x:      training vecors, size n * d / 8
        
         Add n vectors of dimension d to the index.

        Vectors are implicitly assigned labels ntotal .. ntotal + n - 1
        :type x: uint8_t
        :param x:      input matrix, size n * d / 8
        
         Same as add, but stores xids instead of sequential ids.

        The default implementation fails with an assertion, as it is
        not supported by all indexes.

        :type xids: int
        :param xids: if non-null, ids to store for the vectors (size n)
        
         Query n vectors of dimension d to the index.

        return at most k vectors. If there are not enough results for a
        query, the result array is padded with -1s.

        :type x: uint8_t
        :param x:           input vectors to search, size n * d / 8
        :type labels: int
        :param labels:      output labels of the NNs, size n*k
        :type distances: int
        :param distances:   output pairwise distances, size n*k
        
         Query n vectors of dimension d to the index.

        return all vectors with distance < radius. Note that many indexes
        do not implement the range_search (only the k-NN search is
        mandatory). The distances are converted to float to reuse the
        RangeSearchResult structure, but they are integer. By convention,
        only distances < radius (strict comparison) are returned,
        ie. radius = 0 does not return any result and 1 returns only
        exact same vectors.

        :type x: uint8_t
        :param x:           input vectors to search, size n * d / 8
        :type radius: int
        :param radius:      search radius
        :type result: :py:class:`RangeSearchResult`
        :param result:      result table
        
         Return the indexes of the k vectors closest to the query x.

        This function is identical to search but only returns labels of
        neighbors.
        :type x: uint8_t
        :param x:           input vectors to search, size n * d / 8
        :type labels: int
        :param labels:      output labels of the NNs, size n*k
        Removes all elements from the database.Removes IDs from the index. Not supported by all indexes.
         Reconstruct a stored vector.

        This function may not be defined for some indexes.
        :type key: int
        :param key:         id of the vector to reconstruct
        :type recons: uint8_t
        :param recons:      reconstucted vector (size d / 8)
        
         Reconstruct vectors i0 to i0 + ni - 1.

        This function may not be defined for some indexes.
        :type recons: uint8_t
        :param recons:      reconstucted vectors (size ni * d / 8)
        
         Similar to search, but also reconstructs the stored vectors (or an
        approximation in the case of lossy coding) for the search results.

        If there are not enough results for a query, the resulting array
        is padded with -1s.

        :type recons: uint8_t
        :param recons:      reconstructed vectors size (n, k, d)
        Display the actual class name and some more info.
         moves the entries from another dataset to self.
        On output, other is empty.
        add_id is added to all moved ids
        (for sequential ids, this would be this->ntotal)
        
         check that the two indexes are compatible (ie, they are
        trained in the same way and have the same
        parameters). Otherwise throw.
        size of the produced codes in bytesSame as add_with_ids for IndexBinary.Index that stores the full vectors and performs exhaustive search.database vectors, size ntotal * d / 8
     Select between using a heap or counting to select the k smallest values
    when scanning inverted lists.
    
         Remove some ids. Note that because of the indexing structure,
        the semantics of this operation are different from the usual ones:
        the new ids are shifted.
        
     Index based on a inverted file (IVF)

    In the inverted file, the quantizer (an IndexBinary instance) provides a
    quantization index for each vector to be added. The quantization
    index maps to a list (aka inverted list or posting list), where the
    id of the vector is stored.

    Otherwise the object is similar to the IndexIVF
    Access to the actual datanumber of probes at query timemax nb of codes to visit to do a query
     Select between using a heap or counting to select the k smallest values
    when scanning inverted lists.
    collect computations per batchmap for direct access to the elements. Enables reconstruct().quantizer that maps vectors to inverted listsnumber of possible key valueswhether object owns the quantizerto override default clustering paramsto override index used during clustering
         The Inverted file takes a quantizer (an IndexBinary) on input,
        which implements the function mapping a vector to a list
        identifier. The pointer is borrowed: the quantizer should not
        be deleted while the IndexBinaryIVF is in use.
        Trains the quantizer
         Implementation of vector addition where the vector assignments are
        predefined.

        :type precomputed_idx: int
        :param precomputed_idx:    quantization indices for the input vectors
            (size n)
        
         Search a set of vectors, that are pre-quantized by the IVF
         quantizer. Fill in the corresponding heaps with the query
         results. search() calls this.

        :type n: int
        :param n:      nb of vectors to query
        :type x: uint8_t
        :param x:      query vectors, size nx * d
        :type assign: int
        :param assign: coarse quantization indices, size nx * nprobe
        :type centroid_dis: int
        :param centroid_dis:
                          distances to coarse centroids, size nx * nprobe
        :param distance:
                          output distances, size n * k
        :type labels: int
        :param labels: output labels, size n * k
        :type store_pairs: boolean
        :param store_pairs: store inv list index + inv list offset
                                instead in upper/lower 32 bit of result,
                                instead of ids (used for reranking).
        :type params: :py:class:`IVFSearchParameters`, optional
        :param params: used to override the object's search parameters
        assign the vectors, then call search_preassign
         Reconstruct a subset of the indexed vectors.

        Overrides default implementation to bypass reconstruct() which requires
        direct_map to be maintained.

        :type i0: int
        :param i0:     first vector to reconstruct
        :type ni: int
        :param ni:     nb of vectors to reconstruct
        :type recons: uint8_t
        :param recons: output array of reconstructed vectors, size ni * d / 8
        
         Similar to search, but also reconstructs the stored vectors (or an
        approximation in the case of lossy coding) for the search results.

        Overrides default implementation to avoid having to maintain direct_map
        and instead fetch the code offsets through the `store_pairs` flag in
        search_preassigned().

        :type recons: uint8_t
        :param recons:      reconstructed vectors size (n, k, d / 8)
        
         Reconstruct a vector given the location in terms of (inv list index +
        inv list offset) instead of the id.

        Useful for reconstructing when the direct_map is not maintained and
        the inv list offset is computed by search_preassigned() with
        `store_pairs` set.
        Dataset manipulation functions
         initialize a direct map

        :type new_maintain_direct_map: boolean, optional
        :param new_maintain_direct_map:    if true, create a direct map,
                                              else clear it
        from now on we handle this query.following codes come from this inverted listcompute a single query-to-code distance
         compute the distances to codes. (distances, labels) should be
        organized as a min- or max-heap

        :type n: int
        :param n:      number of codes to scan
        :type codes: uint8_t
        :param codes:  codes to scan (n * code_size)
        :type ids: int
        :param ids:        corresponding ids (ignored if store_pairs)
        :type distances: int
        :param distances:  heap distances (size k)
        :type labels: int
        :param labels:     heap labels (size k)
        :type k: int
        :param k:          heap size
        
     IndexBinary backed by a float Index.

    Supports adding vertices and searching them.

    All queries are symmetric because there is no distinction between codes and
    vectors.
    Whether object owns the index pointer.
     The HNSW index is a normal random-access index with a HNSW
    link structure built on top
    Trains the storage if neededentry point for searchjust uses the b first bits as a hash valuejust uses the b first bits as a hash valuenb of hash mapsnb bits per hash mapnb bit flips to use at search time
    A holder of indices in a collection of threads
    The interface to this class itself is not thread safe
    
        override an index that is managed by ourselves.
        WARNING: once an index is added, it becomes unsafe to touch it from any
        other thread than that on which is managing it, until we are shut
        down. Use runOnIndex to perform work on it instead.
        
        Remove an index that is managed by ourselves.
        This will flush all pending work on that index, and then shut
        down its managing thread, and will remove the index.
        
        Run a function on all indices, in the thread that the index is
        managed in.
        Function arguments are (index in collection, index pointer)
        
        faiss::Index API
        All indices receive the same call
        Returns the number of sub-indices
        *Overload 1:*
        Returns the i-th sub-index

        |

        *Overload 2:*
        Returns the i-th sub-index (const version)
        Whether or not we are responsible for deleting our contained indices
    A holder of indices in a collection of threads
    The interface to this class itself is not thread safe
    
        override an index that is managed by ourselves.
        WARNING: once an index is added, it becomes unsafe to touch it from any
        other thread than that on which is managing it, until we are shut
        down. Use runOnIndex to perform work on it instead.
        
        Remove an index that is managed by ourselves.
        This will flush all pending work on that index, and then shut
        down its managing thread, and will remove the index.
        
        Run a function on all indices, in the thread that the index is
        managed in.
        Function arguments are (index in collection, index pointer)
        
        faiss::Index API
        All indices receive the same call
        Returns the number of sub-indices
        *Overload 1:*
        Returns the i-th sub-index

        |

        *Overload 2:*
        Returns the i-th sub-index (const version)
        Whether or not we are responsible for deleting our contained indicesIndex that concatenates the results from several sub-indexes
        *Overload 1:*

        The dimension that all sub-indices must share will be the dimension of
        the first sub-index added

        :type threaded: boolean, optional
        :param threaded:     do we use one thread per sub_index or do
                                queries sequentially?
        :type successive_ids: boolean, optional
        :param successive_ids: should we shift the returned ids by
                                the size of each sub-index or return them
                                as they are?

        |

        *Overload 2:*

        :type threaded: boolean, optional
        :param threaded:     do we use one thread per sub_index or do
                                queries sequentially?
        :type successive_ids: boolean, optional
        :param successive_ids: should we shift the returned ids by
                                the size of each sub-index or return them
                                as they are?

        |

        *Overload 3:*

        :type threaded: boolean, optional
        :param threaded:     do we use one thread per sub_index or do
                                queries sequentially?
        :param successive_ids: should we shift the returned ids by
                                the size of each sub-index or return them
                                as they are?

        |

        *Overload 4:*

        :param threaded:     do we use one thread per sub_index or do
                                queries sequentially?
        :param successive_ids: should we shift the returned ids by
                                the size of each sub-index or return them
                                as they are?

        |

        *Overload 5:*
         int version due to the implicit bool conversion ambiguity of int as
         dimension

        |

        *Overload 6:*
         int version due to the implicit bool conversion ambiguity of int as
         dimension

        |

        *Overload 7:*
         int version due to the implicit bool conversion ambiguity of int as
         dimension
        Alias for addIndex()Alias for removeIndex()supported only for sub-indices that implement add_with_ids
        Cases (successive_ids, xids):
        - true, non-NULL       ERROR: it makes no sense to pass in ids and
                               request them to be shifted
        - true, NULL           OK: but should be called only once (calls add()
                               on sub-indexes).
        - false, non-NULL      OK: will call add_with_ids with passed in xids
                               distributed evenly over shards
        - false, NULL          OK: will call add_with_ids on each sub-index,
                               starting at ntotal
        
        Synchronize the top-level index (IndexShards) with data in the
        sub-indices
        Index that concatenates the results from several sub-indexes
        *Overload 1:*

        The dimension that all sub-indices must share will be the dimension of
        the first sub-index added

        :type threaded: boolean, optional
        :param threaded:     do we use one thread per sub_index or do
                                queries sequentially?
        :type successive_ids: boolean, optional
        :param successive_ids: should we shift the returned ids by
                                the size of each sub-index or return them
                                as they are?

        |

        *Overload 2:*

        :type threaded: boolean, optional
        :param threaded:     do we use one thread per sub_index or do
                                queries sequentially?
        :type successive_ids: boolean, optional
        :param successive_ids: should we shift the returned ids by
                                the size of each sub-index or return them
                                as they are?

        |

        *Overload 3:*

        :type threaded: boolean, optional
        :param threaded:     do we use one thread per sub_index or do
                                queries sequentially?
        :param successive_ids: should we shift the returned ids by
                                the size of each sub-index or return them
                                as they are?

        |

        *Overload 4:*

        :param threaded:     do we use one thread per sub_index or do
                                queries sequentially?
        :param successive_ids: should we shift the returned ids by
                                the size of each sub-index or return them
                                as they are?

        |

        *Overload 5:*
         int version due to the implicit bool conversion ambiguity of int as
         dimension

        |

        *Overload 6:*
         int version due to the implicit bool conversion ambiguity of int as
         dimension

        |

        *Overload 7:*
         int version due to the implicit bool conversion ambiguity of int as
         dimension
        Alias for addIndex()Alias for removeIndex()supported only for sub-indices that implement add_with_ids
        Cases (successive_ids, xids):
        - true, non-NULL       ERROR: it makes no sense to pass in ids and
                               request them to be shifted
        - true, NULL           OK: but should be called only once (calls add()
                               on sub-indexes).
        - false, non-NULL      OK: will call add_with_ids with passed in xids
                               distributed evenly over shards
        - false, NULL          OK: will call add_with_ids on each sub-index,
                               starting at ntotal
        
        Synchronize the top-level index (IndexShards) with data in the
        sub-indices
        
    IndexShards with a common coarse quantizer. All the indexes added should be
    IndexIVFInterface indexes so that the search_precomputed can be called.
    
    Takes individual faiss::Index instances, and splits queries for
    sending to each Index instance, and joins the results together
    when done.
    Each index is managed by a separate CPU thread.
    
        *Overload 1:*
        The dimension that all sub-indices must share will be the dimension of
        the first sub-index added
        :type threaded: boolean, optional
        :param threaded: do we use one thread per sub-index or do queries
            sequentially?

        |

        *Overload 2:*
        :type d: int
        :param d: the dimension that all sub-indices must share
        :type threaded: boolean, optional
        :param threaded: do we use one thread per sub index or do queries
            sequentially?

        |

        *Overload 3:*
        :type d: int
        :param d: the dimension that all sub-indices must share
        :param threaded: do we use one thread per sub index or do queries
            sequentially?

        |

        *Overload 4:*
        int version due to the implicit bool conversion ambiguity of int as
        dimension

        |

        *Overload 5:*
        int version due to the implicit bool conversion ambiguity of int as
        dimension
        Alias for addIndex()Alias for removeIndex()
        faiss::Index API
        All indices receive the same call
        
        faiss::Index API
        All indices receive the same call
        
        faiss::Index API
        Query is partitioned into a slice for each sub-index
        split by ceil(n / 
        reconstructs from the first index
        Synchronize the top-level index (IndexShards) with data in the
        sub-indices
        
    Takes individual faiss::Index instances, and splits queries for
    sending to each Index instance, and joins the results together
    when done.
    Each index is managed by a separate CPU thread.
    
        *Overload 1:*
        The dimension that all sub-indices must share will be the dimension of
        the first sub-index added
        :type threaded: boolean, optional
        :param threaded: do we use one thread per sub-index or do queries
            sequentially?

        |

        *Overload 2:*
        :type d: int
        :param d: the dimension that all sub-indices must share
        :type threaded: boolean, optional
        :param threaded: do we use one thread per sub index or do queries
            sequentially?

        |

        *Overload 3:*
        :type d: int
        :param d: the dimension that all sub-indices must share
        :param threaded: do we use one thread per sub index or do queries
            sequentially?

        |

        *Overload 4:*
        int version due to the implicit bool conversion ambiguity of int as
        dimension

        |

        *Overload 5:*
        int version due to the implicit bool conversion ambiguity of int as
        dimension
        Alias for addIndex()Alias for removeIndex()
        faiss::Index API
        All indices receive the same call
        
        faiss::Index API
        All indices receive the same call
        
        faiss::Index API
        Query is partitioned into a slice for each sub-index
        split by ceil(n / 
        reconstructs from the first index
        Synchronize the top-level index (IndexShards) with data in the
        sub-indices
        
     splits input vectors in segments and assigns each segment to a sub-index
    used to distribute a MultiIndexQuantizer
    sum of dimensions seen so far
     index that returns random results.
    used mainly for time benchmarks
    
     Index wrapper that performs rowwise normalization to [0,1], preserving
     the coefficients. This is a vector codec index only.

     Basically, this index performs a rowwise scaling to [0,1] of every row
     in an input dataset before calling subindex::train() and
     subindex::sa_encode(). sa_encode() call stores the scaling coefficients
      (scaler and minv) in the very beginning of every output code. The format:
         [scaler][minv][subindex::sa_encode() output]
     The de-scaling in sa_decode() is done using:
         output_rescaled = scaler * output + minv

     An additional ::train_inplace() function is provided in order to do
     an inplace scaling before calling subindex::train() and, thus, avoiding
     the cloning of the input dataset, but modifying the input dataset because
     of the scaling and the scaling back. It is up to user to call
     this function instead of ::train()

     Derived classes provide different data types for scaling coefficients.
     Currently, versions with fp16 and fp32 scaling coefficients are available.
    fp16 version adds 4 extra bytes per encoded vector
    fp32 version adds 8 extra bytes per encoded vector
     Provides base functions for rowwise normalizing indices.
    sub-indexwhether the subindex needs to be freed in the destructor.Stores scaling coefficients as fp16 values.Stores scaling coefficients as fp32 values.minimal translation of nn.Linearminimal translation of nn.Embedding
    Feed forward layer that expands to a hidden dimension, applies a ReLU non
    linearity and maps back to the orignal dimension
    d: input dim, K: codebook size, L: 
    K = property(_swigfaiss.QINCoStep_K_get, _swigfaiss.QINCoStep_K_set)
    L = property(_swigfaiss.QINCoStep_L_get, _swigfaiss.QINCoStep_L_set)
    h = property(_swigfaiss.QINCoStep_h_get, _swigfaiss.QINCoStep_h_set)

    def __init__(self, d, K, L, h):
        _swigfaiss.QINCoStep_swiginit(self, _swigfaiss.new_QINCoStep(d, K, L, h))
    codebook = property(_swigfaiss.QINCoStep_codebook_get, _swigfaiss.QINCoStep_codebook_set)
    MLPconcat = property(_swigfaiss.QINCoStep_MLPconcat_get, _swigfaiss.QINCoStep_MLPconcat_set)
    residual_blocks = property(_swigfaiss.QINCoStep_residual_blocks_get, _swigfaiss.QINCoStep_residual_blocks_set)

    def get_residual_block(self, i):
        return _swigfaiss.QINCoStep_get_residual_block(self, i)

    def encode(self, xhat, x, residuals=None):
        r
        return _swigfaiss.QINCoStep_encode(self, xhat, x, residuals)

    def decode(self, xhat, codes):
        return _swigfaiss.QINCoStep_decode(self, xhat, codes)
    __swig_destroy__ = _swigfaiss.delete_QINCoStep


_swigfaiss.QINCoStep_swigregister(QINCoStep)
class NeuralNetCodec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    d = property(_swigfaiss.NeuralNetCodec_d_get, _swigfaiss.NeuralNetCodec_d_set)
    M = property(_swigfaiss.NeuralNetCodec_M_get, _swigfaiss.NeuralNetCodec_M_set)

    def decode(self, codes):
        return _swigfaiss.NeuralNetCodec_decode(self, codes)

    def encode(self, x):
        return _swigfaiss.NeuralNetCodec_encode(self, x)
    __swig_destroy__ = _swigfaiss.delete_NeuralNetCodec


_swigfaiss.NeuralNetCodec_swigregister(NeuralNetCodec)
class QINCo(NeuralNetCodec):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    K = property(_swigfaiss.QINCo_K_get, _swigfaiss.QINCo_K_set)
    L = property(_swigfaiss.QINCo_L_get, _swigfaiss.QINCo_L_set)
    h = property(_swigfaiss.QINCo_h_get, _swigfaiss.QINCo_h_set)
    codebook0 = property(_swigfaiss.QINCo_codebook0_get, _swigfaiss.QINCo_codebook0_set)
    steps = property(_swigfaiss.QINCo_steps_get, _swigfaiss.QINCo_steps_set)

    def __init__(self, d, K, L, M, h):
        _swigfaiss.QINCo_swiginit(self, _swigfaiss.new_QINCo(d, K, L, M, h))

    def get_step(self, i):
        return _swigfaiss.QINCo_get_step(self, i)

    def decode(self, codes):
        return _swigfaiss.QINCo_decode(self, codes)

    def encode(self, x):
        return _swigfaiss.QINCo_encode(self, x)
    __swig_destroy__ = _swigfaiss.delete_QINCo


_swigfaiss.QINCo_swigregister(QINCo)
class Tensor2D(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    shape = property(_swigfaiss.Tensor2D_shape_get, _swigfaiss.Tensor2D_shape_set)
    v = property(_swigfaiss.Tensor2D_v_get, _swigfaiss.Tensor2D_v_set)

    def __init__(self, n0, n1, data=None):
        _swigfaiss.Tensor2D_swiginit(self, _swigfaiss.new_Tensor2D(n0, n1, data))

    def __iadd__(self, arg2):
        return _swigfaiss.Tensor2D___iadd__(self, arg2)

    def column(self, j):
        rImplements a few neural net layers, mainly to support QINCoget column 
        return _swigfaiss.Int32Tensor2D_column(self, j)

    def numel(self):
        return _swigfaiss.Int32Tensor2D_numel(self)

    def data(self, *args):
        return _swigfaiss.Int32Tensor2D_data(self, *args)
    __swig_destroy__ = _swigfaiss.delete_Int32Tensor2D


_swigfaiss.Int32Tensor2D_swigregister(Int32Tensor2D)
class IndexNeuralNetCodec(IndexFlatCodes):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    net = property(_swigfaiss.IndexNeuralNetCodec_net_get, _swigfaiss.IndexNeuralNetCodec_net_set)
    M = property(_swigfaiss.IndexNeuralNetCodec_M_get, _swigfaiss.IndexNeuralNetCodec_M_set)
    nbits = property(_swigfaiss.IndexNeuralNetCodec_nbits_get, _swigfaiss.IndexNeuralNetCodec_nbits_set)

    def __init__(self, *args):
        _swigfaiss.IndexNeuralNetCodec_swiginit(self, _swigfaiss.new_IndexNeuralNetCodec(*args))

    def train(self, n, x):
        return _swigfaiss.IndexNeuralNetCodec_train(self, n, x)

    def sa_encode(self, n, x, codes):
        return _swigfaiss.IndexNeuralNetCodec_sa_encode(self, n, x, codes)

    def sa_decode(self, n, codes, x):
        return _swigfaiss.IndexNeuralNetCodec_sa_decode(self, n, codes, x)
    __swig_destroy__ = _swigfaiss.delete_IndexNeuralNetCodec


_swigfaiss.IndexNeuralNetCodec_swigregister(IndexNeuralNetCodec)
class IndexQINCo(IndexNeuralNetCodec):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    qinco = property(_swigfaiss.IndexQINCo_qinco_get, _swigfaiss.IndexQINCo_qinco_set)

    def __init__(self, *args):
        _swigfaiss.IndexQINCo_swiginit(self, _swigfaiss.new_IndexQINCo(*args))
    __swig_destroy__ = _swigfaiss.delete_IndexQINCo


_swigfaiss.IndexQINCo_swigregister(IndexQINCo)
class RaBitQuantizer(Quantizer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    centroid = property(_swigfaiss.RaBitQuantizer_centroid_get, _swigfaiss.RaBitQuantizer_centroid_set)
    metric_type = property(_swigfaiss.RaBitQuantizer_metric_type_get, _swigfaiss.RaBitQuantizer_metric_type_set)

    def __init__(self, *args):
        _swigfaiss.RaBitQuantizer_swiginit(self, _swigfaiss.new_RaBitQuantizer(*args))

    def train(self, n, x):
        return _swigfaiss.RaBitQuantizer_train(self, n, x)

    def compute_codes(self, x, codes, n):
        return _swigfaiss.RaBitQuantizer_compute_codes(self, x, codes, n)

    def compute_codes_core(self, x, codes, n, centroid_in):
        return _swigfaiss.RaBitQuantizer_compute_codes_core(self, x, codes, n, centroid_in)

    def decode(self, codes, x, n):
        return _swigfaiss.RaBitQuantizer_decode(self, codes, x, n)

    def decode_core(self, codes, x, n, centroid_in):
        return _swigfaiss.RaBitQuantizer_decode_core(self, codes, x, n, centroid_in)

    def get_distance_computer(self, qb, centroid_in=None):
        return _swigfaiss.RaBitQuantizer_get_distance_computer(self, qb, centroid_in)
    __swig_destroy__ = _swigfaiss.delete_RaBitQuantizer


_swigfaiss.RaBitQuantizer_swigregister(RaBitQuantizer)
class RaBitQSearchParameters(SearchParameters):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    qb = property(_swigfaiss.RaBitQSearchParameters_qb_get, _swigfaiss.RaBitQSearchParameters_qb_set)

    def __init__(self):
        _swigfaiss.RaBitQSearchParameters_swiginit(self, _swigfaiss.new_RaBitQSearchParameters())
    __swig_destroy__ = _swigfaiss.delete_RaBitQSearchParameters


_swigfaiss.RaBitQSearchParameters_swigregister(RaBitQSearchParameters)
class IndexRaBitQ(IndexFlatCodes):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rabitq = property(_swigfaiss.IndexRaBitQ_rabitq_get, _swigfaiss.IndexRaBitQ_rabitq_set)
    center = property(_swigfaiss.IndexRaBitQ_center_get, _swigfaiss.IndexRaBitQ_center_set)
    qb = property(_swigfaiss.IndexRaBitQ_qb_get, _swigfaiss.IndexRaBitQ_qb_set)

    def __init__(self, *args):
        _swigfaiss.IndexRaBitQ_swiginit(self, _swigfaiss.new_IndexRaBitQ(*args))

    def train(self, n, x):
        return _swigfaiss.IndexRaBitQ_train(self, n, x)

    def sa_encode(self, n, x, bytes):
        return _swigfaiss.IndexRaBitQ_sa_encode(self, n, x, bytes)

    def sa_decode(self, n, bytes, x):
        return _swigfaiss.IndexRaBitQ_sa_decode(self, n, bytes, x)

    def get_FlatCodesDistanceComputer(self):
        return _swigfaiss.IndexRaBitQ_get_FlatCodesDistanceComputer(self)

    def get_quantized_distance_computer(self, qb_in):
        return _swigfaiss.IndexRaBitQ_get_quantized_distance_computer(self, qb_in)

    def search(self, n, x, k, distances, labels, params=None):
        return _swigfaiss.IndexRaBitQ_search(self, n, x, k, distances, labels, params)

    def range_search(self, n, x, radius, result, params=None):
        return _swigfaiss.IndexRaBitQ_range_search(self, n, x, radius, result, params)
    __swig_destroy__ = _swigfaiss.delete_IndexRaBitQ


_swigfaiss.IndexRaBitQ_swigregister(IndexRaBitQ)
class IVFRaBitQSearchParameters(SearchParametersIVF):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    qb = property(_swigfaiss.IVFRaBitQSearchParameters_qb_get, _swigfaiss.IVFRaBitQSearchParameters_qb_set)

    def __init__(self):
        _swigfaiss.IVFRaBitQSearchParameters_swiginit(self, _swigfaiss.new_IVFRaBitQSearchParameters())
    __swig_destroy__ = _swigfaiss.delete_IVFRaBitQSearchParameters


_swigfaiss.IVFRaBitQSearchParameters_swigregister(IVFRaBitQSearchParameters)
class IndexIVFRaBitQ(IndexIVF):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rabitq = property(_swigfaiss.IndexIVFRaBitQ_rabitq_get, _swigfaiss.IndexIVFRaBitQ_rabitq_set)
    qb = property(_swigfaiss.IndexIVFRaBitQ_qb_get, _swigfaiss.IndexIVFRaBitQ_qb_set)

    def __init__(self, *args):
        _swigfaiss.IndexIVFRaBitQ_swiginit(self, _swigfaiss.new_IndexIVFRaBitQ(*args))

    def train_encoder(self, n, x, assign):
        return _swigfaiss.IndexIVFRaBitQ_train_encoder(self, n, x, assign)

    def encode_vectors(self, n, x, list_nos, codes, include_listnos=False):
        return _swigfaiss.IndexIVFRaBitQ_encode_vectors(self, n, x, list_nos, codes, include_listnos)

    def add_core(self, n, x, xids, precomputed_idx, inverted_list_context=None):
        return _swigfaiss.IndexIVFRaBitQ_add_core(self, n, x, xids, precomputed_idx, inverted_list_context)

    def get_InvertedListScanner(self, store_pairs, sel, params):
        return _swigfaiss.IndexIVFRaBitQ_get_InvertedListScanner(self, store_pairs, sel, params)

    def reconstruct_from_offset(self, list_no, offset, recons):
        return _swigfaiss.IndexIVFRaBitQ_reconstruct_from_offset(self, list_no, offset, recons)

    def sa_decode(self, n, bytes, x):
        return _swigfaiss.IndexIVFRaBitQ_sa_decode(self, n, bytes, x)

    def get_distance_computer(self):
        return _swigfaiss.IndexIVFRaBitQ_get_distance_computer(self)
    __swig_destroy__ = _swigfaiss.delete_IndexIVFRaBitQ


_swigfaiss.IndexIVFRaBitQ_swigregister(IndexIVFRaBitQ)
class RangeSearchResult(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nq = property(_swigfaiss.RangeSearchResult_nq_get, _swigfaiss.RangeSearchResult_nq_set, doc=r)
    lims = property(_swigfaiss.RangeSearchResult_lims_get, _swigfaiss.RangeSearchResult_lims_set, doc=r)
    labels = property(_swigfaiss.RangeSearchResult_labels_get, _swigfaiss.RangeSearchResult_labels_set, doc=r)
    distances = property(_swigfaiss.RangeSearchResult_distances_get, _swigfaiss.RangeSearchResult_distances_set, doc=r)
    buffer_size = property(_swigfaiss.RangeSearchResult_buffer_size_get, _swigfaiss.RangeSearchResult_buffer_size_set, doc=r)

    def __init__(self, nq, alloc_lims=True):
        r
        _swigfaiss.RangeSearchResult_swiginit(self, _swigfaiss.new_RangeSearchResult(nq, alloc_lims))

    def do_allocation(self):
        r
        return _swigfaiss.RangeSearchResult_do_allocation(self)
    __swig_destroy__ = _swigfaiss.delete_RangeSearchResult


_swigfaiss.RangeSearchResult_swigregister(RangeSearchResult)
class BufferList(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    buffer_size = property(_swigfaiss.BufferList_buffer_size_get, _swigfaiss.BufferList_buffer_size_set)
    buffers = property(_swigfaiss.BufferList_buffers_get, _swigfaiss.BufferList_buffers_set)
    wp = property(_swigfaiss.BufferList_wp_get, _swigfaiss.BufferList_wp_set, doc=r)

    def __init__(self, buffer_size):
        _swigfaiss.BufferList_swiginit(self, _swigfaiss.new_BufferList(buffer_size))
    __swig_destroy__ = _swigfaiss.delete_BufferList

    def append_buffer(self):
        r
        return _swigfaiss.BufferList_append_buffer(self)

    def add(self, id, dis):
        r
        return _swigfaiss.BufferList_add(self, id, dis)

    def copy_range(self, ofs, n, dest_ids, dest_dis):
        r
        return _swigfaiss.BufferList_copy_range(self, ofs, n, dest_ids, dest_dis)


_swigfaiss.BufferList_swigregister(BufferList)
class RangeQueryResult(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    qno = property(_swigfaiss.RangeQueryResult_qno_get, _swigfaiss.RangeQueryResult_qno_set)
    nres = property(_swigfaiss.RangeQueryResult_nres_get, _swigfaiss.RangeQueryResult_nres_set)
    pres = property(_swigfaiss.RangeQueryResult_pres_get, _swigfaiss.RangeQueryResult_pres_set)

    def add(self, dis, id):
        r
        return _swigfaiss.RangeQueryResult_add(self, dis, id)

    def __init__(self):
        _swigfaiss.RangeQueryResult_swiginit(self, _swigfaiss.new_RangeQueryResult())
    __swig_destroy__ = _swigfaiss.delete_RangeQueryResult


_swigfaiss.RangeQueryResult_swigregister(RangeQueryResult)
class RangeSearchPartialResult(BufferList):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    res = property(_swigfaiss.RangeSearchPartialResult_res_get, _swigfaiss.RangeSearchPartialResult_res_set)

    def __init__(self, res_in):
        r
        _swigfaiss.RangeSearchPartialResult_swiginit(self, _swigfaiss.new_RangeSearchPartialResult(res_in))
    queries = property(_swigfaiss.RangeSearchPartialResult_queries_get, _swigfaiss.RangeSearchPartialResult_queries_set, doc=r)

    def new_result(self, qno):
        r
        return _swigfaiss.RangeSearchPartialResult_new_result(self, qno)

    def finalize(self):
        return _swigfaiss.RangeSearchPartialResult_finalize(self)

    def set_lims(self):
        r
        return _swigfaiss.RangeSearchPartialResult_set_lims(self)

    def copy_result(self, incremental=False):
        r
        return _swigfaiss.RangeSearchPartialResult_copy_result(self, incremental)

    @staticmethod
    def merge(partial_results, do_delete=True):
        r
        return _swigfaiss.RangeSearchPartialResult_merge(partial_results, do_delete)
    __swig_destroy__ = _swigfaiss.delete_RangeSearchPartialResult


_swigfaiss.RangeSearchPartialResult_swigregister(RangeSearchPartialResult)
class InterruptCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def want_interrupt(self):
        return _swigfaiss.InterruptCallback_want_interrupt(self)
    __swig_destroy__ = _swigfaiss.delete_InterruptCallback

    @staticmethod
    def clear_instance():
        return _swigfaiss.InterruptCallback_clear_instance()

    @staticmethod
    def check():
        r
        return _swigfaiss.InterruptCallback_check()

    @staticmethod
    def is_interrupted():
        r
        return _swigfaiss.InterruptCallback_is_interrupted()

    @staticmethod
    def get_period_hint(flops):
        r
        return _swigfaiss.InterruptCallback_get_period_hint(flops)


_swigfaiss.InterruptCallback_swigregister(InterruptCallback)
class TimeoutCallback(InterruptCallback):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    start = property(_swigfaiss.TimeoutCallback_start_get, _swigfaiss.TimeoutCallback_start_set)
    timeout = property(_swigfaiss.TimeoutCallback_timeout_get, _swigfaiss.TimeoutCallback_timeout_set)

    def want_interrupt(self):
        return _swigfaiss.TimeoutCallback_want_interrupt(self)

    def set_timeout(self, timeout_in_seconds):
        return _swigfaiss.TimeoutCallback_set_timeout(self, timeout_in_seconds)

    @staticmethod
    def reset(timeout_in_seconds):
        return _swigfaiss.TimeoutCallback_reset(timeout_in_seconds)

    def __init__(self):
        _swigfaiss.TimeoutCallback_swiginit(self, _swigfaiss.new_TimeoutCallback())
    __swig_destroy__ = _swigfaiss.delete_TimeoutCallback


_swigfaiss.TimeoutCallback_swigregister(TimeoutCallback)
class VisitedTable(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    visited = property(_swigfaiss.VisitedTable_visited_get, _swigfaiss.VisitedTable_visited_set)
    visno = property(_swigfaiss.VisitedTable_visno_get, _swigfaiss.VisitedTable_visno_set)

    def __init__(self, size):
        _swigfaiss.VisitedTable_swiginit(self, _swigfaiss.new_VisitedTable(size))

    def set(self, no):
        rget flag 
        return _swigfaiss.VisitedTable_get(self, no)

    def advance(self):
        r
        return _swigfaiss.VisitedTable_advance(self)
    __swig_destroy__ = _swigfaiss.delete_VisitedTable


_swigfaiss.VisitedTable_swigregister(VisitedTable)
class IDSelector(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def is_member(self, id):
        return _swigfaiss.IDSelector_is_member(self, id)
    __swig_destroy__ = _swigfaiss.delete_IDSelector


_swigfaiss.IDSelector_swigregister(IDSelector)
class IDSelectorRange(IDSelector):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    imin = property(_swigfaiss.IDSelectorRange_imin_get, _swigfaiss.IDSelectorRange_imin_set)
    imax = property(_swigfaiss.IDSelectorRange_imax_get, _swigfaiss.IDSelectorRange_imax_set)
    assume_sorted = property(_swigfaiss.IDSelectorRange_assume_sorted_get, _swigfaiss.IDSelectorRange_assume_sorted_set, doc=r)

    def __init__(self, imin, imax, assume_sorted=False):
        _swigfaiss.IDSelectorRange_swiginit(self, _swigfaiss.new_IDSelectorRange(imin, imax, assume_sorted))

    def is_member(self, id):
        return _swigfaiss.IDSelectorRange_is_member(self, id)

    def find_sorted_ids_bounds(self, list_size, ids, jmin, jmax):
        r
        return _swigfaiss.IDSelectorRange_find_sorted_ids_bounds(self, list_size, ids, jmin, jmax)
    __swig_destroy__ = _swigfaiss.delete_IDSelectorRange


_swigfaiss.IDSelectorRange_swigregister(IDSelectorRange)
class IDSelectorArray(IDSelector):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_swigfaiss.IDSelectorArray_n_get, _swigfaiss.IDSelectorArray_n_set)
    ids = property(_swigfaiss.IDSelectorArray_ids_get, _swigfaiss.IDSelectorArray_ids_set)

    def __init__(self, n, ids):
        r
        _swigfaiss.IDSelectorArray_swiginit(self, _swigfaiss.new_IDSelectorArray(n, ids))

    def is_member(self, id):
        return _swigfaiss.IDSelectorArray_is_member(self, id)
    __swig_destroy__ = _swigfaiss.delete_IDSelectorArray


_swigfaiss.IDSelectorArray_swigregister(IDSelectorArray)
class IDSelectorBatch(IDSelector):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nbits = property(_swigfaiss.IDSelectorBatch_nbits_get, _swigfaiss.IDSelectorBatch_nbits_set)
    mask = property(_swigfaiss.IDSelectorBatch_mask_get, _swigfaiss.IDSelectorBatch_mask_set)

    def __init__(self, n, indices):
        r
        _swigfaiss.IDSelectorBatch_swiginit(self, _swigfaiss.new_IDSelectorBatch(n, indices))

    def is_member(self, id):
        return _swigfaiss.IDSelectorBatch_is_member(self, id)
    __swig_destroy__ = _swigfaiss.delete_IDSelectorBatch


_swigfaiss.IDSelectorBatch_swigregister(IDSelectorBatch)
class IDSelectorBitmap(IDSelector):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_swigfaiss.IDSelectorBitmap_n_get, _swigfaiss.IDSelectorBitmap_n_set)
    bitmap = property(_swigfaiss.IDSelectorBitmap_bitmap_get, _swigfaiss.IDSelectorBitmap_bitmap_set)

    def __init__(self, n, bitmap):
        r
        _swigfaiss.IDSelectorBitmap_swiginit(self, _swigfaiss.new_IDSelectorBitmap(n, bitmap))

    def is_member(self, id):
        return _swigfaiss.IDSelectorBitmap_is_member(self, id)
    __swig_destroy__ = _swigfaiss.delete_IDSelectorBitmap


_swigfaiss.IDSelectorBitmap_swigregister(IDSelectorBitmap)
class IDSelectorNot(IDSelector):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sel = property(_swigfaiss.IDSelectorNot_sel_get, _swigfaiss.IDSelectorNot_sel_set)

    def __init__(self, sel):
        _swigfaiss.IDSelectorNot_swiginit(self, _swigfaiss.new_IDSelectorNot(sel))

    def is_member(self, id):
        return _swigfaiss.IDSelectorNot_is_member(self, id)
    __swig_destroy__ = _swigfaiss.delete_IDSelectorNot


_swigfaiss.IDSelectorNot_swigregister(IDSelectorNot)
class IDSelectorAll(IDSelector):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def is_member(self, id):
        return _swigfaiss.IDSelectorAll_is_member(self, id)
    __swig_destroy__ = _swigfaiss.delete_IDSelectorAll

    def __init__(self):
        _swigfaiss.IDSelectorAll_swiginit(self, _swigfaiss.new_IDSelectorAll())


_swigfaiss.IDSelectorAll_swigregister(IDSelectorAll)
class IDSelectorAnd(IDSelector):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lhs = property(_swigfaiss.IDSelectorAnd_lhs_get, _swigfaiss.IDSelectorAnd_lhs_set)
    rhs = property(_swigfaiss.IDSelectorAnd_rhs_get, _swigfaiss.IDSelectorAnd_rhs_set)

    def __init__(self, lhs, rhs):
        _swigfaiss.IDSelectorAnd_swiginit(self, _swigfaiss.new_IDSelectorAnd(lhs, rhs))

    def is_member(self, id):
        return _swigfaiss.IDSelectorAnd_is_member(self, id)
    __swig_destroy__ = _swigfaiss.delete_IDSelectorAnd


_swigfaiss.IDSelectorAnd_swigregister(IDSelectorAnd)
class IDSelectorOr(IDSelector):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lhs = property(_swigfaiss.IDSelectorOr_lhs_get, _swigfaiss.IDSelectorOr_lhs_set)
    rhs = property(_swigfaiss.IDSelectorOr_rhs_get, _swigfaiss.IDSelectorOr_rhs_set)

    def __init__(self, lhs, rhs):
        _swigfaiss.IDSelectorOr_swiginit(self, _swigfaiss.new_IDSelectorOr(lhs, rhs))

    def is_member(self, id):
        return _swigfaiss.IDSelectorOr_is_member(self, id)
    __swig_destroy__ = _swigfaiss.delete_IDSelectorOr


_swigfaiss.IDSelectorOr_swigregister(IDSelectorOr)
class IDSelectorXOr(IDSelector):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lhs = property(_swigfaiss.IDSelectorXOr_lhs_get, _swigfaiss.IDSelectorXOr_lhs_set)
    rhs = property(_swigfaiss.IDSelectorXOr_rhs_get, _swigfaiss.IDSelectorXOr_rhs_set)

    def __init__(self, lhs, rhs):
        _swigfaiss.IDSelectorXOr_swiginit(self, _swigfaiss.new_IDSelectorXOr(lhs, rhs))

    def is_member(self, id):
        return _swigfaiss.IDSelectorXOr_is_member(self, id)
    __swig_destroy__ = _swigfaiss.delete_IDSelectorXOr


_swigfaiss.IDSelectorXOr_swigregister(IDSelectorXOr)
class IDSelectorTranslated(IDSelector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    id_map = property(_swigfaiss.IDSelectorTranslated_id_map_get)
    sel = property(_swigfaiss.IDSelectorTranslated_sel_get, _swigfaiss.IDSelectorTranslated_sel_set)

    def __init__(self, *args):
        _swigfaiss.IDSelectorTranslated_swiginit(self, _swigfaiss.new_IDSelectorTranslated(*args))

    def is_member(self, id):
        return _swigfaiss.IDSelectorTranslated_is_member(self, id)
    __swig_destroy__ = _swigfaiss.delete_IDSelectorTranslated


_swigfaiss.IDSelectorTranslated_swigregister(IDSelectorTranslated)
class IndexIDMap(Index):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    index = property(_swigfaiss.IndexIDMap_index_get, _swigfaiss.IndexIDMap_index_set)
    own_fields = property(_swigfaiss.IndexIDMap_own_fields_get, _swigfaiss.IndexIDMap_own_fields_set, doc=r)
    id_map = property(_swigfaiss.IndexIDMap_id_map_get, _swigfaiss.IndexIDMap_id_map_set, doc=r)

    def add_with_ids(self, n, x, xids):
        r
        return _swigfaiss.IndexIDMap_add_with_ids(self, n, x, xids)

    def add(self, n, x):
        r
        return _swigfaiss.IndexIDMap_add(self, n, x)

    def search(self, n, x, k, distances, labels, params=None):
        return _swigfaiss.IndexIDMap_search(self, n, x, k, distances, labels, params)

    def train(self, n, x):
        return _swigfaiss.IndexIDMap_train(self, n, x)

    def reset(self):
        return _swigfaiss.IndexIDMap_reset(self)

    def remove_ids(self, sel):
        r
        return _swigfaiss.IndexIDMap_remove_ids(self, sel)

    def range_search(self, n, x, radius, result, params=None):
        return _swigfaiss.IndexIDMap_range_search(self, n, x, radius, result, params)

    def merge_from(self, otherIndex, add_id=0):
        return _swigfaiss.IndexIDMap_merge_from(self, otherIndex, add_id)

    def check_compatible_for_merge(self, otherIndex):
        return _swigfaiss.IndexIDMap_check_compatible_for_merge(self, otherIndex)

    def sa_code_size(self):
        return _swigfaiss.IndexIDMap_sa_code_size(self)

    def add_sa_codes(self, n, x, xids):
        return _swigfaiss.IndexIDMap_add_sa_codes(self, n, x, xids)
    __swig_destroy__ = _swigfaiss.delete_IndexIDMap

    def __init__(self, *args):
        _swigfaiss.IndexIDMap_swiginit(self, _swigfaiss.new_IndexIDMap(*args))


_swigfaiss.IndexIDMap_swigregister(IndexIDMap)
class IndexBinaryIDMap(IndexBinary):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    index = property(_swigfaiss.IndexBinaryIDMap_index_get, _swigfaiss.IndexBinaryIDMap_index_set)
    own_fields = property(_swigfaiss.IndexBinaryIDMap_own_fields_get, _swigfaiss.IndexBinaryIDMap_own_fields_set, doc=r)
    id_map = property(_swigfaiss.IndexBinaryIDMap_id_map_get, _swigfaiss.IndexBinaryIDMap_id_map_set, doc=r)

    def add_with_ids(self, n, x, xids):
        r
        return _swigfaiss.IndexBinaryIDMap_add_with_ids(self, n, x, xids)

    def add(self, n, x):
        r
        return _swigfaiss.IndexBinaryIDMap_add(self, n, x)

    def search(self, n, x, k, distances, labels, params=None):
        return _swigfaiss.IndexBinaryIDMap_search(self, n, x, k, distances, labels, params)

    def train(self, n, x):
        return _swigfaiss.IndexBinaryIDMap_train(self, n, x)

    def reset(self):
        return _swigfaiss.IndexBinaryIDMap_reset(self)

    def remove_ids(self, sel):
        r
        return _swigfaiss.IndexBinaryIDMap_remove_ids(self, sel)

    def range_search(self, n, x, radius, result, params=None):
        return _swigfaiss.IndexBinaryIDMap_range_search(self, n, x, radius, result, params)

    def merge_from(self, otherIndex, add_id=0):
        return _swigfaiss.IndexBinaryIDMap_merge_from(self, otherIndex, add_id)

    def check_compatible_for_merge(self, otherIndex):
        return _swigfaiss.IndexBinaryIDMap_check_compatible_for_merge(self, otherIndex)

    def sa_code_size(self):
        return _swigfaiss.IndexBinaryIDMap_sa_code_size(self)

    def add_sa_codes(self, n, x, xids):
        return _swigfaiss.IndexBinaryIDMap_add_sa_codes(self, n, x, xids)
    __swig_destroy__ = _swigfaiss.delete_IndexBinaryIDMap

    def __init__(self, *args):
        _swigfaiss.IndexBinaryIDMap_swiginit(self, _swigfaiss.new_IndexBinaryIDMap(*args))


_swigfaiss.IndexBinaryIDMap_swigregister(IndexBinaryIDMap)
class IndexIDMap2(IndexIDMap):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rev_map = property(_swigfaiss.IndexIDMap2_rev_map_get, _swigfaiss.IndexIDMap2_rev_map_set)

    def construct_rev_map(self):
        r
        return _swigfaiss.IndexIDMap2_construct_rev_map(self)

    def add_with_ids(self, n, x, xids):
        return _swigfaiss.IndexIDMap2_add_with_ids(self, n, x, xids)

    def remove_ids(self, sel):
        return _swigfaiss.IndexIDMap2_remove_ids(self, sel)

    def reconstruct(self, key, recons):
        return _swigfaiss.IndexIDMap2_reconstruct(self, key, recons)

    def check_consistency(self):
        r
        return _swigfaiss.IndexIDMap2_check_consistency(self)

    def merge_from(self, otherIndex, add_id=0):
        return _swigfaiss.IndexIDMap2_merge_from(self, otherIndex, add_id)
    __swig_destroy__ = _swigfaiss.delete_IndexIDMap2

    def __init__(self, *args):
        _swigfaiss.IndexIDMap2_swiginit(self, _swigfaiss.new_IndexIDMap2(*args))


_swigfaiss.IndexIDMap2_swigregister(IndexIDMap2)
class IndexBinaryIDMap2(IndexBinaryIDMap):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rev_map = property(_swigfaiss.IndexBinaryIDMap2_rev_map_get, _swigfaiss.IndexBinaryIDMap2_rev_map_set)

    def construct_rev_map(self):
        r
        return _swigfaiss.IndexBinaryIDMap2_construct_rev_map(self)

    def add_with_ids(self, n, x, xids):
        return _swigfaiss.IndexBinaryIDMap2_add_with_ids(self, n, x, xids)

    def remove_ids(self, sel):
        return _swigfaiss.IndexBinaryIDMap2_remove_ids(self, sel)

    def reconstruct(self, key, recons):
        return _swigfaiss.IndexBinaryIDMap2_reconstruct(self, key, recons)

    def check_consistency(self):
        r
        return _swigfaiss.IndexBinaryIDMap2_check_consistency(self)

    def merge_from(self, otherIndex, add_id=0):
        return _swigfaiss.IndexBinaryIDMap2_merge_from(self, otherIndex, add_id)
    __swig_destroy__ = _swigfaiss.delete_IndexBinaryIDMap2

    def __init__(self, *args):
        _swigfaiss.IndexBinaryIDMap2_swiginit(self, _swigfaiss.new_IndexBinaryIDMap2(*args))


_swigfaiss.IndexBinaryIDMap2_swigregister(IndexBinaryIDMap2)
EXACT_TOPK = _swigfaiss.EXACT_TOPK
APPROX_TOPK_BUCKETS_B32_D2 = _swigfaiss.APPROX_TOPK_BUCKETS_B32_D2
APPROX_TOPK_BUCKETS_B8_D3 = _swigfaiss.APPROX_TOPK_BUCKETS_B8_D3
APPROX_TOPK_BUCKETS_B16_D2 = _swigfaiss.APPROX_TOPK_BUCKETS_B16_D2
APPROX_TOPK_BUCKETS_B8_D2 = _swigfaiss.APPROX_TOPK_BUCKETS_B8_D2

def downcast_index(index):
    return _swigfaiss.downcast_index(index)

def downcast_VectorTransform(vt):
    return _swigfaiss.downcast_VectorTransform(vt)

def downcast_IndexBinary(index):
    return _swigfaiss.downcast_IndexBinary(index)

def downcast_InvertedLists(il):
    return _swigfaiss.downcast_InvertedLists(il)

def downcast_AdditiveQuantizer(aq):
    return _swigfaiss.downcast_AdditiveQuantizer(aq)

def downcast_Quantizer(aq):
    return _swigfaiss.downcast_Quantizer(aq)

def write_index(*args):
    return _swigfaiss.write_index(*args)

def write_index_binary(*args):
    return _swigfaiss.write_index_binary(*args)

def read_index(*args):
    return _swigfaiss.read_index(*args)

def read_index_binary(*args):
    return _swigfaiss.read_index_binary(*args)

def write_VectorTransform(*args):
    return _swigfaiss.write_VectorTransform(*args)

def read_VectorTransform(*args):
    return _swigfaiss.read_VectorTransform(*args)

def read_ProductQuantizer(*args):
    return _swigfaiss.read_ProductQuantizer(*args)

def write_ProductQuantizer(*args):
    return _swigfaiss.write_ProductQuantizer(*args)

def write_InvertedLists(ils, f):
    return _swigfaiss.write_InvertedLists(ils, f)

def read_InvertedLists(reader, io_flags=0):
    return _swigfaiss.read_InvertedLists(reader, io_flags)

def clone_index(arg1):
    return _swigfaiss.clone_index(arg1)
class Cloner(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def clone_VectorTransform(self, arg2):
        return _swigfaiss.Cloner_clone_VectorTransform(self, arg2)

    def clone_Index(self, arg2):
        return _swigfaiss.Cloner_clone_Index(self, arg2)

    def clone_IndexIVF(self, arg2):
        return _swigfaiss.Cloner_clone_IndexIVF(self, arg2)
    __swig_destroy__ = _swigfaiss.delete_Cloner

    def __init__(self):
        _swigfaiss.Cloner_swiginit(self, _swigfaiss.new_Cloner())


_swigfaiss.Cloner_swigregister(Cloner)
IO_FLAG_SKIP_STORAGE = cvar.IO_FLAG_SKIP_STORAGE
IO_FLAG_READ_ONLY = cvar.IO_FLAG_READ_ONLY
IO_FLAG_ONDISK_SAME_DIR = cvar.IO_FLAG_ONDISK_SAME_DIR
IO_FLAG_SKIP_IVF_DATA = cvar.IO_FLAG_SKIP_IVF_DATA
IO_FLAG_SKIP_PRECOMPUTE_TABLE = cvar.IO_FLAG_SKIP_PRECOMPUTE_TABLE
IO_FLAG_PQ_SKIP_SDC_TABLE = cvar.IO_FLAG_PQ_SKIP_SDC_TABLE
IO_FLAG_MMAP = cvar.IO_FLAG_MMAP
IO_FLAG_MMAP_IFC = cvar.IO_FLAG_MMAP_IFC


def clone_Quantizer(quant):
    return _swigfaiss.clone_Quantizer(quant)

def clone_binary_index(index):
    return _swigfaiss.clone_binary_index(index)
class AutoTuneCriterion(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    nq = property(_swigfaiss.AutoTuneCriterion_nq_get, _swigfaiss.AutoTuneCriterion_nq_set, doc=r)
    nnn = property(_swigfaiss.AutoTuneCriterion_nnn_get, _swigfaiss.AutoTuneCriterion_nnn_set, doc=r)
    gt_nnn = property(_swigfaiss.AutoTuneCriterion_gt_nnn_get, _swigfaiss.AutoTuneCriterion_gt_nnn_set, doc=r)
    gt_D = property(_swigfaiss.AutoTuneCriterion_gt_D_get, _swigfaiss.AutoTuneCriterion_gt_D_set, doc=r)
    gt_I = property(_swigfaiss.AutoTuneCriterion_gt_I_get, _swigfaiss.AutoTuneCriterion_gt_I_set, doc=r)

    def set_groundtruth(self, gt_nnn, gt_D_in, gt_I_in):
        r
        return _swigfaiss.AutoTuneCriterion_set_groundtruth(self, gt_nnn, gt_D_in, gt_I_in)

    def evaluate(self, D, I):
        r
        return _swigfaiss.AutoTuneCriterion_evaluate(self, D, I)
    __swig_destroy__ = _swigfaiss.delete_AutoTuneCriterion


_swigfaiss.AutoTuneCriterion_swigregister(AutoTuneCriterion)
class OneRecallAtRCriterion(AutoTuneCriterion):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    R = property(_swigfaiss.OneRecallAtRCriterion_R_get, _swigfaiss.OneRecallAtRCriterion_R_set)

    def __init__(self, nq, R):
        _swigfaiss.OneRecallAtRCriterion_swiginit(self, _swigfaiss.new_OneRecallAtRCriterion(nq, R))

    def evaluate(self, D, I):
        return _swigfaiss.OneRecallAtRCriterion_evaluate(self, D, I)
    __swig_destroy__ = _swigfaiss.delete_OneRecallAtRCriterion


_swigfaiss.OneRecallAtRCriterion_swigregister(OneRecallAtRCriterion)
class IntersectionCriterion(AutoTuneCriterion):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    R = property(_swigfaiss.IntersectionCriterion_R_get, _swigfaiss.IntersectionCriterion_R_set)

    def __init__(self, nq, R):
        _swigfaiss.IntersectionCriterion_swiginit(self, _swigfaiss.new_IntersectionCriterion(nq, R))

    def evaluate(self, D, I):
        return _swigfaiss.IntersectionCriterion_evaluate(self, D, I)
    __swig_destroy__ = _swigfaiss.delete_IntersectionCriterion


_swigfaiss.IntersectionCriterion_swigregister(IntersectionCriterion)
class OperatingPoint(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    perf = property(_swigfaiss.OperatingPoint_perf_get, _swigfaiss.OperatingPoint_perf_set, doc=r)
    t = property(_swigfaiss.OperatingPoint_t_get, _swigfaiss.OperatingPoint_t_set, doc=r)
    key = property(_swigfaiss.OperatingPoint_key_get, _swigfaiss.OperatingPoint_key_set, doc=r)
    cno = property(_swigfaiss.OperatingPoint_cno_get, _swigfaiss.OperatingPoint_cno_set, doc=r)

    def __init__(self):
        _swigfaiss.OperatingPoint_swiginit(self, _swigfaiss.new_OperatingPoint())
    __swig_destroy__ = _swigfaiss.delete_OperatingPoint


_swigfaiss.OperatingPoint_swigregister(OperatingPoint)
class OperatingPoints(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    all_pts = property(_swigfaiss.OperatingPoints_all_pts_get, _swigfaiss.OperatingPoints_all_pts_set, doc=r)
    optimal_pts = property(_swigfaiss.OperatingPoints_optimal_pts_get, _swigfaiss.OperatingPoints_optimal_pts_set, doc=r)

    def __init__(self):
        _swigfaiss.OperatingPoints_swiginit(self, _swigfaiss.new_OperatingPoints())

    def merge_with(self, *args):
        r
        return _swigfaiss.OperatingPoints_merge_with(self, *args)

    def clear(self):
        return _swigfaiss.OperatingPoints_clear(self)

    def add(self, perf, t, key, cno=0):
        r
        return _swigfaiss.OperatingPoints_add(self, perf, t, key, cno)

    def t_for_perf(self, perf):
        r
        return _swigfaiss.OperatingPoints_t_for_perf(self, perf)

    def display(self, only_optimal=True):
        r
        return _swigfaiss.OperatingPoints_display(self, only_optimal)

    def all_to_gnuplot(self, fname):
        r
        return _swigfaiss.OperatingPoints_all_to_gnuplot(self, fname)

    def optimal_to_gnuplot(self, fname):
        return _swigfaiss.OperatingPoints_optimal_to_gnuplot(self, fname)
    __swig_destroy__ = _swigfaiss.delete_OperatingPoints


_swigfaiss.OperatingPoints_swigregister(OperatingPoints)
class ParameterRange(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_swigfaiss.ParameterRange_name_get, _swigfaiss.ParameterRange_name_set)
    values = property(_swigfaiss.ParameterRange_values_get, _swigfaiss.ParameterRange_values_set)

    def __init__(self):
        _swigfaiss.ParameterRange_swiginit(self, _swigfaiss.new_ParameterRange())
    __swig_destroy__ = _swigfaiss.delete_ParameterRange


_swigfaiss.ParameterRange_swigregister(ParameterRange)
class ParameterSpace(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    parameter_ranges = property(_swigfaiss.ParameterSpace_parameter_ranges_get, _swigfaiss.ParameterSpace_parameter_ranges_set, doc=r)
    verbose = property(_swigfaiss.ParameterSpace_verbose_get, _swigfaiss.ParameterSpace_verbose_set, doc=r)
    n_experiments = property(_swigfaiss.ParameterSpace_n_experiments_get, _swigfaiss.ParameterSpace_n_experiments_set, doc=r)
    batchsize = property(_swigfaiss.ParameterSpace_batchsize_get, _swigfaiss.ParameterSpace_batchsize_set, doc=r)
    thread_over_batches = property(_swigfaiss.ParameterSpace_thread_over_batches_get, _swigfaiss.ParameterSpace_thread_over_batches_set, doc=r)
    min_test_duration = property(_swigfaiss.ParameterSpace_min_test_duration_get, _swigfaiss.ParameterSpace_min_test_duration_set, doc=r)

    def __init__(self):
        _swigfaiss.ParameterSpace_swiginit(self, _swigfaiss.new_ParameterSpace())

    def n_combinations(self):
        r
        return _swigfaiss.ParameterSpace_n_combinations(self)

    def combination_ge(self, c1, c2):
        r
        return _swigfaiss.ParameterSpace_combination_ge(self, c1, c2)

    def combination_name(self, cno):
        r
        return _swigfaiss.ParameterSpace_combination_name(self, cno)

    def display(self):
        r
        return _swigfaiss.ParameterSpace_display(self)

    def add_range(self, name):
        r
        return _swigfaiss.ParameterSpace_add_range(self, name)

    def initialize(self, index):
        r
        return _swigfaiss.ParameterSpace_initialize(self, index)

    def set_index_parameters(self, *args):
        r
        return _swigfaiss.ParameterSpace_set_index_parameters(self, *args)

    def set_index_parameter(self, index, name, val):
        r
        return _swigfaiss.ParameterSpace_set_index_parameter(self, index, name, val)

    def update_bounds(self, cno, op, upper_bound_perf, lower_bound_t):
        r
        return _swigfaiss.ParameterSpace_update_bounds(self, cno, op, upper_bound_perf, lower_bound_t)

    def explore(self, index, nq, xq, crit, ops):
        r
        return _swigfaiss.ParameterSpace_explore(self, index, nq, xq, crit, ops)
    __swig_destroy__ = _swigfaiss.delete_ParameterSpace


_swigfaiss.ParameterSpace_swigregister(ParameterSpace)

def index_factory(*args):
    r
    return _swigfaiss.index_factory(*args)

def index_binary_factory(d, description):
    return _swigfaiss.index_binary_factory(d, description)
class MatrixStats(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, n, d, x):
        _swigfaiss.MatrixStats_swiginit(self, _swigfaiss.new_MatrixStats(n, d, x))
    comments = property(_swigfaiss.MatrixStats_comments_get, _swigfaiss.MatrixStats_comments_set)
    n = property(_swigfaiss.MatrixStats_n_get, _swigfaiss.MatrixStats_n_set)
    d = property(_swigfaiss.MatrixStats_d_get, _swigfaiss.MatrixStats_d_set)
    n_collision = property(_swigfaiss.MatrixStats_n_collision_get, _swigfaiss.MatrixStats_n_collision_set)
    n_valid = property(_swigfaiss.MatrixStats_n_valid_get, _swigfaiss.MatrixStats_n_valid_set)
    n0 = property(_swigfaiss.MatrixStats_n0_get, _swigfaiss.MatrixStats_n0_set)
    min_norm2 = property(_swigfaiss.MatrixStats_min_norm2_get, _swigfaiss.MatrixStats_min_norm2_set)
    max_norm2 = property(_swigfaiss.MatrixStats_max_norm2_get, _swigfaiss.MatrixStats_max_norm2_set)
    hash_value = property(_swigfaiss.MatrixStats_hash_value_get, _swigfaiss.MatrixStats_hash_value_set)
    per_dim_stats = property(_swigfaiss.MatrixStats_per_dim_stats_get, _swigfaiss.MatrixStats_per_dim_stats_set)
    occurrences = property(_swigfaiss.MatrixStats_occurrences_get, _swigfaiss.MatrixStats_occurrences_set)
    buf = property(_swigfaiss.MatrixStats_buf_get, _swigfaiss.MatrixStats_buf_set)
    nbuf = property(_swigfaiss.MatrixStats_nbuf_get, _swigfaiss.MatrixStats_nbuf_set)

    def do_comment(self, fmt):
        return _swigfaiss.MatrixStats_do_comment(self, fmt)
    __swig_destroy__ = _swigfaiss.delete_MatrixStats


_swigfaiss.MatrixStats_swigregister(MatrixStats)
class PyCallbackIOWriter(IOWriter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    callback = property(_swigfaiss.PyCallbackIOWriter_callback_get, _swigfaiss.PyCallbackIOWriter_callback_set)
    bs = property(_swigfaiss.PyCallbackIOWriter_bs_get, _swigfaiss.PyCallbackIOWriter_bs_set)

    def __init__(self, *args):
        r
        _swigfaiss.PyCallbackIOWriter_swiginit(self, _swigfaiss.new_PyCallbackIOWriter(*args))

    def __call__(self, ptrv, size, nitems):
        return _swigfaiss.PyCallbackIOWriter___call__(self, ptrv, size, nitems)
    __swig_destroy__ = _swigfaiss.delete_PyCallbackIOWriter


_swigfaiss.PyCallbackIOWriter_swigregister(PyCallbackIOWriter)
class PyCallbackIOReader(IOReader):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    callback = property(_swigfaiss.PyCallbackIOReader_callback_get, _swigfaiss.PyCallbackIOReader_callback_set)
    bs = property(_swigfaiss.PyCallbackIOReader_bs_get, _swigfaiss.PyCallbackIOReader_bs_set)

    def __init__(self, *args):
        r
        _swigfaiss.PyCallbackIOReader_swiginit(self, _swigfaiss.new_PyCallbackIOReader(*args))

    def __call__(self, ptrv, size, nitems):
        return _swigfaiss.PyCallbackIOReader___call__(self, ptrv, size, nitems)
    __swig_destroy__ = _swigfaiss.delete_PyCallbackIOReader


_swigfaiss.PyCallbackIOReader_swigregister(PyCallbackIOReader)
class PyCallbackIDSelector(IDSelector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    callback = property(_swigfaiss.PyCallbackIDSelector_callback_get, _swigfaiss.PyCallbackIDSelector_callback_set)

    def __init__(self, callback):
        _swigfaiss.PyCallbackIDSelector_swiginit(self, _swigfaiss.new_PyCallbackIDSelector(callback))

    def is_member(self, id):
        return _swigfaiss.PyCallbackIDSelector_is_member(self, id)
    __swig_destroy__ = _swigfaiss.delete_PyCallbackIDSelector


_swigfaiss.PyCallbackIDSelector_swigregister(PyCallbackIDSelector)
class PyCallbackShardingFunction(ShardingFunction):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    callback = property(_swigfaiss.PyCallbackShardingFunction_callback_get, _swigfaiss.PyCallbackShardingFunction_callback_set)

    def __call__(self, i, shard_count):
        return _swigfaiss.PyCallbackShardingFunction___call__(self, i, shard_count)
    __swig_destroy__ = _swigfaiss.delete_PyCallbackShardingFunction

    def __init__(self, *args):
        _swigfaiss.PyCallbackShardingFunction_swiginit(self, _swigfaiss.new_PyCallbackShardingFunction(*args))


_swigfaiss.PyCallbackShardingFunction_swigregister(PyCallbackShardingFunction)
class float_minheap_array_t(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nh = property(_swigfaiss.float_minheap_array_t_nh_get, _swigfaiss.float_minheap_array_t_nh_set, doc=r)
    k = property(_swigfaiss.float_minheap_array_t_k_get, _swigfaiss.float_minheap_array_t_k_set, doc=r)
    ids = property(_swigfaiss.float_minheap_array_t_ids_get, _swigfaiss.float_minheap_array_t_ids_set, doc=r)
    val = property(_swigfaiss.float_minheap_array_t_val_get, _swigfaiss.float_minheap_array_t_val_set, doc=r)

    def get_val(self, key):
        r
        return _swigfaiss.float_minheap_array_t_get_val(self, key)

    def get_ids(self, key):
        r
        return _swigfaiss.float_minheap_array_t_get_ids(self, key)

    def heapify(self):
        r
        return _swigfaiss.float_minheap_array_t_heapify(self)

    def addn(self, nj, vin, j0=0, i0=0, ni=-1):
        r
        return _swigfaiss.float_minheap_array_t_addn(self, nj, vin, j0, i0, ni)

    def addn_with_ids(self, nj, vin, id_in=None, id_stride=0, i0=0, ni=-1):
        r
        return _swigfaiss.float_minheap_array_t_addn_with_ids(self, nj, vin, id_in, id_stride, i0, ni)

    def addn_query_subset_with_ids(self, nsubset, subset, nj, vin, id_in=None, id_stride=0):
        r
        return _swigfaiss.float_minheap_array_t_addn_query_subset_with_ids(self, nsubset, subset, nj, vin, id_in, id_stride)

    def reorder(self):
        r
        return _swigfaiss.float_minheap_array_t_reorder(self)

    def per_line_extrema(self, vals_out, idx_out):
        r
        return _swigfaiss.float_minheap_array_t_per_line_extrema(self, vals_out, idx_out)

    def __init__(self):
        _swigfaiss.float_minheap_array_t_swiginit(self, _swigfaiss.new_float_minheap_array_t())
    __swig_destroy__ = _swigfaiss.delete_float_minheap_array_t


_swigfaiss.float_minheap_array_t_swigregister(float_minheap_array_t)
class int_minheap_array_t(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nh = property(_swigfaiss.int_minheap_array_t_nh_get, _swigfaiss.int_minheap_array_t_nh_set, doc=r)
    k = property(_swigfaiss.int_minheap_array_t_k_get, _swigfaiss.int_minheap_array_t_k_set, doc=r)
    ids = property(_swigfaiss.int_minheap_array_t_ids_get, _swigfaiss.int_minheap_array_t_ids_set, doc=r)
    val = property(_swigfaiss.int_minheap_array_t_val_get, _swigfaiss.int_minheap_array_t_val_set, doc=r)

    def get_val(self, key):
        r
        return _swigfaiss.int_minheap_array_t_get_val(self, key)

    def get_ids(self, key):
        r
        return _swigfaiss.int_minheap_array_t_get_ids(self, key)

    def heapify(self):
        r
        return _swigfaiss.int_minheap_array_t_heapify(self)

    def addn(self, nj, vin, j0=0, i0=0, ni=-1):
        r
        return _swigfaiss.int_minheap_array_t_addn(self, nj, vin, j0, i0, ni)

    def addn_with_ids(self, nj, vin, id_in=None, id_stride=0, i0=0, ni=-1):
        r
        return _swigfaiss.int_minheap_array_t_addn_with_ids(self, nj, vin, id_in, id_stride, i0, ni)

    def addn_query_subset_with_ids(self, nsubset, subset, nj, vin, id_in=None, id_stride=0):
        r
        return _swigfaiss.int_minheap_array_t_addn_query_subset_with_ids(self, nsubset, subset, nj, vin, id_in, id_stride)

    def reorder(self):
        r
        return _swigfaiss.int_minheap_array_t_reorder(self)

    def per_line_extrema(self, vals_out, idx_out):
        r
        return _swigfaiss.int_minheap_array_t_per_line_extrema(self, vals_out, idx_out)

    def __init__(self):
        _swigfaiss.int_minheap_array_t_swiginit(self, _swigfaiss.new_int_minheap_array_t())
    __swig_destroy__ = _swigfaiss.delete_int_minheap_array_t


_swigfaiss.int_minheap_array_t_swigregister(int_minheap_array_t)
class float_maxheap_array_t(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nh = property(_swigfaiss.float_maxheap_array_t_nh_get, _swigfaiss.float_maxheap_array_t_nh_set, doc=r)
    k = property(_swigfaiss.float_maxheap_array_t_k_get, _swigfaiss.float_maxheap_array_t_k_set, doc=r)
    ids = property(_swigfaiss.float_maxheap_array_t_ids_get, _swigfaiss.float_maxheap_array_t_ids_set, doc=r)
    val = property(_swigfaiss.float_maxheap_array_t_val_get, _swigfaiss.float_maxheap_array_t_val_set, doc=r)

    def get_val(self, key):
        r
        return _swigfaiss.float_maxheap_array_t_get_val(self, key)

    def get_ids(self, key):
        r
        return _swigfaiss.float_maxheap_array_t_get_ids(self, key)

    def heapify(self):
        r
        return _swigfaiss.float_maxheap_array_t_heapify(self)

    def addn(self, nj, vin, j0=0, i0=0, ni=-1):
        r
        return _swigfaiss.float_maxheap_array_t_addn(self, nj, vin, j0, i0, ni)

    def addn_with_ids(self, nj, vin, id_in=None, id_stride=0, i0=0, ni=-1):
        r
        return _swigfaiss.float_maxheap_array_t_addn_with_ids(self, nj, vin, id_in, id_stride, i0, ni)

    def addn_query_subset_with_ids(self, nsubset, subset, nj, vin, id_in=None, id_stride=0):
        r
        return _swigfaiss.float_maxheap_array_t_addn_query_subset_with_ids(self, nsubset, subset, nj, vin, id_in, id_stride)

    def reorder(self):
        r
        return _swigfaiss.float_maxheap_array_t_reorder(self)

    def per_line_extrema(self, vals_out, idx_out):
        r
        return _swigfaiss.float_maxheap_array_t_per_line_extrema(self, vals_out, idx_out)

    def __init__(self):
        _swigfaiss.float_maxheap_array_t_swiginit(self, _swigfaiss.new_float_maxheap_array_t())
    __swig_destroy__ = _swigfaiss.delete_float_maxheap_array_t


_swigfaiss.float_maxheap_array_t_swigregister(float_maxheap_array_t)
class int_maxheap_array_t(object):
    r

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nh = property(_swigfaiss.int_maxheap_array_t_nh_get, _swigfaiss.int_maxheap_array_t_nh_set, doc=r)
    k = property(_swigfaiss.int_maxheap_array_t_k_get, _swigfaiss.int_maxheap_array_t_k_set, doc=r)
    ids = property(_swigfaiss.int_maxheap_array_t_ids_get, _swigfaiss.int_maxheap_array_t_ids_set, doc=r)
    val = property(_swigfaiss.int_maxheap_array_t_val_get, _swigfaiss.int_maxheap_array_t_val_set, doc=r)

    def get_val(self, key):
        r
        return _swigfaiss.int_maxheap_array_t_get_val(self, key)

    def get_ids(self, key):
        r
        return _swigfaiss.int_maxheap_array_t_get_ids(self, key)

    def heapify(self):
        r
        return _swigfaiss.int_maxheap_array_t_heapify(self)

    def addn(self, nj, vin, j0=0, i0=0, ni=-1):
        r
        return _swigfaiss.int_maxheap_array_t_addn(self, nj, vin, j0, i0, ni)

    def addn_with_ids(self, nj, vin, id_in=None, id_stride=0, i0=0, ni=-1):
        r
        return _swigfaiss.int_maxheap_array_t_addn_with_ids(self, nj, vin, id_in, id_stride, i0, ni)

    def addn_query_subset_with_ids(self, nsubset, subset, nj, vin, id_in=None, id_stride=0):
        r
        return _swigfaiss.int_maxheap_array_t_addn_query_subset_with_ids(self, nsubset, subset, nj, vin, id_in, id_stride)

    def reorder(self):
        r
        return _swigfaiss.int_maxheap_array_t_reorder(self)

    def per_line_extrema(self, vals_out, idx_out):
        r
        return _swigfaiss.int_maxheap_array_t_per_line_extrema(self, vals_out, idx_out)

    def __init__(self):
        _swigfaiss.int_maxheap_array_t_swiginit(self, _swigfaiss.new_int_maxheap_array_t())
    __swig_destroy__ = _swigfaiss.delete_int_maxheap_array_t


_swigfaiss.int_maxheap_array_t_swigregister(int_maxheap_array_t)

def CMin_float_partition_fuzzy(vals, ids, n, q_min, q_max, q_out):
    r
    return _swigfaiss.CMin_float_partition_fuzzy(vals, ids, n, q_min, q_max, q_out)

def CMax_float_partition_fuzzy(vals, ids, n, q_min, q_max, q_out):
    r
    return _swigfaiss.CMax_float_partition_fuzzy(vals, ids, n, q_min, q_max, q_out)
class AlignedTableUint8(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    tab = property(_swigfaiss.AlignedTableUint8_tab_get, _swigfaiss.AlignedTableUint8_tab_set)
    numel = property(_swigfaiss.AlignedTableUint8_numel_get, _swigfaiss.AlignedTableUint8_numel_set)

    @staticmethod
    def round_capacity(n):
        return _swigfaiss.AlignedTableUint8_round_capacity(n)

    def __init__(self, *args):
        _swigfaiss.AlignedTableUint8_swiginit(self, _swigfaiss.new_AlignedTableUint8(*args))

    def itemsize(self):
        return _swigfaiss.AlignedTableUint8_itemsize(self)

    def resize(self, n):
        return _swigfaiss.AlignedTableUint8_resize(self, n)

    def clear(self):
        return _swigfaiss.AlignedTableUint8_clear(self)

    def size(self):
        return _swigfaiss.AlignedTableUint8_size(self)

    def nbytes(self):
        return _swigfaiss.AlignedTableUint8_nbytes(self)

    def get(self, *args):
        return _swigfaiss.AlignedTableUint8_get(self, *args)

    def data(self, *args):
        return _swigfaiss.AlignedTableUint8_data(self, *args)
    __swig_destroy__ = _swigfaiss.delete_AlignedTableUint8


_swigfaiss.AlignedTableUint8_swigregister(AlignedTableUint8)
class AlignedTableUint16(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    tab = property(_swigfaiss.AlignedTableUint16_tab_get, _swigfaiss.AlignedTableUint16_tab_set)
    numel = property(_swigfaiss.AlignedTableUint16_numel_get, _swigfaiss.AlignedTableUint16_numel_set)

    @staticmethod
    def round_capacity(n):
        return _swigfaiss.AlignedTableUint16_round_capacity(n)

    def __init__(self, *args):
        _swigfaiss.AlignedTableUint16_swiginit(self, _swigfaiss.new_AlignedTableUint16(*args))

    def itemsize(self):
        return _swigfaiss.AlignedTableUint16_itemsize(self)

    def resize(self, n):
        return _swigfaiss.AlignedTableUint16_resize(self, n)

    def clear(self):
        return _swigfaiss.AlignedTableUint16_clear(self)

    def size(self):
        return _swigfaiss.AlignedTableUint16_size(self)

    def nbytes(self):
        return _swigfaiss.AlignedTableUint16_nbytes(self)

    def get(self, *args):
        return _swigfaiss.AlignedTableUint16_get(self, *args)

    def data(self, *args):
        return _swigfaiss.AlignedTableUint16_data(self, *args)
    __swig_destroy__ = _swigfaiss.delete_AlignedTableUint16


_swigfaiss.AlignedTableUint16_swigregister(AlignedTableUint16)
class AlignedTableFloat32(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    tab = property(_swigfaiss.AlignedTableFloat32_tab_get, _swigfaiss.AlignedTableFloat32_tab_set)
    numel = property(_swigfaiss.AlignedTableFloat32_numel_get, _swigfaiss.AlignedTableFloat32_numel_set)

    @staticmethod
    def round_capacity(n):
        return _swigfaiss.AlignedTableFloat32_round_capacity(n)

    def __init__(self, *args):
        _swigfaiss.AlignedTableFloat32_swiginit(self, _swigfaiss.new_AlignedTableFloat32(*args))

    def itemsize(self):
        return _swigfaiss.AlignedTableFloat32_itemsize(self)

    def resize(self, n):
        return _swigfaiss.AlignedTableFloat32_resize(self, n)

    def clear(self):
        return _swigfaiss.AlignedTableFloat32_clear(self)

    def size(self):
        return _swigfaiss.AlignedTableFloat32_size(self)

    def nbytes(self):
        return _swigfaiss.AlignedTableFloat32_nbytes(self)

    def get(self, *args):
        return _swigfaiss.AlignedTableFloat32_get(self, *args)

    def data(self, *args):
        return _swigfaiss.AlignedTableFloat32_data(self, *args)
    __swig_destroy__ = _swigfaiss.delete_AlignedTableFloat32


_swigfaiss.AlignedTableFloat32_swigregister(AlignedTableFloat32)
class MaybeOwnedVectorUInt8(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_owned = property(_swigfaiss.MaybeOwnedVectorUInt8_is_owned_get, _swigfaiss.MaybeOwnedVectorUInt8_is_owned_set)
    owned_data = property(_swigfaiss.MaybeOwnedVectorUInt8_owned_data_get, _swigfaiss.MaybeOwnedVectorUInt8_owned_data_set)
    view_data = property(_swigfaiss.MaybeOwnedVectorUInt8_view_data_get, _swigfaiss.MaybeOwnedVectorUInt8_view_data_set)
    view_size = property(_swigfaiss.MaybeOwnedVectorUInt8_view_size_get, _swigfaiss.MaybeOwnedVectorUInt8_view_size_set)
    owner = property(_swigfaiss.MaybeOwnedVectorUInt8_owner_get, _swigfaiss.MaybeOwnedVectorUInt8_owner_set)
    c_ptr = property(_swigfaiss.MaybeOwnedVectorUInt8_c_ptr_get, _swigfaiss.MaybeOwnedVectorUInt8_c_ptr_set)
    c_size = property(_swigfaiss.MaybeOwnedVectorUInt8_c_size_get, _swigfaiss.MaybeOwnedVectorUInt8_c_size_set)

    def __init__(self, *args):
        _swigfaiss.MaybeOwnedVectorUInt8_swiginit(self, _swigfaiss.new_MaybeOwnedVectorUInt8(*args))

    @staticmethod
    def create_view(address, n_elements, owner):
        return _swigfaiss.MaybeOwnedVectorUInt8_create_view(address, n_elements, owner)

    def data(self, *args):
        return _swigfaiss.MaybeOwnedVectorUInt8_data(self, *args)

    def size(self):
        return _swigfaiss.MaybeOwnedVectorUInt8_size(self)

    def byte_size(self):
        return _swigfaiss.MaybeOwnedVectorUInt8_byte_size(self)

    def at(self, *args):
        return _swigfaiss.MaybeOwnedVectorUInt8_at(self, *args)

    def begin(self, *args):
        return _swigfaiss.MaybeOwnedVectorUInt8_begin(self, *args)

    def end(self, *args):
        return _swigfaiss.MaybeOwnedVectorUInt8_end(self, *args)

    def erase(self, begin, end):
        return _swigfaiss.MaybeOwnedVectorUInt8_erase(self, begin, end)

    def clear(self):
        return _swigfaiss.MaybeOwnedVectorUInt8_clear(self)

    def resize(self, *args):
        return _swigfaiss.MaybeOwnedVectorUInt8_resize(self, *args)
    __swig_destroy__ = _swigfaiss.delete_MaybeOwnedVectorUInt8


_swigfaiss.MaybeOwnedVectorUInt8_swigregister(MaybeOwnedVectorUInt8)
class MaybeOwnedVectorInt32(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_owned = property(_swigfaiss.MaybeOwnedVectorInt32_is_owned_get, _swigfaiss.MaybeOwnedVectorInt32_is_owned_set)
    owned_data = property(_swigfaiss.MaybeOwnedVectorInt32_owned_data_get, _swigfaiss.MaybeOwnedVectorInt32_owned_data_set)
    view_data = property(_swigfaiss.MaybeOwnedVectorInt32_view_data_get, _swigfaiss.MaybeOwnedVectorInt32_view_data_set)
    view_size = property(_swigfaiss.MaybeOwnedVectorInt32_view_size_get, _swigfaiss.MaybeOwnedVectorInt32_view_size_set)
    owner = property(_swigfaiss.MaybeOwnedVectorInt32_owner_get, _swigfaiss.MaybeOwnedVectorInt32_owner_set)
    c_ptr = property(_swigfaiss.MaybeOwnedVectorInt32_c_ptr_get, _swigfaiss.MaybeOwnedVectorInt32_c_ptr_set)
    c_size = property(_swigfaiss.MaybeOwnedVectorInt32_c_size_get, _swigfaiss.MaybeOwnedVectorInt32_c_size_set)

    def __init__(self, *args):
        _swigfaiss.MaybeOwnedVectorInt32_swiginit(self, _swigfaiss.new_MaybeOwnedVectorInt32(*args))

    @staticmethod
    def create_view(address, n_elements, owner):
        return _swigfaiss.MaybeOwnedVectorInt32_create_view(address, n_elements, owner)

    def data(self, *args):
        return _swigfaiss.MaybeOwnedVectorInt32_data(self, *args)

    def size(self):
        return _swigfaiss.MaybeOwnedVectorInt32_size(self)

    def byte_size(self):
        return _swigfaiss.MaybeOwnedVectorInt32_byte_size(self)

    def at(self, *args):
        return _swigfaiss.MaybeOwnedVectorInt32_at(self, *args)

    def begin(self, *args):
        return _swigfaiss.MaybeOwnedVectorInt32_begin(self, *args)

    def end(self, *args):
        return _swigfaiss.MaybeOwnedVectorInt32_end(self, *args)

    def erase(self, begin, end):
        return _swigfaiss.MaybeOwnedVectorInt32_erase(self, begin, end)

    def clear(self):
        return _swigfaiss.MaybeOwnedVectorInt32_clear(self)

    def resize(self, *args):
        return _swigfaiss.MaybeOwnedVectorInt32_resize(self, *args)
    __swig_destroy__ = _swigfaiss.delete_MaybeOwnedVectorInt32


_swigfaiss.MaybeOwnedVectorInt32_swigregister(MaybeOwnedVectorInt32)
class MaybeOwnedVectorFloat32(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_owned = property(_swigfaiss.MaybeOwnedVectorFloat32_is_owned_get, _swigfaiss.MaybeOwnedVectorFloat32_is_owned_set)
    owned_data = property(_swigfaiss.MaybeOwnedVectorFloat32_owned_data_get, _swigfaiss.MaybeOwnedVectorFloat32_owned_data_set)
    view_data = property(_swigfaiss.MaybeOwnedVectorFloat32_view_data_get, _swigfaiss.MaybeOwnedVectorFloat32_view_data_set)
    view_size = property(_swigfaiss.MaybeOwnedVectorFloat32_view_size_get, _swigfaiss.MaybeOwnedVectorFloat32_view_size_set)
    owner = property(_swigfaiss.MaybeOwnedVectorFloat32_owner_get, _swigfaiss.MaybeOwnedVectorFloat32_owner_set)
    c_ptr = property(_swigfaiss.MaybeOwnedVectorFloat32_c_ptr_get, _swigfaiss.MaybeOwnedVectorFloat32_c_ptr_set)
    c_size = property(_swigfaiss.MaybeOwnedVectorFloat32_c_size_get, _swigfaiss.MaybeOwnedVectorFloat32_c_size_set)

    def __init__(self, *args):
        _swigfaiss.MaybeOwnedVectorFloat32_swiginit(self, _swigfaiss.new_MaybeOwnedVectorFloat32(*args))

    @staticmethod
    def create_view(address, n_elements, owner):
        return _swigfaiss.MaybeOwnedVectorFloat32_create_view(address, n_elements, owner)

    def data(self, *args):
        return _swigfaiss.MaybeOwnedVectorFloat32_data(self, *args)

    def size(self):
        return _swigfaiss.MaybeOwnedVectorFloat32_size(self)

    def byte_size(self):
        return _swigfaiss.MaybeOwnedVectorFloat32_byte_size(self)

    def at(self, *args):
        return _swigfaiss.MaybeOwnedVectorFloat32_at(self, *args)

    def begin(self, *args):
        return _swigfaiss.MaybeOwnedVectorFloat32_begin(self, *args)

    def end(self, *args):
        return _swigfaiss.MaybeOwnedVectorFloat32_end(self, *args)

    def erase(self, begin, end):
        return _swigfaiss.MaybeOwnedVectorFloat32_erase(self, begin, end)

    def clear(self):
        return _swigfaiss.MaybeOwnedVectorFloat32_clear(self)

    def resize(self, *args):
        return _swigfaiss.MaybeOwnedVectorFloat32_resize(self, *args)
    __swig_destroy__ = _swigfaiss.delete_MaybeOwnedVectorFloat32


_swigfaiss.MaybeOwnedVectorFloat32_swigregister(MaybeOwnedVectorFloat32)

def CMin_uint16_partition_fuzzy(*args):
    return _swigfaiss.CMin_uint16_partition_fuzzy(*args)

def CMax_uint16_partition_fuzzy(*args):
    return _swigfaiss.CMax_uint16_partition_fuzzy(*args)

def merge_knn_results_CMin(*args):
    return _swigfaiss.merge_knn_results_CMin(*args)

def merge_knn_results_CMax(*args):
    return _swigfaiss.merge_knn_results_CMax(*args)
class MapLong2Long(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    map = property(_swigfaiss.MapLong2Long_map_get, _swigfaiss.MapLong2Long_map_set)

    def add(self, n, keys, vals):
        return _swigfaiss.MapLong2Long_add(self, n, keys, vals)

    def search(self, key):
        return _swigfaiss.MapLong2Long_search(self, key)

    def search_multiple(self, n, keys, vals):
        return _swigfaiss.MapLong2Long_search_multiple(self, n, keys, vals)

    def __init__(self):
        _swigfaiss.MapLong2Long_swiginit(self, _swigfaiss.new_MapLong2Long())
    __swig_destroy__ = _swigfaiss.delete_MapLong2Long


_swigfaiss.MapLong2Long_swigregister(MapLong2Long)

def omp_set_num_threads(num_threads):
    return _swigfaiss.omp_set_num_threads(num_threads)

def omp_get_max_threads():
    return _swigfaiss.omp_get_max_threads()

def memcpy(dest, src, n):
    return _swigfaiss.memcpy(dest, src, n)
class PythonInterruptCallback(InterruptCallback):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def want_interrupt(self):
        return _swigfaiss.PythonInterruptCallback_want_interrupt(self)

    @staticmethod
    def reset():
        return _swigfaiss.PythonInterruptCallback_reset()

    def __init__(self):
        _swigfaiss.PythonInterruptCallback_swiginit(self, _swigfaiss.new_PythonInterruptCallback())
    __swig_destroy__ = _swigfaiss.delete_PythonInterruptCallback


_swigfaiss.PythonInterruptCallback_swigregister(PythonInterruptCallback)

def swig_ptr(a):
    return _swigfaiss.swig_ptr(a)

def rev_swig_ptr(*args):
    return _swigfaiss.rev_swig_ptr(*args)

def cast_integer_to_uint8_ptr(x):
    return _swigfaiss.cast_integer_to_uint8_ptr(x)

def cast_integer_to_float_ptr(x):
    return _swigfaiss.cast_integer_to_float_ptr(x)

def cast_integer_to_idx_t_ptr(x):
    return _swigfaiss.cast_integer_to_idx_t_ptr(x)

def cast_integer_to_int_ptr(x):
    return _swigfaiss.cast_integer_to_int_ptr(x)

def cast_integer_to_void_ptr(x):
    return _swigfaiss.cast_integer_to_void_ptr(x)

def swig_version():
    return _swigfaiss.swig_version()

