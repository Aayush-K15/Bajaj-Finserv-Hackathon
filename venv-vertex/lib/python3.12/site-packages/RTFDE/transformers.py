














from typing import Union, List, Tuple
from typing import TypedDict

from collections.abc import Generator

from lark.visitors import Transformer
from lark.visitors import v_args, Discard
from lark.tree import Tree
from lark.lexer import Token
import re

from RTFDE.utils import log_htmlrtf_stripping, is_logger_on

import logging
log = logging.getLogger("RTFDE")

class StripNonVisibleRTFGroups(Transformer):
    

    @v_args(tree=True)
    def group(self, tree: Tree):
        
        children = tree.children
        if len(children) == 0:
            return b""
        first_child = children[0]

        known_control_groups = ["htmltag_group"]
        if isinstance(first_child, Tree):
            if first_child.data in known_control_groups:
                return tree
        known_non_visible_control_groups = ["mhtmltag_group"]
        if isinstance(first_child, Tree):
            if first_child.data in known_non_visible_control_groups:
                
                return b""

        
        non_visible_control_words = [b"\\context", b"\\colortbl", b"\\fonttbl"]
        first_control = self.get_first_controlword(children)
        
        if first_control in non_visible_control_words:
            return b""

        
        
        
        understood_commands: List[str] = []
        is_star_escaped = None
        if (isinstance(first_child, Tree) and
             len(first_child.children) != 0 ):
            first_item = first_child.children[0]
            if isinstance(first_item, Token):
                if first_item.type == "STAR_ESCAPE":
                    is_star_escaped = True
        control_word = None
        if is_star_escaped is True:
            
            first_token = children[1]
            if isinstance(first_token, Token):
                if first_token.type == "CONTROLWORD":
                    control_word = first_token
                    if control_word.value in understood_commands:
                        return tree
                    return b""
        return tree

    @staticmethod
    def get_first_controlword(children: List) -> Union[str,None]:
        
        for i in children:
            try:
                if i.type == "CONTROLWORD":
                    return i.value
            except AttributeError:
                continue
        return None

class RTFCleaner(Transformer):
    

    def start(self, args: List) -> bytes:
        
        return b"".join(args)

    def STRING(self, string: Token) -> bytes:
        
        if string.value is not None:
            return string.value
        return b""

    def SPACE_SAVE(self, string: Token) -> bytes:
        return string.value

    def string(self, strings: List) -> bytes:
        
        
        return b"".join(strings)

    def group(self, grp: List) -> bytes:
        
        _new_children = []
        for i in grp:
            if isinstance(i, type(Discard)):
                pass
            else:
                _new_children.append(i)
        return b"".join(_new_children)

    def document(self, args: List) -> bytes:
        
        args = [i for i in args if i is not None]
        return b"".join(args)

    def OPENPAREN(self, args: Token) -> bytes:
        
        return b""

    def CLOSEPAREN(self, args: Token) -> bytes:
        
        return b""

    def mhtmltag_group(self, args: List):
        
        return Discard

    def htmltag_group(self, strings: List) -> bytes:
        
        return b"".join(strings)

    def HTMLTAG(self, htmltag: Token) -> bytes:
        
        return b""

    def STAR_ESCAPE(self, char: Token) -> bytes:
        
        
        return b""

    def control_symbol(self, symbols: List) -> bytes:
        
        return b"".join(symbols)

    def NONBREAKING_SPACE(self, args: Token) -> bytes:
        
        
        return u'\u00A0'.encode()

    def NONBREAKING_HYPHEN(self, args: Token) -> bytes:
        
        
        return u'\u00AD'.encode()

    def OPTIONAL_HYPHEN(self, args: Token) -> bytes:
        
        
        return u'\u2027'.encode()

    def FORMULA_CHARACTER(self, args: Token) -> bytes:
        
        return b""

    def INDEX_SUBENTRY(self, args: Token) -> bytes:
        
        return b""

    def CONTROLSYMBOL(self, args: Token) -> bytes:
        
        symbols = {
            b'\\{': b'\x7B',
            b'\\}': b'\x7D',
            b'\\\\': b'\x5C',
        }
        replacement = symbols.get(args.value, None)
        
        if replacement is not None:
            return replacement
        return b""

    def CONTROLWORD(self, args: Token) -> bytes:
        
        words = {
            b'\\par': b'\n',
            b'\\tab': b'\t',
            b'\\line': b'\n',
            b'\\lquote': b'\u2018',
            b'\\rquote': b'\u2019',
            b'\\ldblquote': b'\u201C',
            b'\\rdblquote': b'\u201D',
            b'\\bullet': b'\u2022',
            b'\\endash': b'\u2013',
            b'\\emdash': b'\u2014'
        }
        replacement = words.get(args.value, None)
        
        if replacement is not None:
            return replacement
        return b""

def get_stripped_HTMLRTF_values(tree: Tree, current_state: Union[bool,None] = None) -> Generator:
    
    if current_state is None:
        htmlrtf_stack = [False]
    else:
        htmlrtf_stack = [current_state]
    for child in tree.children:
        is_htmlrtf = None
        if isinstance(child, Tree):
            
            for toggle in get_stripped_HTMLRTF_values(child, htmlrtf_stack[-1]):
                yield toggle
        else:
            is_htmlrtf = toggle_htmlrtf(child)
            if is_htmlrtf is not None:
                htmlrtf_stack.append(is_htmlrtf)
                yield child
            elif htmlrtf_stack[-1] is True:
                yield child

def toggle_htmlrtf(child: Union[Token,str]) -> Union[bool,None]:
    
    if isinstance(child, Token):
        if child.type == "HTMLRTF":
            htmlrtfstr = child.value.decode().strip()
            if (len(htmlrtfstr) > 0 and htmlrtfstr[-1] == "0"):
                return False
            return True
    return None

class DeleteTokensFromTree(Transformer):
    

    def __init__(self, tokens_to_delete: List[Token]):
        
        super().__init__()
        self.to_delete = tokens_to_delete
        self.delete_start_pos = {i.start_pos for i in self.to_delete}

    def __default_token__(self, token: Token):
        
        
        if isinstance(token, Token):
            if token.start_pos in self.delete_start_pos:
                for i in self.to_delete:
                    if (i.start_pos == token.start_pos and
                        i.end_pos == token.end_pos and
                        i.value == token.value):
                        if is_logger_on("RTFDE.HTMLRTF_Stripping_logger") is True:
                            log_htmlrtf_stripping(i)
                        
                        return Discard
        return token

class StripUnusedSpecialCharacters(Transformer):
    

    def _LBRACE(self, token: Token):
        
        return Discard

    def _RBRACE(self, token: Token):
        
        return Discard

    def _SPACE_DELETE(self, token: Token):
        
        return Discard


class StripControlWords(Transformer):
    

    def CONTROLWORD(self, token: Token):
        
        tok = token.update(value=token.value.strip())
        return tok


def strip_binary_objects(raw_rtf: bytes) -> tuple:
    
    found_bytes = []
    byte_finder = rb'(\\bin)([0-9]+)[ ]?'
    for matchitem in re.finditer(byte_finder, raw_rtf):
        param = int(matchitem[2])
        bin_start_pos = matchitem.span()[-1]
        byte_obj = {"bytes": raw_rtf[bin_start_pos:bin_start_pos+param],
                    "ctrl_char": matchitem.groups(),
                    "start_pos": matchitem.span()[0],
                    "end_pos": bin_start_pos+param,
                    "bin_start_pos": bin_start_pos
                    }
        
        found_bytes.append(byte_obj)
    new_raw = b''
    start_buffer = 0
    for new_bytes in found_bytes:
        new_raw += raw_rtf[start_buffer:new_bytes["start_pos"]]
        start_buffer = new_bytes["end_pos"]
    new_raw += raw_rtf[start_buffer:]
    return (new_raw, found_bytes)
