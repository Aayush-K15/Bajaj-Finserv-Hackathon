













from typing import Union, AnyStr, Tuple, Dict, Any
from io import BufferedReader

from lark import Lark
from lark.tree import Tree
from lark.lexer import Token
from lark.exceptions import UnexpectedInput

from RTFDE.transformers import RTFCleaner, StripControlWords
from RTFDE.transformers import StripNonVisibleRTFGroups
from RTFDE.transformers import StripUnusedSpecialCharacters
from RTFDE.utils import encode_escaped_control_chars
from RTFDE.utils import log_validators, log_transformations, is_logger_on
from RTFDE.transformers import get_stripped_HTMLRTF_values, DeleteTokensFromTree, strip_binary_objects
from RTFDE.grammar import make_concise_grammar
from RTFDE.text_extraction import TextDecoder
from RTFDE.text_extraction import validate_ansi_cpg


from RTFDE.exceptions import NotEncapsulatedRtf, MalformedEncapsulatedRtf, MalformedRtf

import logging
log = logging.getLogger("RTFDE")

class DeEncapsulator():
    

    def __init__(self, raw_rtf:bytes, grammar: Union[str,None] = None):
        
        self.content: str
        self.content_type: str
        self.content_type_token: str
        self.parser: Any

        self.html: str
        self.text: str
        self.found_binary: list
        self.full_tree: Tree
        self.doc_tree: Tree
        self.catch_common_validation_issues(raw_rtf)
        if isinstance(raw_rtf, bytes):
            raw_rtf_bytes = raw_rtf
        else:
            raise TypeError("DeEncapssulator only accepts RTF files in string or byte-string formats")
        raw_rtf_bytes = raw_rtf_bytes.rstrip(b'\x00')
        raw_rtf_bytes = raw_rtf_bytes.replace(b'\r\n',b'\n')
        raw_rtf_bytes = raw_rtf_bytes.replace(b'\r',b'\n')
        self.raw_rtf: bytes = raw_rtf_bytes
        if grammar is not None:
            self.grammar: str = grammar
        else:
            self.grammar = make_concise_grammar()

    def deencapsulate(self):
        
        stripped_data = strip_binary_objects(self.raw_rtf)
        non_binary_rtf = stripped_data[0]
        found_binary = stripped_data[1]
        if len(found_binary) > 0:
            self.found_binary = found_binary
            log.info("Binary data found and extracted from rtf file.")
        escaped_rtf = encode_escaped_control_chars(non_binary_rtf)
        if is_logger_on("RTFDE.transform_logger") is True:
            log_transformations(escaped_rtf)
        try:
            self.parse_rtf(escaped_rtf)
        except UnexpectedInput as _e:
            raise MalformedEncapsulatedRtf(f"Malformed encapsulated RTF discovered:") from _e
        Decoder = TextDecoder()
        Decoder.update_children(self.full_tree)
        self.get_doc_tree()
        self.validate_encapsulation()

        
        htmlrtf_stripped = self.strip_htmlrtf_tokens()
        
        control_stripped = StripControlWords().transform(htmlrtf_stripped)
        
        special_stripper = StripUnusedSpecialCharacters()
        non_special_tree = special_stripper.transform(control_stripped)
        
        stripper = StripNonVisibleRTFGroups()
        stripped_tree = stripper.transform(non_special_tree)
        
        cleaner = RTFCleaner(visit_tokens=True)
        cleaned_text = cleaner.transform(stripped_tree)

        self.content = cleaned_text
        self.set_content() 

    def validate_charset(self, fallback_to_default:bool =False) -> bytes:
        
        main_headers = self.get_header_control_words_before_first_group()

        for token in main_headers:
            if token.value in [b'\\ansi', b'\\mac', b'\\pc', b'\\pca']:
                return token

        log.debug("Acceptable charset not found as the second token in the RTF stream. The control word for the character set must precede any plain text or any table control words. So, if this stream doesn't have one it is malformed or corrupted.")
        if fallback_to_default is False:
            raise MalformedRtf("RTF stream does not include charset control word.")

        log.warning("The fallback_to_default option on _get_charset is considered DANGEROUS if used on possibly malicious samples. Make sure you know what you are doing before using it.")
        log.info("Attempting to decode RTF using the default charset ansi. This is not recommended and could have unforeseen consequences for the resulting file and your systems security.")
        log.debug("You have a malformed RTF stream. Are you sure you really want to be parsing it? It might not just be corrupted. It could be maliciously constructed.")
        return b"\\ansi"

    def set_content(self):
        
        self.content_type = self.get_content_type()
        if self.content_type == 'html':
            self.html = self.content
        else:
            self.text = self.content

    def get_doc_tree(self):
        
        if self.full_tree.children[1].data == "document":
            self.doc_tree = self.full_tree.children[1]
        else:
            raise ValueError("Document object in the wrong place after parsing.")

    def get_content_type(self):
        
        if self.content_type_token is None:
            self.validate_FROM_in_doc_header()
        elif self.content_type_token == b'\\fromhtml1':
            return 'html'
        elif self.content_type_token == b'\\fromtext':
            return "text"

        raise NotEncapsulatedRtf("Data is missing encapsulated content type header (the FROM header).")

    def validate_encapsulation(self):
        
        self.validate_rtf_doc_header(self.doc_tree)
        self.validate_charset()
        self.validate_FROM_in_doc_header()
        ansicpg = self.get_ansicpg_header()
        if ansicpg is not None: 
            validate_ansi_cpg(ansicpg.value)

    def get_ansicpg_header(self) -> Union[Token,None]:
        
        headers = self.get_header_control_words_before_first_group()
        for item in headers:
            if item.value.startswith(b'\\ansicpg'):
                return item
        return None

    def parse_rtf(self, rtf: str):
        
        
        
        
        self.parser = Lark(self.grammar,
                           parser='lalr',
                           keep_all_tokens=True,
                           use_bytes=True,
                           
                           propagate_positions=True)
        self.full_tree = self.parser.parse(rtf)
        if is_logger_on("RTFDE.transform_logger") is True:
            log_transformations(self.full_tree)


    def strip_htmlrtf_tokens(self) -> Tree:
        
        
        delete_generator = get_stripped_HTMLRTF_values(self.doc_tree)
        tokens_to_delete = list(delete_generator)
        deleter = DeleteTokensFromTree(tokens_to_delete)
        htmlrtf_cleaned_tree = deleter.transform(self.doc_tree)
        return htmlrtf_cleaned_tree


    def get_header_control_words_before_first_group(self) -> list:
        
        initial_control_words = []
        for token in self.doc_tree.children[:20]:
            if isinstance(token, Token):
                initial_control_words.append(token)
            else:
                return initial_control_words
        return initial_control_words


    def validate_FROM_in_doc_header(self):
        
        cw_found = {"rtf1":False,
                    "from":False,
                    "fonttbl":False,
                    "malformed":False}
        
        decoded_tree = StripControlWords().transform(self.doc_tree)
        first_ten_tokens = decoded_tree.children[:10]
        operating_tokens = []
        found_token = None
        for token in first_ten_tokens:
            if isinstance(token, Token):
                operating_tokens.append(token)
            else:
                operating_tokens += list(token.scan_values(lambda t: t.type == 'CONTROLWORD'))
        if is_logger_on("RTFDE.validation_logger") is True:
            log_validators(f"Header tokens being evaluated: {operating_tokens}")

        for token in operating_tokens:
            cw_found,found_token = self.check_from_token(token=token, cw_found=cw_found)
            if cw_found['from'] is True and cw_found["malformed"] is True:
                raise MalformedEncapsulatedRtf("RTF file looks like is was supposed to be encapsulated HTML/TEXT but the headers are malformed. Turn on debugging to see specific information")
            
            if found_token is not None:
                self.content_type_token = found_token

        if cw_found['from'] is False:
            log.debug("FROMHTML/TEXT control word not found in first 10 RTF tokens. This is not an HTML/TEXT encapsulated RTF document.")
            raise NotEncapsulatedRtf("FROMHTML/TEXT control word not found.")

    @staticmethod
    def check_from_token(token:Token, cw_found:dict) -> Tuple[Dict,Union[None,str]] :
        
        from_cws = [b'\\fromhtml1', b'\\fromtext']
        
        rtf1_cw = b"\\rtf1"
        found_token = None
        fonttbl_cw = b"\\fonttbl"
        if token.type == "CONTROLWORD":
            if token.value.strip() in from_cws:
                if cw_found['from'] is True:
                    cw_found["malformed"] = True
                    log.debug("Multiple FROM HTML/TXT tokens found in the header. This encapsulated RTF is malformed.")
                if cw_found['rtf1'] is True:
                    cw_found['from'] = True
                    found_token = token.value
                else:
                    log.debug("FROMHTML/TEXT control word found before rtf1 control word. That's not allowed in the RTF spec.")
                    cw_found['from'] = True
                    cw_found["malformed"] = True
            elif token.value.strip() == rtf1_cw:
                cw_found['rtf1'] = True
            elif token.value.strip() == fonttbl_cw:
                cw_found['fonttbl'] = True
                if cw_found['from'] is not True:
                    log.debug("\\fonttbl code word found before FROMTML/TEXT was defined. This is not allowed for encapsulated HTML/TEXT. So... this is not encapsulated HTML/TEXT or it was badly encapsulated.")
                    cw_found["malformed"] = True
        return cw_found, found_token


    @staticmethod
    def validate_rtf_doc_header(doc_tree: Tree):
        
        first_token = doc_tree.children[0].value
        if first_token != b"\\rtf1":
            log.debug("RTF stream does not contain valid valid RTF document heading. The file must start with \"{\\rtf1\"")
            if is_logger_on("RTFDE.validation_logger") is True:
                log_validators(f"First child object in document tree is: {first_token!r}")
            raise MalformedRtf("RTF stream does not start with {\\rtf1")

    @staticmethod
    def catch_common_validation_issues(raw_rtf: AnyStr):
        
        if isinstance(raw_rtf, BufferedReader):
            raise TypeError("Data passed as file pointer. DeEncapsulator only accepts byte objects.")
        if raw_rtf is None:
            raise TypeError("Data passed as raw RTF file is a null object `None` keyword.")
        if raw_rtf[:8] == b"\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1":
            raise TypeError("Data passed is a full MSG object. You must extract the encapsulated RTF body first.")
        if raw_rtf in (b'', ''):
            raise MalformedRtf("Data passed as raw RTF file is an empty string.")
