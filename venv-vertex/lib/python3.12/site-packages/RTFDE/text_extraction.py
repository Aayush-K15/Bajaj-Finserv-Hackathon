













import codecs
import re
from collections import namedtuple
from typing import Union, Any, List, Tuple, Dict

from oletools.common import codepages

from lark.lexer import Token
from lark.tree import Tree

from RTFDE.exceptions import MalformedRtf
from RTFDE.utils import is_codeword_with_numeric_arg
from RTFDE.utils import flatten_tree_to_string_array
from RTFDE.utils import log_text_extraction, is_logger_on

import logging
log = logging.getLogger("RTFDE")

fontdef = namedtuple("fontdef", ["fnum", "codepage", "codec", "fontdef_tree"])


def get_font_table(tree: Tree) -> Tree:
    
    for item in tree.children[:20]:
        if isinstance(item, Tree):
            try:
                ctrl_value = item.children[1]
            except IndexError as _e:
                continue
            if isinstance(ctrl_value, Token):
                table_type = ctrl_value.value.strip()
                if table_type == b"\\fonttbl":
                    return item
    raise ValueError("No font table found in tree")


def is_font_number(token: Token) -> bool:
    
    try:
        if is_codeword_with_numeric_arg(token, b'\\f'):
            return True
    except AttributeError: 
        return False
    return False

def get_codepage_num_from_fcharset(fcharsetN: int) -> Union[int,None]:
    
    
    
    charsets: dict[int,dict[str,Any]] = {
        0:{"name":"ANSI_CHARSET","hex":"0x00","decimal":0,"id":1252},
        1:{"name":"DEFAULT_CHARSET","hex":"0x01","decimal":1,"id":None},
        2:{"name":"SYMBOL_CHARSET","hex":"0x02","decimal":2,"id":None},
        128:{"name":"SHIFTJIS_CHARSET","hex":"0x80","decimal":128,"id":932},
        129:{"name":"HANGUL_CHARSET","hex":"0x81","decimal":129,"id":949},
        134:{"name":"GB2312_CHARSET","hex":"0x86","decimal":134,"id":936},
        136:{"name":"CHINESEBIG5_CHARSET","hex":"0x88","decimal":136,"id":950},
        161:{"name":"GREEK_CHARSET","hex":"0xA1","decimal":161,"id":1253},
        162:{"name":"TURKISH_CHARSET","hex":"0xA2","decimal":162,"id":1254},
        177:{"name":"HEBREW_CHARSET","hex":"0xB1","decimal":177,"id":1255},
        178:{"name":"ARABIC_CHARSET","hex":"0xB2","decimal":178,"id":1256},
        186:{"name":"BALTIC_CHARSET","hex":"0xBA","decimal":186,"id":1257},
        204:{"name":"RUSSIAN_CHARSET","hex":"0xCC","decimal":204,"id":1251},
        222:{"name":"THAI_CHARSET","hex":"0xDE","decimal":222,"id":874},
        238:{"name":"EE_CHARSET","hex":"0xEE","decimal":238,"id":1250},
        255:{"name":"OEM_CHARSET","hex":"0xFF","decimal":255,"id":None},
}
    if is_logger_on("RTFDE.text_extraction") is True:
        log_text_extraction(f"Getting charset for {fcharsetN}")
    charset = charsets.get(fcharsetN, None)
    if charset is not None:
        charset_id = charset.get('id', None)
        return charset_id
    return None


def get_default_font(tree: Tree) -> Union[str,None]:
    
    deff_gen = tree.scan_values(
        lambda v: is_codeword_with_numeric_arg(v, b'\\deff')
    )
    deff_options = list(deff_gen)
    try:
        
        deff = deff_options[0]
        deff_num = deff.value[5:]
        return b'\\f' + deff_num
    except IndexError:
        return None

def parse_font_tree(font_tree: Tree) -> dict:
    
    parsed_font_tree = {}
    for tree in font_tree.children:
        if isinstance(tree, Tree):
            fnum = None
            fcharset = None
            cpg_num = None
            for tok in tree.children:
                if is_codeword_with_numeric_arg(tok, b'\\f'):
                    fnum = tok.value
                elif is_codeword_with_numeric_arg(tok, b'\\fcharset'):
                    fchar_num = int(tok.value[9:])
                    fcharset = get_codepage_num_from_fcharset(fchar_num)
                elif is_codeword_with_numeric_arg(tok, b'\\cpg'):
                    cpg_num = int(tok.value[4:])
            if fnum is not None:
                
                codepage_num = None

                if fcharset is not None:
                    try:
                        codepage_num = check_codepage_num(fcharset)
                    except ValueError: 
                        codepage_num = None
                
                if ((codepage_num is None) and (cpg_num is not None)):
                    try:
                        codepage_num = check_codepage_num(cpg_num)
                    except ValueError: 
                        codepage_num = None
                
                if codepage_num is not None:
                    codec = get_python_codec(codepage_num)
                else:
                    codec = None
                
                tree_str =  b"".join(list(flatten_tree_to_string_array(tree)))
                parsed_font_tree[fnum] = fontdef(fnum, codepage_num, codec, tree_str)
    return parsed_font_tree


def get_python_codec(codepage_num: int) -> str:
    
    text_codec = codepages.codepage2codec(codepage_num)
    log.debug('Found python codec corresponding to code page {0}: {1}'.format(codepage_num, text_codec))
    return text_codec

def check_codepage_num(codepage_num: int) -> int:
    
    
    
    
    allowed_codepage_nums = set([37, 437, 500, 708, 709, 710, 720, 737, 775, 850, 852, 855, 857, 858, 860, 861, 862, 863, 864, 865, 866, 869, 870, 874, 875, 932, 936, 949, 950, 1026, 1047, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1200, 1201, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1361, 10000, 10001, 10002, 10003, 10004, 10005, 10006, 10007, 10008, 10010, 10017, 10021, 10029, 10079, 10081, 10082, 12000, 12001, 20000, 20001, 20002, 20003, 20004, 20005, 20105, 20106, 20107, 20108, 20127, 20261, 20269, 20273, 20277, 20278, 20280, 20284, 20285, 20290, 20297, 20420, 20423, 20424, 20833, 20838, 20866, 20871, 20880, 20905, 20924, 20932, 20936, 20949, 21025, 21027, 21866, 28591, 28592, 28593, 28594, 28595, 28596, 28597, 28598, 28599, 28603, 28605, 29001, 38598, 50220, 50221, 50222, 50225, 50227, 50229, 50930, 50931, 50933, 50935, 50936, 50937, 50939, 51932, 51936, 51949, 51950, 52936, 54936, 57002, 57003, 57004, 57005, 57006, 57007, 57008, 57009, 57010, 57011, 65000, 65001])
    if codepage_num in allowed_codepage_nums:
        return codepage_num
    
    
    raise ValueError(f"Unsupported unicode codepage number `{codepage_num}` found in the header")


def validate_ansi_cpg(header: str) -> None:
    
    try:
        possible_cpg_num = int(header.strip()[8:])
        check_codepage_num(possible_cpg_num)
    except ValueError as _e:
        raise MalformedRtf(f"Unsupported unicode codepage number `{header}` found in the header") from _e



def unicode_escape_to_chr(item: bytes) -> str:
    
    try:
        prefix = b'\\u'
        if item.startswith(prefix):
            nnnn = item[len(prefix):]
        else:
            nnnn = item
        nnnn = int(nnnn) 
    except ValueError as _e:
        raise ValueError(f"`{item}` is not a valid escaped unicode character.") from _e
    if nnnn < 0: 
        ncr = 65536 + nnnn
    else: 
        ncr = nnnn
    
    return chr(ncr)

def is_hex_encoded(item: Token) -> bool:
    
    if isinstance(item, Token):
        if item.type == "HEXENCODED":
            return True
    return False

def is_valid_ANSI_representation_char(item: Token) -> bool:
    
    if isinstance(item, Token):
        
        if is_hex_encoded(item):
            
            return True
        if item.type == 'STRING':
            
            if not item.value.isspace(): 
                
                return True
            
            
    
    return False

def is_unicode_encoded(item: Token) -> bool:
    
    if isinstance(item, Token):
        if item.type == "UNICODE":
            return True
    return False

def includes_unicode_chars(children: List[Token]) -> bool:
    
    for child in children:
        if is_unicode_encoded(child):
            return True
    return False


def remove_unicode_replacements(children: List[Token],
                                return_ascii_map: bool = True,
                                byte_count: int = 1) -> Union[
                                    Tuple[List[Token], Dict[Token,List[Token]]],
                                    List[Token]]:
    
    byte_count = 1
    ascii_map: Dict[Token,List[Token]]  = {}
    new_children = []
    removal_map: List[Token] = []
    if is_logger_on("RTFDE.text_extraction") is True:
        log_text_extraction(f"Removing unicode replacements on {repr(children)}")
    for child in children:
        if len(removal_map) > 0:
            if isinstance(child, Token):
                
                
                if child.value.isspace():
                    ascii_map.setdefault(removal_map[0], []).append(child)
                    continue
            if is_valid_ANSI_representation_char(child):
                
                
                ascii_map.setdefault(removal_map.pop(), []).append(child)
                continue
            elif isinstance(child, Tree) and (
                    (child.data == "string") or (child.data == "hexarray")):
                
                ansi_children = child.children
                new_ansi_children = []
                for aci,ac in enumerate(ansi_children):
                    
                    if is_valid_ANSI_representation_char(ac):
                        
                        if len(removal_map) > 0:
                            
                            
                            ascii_map.setdefault(removal_map.pop(), []).append(ac)
                        else:
                            
                            new_ansi_children.append(ac)
                    else:
                        
                        new_ansi_children.append(ac)
                
                if new_ansi_children == []:
                    from RTFDE.utils import make_token_replacement
                    
                    
                    child = make_token_replacement("STRING", b"", child)
                else:
                    child.children = new_ansi_children
                
            
                
                
        
        if is_unicode_char_byte_count(child):
            byte_count = get_unicode_char_byte_count(child)
            
        if is_unicode_encoded(child):
            
            for j in range(byte_count):
                
                
                removal_map.append(child)
        new_children.append(child)
    if return_ascii_map is True:
        return new_children, ascii_map
    return new_children



def is_surrogate_high_char(item: bytes) -> bool:
    
    if item.startswith(b"\\u"):
        item = item[2:]
    if 0xD800 <= ord(chr(65536+int(item))) <= 0xDBFF:
        return True
    
    elif 0xD800 <= int(item) <= 0xDBFF:
        return True
    return False

def is_surrogate_low_char(item: bytes) -> bool:
    
    if item.startswith(b"\\u"):
        item = item[2:]
    if 0xDC00 <= ord(chr(65536+int(item))) <= 0xDFFF:
        return True
    
    elif 0xDC00 <= int(item) <= 0xDFFF:
        return True
    return False

def is_surrogate_16bit(item: bytes, cp_range) -> bool:
    
    if cp_range == 'low':
        if 0xDC00 <= ord(chr(65536+int(item))) <= 0xDFFF:
            return True
    elif cp_range == 'high':
        if 0xD800 <= ord(chr(65536+int(item))) <= 0xDBFF:
            return True
    else:
        raise ValueError("cp_range must be either 'low' or 'high'")
    return False


def is_surrogate_pair(first: bytes, second: bytes) -> bool:
    
    if is_surrogate_high_char(first):
        if is_surrogate_low_char(second):
            return True
        else:
            log.info("RTFDE encountered a standalone high-surrogate point without a corresponding low-surrogate. Standalone surrogate code points have either a high surrogate without an adjacent low surrogate, or vice versa. These code points are invalid and are not supported. Their behavior is undefined. Codepoints encountered: {0}, {1}".format(first, second))
    return False

def decode_surrogate_pair(high: bytes, low: bytes, encoding: str ='utf-16-le') -> bytes:
    
    
    
     
     
    if high.startswith(b"\\u"):
        high = high[2:]
    if low.startswith(b"\\u"):
        low = low[2:]
    if is_surrogate_16bit(high, "high"):
        char_high = chr(65536+int(high))
    else:
        char_high = chr(int(high))
    if is_surrogate_16bit(low, "low"):
        char_low = chr(65536+int(low))
    else:
        char_low = chr(int(low))
    unicode_scalar_value = ((ord(char_high) - 0xD800) * 0x400) + (ord(char_low) - 0xDC00) + 0x10000
    unicode_bytes = chr(unicode_scalar_value).encode(encoding)
    return unicode_bytes.decode(encoding).encode()

def merge_surrogate_chars(children,
                          ascii_map,
                          use_ASCII_alternatives_on_unicode_decode_failure = False):
    
    surrogate_start = None
    surrogate_high = None
    for i,c in enumerate(children):
        if isinstance(c, Tree):
            continue
        if is_unicode_encoded(c):
            if is_surrogate_high_char(c.value):
                surrogate_start = i
                surrogate_high = c
            elif surrogate_start is not None:
                if is_surrogate_low_char(c.value):
                    surrogate_low = c
                    try:
                        surrogate_value = decode_surrogate_pair(surrogate_high.value,
                                                                surrogate_low.value)
                        
                        surrogate_tok = Token('STRING',
                                              surrogate_value,
                                              start_pos=surrogate_high.start_pos,
                                              end_pos=surrogate_low.end_pos,
                                              line=surrogate_high.line,
                                              end_line=surrogate_low.end_line,
                                              column=surrogate_high.column,
                                              end_column=surrogate_low.end_column)
                        children[surrogate_start] = surrogate_tok
                        blank_tok = Token('STRING',
                                          b"",
                                          start_pos=surrogate_high.start_pos+1,
                                          end_pos=surrogate_low.end_pos+1,
                                          line=surrogate_high.line,
                                          end_line=surrogate_low.end_line,
                                          column=surrogate_high.column,
                                          end_column=surrogate_low.end_column)
                        children[i] = blank_tok
                        surrogate_start = None
                        surrogate_high = None
                    except UnicodeDecodeError as _e:
                        if use_ASCII_alternatives_on_unicode_decode_failure is True:
                            children[surrogate_start] = b"".join([i.value for i in ascii_map[surrogate_high]])
                            children[i] = b"".join([i.value for i in ascii_map[surrogate_low]])
                        else:
                            raise _e
                else:
                    log.info("RTFDE encountered a standalone high-surrogate point without a corresponding low-surrogate. Standalone surrogate code points have either a high surrogate without an adjacent low surrogate, or vice versa. These code points are invalid and are not supported. Their behavior is undefined. Codepoints encountered: {0}, {1}".format(surrogate_high, surrogate_low))
                    if use_ASCII_alternatives_on_unicode_decode_failure is True:
                        children[surrogate_start] = b"".join([i.value for i in ascii_map[surrogate_high]])
                    else:
                        raise ValueError("Standalone high-surrogate found. High surrogate followed by a illegal low-surrogate character.")
    return children



def is_unicode_char_byte_count(item: Token) -> bool:
    if isinstance(item, Token):
        if item.type == "CONTROLWORD":
            if item.value.startswith(b'\\uc'):
                return True
    return False

def get_unicode_char_byte_count(item: Token) -> int:
    item = item.value.decode()
    cur_uc = int(item[3:])
    return cur_uc



def has_hexarray(children: List[Union[Token, Tree]]) -> bool:
    
    for item in children:
        if is_hexarray(item):
            return True
    return False

def is_hexarray(item):
    
    if isinstance(item, Tree):
        if item.data.value == 'hexarray':
            return True
    return False

def get_bytes_from_hex_encoded(item):
    
    hexstring = item.replace(b"\\'", b"")
    hex_bytes = bytes.fromhex(hexstring.decode())
    return hex_bytes

def decode_hex_char(item, codec):
    
    if is_logger_on("RTFDE.text_extraction") is True:
        log_text_extraction("decoding char {0} with font {1}".format(item, codec))
    if codec is None:
        
        codec = 'CP1252'
    decoded = item.decode(codec)
    decoded = decoded.encode()
    if is_logger_on("RTFDE.text_extraction") is True:
        log_text_extraction("char {0} decoded into {1} using codec {2}".format(item, decoded, codec))
    return decoded


class TextDecoder:

    def __init__(self, keep_fontdef=False,
               initial_byte_count=None, use_ASCII_alternatives_on_unicode_decode_failure=False):
        
        self.keep_fontdef = keep_fontdef
        self.ucbc = initial_byte_count
        self.use_ASCII_alternatives_on_unicode_decode_failure = use_ASCII_alternatives_on_unicode_decode_failure

        
        self.default_font = None
        self.font_stack = []
        self.font_table = {}


    def set_font_info(self, obj: Tree):
        
        self.default_font = get_default_font(obj)
        self.font_stack = [self.default_font]
        raw_fonttbl = get_font_table(obj.children[1])
        self.font_table = parse_font_tree(raw_fonttbl)
        if is_logger_on("RTFDE.text_extraction") is True:
            log_text_extraction(f"FONT TABLE FOUND: {raw_fonttbl}")


    def update_children(self, obj: Tree):
        
        
        self.set_font_info(obj)
        children = obj.children
        obj.children = [i for i in self.iterate_on_children(children)]

    def prep_unicode(self, children: List[Token]):
        if includes_unicode_chars(children):
            
            
            children, ascii_map = remove_unicode_replacements(children,
                                                              byte_count=self.ucbc)
            
            
            
            children = merge_surrogate_chars(children,
                                             ascii_map,
                                             self.use_ASCII_alternatives_on_unicode_decode_failure)
            
            
        return children

    def iterate_on_children(self, children): 
        set_fonts = []
        if is_logger_on("RTFDE.text_extraction") is True:
            log_text_extraction("Starting to iterate on text extraction children...")
            log_text_extraction("PREP-BEFORE: "+repr(children))
        children = self.prep_unicode(children)
        if is_logger_on("RTFDE.text_extraction") is True:
            log_text_extraction("PREP-AFTER: "+repr(children))

        for item in children:
            if is_font_number(item): 
                self.font_stack.append(item.value.strip())
                set_fonts.append(item.value)
                if self.keep_fontdef is True:
                    yield item
            elif is_unicode_char_byte_count(item):
                bc = get_unicode_char_byte_count(item)
            elif is_unicode_encoded(item): 
                decoded = unicode_escape_to_chr(item.value).encode()
                
                decoded_tok = Token('STRING',
                                    decoded,
                                    start_pos=item.start_pos,
                                    end_pos=item.end_pos,
                                    line=item.line,
                                    end_line=item.end_line,
                                    column=item.column,
                                    end_column=item.end_column)
                if is_logger_on("RTFDE.text_extraction") is True:
                    log_text_extraction(f"UNICODE TOKEN {item}: {decoded_tok}")
                yield decoded_tok
            
            elif is_hexarray(item):
                
                base_bytes = None
                for hexchild in item.children:
                    if base_bytes is None:
                        base_bytes = get_bytes_from_hex_encoded(hexchild.value)
                    else:
                        base_bytes += get_bytes_from_hex_encoded(hexchild.value)
                current_fontdef = self.font_table[self.font_stack[-1]]
                current_codec = current_fontdef.codec
                decoded_hex = decode_hex_char(base_bytes, current_codec)
                
                decoded_hex_tok = Token('STRING',
                                        decoded_hex,
                                        start_pos=item.data.start_pos,
                                        end_pos=item.data.end_pos,
                                        line=item.data.line,
                                        end_line=item.data.end_line,
                                        column=item.data.column,
                                        end_column=item.data.end_column)
                yield decoded_hex_tok
            elif isinstance(item, Tree):
                
                item.children = [i for i in self.iterate_on_children(item.children)]
                yield item
            else:
                yield item
        for i in set_fonts:
            
            self.font_stack.pop()
