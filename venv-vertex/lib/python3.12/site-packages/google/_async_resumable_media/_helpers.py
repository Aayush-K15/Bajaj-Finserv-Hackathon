















import logging
import random
import time


from google.resumable_media import common


RANGE_HEADER = "range"
CONTENT_RANGE_HEADER = "content-range"

_SLOW_CRC32C_WARNING = (
    "Currently using crcmod in pure python form. This is a slow "
    "implementation. Python 3 has a faster implementation, `google-crc32c`, "
    "which will be used if it is installed."
)
_HASH_HEADER = "x-goog-hash"
_MISSING_CHECKSUM = 
_LOGGER = logging.getLogger(__name__)


def do_nothing():
    


def header_required(response, name, get_headers, callback=do_nothing):
    
    headers = get_headers(response)
    if name not in headers:
        callback()
        raise common.InvalidResponse(
            response, "Response headers must contain header", name
        )

    return headers[name]


def require_status_code(response, status_codes, get_status_code, callback=do_nothing):
    
    status_code = get_status_code(response)
    if status_code not in status_codes:
        callback()
        raise common.InvalidResponse(
            response,
            "Request failed with status code",
            status_code,
            "Expected one of",
            *status_codes
        )
    return status_code


def calculate_retry_wait(base_wait, max_sleep):
    
    new_base_wait = 2.0 * base_wait
    if new_base_wait > max_sleep:
        new_base_wait = max_sleep

    jitter_ms = random.randint(0, 1000)
    return new_base_wait, new_base_wait + 0.001 * jitter_ms


async def wait_and_retry(func, get_status_code, retry_strategy):
    

    total_sleep = 0.0
    num_retries = 0
    base_wait = 0.5  

    while True:  
        error = None
        try:
            response = await func()
        except ConnectionError as e:
            error = e
        else:
            if get_status_code(response) not in common.RETRYABLE:
                return response

        if not retry_strategy.retry_allowed(total_sleep, num_retries):
            
            
            if error:
                raise error

            return response

        base_wait, wait_time = calculate_retry_wait(base_wait, retry_strategy.max_sleep)

        num_retries += 1
        total_sleep += wait_time
        time.sleep(wait_time)


class _DoNothingHash(object):
    

    def update(self, unused_chunk):
        
