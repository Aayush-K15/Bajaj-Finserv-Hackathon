















import json
from typing import Any, Callable, Coroutine, Dict, Optional, Sequence, Tuple

from google.auth import __version__ as auth_version

try:
    from google.auth.aio.transport.sessions import AsyncAuthorizedSession  
except ImportError as e:  
    raise ImportError(
        "The `async_rest` extra of `google-api-core` is required to use long-running operations.  Install it by running "
        "`pip install google-api-core[async_rest]`."
    ) from e

from google.api_core import exceptions as core_exceptions  
from google.api_core import gapic_v1  
from google.api_core import path_template  
from google.api_core import rest_helpers  
from google.api_core import retry_async as retries_async  
from google.auth.aio import credentials as ga_credentials_async  
from google.longrunning import operations_pb2  
from google.protobuf import empty_pb2  
from google.protobuf import json_format  

from .base import DEFAULT_CLIENT_INFO as BASE_DEFAULT_CLIENT_INFO, OperationsTransport

DEFAULT_CLIENT_INFO = gapic_v1.client_info.ClientInfo(
    gapic_version=BASE_DEFAULT_CLIENT_INFO.gapic_version,
    grpc_version=None,
    rest_version=f"google-auth@{auth_version}",
)


class AsyncOperationsRestTransport(OperationsTransport):
    

    def __init__(
        self,
        *,
        host: str = "longrunning.googleapis.com",
        credentials: Optional[ga_credentials_async.Credentials] = None,
        credentials_file: Optional[str] = None,
        scopes: Optional[Sequence[str]] = None,
        client_cert_source_for_mtls: Optional[Callable[[], Tuple[bytes, bytes]]] = None,
        quota_project_id: Optional[str] = None,
        client_info: gapic_v1.client_info.ClientInfo = DEFAULT_CLIENT_INFO,
        always_use_jwt_access: Optional[bool] = False,
        url_scheme: str = "https",
        http_options: Optional[Dict] = None,
        path_prefix: str = "v1",
        
        
        
        
    ) -> None:
        
        unsupported_params = {
            
            "google.api_core.client_options.ClientOptions.credentials_file": credentials_file,
            
            "google.api_core.client_options.ClientOptions.scopes": scopes,
            
            "google.api_core.client_options.ClientOptions.quota_project_id": quota_project_id,
            
            "google.api_core.client_options.ClientOptions.client_cert_source": client_cert_source_for_mtls,
            
            "google.api_core.client_options.ClientOptions.client_cert_source": client_cert_source_for_mtls,
        }
        provided_unsupported_params = [
            name for name, value in unsupported_params.items() if value is not None
        ]
        if provided_unsupported_params:
            raise core_exceptions.AsyncRestUnsupportedParameterError(
                f"The following provided parameters are not supported for `transport=rest_asyncio`: {', '.join(provided_unsupported_params)}"
            )

        super().__init__(
            host=host,
            
            credentials=credentials,  
            client_info=client_info,
            
            always_use_jwt_access=False,
        )
        
        
        
        
        self._session = AsyncAuthorizedSession(self._credentials)  
        
        self._prep_wrapped_messages(client_info)
        self._http_options = http_options or {}
        self._path_prefix = path_prefix

    def _prep_wrapped_messages(self, client_info):
        
        self._wrapped_methods = {
            self.list_operations: gapic_v1.method_async.wrap_method(
                self.list_operations,
                default_retry=retries_async.AsyncRetry(
                    initial=0.5,
                    maximum=10.0,
                    multiplier=2.0,
                    predicate=retries_async.if_exception_type(
                        core_exceptions.ServiceUnavailable,
                    ),
                    deadline=10.0,
                ),
                default_timeout=10.0,
                client_info=client_info,
                kind="rest_asyncio",
            ),
            self.get_operation: gapic_v1.method_async.wrap_method(
                self.get_operation,
                default_retry=retries_async.AsyncRetry(
                    initial=0.5,
                    maximum=10.0,
                    multiplier=2.0,
                    predicate=retries_async.if_exception_type(
                        core_exceptions.ServiceUnavailable,
                    ),
                    deadline=10.0,
                ),
                default_timeout=10.0,
                client_info=client_info,
                kind="rest_asyncio",
            ),
            self.delete_operation: gapic_v1.method_async.wrap_method(
                self.delete_operation,
                default_retry=retries_async.AsyncRetry(
                    initial=0.5,
                    maximum=10.0,
                    multiplier=2.0,
                    predicate=retries_async.if_exception_type(
                        core_exceptions.ServiceUnavailable,
                    ),
                    deadline=10.0,
                ),
                default_timeout=10.0,
                client_info=client_info,
                kind="rest_asyncio",
            ),
            self.cancel_operation: gapic_v1.method_async.wrap_method(
                self.cancel_operation,
                default_retry=retries_async.AsyncRetry(
                    initial=0.5,
                    maximum=10.0,
                    multiplier=2.0,
                    predicate=retries_async.if_exception_type(
                        core_exceptions.ServiceUnavailable,
                    ),
                    deadline=10.0,
                ),
                default_timeout=10.0,
                client_info=client_info,
                kind="rest_asyncio",
            ),
        }

    async def _list_operations(
        self,
        request: operations_pb2.ListOperationsRequest,
        *,
        
        
        retry=gapic_v1.method_async.DEFAULT,
        timeout: Optional[float] = None,
        metadata: Sequence[Tuple[str, str]] = (),
    ) -> operations_pb2.ListOperationsResponse:
        r

        http_options = [
            {
                "method": "get",
                "uri": "/{}/{{name=**}}/operations".format(self._path_prefix),
            },
        ]
        if "google.longrunning.Operations.ListOperations" in self._http_options:
            http_options = self._http_options[
                "google.longrunning.Operations.ListOperations"
            ]

        request_kwargs = self._convert_protobuf_message_to_dict(request)
        transcoded_request = path_template.transcode(http_options, **request_kwargs)

        uri = transcoded_request["uri"]
        method = transcoded_request["method"]

        
        query_params_request = operations_pb2.ListOperationsRequest()
        json_format.ParseDict(transcoded_request["query_params"], query_params_request)
        query_params = json_format.MessageToDict(
            query_params_request,
            preserving_proto_field_name=False,
            use_integers_for_enums=False,
        )

        
        headers = dict(metadata)
        headers["Content-Type"] = "application/json"
        
        response = await getattr(self._session, method)(
            "{host}{uri}".format(host=self._host, uri=uri),
            timeout=timeout,
            headers=headers,
            params=rest_helpers.flatten_query_params(query_params),
        )
        content = await response.read()

        
        
        if response.status_code >= 400:
            payload = json.loads(content.decode("utf-8"))
            request_url = "{host}{uri}".format(host=self._host, uri=uri)
            raise core_exceptions.format_http_response_error(response, method, request_url, payload)  

        
        api_response = operations_pb2.ListOperationsResponse()
        json_format.Parse(content, api_response, ignore_unknown_fields=False)
        return api_response

    async def _get_operation(
        self,
        request: operations_pb2.GetOperationRequest,
        *,
        
        
        retry=gapic_v1.method_async.DEFAULT,
        timeout: Optional[float] = None,
        metadata: Sequence[Tuple[str, str]] = (),
    ) -> operations_pb2.Operation:
        r

        http_options = [
            {
                "method": "get",
                "uri": "/{}/{{name=**/operations/*}}".format(self._path_prefix),
            },
        ]
        if "google.longrunning.Operations.GetOperation" in self._http_options:
            http_options = self._http_options[
                "google.longrunning.Operations.GetOperation"
            ]

        request_kwargs = self._convert_protobuf_message_to_dict(request)
        transcoded_request = path_template.transcode(http_options, **request_kwargs)

        uri = transcoded_request["uri"]
        method = transcoded_request["method"]

        
        query_params_request = operations_pb2.GetOperationRequest()
        json_format.ParseDict(transcoded_request["query_params"], query_params_request)
        query_params = json_format.MessageToDict(
            query_params_request,
            preserving_proto_field_name=False,
            use_integers_for_enums=False,
        )

        
        headers = dict(metadata)
        headers["Content-Type"] = "application/json"
        
        response = await getattr(self._session, method)(
            "{host}{uri}".format(host=self._host, uri=uri),
            timeout=timeout,
            headers=headers,
            params=rest_helpers.flatten_query_params(query_params),
        )
        content = await response.read()

        
        
        if response.status_code >= 400:
            payload = json.loads(content.decode("utf-8"))
            request_url = "{host}{uri}".format(host=self._host, uri=uri)
            raise core_exceptions.format_http_response_error(response, method, request_url, payload)  

        
        api_response = operations_pb2.Operation()
        json_format.Parse(content, api_response, ignore_unknown_fields=False)
        return api_response

    async def _delete_operation(
        self,
        request: operations_pb2.DeleteOperationRequest,
        *,
        
        
        retry=gapic_v1.method_async.DEFAULT,
        timeout: Optional[float] = None,
        metadata: Sequence[Tuple[str, str]] = (),
    ) -> empty_pb2.Empty:
        r

        http_options = [
            {
                "method": "delete",
                "uri": "/{}/{{name=**/operations/*}}".format(self._path_prefix),
            },
        ]
        if "google.longrunning.Operations.DeleteOperation" in self._http_options:
            http_options = self._http_options[
                "google.longrunning.Operations.DeleteOperation"
            ]

        request_kwargs = self._convert_protobuf_message_to_dict(request)
        transcoded_request = path_template.transcode(http_options, **request_kwargs)

        uri = transcoded_request["uri"]
        method = transcoded_request["method"]

        
        query_params_request = operations_pb2.DeleteOperationRequest()
        json_format.ParseDict(transcoded_request["query_params"], query_params_request)
        query_params = json_format.MessageToDict(
            query_params_request,
            preserving_proto_field_name=False,
            use_integers_for_enums=False,
        )

        
        headers = dict(metadata)
        headers["Content-Type"] = "application/json"
        
        response = await getattr(self._session, method)(
            "{host}{uri}".format(host=self._host, uri=uri),
            timeout=timeout,
            headers=headers,
            params=rest_helpers.flatten_query_params(query_params),
        )

        
        
        if response.status_code >= 400:
            content = await response.read()
            payload = json.loads(content.decode("utf-8"))
            request_url = "{host}{uri}".format(host=self._host, uri=uri)
            raise core_exceptions.format_http_response_error(response, method, request_url, payload)  

        return empty_pb2.Empty()

    async def _cancel_operation(
        self,
        request: operations_pb2.CancelOperationRequest,
        *,
        
        
        retry=gapic_v1.method_async.DEFAULT,
        timeout: Optional[float] = None,
        metadata: Sequence[Tuple[str, str]] = (),
        
        
    ) -> empty_pb2.Empty:
        r

        http_options = [
            {
                "method": "post",
                "uri": "/{}/{{name=**/operations/*}}:cancel".format(self._path_prefix),
                "body": "*",
            },
        ]
        if "google.longrunning.Operations.CancelOperation" in self._http_options:
            http_options = self._http_options[
                "google.longrunning.Operations.CancelOperation"
            ]

        request_kwargs = self._convert_protobuf_message_to_dict(request)
        transcoded_request = path_template.transcode(http_options, **request_kwargs)

        
        body_request = operations_pb2.CancelOperationRequest()
        json_format.ParseDict(transcoded_request["body"], body_request)
        body = json_format.MessageToDict(
            body_request,
            preserving_proto_field_name=False,
            use_integers_for_enums=False,
        )
        uri = transcoded_request["uri"]
        method = transcoded_request["method"]

        
        query_params_request = operations_pb2.CancelOperationRequest()
        json_format.ParseDict(transcoded_request["query_params"], query_params_request)
        query_params = json_format.MessageToDict(
            query_params_request,
            preserving_proto_field_name=False,
            use_integers_for_enums=False,
        )

        
        headers = dict(metadata)
        headers["Content-Type"] = "application/json"
        
        response = await getattr(self._session, method)(
            "{host}{uri}".format(host=self._host, uri=uri),
            timeout=timeout,
            headers=headers,
            params=rest_helpers.flatten_query_params(query_params),
            data=body,
        )

        
        
        if response.status_code >= 400:
            content = await response.read()
            payload = json.loads(content.decode("utf-8"))
            request_url = "{host}{uri}".format(host=self._host, uri=uri)
            raise core_exceptions.format_http_response_error(response, method, request_url, payload)  

        return empty_pb2.Empty()

    @property
    def list_operations(
        self,
    ) -> Callable[
        [operations_pb2.ListOperationsRequest],
        Coroutine[Any, Any, operations_pb2.ListOperationsResponse],
    ]:
        return self._list_operations

    @property
    def get_operation(
        self,
    ) -> Callable[
        [operations_pb2.GetOperationRequest],
        Coroutine[Any, Any, operations_pb2.Operation],
    ]:
        return self._get_operation

    @property
    def delete_operation(
        self,
    ) -> Callable[
        [operations_pb2.DeleteOperationRequest], Coroutine[Any, Any, empty_pb2.Empty]
    ]:
        return self._delete_operation

    @property
    def cancel_operation(
        self,
    ) -> Callable[
        [operations_pb2.CancelOperationRequest], Coroutine[Any, Any, empty_pb2.Empty]
    ]:
        return self._cancel_operation


__all__ = ("AsyncOperationsRestTransport",)
