















import abc
import concurrent.futures

from google.api_core import exceptions
from google.api_core import retry as retries
from google.api_core.future import _helpers
from google.api_core.future import base


class _OperationNotComplete(Exception):
    

    pass




RETRY_PREDICATE = retries.if_exception_type(
    _OperationNotComplete,
    exceptions.TooManyRequests,
    exceptions.InternalServerError,
    exceptions.BadGateway,
    exceptions.ServiceUnavailable,
)




DEFAULT_RETRY = retries.Retry(predicate=RETRY_PREDICATE)





POLLING_PREDICATE = retries.if_exception_type(
    _OperationNotComplete,
)


DEFAULT_POLLING = retries.Retry(
    predicate=POLLING_PREDICATE,
    initial=1.0,  
    maximum=20.0,  
    multiplier=1.5,
    timeout=900,  
)


class PollingFuture(base.Future):
    

    _DEFAULT_VALUE = object()

    def __init__(self, polling=DEFAULT_POLLING, **kwargs):
        super(PollingFuture, self).__init__()
        self._polling = kwargs.get("retry", polling)
        self._result = None
        self._exception = None
        self._result_set = False
        
        self._polling_thread = None
        self._done_callbacks = []

    @abc.abstractmethod
    def done(self, retry=None):
        
        
        raise NotImplementedError()

    def _done_or_raise(self, retry=None):
        
        if not self.done(retry=retry):
            raise _OperationNotComplete()

    def running(self):
        
        return not self.done()

    def _blocking_poll(self, timeout=_DEFAULT_VALUE, retry=None, polling=None):
        

        if self._result_set:
            return

        polling = polling or self._polling
        if timeout is not PollingFuture._DEFAULT_VALUE:
            polling = polling.with_timeout(timeout)

        try:
            polling(self._done_or_raise)(retry=retry)
        except exceptions.RetryError:
            raise concurrent.futures.TimeoutError(
                f"Operation did not complete within the designated timeout of "
                f"{polling.timeout} seconds."
            )

    def result(self, timeout=_DEFAULT_VALUE, retry=None, polling=None):
        

        self._blocking_poll(timeout=timeout, retry=retry, polling=polling)

        if self._exception is not None:
            
            
            raise self._exception

        return self._result

    def exception(self, timeout=_DEFAULT_VALUE):
        
        self._blocking_poll(timeout=timeout)
        return self._exception

    def add_done_callback(self, fn):
        
        if self._result_set:
            _helpers.safe_invoke_callback(fn, self)
            return

        self._done_callbacks.append(fn)

        if self._polling_thread is None:
            
            
            self._polling_thread = _helpers.start_daemon_thread(
                target=self._blocking_poll
            )

    def _invoke_callbacks(self, *args, **kwargs):
        
        for callback in self._done_callbacks:
            _helpers.safe_invoke_callback(callback, *args, **kwargs)

    def set_result(self, result):
        
        self._result = result
        self._result_set = True
        self._invoke_callbacks(self)

    def set_exception(self, exception):
        
        self._exception = exception
        self._result_set = True
        self._invoke_callbacks(self)
