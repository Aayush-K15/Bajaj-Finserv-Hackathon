















import asyncio

from google.api_core import exceptions
from google.api_core import retry
from google.api_core import retry_async
from google.api_core.future import base


class _OperationNotComplete(Exception):
    

    pass


RETRY_PREDICATE = retry.if_exception_type(
    _OperationNotComplete,
    exceptions.TooManyRequests,
    exceptions.InternalServerError,
    exceptions.BadGateway,
)
DEFAULT_RETRY = retry_async.AsyncRetry(predicate=RETRY_PREDICATE)


class AsyncFuture(base.Future):
    

    def __init__(self, retry=DEFAULT_RETRY):
        super().__init__()
        self._retry = retry
        self._future = asyncio.get_event_loop().create_future()
        self._background_task = None

    async def done(self, retry=DEFAULT_RETRY):
        
        
        raise NotImplementedError()

    async def _done_or_raise(self):
        
        result = await self.done()
        if not result:
            raise _OperationNotComplete()

    async def running(self):
        
        result = await self.done()
        return not result

    async def _blocking_poll(self, timeout=None):
        
        if self._future.done():
            return

        retry_ = self._retry.with_timeout(timeout)

        try:
            await retry_(self._done_or_raise)()
        except exceptions.RetryError:
            raise asyncio.TimeoutError(
                "Operation did not complete within the designated " "timeout."
            )

    async def result(self, timeout=None):
        
        await self._blocking_poll(timeout=timeout)
        return self._future.result()

    async def exception(self, timeout=None):
        
        await self._blocking_poll(timeout=timeout)
        return self._future.exception()

    def add_done_callback(self, fn):
        
        if self._background_task is None:
            self._background_task = asyncio.get_event_loop().create_task(
                self._blocking_poll()
            )
        self._future.add_done_callback(fn)

    def set_result(self, result):
        
        self._future.set_result(result)

    def set_exception(self, exception):
        
        self._future.set_exception(exception)
