
















from typing import Dict, List, Optional, Union

from google.api_core import operation
from google.auth import credentials as auth_credentials
from google.cloud.aiplatform import base
from google.cloud.aiplatform import initializer
from google.cloud.aiplatform import utils
from google.cloud.aiplatform.compat.services import (
    persistent_resource_service_client_v1 as persistent_resource_service_client_compat,
)
from google.cloud.aiplatform.compat.types import (
    encryption_spec as gca_encryption_spec_compat,
    persistent_resource_v1 as gca_persistent_resource_compat,
)
from google.protobuf import timestamp_pb2  
from google.rpc import status_pb2  

_LOGGER = base.Logger(__name__)


class PersistentResource(base.VertexAiResourceNounWithFutureManager):
    

    client_class = utils.PersistentResourceClientWithOverride
    _resource_noun = "persistentResource"
    _getter_method = "get_persistent_resource"
    _list_method = "list_persistent_resources"
    _delete_method = "delete_persistent_resource"
    _parse_resource_name_method = "parse_persistent_resource_path"
    _format_resource_name_method = "persistent_resource_path"

    def __init__(
        self,
        persistent_resource_id: str,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ):
        
        super().__init__(
            project=project,
            location=location,
            credentials=credentials,
            resource_name=persistent_resource_id,
        )

        self._gca_resource = self._get_gca_resource(
            resource_name=persistent_resource_id
        )

    @property
    def display_name(self) -> Optional[str]:
        
        self._assert_gca_resource_is_available()
        return getattr(self._gca_resource, "display_name", None)

    @property
    def state(self) -> gca_persistent_resource_compat.PersistentResource.State:
        
        self._assert_gca_resource_is_available()
        return getattr(self._gca_resource, "state", None)

    @property
    def error(self) -> Optional[status_pb2.Status]:
        
        self._assert_gca_resource_is_available()
        return getattr(self._gca_resource, "error", None)

    @property
    def create_time(self) -> Optional[timestamp_pb2.Timestamp]:
        
        self._assert_gca_resource_is_available()
        return getattr(self._gca_resource, "create_time", None)

    @property
    def start_time(self) -> Optional[timestamp_pb2.Timestamp]:
        
        self._assert_gca_resource_is_available()
        return getattr(self._gca_resource, "start_time", None)

    @property
    def update_time(self) -> Optional[timestamp_pb2.Timestamp]:
        
        self._assert_gca_resource_is_available()
        return getattr(self._gca_resource, "update_time", None)

    @property
    def network(self) -> Optional[str]:
        
        self._assert_gca_resource_is_available()
        return getattr(self._gca_resource, "network", None)

    @classmethod
    @base.optional_sync()
    def create(
        cls,
        persistent_resource_id: str,
        resource_pools: Union[
            List[Dict], List[gca_persistent_resource_compat.ResourcePool]
        ],
        display_name: Optional[str] = None,
        labels: Optional[Dict[str, str]] = None,
        network: Optional[str] = None,
        kms_key_name: Optional[str] = None,
        enable_custom_service_account: Optional[bool] = None,
        service_account: Optional[str] = None,
        reserved_ip_ranges: List[str] = None,
        sync: Optional[bool] = True,  
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ) -> "PersistentResource":
        r

        if labels:
            utils.validate_labels(labels)

        gca_persistent_resource = gca_persistent_resource_compat.PersistentResource(
            name=persistent_resource_id,
            display_name=display_name,
            resource_pools=resource_pools,
            labels=labels,
            network=network,
            reserved_ip_ranges=reserved_ip_ranges,
        )

        if kms_key_name:
            gca_persistent_resource.encryption_spec = (
                gca_encryption_spec_compat.EncryptionSpec(kms_key_name=kms_key_name)
            )

        
        
        if (
            enable_custom_service_account is False and service_account is not None
        ):  
            raise ValueError(
                "The parameter `enable_custom_service_account` was set to False, "
                "but a value was provided for `service_account`. These two "
                "settings are incompatible. If you want to use a custom "
                "service account, set `enable_custom_service_account` to True."
            )

        elif enable_custom_service_account:
            service_account_spec = gca_persistent_resource_compat.ServiceAccountSpec(
                enable_custom_service_account=True,
                
                service_account=service_account if service_account else None,
            )
            gca_persistent_resource.resource_runtime_spec = (
                gca_persistent_resource_compat.ResourceRuntimeSpec(
                    service_account_spec=service_account_spec
                )
            )
        elif service_account:
            
            service_account_spec = gca_persistent_resource_compat.ServiceAccountSpec(
                enable_custom_service_account=True, service_account=service_account
            )
            gca_persistent_resource.resource_runtime_spec = (
                gca_persistent_resource_compat.ResourceRuntimeSpec(
                    service_account_spec=service_account_spec
                )
            )

        api_client = cls._instantiate_client(location, credentials)
        create_lro = cls._create(
            api_client=api_client,
            parent=initializer.global_config.common_location_path(
                project=project, location=location
            ),
            persistent_resource=gca_persistent_resource,
            persistent_resource_id=persistent_resource_id,
        )

        _LOGGER.log_create_with_lro(cls, create_lro)

        create_lro.result(timeout=None)
        persistent_resource_result = cls(
            persistent_resource_id=persistent_resource_id,
            project=project,
            location=location,
            credentials=credentials,
        )

        _LOGGER.log_create_complete(
            cls, persistent_resource_result._gca_resource, "persistent resource"
        )

        return persistent_resource_result

    @classmethod
    def _create(
        cls,
        api_client: (
            persistent_resource_service_client_compat.PersistentResourceServiceClient
        ),
        parent: str,
        persistent_resource: gca_persistent_resource_compat.PersistentResource,
        persistent_resource_id: str,
        create_request_timeout: Optional[float] = None,
    ) -> operation.Operation:
        
        return api_client.create_persistent_resource(
            parent=parent,
            persistent_resource_id=persistent_resource_id,
            persistent_resource=persistent_resource,
            timeout=create_request_timeout,
        )

    @classmethod
    def list(
        cls,
        filter: Optional[str] = None,
        order_by: Optional[str] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ) -> List["PersistentResource"]:
        
        return cls._list_with_local_order(
            filter=filter,
            order_by=order_by,
            project=project,
            location=location,
            credentials=credentials,
        )

    @base.optional_sync()
    def reboot(
        self,
        sync: Optional[bool] = True,  
    ) -> None:
        

        _LOGGER.log_action_start_against_resource("Rebooting", "", self)
        lro = self.api_client.reboot_persistent_resource(name=self.resource_name)
        _LOGGER.log_action_started_against_resource_with_lro(
            "Reboot", "", self.__class__, lro
        )
        lro.result(timeout=None)
        _LOGGER.log_action_completed_against_resource("rebooted.", "", self)
