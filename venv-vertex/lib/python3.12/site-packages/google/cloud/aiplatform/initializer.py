

















from concurrent import futures
import enum
import functools
import inspect
import logging
import os
import types
from typing import Any, Iterator, List, Optional, Sequence, Tuple, Type, TypeVar, Union

from google.api_core import client_options
from google.api_core import gapic_v1
import google.auth
from google.auth import credentials as auth_credentials
from google.auth.exceptions import GoogleAuthError

from google.cloud.aiplatform import __version__
from google.cloud.aiplatform import compat
from google.cloud.aiplatform.constants import base as constants
from google.cloud.aiplatform import utils
from google.cloud.aiplatform.metadata import metadata
from google.cloud.aiplatform.utils import resource_manager_utils
from google.cloud.aiplatform.tensorboard import tensorboard_resource
from google.cloud.aiplatform import telemetry

from google.cloud.aiplatform.compat.types import (
    encryption_spec as gca_encryption_spec_compat,
    encryption_spec_v1 as gca_encryption_spec_v1,
    encryption_spec_v1beta1 as gca_encryption_spec_v1beta1,
)

try:
    import google.auth.aio

    AsyncCredentials = google.auth.aio.credentials.Credentials
    _HAS_ASYNC_CRED_DEPS = True
except (ImportError, AttributeError):
    AsyncCredentials = Any
    _HAS_ASYNC_CRED_DEPS = False

_TVertexAiServiceClientWithOverride = TypeVar(
    "_TVertexAiServiceClientWithOverride",
    bound=utils.VertexAiServiceClientWithOverride,
)

_TOP_GOOGLE_CONSTRUCTOR_METHOD_TAG = "top_google_constructor_method"


class _Product(enum.Enum):
    

    WORKBENCH_INSTANCE = "WORKBENCH_INSTANCE"
    COLAB_ENTERPRISE = "COLAB_ENTERPRISE"
    WORKBENCH_CUSTOM_CONTAINER = "WORKBENCH_CUSTOM_CONTAINER"


class _Config:
    

    def _set_project_as_env_var_or_google_auth_default(self):
        

        if not self._project and not self._api_key:
            
            
            
            
            
            project_number = os.environ.get("GOOGLE_CLOUD_PROJECT") or os.environ.get(
                "CLOUD_ML_PROJECT_ID"
            )
            if project_number:
                if not self._credentials:
                    credentials, _ = google.auth.default(
                        scopes=constants.DEFAULT_AUTHED_SCOPES
                    )
                    self._credentials = credentials
                
                try:
                    project_id = resource_manager_utils.get_project_id(
                        project_number=project_number,
                        credentials=self._credentials,
                    )
                    self._project = project_id
                except Exception:
                    logging.getLogger(__name__).warning(
                        "Failed to convert project number to project ID.", exc_info=True
                    )
                    self._project = project_number
            else:
                credentials, project = google.auth.default()
                self._credentials = self._credentials or credentials
                self._project = project

        if not self._credentials and not self._api_key:
            credentials, _ = google.auth.default(scopes=constants.DEFAULT_AUTHED_SCOPES)
            self._credentials = credentials

    def __init__(self):
        self._project = None
        self._location = None
        self._staging_bucket = None
        self._credentials = None
        self._encryption_spec_key_name = None
        self._network = None
        self._service_account = None
        self._api_endpoint = None
        self._api_key = None
        self._api_transport = None
        self._request_metadata = None
        self._resource_type = None
        self._async_rest_credentials = None

    def init(
        self,
        *,
        project: Optional[str] = None,
        location: Optional[str] = None,
        experiment: Optional[str] = None,
        experiment_description: Optional[str] = None,
        experiment_tensorboard: Optional[
            Union[str, tensorboard_resource.Tensorboard, bool]
        ] = None,
        staging_bucket: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
        encryption_spec_key_name: Optional[str] = None,
        network: Optional[str] = None,
        service_account: Optional[str] = None,
        api_endpoint: Optional[str] = None,
        api_key: Optional[str] = None,
        api_transport: Optional[str] = None,
        request_metadata: Optional[Sequence[Tuple[str, str]]] = None,
    ):
        
        
        
        if api_transport:
            VALID_TRANSPORT_TYPES = ["grpc", "rest"]
            if api_transport not in VALID_TRANSPORT_TYPES:
                raise ValueError(
                    f"{api_transport} is not a valid transport type. "
                    + f"Valid transport types: {VALID_TRANSPORT_TYPES}"
                )
            
            elif api_key and api_transport != "rest":
                raise ValueError(f"{api_transport} is not supported with API keys. ")
        else:
            if not project and not api_transport:
                api_transport = "rest"

        if location:
            utils.validate_region(location)
            
            if location == "global" and not api_transport:
                self._api_transport = "rest"
            elif location == "global" and api_transport == "grpc":
                raise ValueError(
                    "api_transport cannot be 'grpc' when location is 'global'."
                )
        if experiment_description and experiment is None:
            raise ValueError(
                "Experiment needs to be set in `init` in order to add experiment"
                " descriptions."
            )

        
        if (project and project != self._project) or (
            location and location != self._location
        ):
            if metadata._experiment_tracker.experiment_name:
                logging.info("project/location updated, reset Experiment config.")
            metadata._experiment_tracker.reset()

        if project and api_key:
            logging.info(
                "Both a project and API key have been provided. The project will take precedence over the API key."
            )

        
        if api_endpoint is not None:
            self._api_endpoint = api_endpoint
        if api_transport:
            self._api_transport = api_transport
        if project:
            self._project = project
        if location:
            self._location = location
        if staging_bucket:
            self._staging_bucket = staging_bucket
        if credentials:
            self._credentials = credentials
        if encryption_spec_key_name:
            self._encryption_spec_key_name = encryption_spec_key_name
        if network is not None:
            self._network = network
        if service_account is not None:
            self._service_account = service_account
        if request_metadata is not None:
            self._request_metadata = request_metadata
        if api_key is not None:
            self._api_key = api_key
        self._resource_type = None

        
        if experiment_tensorboard and not isinstance(experiment_tensorboard, bool):
            metadata._experiment_tracker.set_tensorboard(
                tensorboard=experiment_tensorboard,
                project=project,
                location=location,
                credentials=credentials,
            )

        if experiment:
            metadata._experiment_tracker.set_experiment(
                experiment=experiment,
                description=experiment_description,
                backing_tensorboard=experiment_tensorboard,
            )

    def get_encryption_spec(
        self,
        encryption_spec_key_name: Optional[str],
        select_version: Optional[str] = compat.DEFAULT_VERSION,
    ) -> Optional[
        Union[
            gca_encryption_spec_v1.EncryptionSpec,
            gca_encryption_spec_v1beta1.EncryptionSpec,
        ]
    ]:
        
        kms_key_name = encryption_spec_key_name or self.encryption_spec_key_name
        encryption_spec = None
        if kms_key_name:
            gca_encryption_spec = gca_encryption_spec_compat
            if select_version == compat.V1BETA1:
                gca_encryption_spec = gca_encryption_spec_v1beta1
            encryption_spec = gca_encryption_spec.EncryptionSpec(
                kms_key_name=kms_key_name
            )
        return encryption_spec

    @property
    def api_endpoint(self) -> Optional[str]:
        
        return self._api_endpoint

    @property
    def api_key(self) -> Optional[str]:
        
        return self._api_key

    @property
    def project(self) -> str:
        
        if self._project:
            return self._project

        project_not_found_exception_str = (
            "Unable to find your project. Please provide a project ID by:"
            "\n- Passing a constructor argument"
            "\n- Using vertexai.init()"
            "\n- Setting project using 'gcloud config set project my-project'"
            "\n- Setting a GCP environment variable"
            "\n- To create a Google Cloud project, please follow guidance at https://developers.google.com/workspace/guides/create-project"
        )

        try:
            self._set_project_as_env_var_or_google_auth_default()
            project_id = self._project
        except GoogleAuthError as exc:
            raise GoogleAuthError(project_not_found_exception_str) from exc

        if not project_id and not self.api_key:
            raise ValueError(project_not_found_exception_str)

        return project_id

    @property
    def location(self) -> str:
        
        if self._location:
            return self._location

        location = os.getenv("GOOGLE_CLOUD_REGION") or os.getenv("CLOUD_ML_REGION")
        if location:
            utils.validate_region(location)
            return location

        return constants.DEFAULT_REGION

    @property
    def staging_bucket(self) -> Optional[str]:
        
        return self._staging_bucket

    @property
    def credentials(self) -> Optional[auth_credentials.Credentials]:
        
        if self._credentials:
            return self._credentials
        logger = logging.getLogger("google.auth._default")
        logging_warning_filter = utils.LoggingFilter(logging.WARNING)
        logger.addFilter(logging_warning_filter)
        self._set_project_as_env_var_or_google_auth_default()
        credentials = self._credentials
        logger.removeFilter(logging_warning_filter)
        return credentials

    @property
    def encryption_spec_key_name(self) -> Optional[str]:
        
        return self._encryption_spec_key_name

    @property
    def network(self) -> Optional[str]:
        
        return self._network

    @property
    def service_account(self) -> Optional[str]:
        
        return self._service_account

    @property
    def experiment_name(self) -> Optional[str]:
        
        return metadata._experiment_tracker.experiment_name

    def get_resource_type(self) -> _Product:
        
        if self._resource_type:
            return self._resource_type

        vertex_product = os.getenv("VERTEX_PRODUCT")
        product_mapping = {
            "COLAB_ENTERPRISE": _Product.COLAB_ENTERPRISE,
            "WORKBENCH_CUSTOM_CONTAINER": _Product.WORKBENCH_CUSTOM_CONTAINER,
            "WORKBENCH_INSTANCE": _Product.WORKBENCH_INSTANCE,
        }

        if vertex_product in product_mapping:
            self._resource_type = product_mapping[vertex_product]

        return self._resource_type

    def get_client_options(
        self,
        location_override: Optional[str] = None,
        prediction_client: bool = False,
        api_base_path_override: Optional[str] = None,
        api_key: Optional[str] = None,
        api_path_override: Optional[str] = None,
    ) -> client_options.ClientOptions:
        

        api_endpoint = self.api_endpoint

        if (
            api_endpoint is None
            and not self._project
            and not self._location
            and not location_override
        ) or (self._location == "global"):
            
            
            api_endpoint = "aiplatform.googleapis.com"

        
        if api_endpoint is None:
            
            if not (self.location or location_override):
                raise ValueError(
                    "No location found. Provide or initialize SDK with a location."
                )

            region = location_override or self.location
            region = region.lower()

            utils.validate_region(region)

            service_base_path = api_base_path_override or (
                constants.PREDICTION_API_BASE_PATH
                if prediction_client
                else constants.API_BASE_PATH
            )

            api_endpoint = (
                f"{region}-{service_base_path}"
                if not api_path_override
                else api_path_override
            )

        
        if api_key and not self._project:
            return client_options.ClientOptions(
                api_endpoint=api_endpoint, api_key=api_key
            )
        return client_options.ClientOptions(api_endpoint=api_endpoint)

    def common_location_path(
        self, project: Optional[str] = None, location: Optional[str] = None
    ) -> str:
        
        if location:
            utils.validate_region(location)

        return "/".join(
            [
                "projects",
                project or self.project,
                "locations",
                location or self.location,
            ]
        )

    def create_client(
        self,
        client_class: Type[_TVertexAiServiceClientWithOverride],
        credentials: Optional[auth_credentials.Credentials] = None,
        location_override: Optional[str] = None,
        prediction_client: bool = False,
        api_base_path_override: Optional[str] = None,
        api_key: Optional[str] = None,
        api_path_override: Optional[str] = None,
        appended_user_agent: Optional[List[str]] = None,
        appended_gapic_version: Optional[str] = None,
    ) -> _TVertexAiServiceClientWithOverride:
        
        gapic_version = __version__

        if appended_gapic_version:
            gapic_version = f"{gapic_version}+{appended_gapic_version}"

        try:
            caller_method = _get_top_level_google_caller_method_name()
            if caller_method:
                gapic_version += (
                    f"+{_TOP_GOOGLE_CONSTRUCTOR_METHOD_TAG}+{caller_method}"
                )
        except Exception:  
            pass

        resource_type = self.get_resource_type()
        if resource_type:
            gapic_version += f"+environment+{resource_type.value}"

        if telemetry._tool_names_to_append:
            
            gapic_version = f"{gapic_version}+tools+{'+'.join(telemetry._tool_names_to_append[::-1])}"

        user_agent = f"{constants.USER_AGENT_PRODUCT}/{gapic_version}"
        if appended_user_agent:
            user_agent = f"{user_agent} {' '.join(appended_user_agent)}"

        client_info = gapic_v1.client_info.ClientInfo(
            gapic_version=gapic_version,
            user_agent=user_agent,
        )

        kwargs = {
            "credentials": credentials or self.credentials,
            "client_options": self.get_client_options(
                location_override=location_override,
                prediction_client=prediction_client,
                api_key=api_key,
                api_base_path_override=api_base_path_override,
                api_path_override=api_path_override,
            ),
            "client_info": client_info,
        }

        
        if self._api_transport == "rest" and "Async" in client_class.__name__:
            
            if self._async_rest_credentials:
                
                kwargs["credentials"] = self._async_rest_credentials
                kwargs["transport"] = "rest_asyncio"
            else:
                
                
                logging.warning(
                    "REST async clients requires async credentials set using "
                    + "aiplatform.initializer._set_async_rest_credentials().\n"
                    + "Falling back to grpc since no async rest credentials "
                    + "were detected."
                )
        elif self._api_transport == "rest":
            
            kwargs["transport"] = self._api_transport

        client = client_class(**kwargs)
        
        if self._request_metadata:
            client = _ClientWrapperThatAddsDefaultMetadata(client)
        return client

    def _get_default_project_and_location(self) -> Tuple[str, str]:
        return (
            self.project,
            self.location,
        )





















class _ClientWrapperThatAddsDefaultMetadata:
    

    def __init__(self, client):
        self._client = client

    def __getattr__(self, name: str):
        result = getattr(self._client, name)
        if global_config._request_metadata and callable(result):
            func = result
            if "metadata" in inspect.signature(func).parameters:
                return _FunctionWrapperThatAddsDefaultMetadata(func)
        return result

    def select_version(self, *args, **kwargs):
        client = self._client.select_version(*args, **kwargs)
        if global_config._request_metadata:
            client = _ClientWrapperThatAddsDefaultMetadata(client)
        return client


class _FunctionWrapperThatAddsDefaultMetadata:
    

    def __init__(self, func):
        self._func = func
        functools.update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        
        metadata_list = list(global_config._request_metadata or [])
        
        
        metadata_list.extend(kwargs.pop("metadata", []))
        
        return self._func(*args, **kwargs, metadata=metadata_list)



global_config = _Config()

global_pool = futures.ThreadPoolExecutor(
    max_workers=min(32, max(4, (os.cpu_count() or 0) * 5))
)


def _set_async_rest_credentials(credentials: AsyncCredentials):
    
    if global_config._api_transport != "rest":
        raise ValueError(
            "Async REST credentials can only be set when using REST transport."
        )
    elif not _HAS_ASYNC_CRED_DEPS or not isinstance(credentials, AsyncCredentials):
        raise ValueError(
            "Async REST transport requires async credentials of type"
            + f"{AsyncCredentials} which is only supported in "
            + "google-auth >= 2.35.0.\n\n"
            + "Install the following dependencies:\n"
            + "pip install google-api-core[grpc, async_rest] >= 2.21.0\n"
            + "pip install google-auth[aiohttp] >= 2.35.0\n\n"
            + "Example usage:\n"
            + "from google.auth.aio.credentials import StaticCredentials\n"
            + "async_credentials = StaticCredentials(token=YOUR_TOKEN_HERE)\n"
            + "aiplatform.initializer._set_async_rest_credentials("
            + "credentials=async_credentials)"
        )
    global_config._async_rest_credentials = credentials


def _get_function_name_from_stack_frame(frame) -> str:
    
    module_name = frame.f_globals["__name__"]
    function_name = frame.f_code.co_name

    
    
    if frame.f_code.co_argcount > 0:
        first_arg_name = frame.f_code.co_varnames[0]
    else:
        first_arg_name = None

    
    if first_arg_name == "self":
        f_cls = frame.f_locals["self"].__class__
    elif first_arg_name == "cls":
        f_cls = frame.f_locals["cls"]
    else:
        f_cls = None

    if f_cls:
        module_name = f_cls.__module__ or module_name
        
        class_name = f_cls.__name__
        return f"{module_name}.{class_name}.{function_name}"
    else:
        return f"{module_name}.{function_name}"


def _get_stack_frames() -> Iterator[types.FrameType]:
    
    frame = inspect.currentframe()
    while frame:
        yield frame
        frame = frame.f_back


def _get_top_level_google_caller_method_name() -> Optional[str]:
    top_level_method = None
    for frame in _get_stack_frames():
        function_name = _get_function_name_from_stack_frame(frame)
        if function_name.startswith("vertexai.") or (
            function_name.startswith("google.cloud.aiplatform.")
            and not function_name.startswith("google.cloud.aiplatform.tests")
        ):
            top_level_method = function_name
    return top_level_method
