
















import time
from typing import Any, Optional

from google.auth import credentials as auth_credentials
from google.cloud.aiplatform import base
from google.cloud.aiplatform import utils
from google.cloud.aiplatform.compat.types import (
    schedule as gca_schedule,
)
from google.cloud.aiplatform.constants import (
    schedule as schedule_constants,
)

_LOGGER = base.Logger(__name__)

_SCHEDULE_COMPLETE_STATES = schedule_constants._SCHEDULE_COMPLETE_STATES

_SCHEDULE_ERROR_STATES = schedule_constants._SCHEDULE_ERROR_STATES


class _Schedule(
    base.VertexAiStatefulResource,
):
    

    client_class = utils.ScheduleClientWithOverride
    _resource_noun = "schedules"
    _delete_method = "delete_schedule"
    _getter_method = "get_schedule"
    _list_method = "list_schedules"
    _pause_method = "pause_schedule"
    _resume_method = "resume_schedule"
    _parse_resource_name_method = "parse_schedule_path"
    _format_resource_name_method = "schedule_path"

    
    _valid_done_states = schedule_constants._SCHEDULE_COMPLETE_STATES

    def __init__(
        self,
        credentials: auth_credentials.Credentials,
        project: str,
        location: str,
    ):
        
        super().__init__(project=project, location=location, credentials=credentials)

    @classmethod
    def get(
        cls,
        schedule_id: str,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ) -> Any:
        
        self = cls._empty_constructor(
            project=project,
            location=location,
            credentials=credentials,
            resource_name=schedule_id,
        )

        self._gca_resource = self._get_gca_resource(resource_name=schedule_id)

        return self

    def pause(self) -> None:
        
        self.api_client.pause_schedule(name=self.resource_name)

    def resume(
        self,
        catch_up: bool = True,
    ) -> None:
        
        self.api_client.resume_schedule(name=self.resource_name)

    def done(self) -> bool:
        
        if not self._gca_resource:
            return False

        return self.state in _SCHEDULE_COMPLETE_STATES

    def wait(self) -> None:
        
        if self._latest_future is None:
            self._block_until_complete()
        else:
            super().wait()

    @property
    def state(self) -> Optional[gca_schedule.Schedule.State]:
        
        self._sync_gca_resource()
        return self._gca_resource.state

    @property
    def max_run_count(self) -> int:
        
        self._sync_gca_resource()
        return self._gca_resource.max_run_count

    @property
    def cron(self) -> str:
        
        self._sync_gca_resource()
        return self._gca_resource.cron

    @property
    def max_concurrent_run_count(self) -> int:
        
        self._sync_gca_resource()
        return self._gca_resource.max_concurrent_run_count

    @property
    def allow_queueing(self) -> bool:
        
        self._sync_gca_resource()
        return self._gca_resource.allow_queueing

    def _block_until_complete(self) -> None:
        
        
        wait = 5  
        log_wait = 5
        max_wait = 60 * 5  
        multiplier = 2  

        previous_time = time.time()
        while self.state not in _SCHEDULE_COMPLETE_STATES:
            current_time = time.time()
            if current_time - previous_time >= log_wait:
                _LOGGER.info(
                    "%s %s current state:\n%s"
                    % (
                        self.__class__.__name__,
                        self._gca_resource.name,
                        self._gca_resource.state,
                    )
                )
                log_wait = min(log_wait * multiplier, max_wait)
                previous_time = current_time
            time.sleep(wait)

        
        if self._gca_resource.state in _SCHEDULE_ERROR_STATES:
            raise RuntimeError("Schedule failed with:\n%s" % self._gca_resource.error)
        else:
            _LOGGER.log_action_completed_against_resource("run", "completed", self)

    def _dashboard_uri(self) -> str:
        
        fields = self._parse_resource_name(self.resource_name)
        url = f"https://console.cloud.google.com/vertex-ai/locations/{fields['location']}/pipelines/schedules/{fields['schedule']}?project={fields['project']}"
        return url
