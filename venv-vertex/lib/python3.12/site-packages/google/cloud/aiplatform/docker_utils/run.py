
















import logging
import os
from pathlib import Path
import re
from typing import Dict, List, Optional, Sequence

try:
    import docker
except ImportError:
    raise ImportError(
        "Docker is not installed and is required to run containers. "
        'Please install the SDK using `pip install "google-cloud-aiplatform[prediction]>=1.16.0"`.'
    )

from google.cloud.aiplatform.constants import prediction
from google.cloud.aiplatform.docker_utils.utils import DEFAULT_MOUNTED_MODEL_DIRECTORY
from google.cloud.aiplatform.utils import prediction_utils

_logger = logging.getLogger(__name__)

_DEFAULT_CONTAINER_CRED_KEY_PATH = "/tmp/keys/cred_key.json"
_ADC_ENVIRONMENT_VARIABLE = "GOOGLE_APPLICATION_CREDENTIALS"

CONTAINER_RUNNING_STATUS = "running"


def _get_adc_environment_variable() -> Optional[str]:
    
    return os.environ.get(_ADC_ENVIRONMENT_VARIABLE)


def _replace_env_var_reference(
    target: str,
    env_vars: Dict[str, str],
) -> str:
    
    
    for key, value in env_vars.items():
        target = re.sub(rf"(?<!\$)\$\({key}\)", str(value), target)
    
    target = re.sub(r"\$\$", "$", target)
    return target


def run_prediction_container(
    serving_container_image_uri: str,
    artifact_uri: Optional[str] = None,
    serving_container_predict_route: Optional[str] = None,
    serving_container_health_route: Optional[str] = None,
    serving_container_command: Optional[Sequence[str]] = None,
    serving_container_args: Optional[Sequence[str]] = None,
    serving_container_environment_variables: Optional[Dict[str, str]] = None,
    serving_container_ports: Optional[Sequence[int]] = None,
    credential_path: Optional[str] = None,
    host_port: Optional[int] = None,
    gpu_count: Optional[int] = None,
    gpu_device_ids: Optional[List[str]] = None,
    gpu_capabilities: Optional[List[List[str]]] = None,
) -> docker.models.containers.Container:
    
    client = docker.from_env()

    envs = {}
    if serving_container_environment_variables:
        for key, value in serving_container_environment_variables.items():
            envs[key] = _replace_env_var_reference(value, envs)

    port = prediction_utils.get_prediction_aip_http_port(serving_container_ports)
    envs[prediction.AIP_HTTP_PORT] = port

    envs[prediction.AIP_HEALTH_ROUTE] = serving_container_health_route
    envs[prediction.AIP_PREDICT_ROUTE] = serving_container_predict_route

    volumes = []
    envs[prediction.AIP_STORAGE_URI] = artifact_uri or ""
    if artifact_uri and not artifact_uri.startswith(prediction_utils.GCS_URI_PREFIX):
        artifact_uri_on_host = Path(artifact_uri).expanduser().resolve()
        if not artifact_uri_on_host.exists():
            raise ValueError(
                "artifact_uri should be specified as either a GCS uri which starts with "
                f"`{prediction_utils.GCS_URI_PREFIX}` or a path to a local directory. "
                f'However, "{artifact_uri_on_host}" does not exist.'
            )

        for mounted_path in artifact_uri_on_host.rglob("*"):
            relative_mounted_path = mounted_path.relative_to(artifact_uri_on_host)
            volumes += [
                f"{mounted_path}:{os.path.join(DEFAULT_MOUNTED_MODEL_DIRECTORY, relative_mounted_path)}"
            ]
        envs[prediction.AIP_STORAGE_URI] = DEFAULT_MOUNTED_MODEL_DIRECTORY

    credential_from_adc_env = credential_path is None
    credential_path = credential_path or _get_adc_environment_variable()
    if credential_path:
        credential_path_on_host = Path(credential_path).expanduser().resolve()
        if not credential_path_on_host.exists() and credential_from_adc_env:
            raise ValueError(
                f"The file from the environment variable {_ADC_ENVIRONMENT_VARIABLE} does "
                f'not exist: "{credential_path}".'
            )
        elif not credential_path_on_host.exists() and not credential_from_adc_env:
            raise ValueError(f'credential_path does not exist: "{credential_path}".')
        credential_mount_path = _DEFAULT_CONTAINER_CRED_KEY_PATH
        volumes = volumes + [f"{credential_path_on_host}:{credential_mount_path}"]
        envs[_ADC_ENVIRONMENT_VARIABLE] = credential_mount_path

    entrypoint = [
        _replace_env_var_reference(i, envs) for i in serving_container_command or []
    ]
    command = [
        _replace_env_var_reference(i, envs) for i in serving_container_args or []
    ]

    device_requests = None
    if gpu_count or gpu_device_ids or gpu_capabilities:
        device_requests = [
            docker.types.DeviceRequest(
                count=gpu_count,
                device_ids=gpu_device_ids,
                capabilities=gpu_capabilities,
            )
        ]

    container = client.containers.run(
        serving_container_image_uri,
        command=command if len(command) > 0 else None,
        entrypoint=entrypoint if len(entrypoint) > 0 else None,
        ports={port: host_port},
        environment=envs,
        volumes=volumes,
        device_requests=device_requests,
        detach=True,
    )

    return container


def print_container_logs(
    container: docker.models.containers.Container,
    start_index: Optional[int] = None,
    message: Optional[str] = None,
) -> int:
    
    if message is not None:
        _logger.info(message)

    logs = container.logs().decode("utf-8").strip().split("\n")
    start_index = 0 if start_index is None else start_index
    for i in range(start_index, len(logs)):
        _logger.info(logs[i])
    return len(logs)
