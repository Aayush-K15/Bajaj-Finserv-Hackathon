
















import json
import logging
import os
from pathlib import Path
import textwrap
from typing import Dict, List, Optional

from shlex import quote

from google.cloud.aiplatform.docker_utils import local_util
from google.cloud.aiplatform.docker_utils.errors import DockerError
from google.cloud.aiplatform.docker_utils.utils import (
    DEFAULT_HOME,
    DEFAULT_WORKDIR,
    Image,
    Package,
)
from google.cloud.aiplatform.utils import path_utils

_logger = logging.getLogger(__name__)


def _generate_copy_command(
    from_path: str, to_path: str, comment: Optional[str] = None
) -> str:
    
    cmd = "COPY {}".format(json.dumps([from_path, to_path]))

    if comment is not None:
        formatted_comment = "\n
        return textwrap.dedent(
            .format(
                formatted_comment,
                cmd,
            )
        )

    return cmd


def _prepare_dependency_entries(
    setup_path: Optional[str] = None,
    requirements_path: Optional[str] = None,
    extra_packages: Optional[List[str]] = None,
    extra_requirements: Optional[List[str]] = None,
    extra_dirs: Optional[List[str]] = None,
    force_reinstall: bool = False,
    pip_command: str = "pip",
) -> str:
    
    ret = ""

    if setup_path is not None:
        ret += _generate_copy_command(
            setup_path,
            "./setup.py",
            comment="setup.py file specified, thus copy it to the docker container.",
        ) + textwrap.dedent(
            .format(
                pip_command,
                "--force-reinstall" if force_reinstall else "",
            )
        )

    if requirements_path is not None:
        ret += textwrap.dedent(
            .format(
                pip_command,
                "--force-reinstall" if force_reinstall else "",
                requirements_path,
            )
        )

    if extra_packages is not None:
        for package in extra_packages:
            ret += textwrap.dedent(
                .format(
                    pip_command,
                    "--force-reinstall" if force_reinstall else "",
                    quote(package),
                )
            )

    if extra_requirements is not None:
        for requirement in extra_requirements:
            ret += textwrap.dedent(
                .format(
                    pip_command,
                    "--force-reinstall" if force_reinstall else "",
                    quote(requirement),
                )
            )

    if extra_dirs is not None:
        for directory in extra_dirs:
            ret += "\n{}\n".format(_generate_copy_command(directory, directory))

    return ret


def _prepare_entrypoint(package: Package, python_command: str = "python") -> str:
    
    exec_str = ""
    
    if package.python_module is not None:
        exec_str = json.dumps([python_command, "-m", package.python_module])
    elif package.script is not None:
        _, ext = os.path.splitext(package.script)
        executable = [python_command] if ext == ".py" else ["/bin/bash"]
        exec_str = json.dumps(executable + [package.script])

    if not exec_str:
        return ""
    return "\nENTRYPOINT {}\n".format(exec_str)


def _copy_source_directory() -> str:
    
    copy_code = _generate_copy_command(
        ".",  
        ".",  
        comment="Copy the source directory into the docker container.",
    )

    return "\n{}\n".format(copy_code)


def _prepare_exposed_ports(exposed_ports: Optional[List[int]] = None) -> str:
    
    ret = ""

    if exposed_ports is None:
        return ret

    for port in exposed_ports:
        ret += "\nEXPOSE {}\n".format(port)
    return ret


def _prepare_environment_variables(
    environment_variables: Optional[Dict[str, str]] = None
) -> str:
    
    ret = ""

    if environment_variables is None:
        return ret

    for key, value in environment_variables.items():
        ret += f"\nENV {key}={value}\n"
    return ret


def _get_relative_path_to_workdir(
    workdir: str,
    path: Optional[str] = None,
    value_name: str = "value",
) -> str:
    
    if path is None:
        return None

    if not Path(path).is_file():
        raise ValueError(f'The {value_name} "{path}" must exist.')
    if not path_utils._is_relative_to(path, workdir):
        raise ValueError(f'The {value_name} "{path}" must be in "{workdir}".')
    abs_path = Path(path).expanduser().resolve()
    abs_workdir = Path(workdir).expanduser().resolve()
    return Path(abs_path).relative_to(abs_workdir).as_posix()


def make_dockerfile(
    base_image: str,
    main_package: Package,
    container_workdir: str,
    container_home: str,
    requirements_path: Optional[str] = None,
    setup_path: Optional[str] = None,
    extra_requirements: Optional[List[str]] = None,
    extra_packages: Optional[List[str]] = None,
    extra_dirs: Optional[List[str]] = None,
    exposed_ports: Optional[List[int]] = None,
    environment_variables: Optional[Dict[str, str]] = None,
    pip_command: str = "pip",
    python_command: str = "python",
) -> str:
    
    dockerfile = textwrap.dedent(
        .format(
            base_image=base_image,
        )
    )

    dockerfile += _prepare_exposed_ports(exposed_ports)

    dockerfile += _prepare_entrypoint(main_package, python_command=python_command)

    dockerfile += textwrap.dedent(
        .format(
            workdir=quote(container_workdir),
            container_home=quote(container_home),
        )
    )

    
    dockerfile += _prepare_dependency_entries(
        requirements_path=None,
        setup_path=None,
        extra_requirements=extra_requirements,
        extra_packages=None,
        extra_dirs=None,
        force_reinstall=True,
        pip_command=pip_command,
    )

    dockerfile += _prepare_environment_variables(
        environment_variables=environment_variables
    )

    
    dockerfile += _copy_source_directory()

    
    dockerfile += _prepare_dependency_entries(
        requirements_path=requirements_path,
        setup_path=None,
        extra_requirements=None,
        extra_packages=None,
        extra_dirs=None,
        force_reinstall=True,
        pip_command=pip_command,
    )

    
    dockerfile += _prepare_dependency_entries(
        requirements_path=None,
        setup_path=setup_path,
        extra_requirements=None,
        extra_packages=extra_packages,
        extra_dirs=extra_dirs,
        force_reinstall=True,
        pip_command=pip_command,
    )

    return dockerfile


def build_image(
    base_image: str,
    host_workdir: str,
    output_image_name: str,
    python_module: Optional[str] = None,
    requirements_path: Optional[str] = None,
    extra_requirements: Optional[List[str]] = None,
    setup_path: Optional[str] = None,
    extra_packages: Optional[List[str]] = None,
    container_workdir: Optional[str] = None,
    container_home: Optional[str] = None,
    extra_dirs: Optional[List[str]] = None,
    exposed_ports: Optional[List[int]] = None,
    pip_command: str = "pip",
    python_command: str = "python",
    no_cache: bool = True,
    platform: Optional[str] = None,
    **kwargs,
) -> Image:
    

    tag_options = ["-t", output_image_name]
    cache_args = ["--no-cache"] if no_cache else []
    platform_args = ["--platform", platform] if platform is not None else []

    command = (
        ["docker", "build"]
        + cache_args
        + platform_args
        + tag_options
        + ["--rm", "-f-", host_workdir]
    )

    requirements_relative_path = _get_relative_path_to_workdir(
        host_workdir,
        path=requirements_path,
        value_name="requirements_path",
    )

    setup_relative_path = _get_relative_path_to_workdir(
        host_workdir,
        path=setup_path,
        value_name="setup_path",
    )

    extra_packages_relative_paths = (
        None
        if extra_packages is None
        else [
            _get_relative_path_to_workdir(
                host_workdir, path=extra_package, value_name="extra_packages"
            )
            for extra_package in extra_packages
            if extra_package is not None
        ]
    )

    home_dir = container_home or DEFAULT_HOME
    work_dir = container_workdir or DEFAULT_WORKDIR

    
    main_package = Package(
        script=None,
        package_path=host_workdir,
        python_module=python_module,
    )

    dockerfile = make_dockerfile(
        base_image,
        main_package,
        work_dir,
        home_dir,
        requirements_path=requirements_relative_path,
        setup_path=setup_relative_path,
        extra_requirements=extra_requirements,
        extra_packages=extra_packages_relative_paths,
        extra_dirs=extra_dirs,
        exposed_ports=exposed_ports,
        pip_command=pip_command,
        python_command=python_command,
        **kwargs,
    )

    joined_command = " ".join(command)
    _logger.info("Running command: {}".format(joined_command))

    return_code = local_util.execute_command(
        command,
        input_str=dockerfile,
    )
    if return_code == 0:
        return Image(output_image_name, home_dir, work_dir)
    else:
        error_msg = textwrap.dedent(
            .format(
                code=return_code, cmd=joined_command
            )
        )
        raise DockerError(error_msg, command, return_code)
