















import re

from typing import Optional, Dict, List
from dataclasses import dataclass


@dataclass
class PredictSchemata:
    

    instance_schema_uri: Optional[str] = None
    parameters_schema_uri: Optional[str] = None
    prediction_schema_uri: Optional[str] = None

    def to_dict(self):
        
        results = {}
        if self.instance_schema_uri:
            results["instanceSchemaUri"] = self.instance_schema_uri
        if self.parameters_schema_uri:
            results["parametersSchemaUri"] = self.parameters_schema_uri
        if self.prediction_schema_uri:
            results["predictionSchemaUri"] = self.prediction_schema_uri

        return results


@dataclass
class ContainerSpec:
    

    image_uri: str
    command: Optional[List[str]] = None
    args: Optional[List[str]] = None
    env: Optional[List[Dict[str, str]]] = None
    ports: Optional[List[int]] = None
    predict_route: Optional[str] = None
    health_route: Optional[str] = None

    def to_dict(self):
        
        results = {}
        results["imageUri"] = self.image_uri
        if self.command:
            results["command"] = self.command
        if self.args:
            results["args"] = self.args
        if self.env:
            results["env"] = self.env
        if self.ports:
            results["ports"] = self.ports
        if self.predict_route:
            results["predictRoute"] = self.predict_route
        if self.health_route:
            results["healthRoute"] = self.health_route

        return results


@dataclass
class AnnotationSpec:
    

    display_name: Optional[str] = None
    id: Optional[str] = None

    def to_dict(self):
        
        results = {}
        if self.display_name:
            results["displayName"] = self.display_name
        if self.id:
            results["id"] = self.id

        return results


@dataclass
class ConfusionMatrix:
    

    matrix: List[List[int]]
    annotation_specs: Optional[List[AnnotationSpec]] = None

    def to_dict(self):
        
        results = {}
        if self.annotation_specs:
            if len(self.annotation_specs) != len(self.matrix):
                raise ValueError(
                    "Length of annotation_specs and matrix must be the same. "
                    "Got lengths {} and {} respectively.".format(
                        len(self.annotation_specs), len(self.matrix)
                    )
                )
            results["annotationSpecs"] = [
                annotation_spec.to_dict() for annotation_spec in self.annotation_specs
            ]
        if self.matrix:
            results["rows"] = self.matrix

        return results


@dataclass
class ConfidenceMetric:
    

    confidence_threshold: float
    recall: Optional[float] = None
    precision: Optional[float] = None
    f1_score: Optional[float] = None
    max_predictions: Optional[int] = None
    false_positive_rate: Optional[float] = None
    accuracy: Optional[float] = None
    true_positive_count: Optional[int] = None
    false_positive_count: Optional[int] = None
    false_negative_count: Optional[int] = None
    true_negative_count: Optional[int] = None
    recall_at_1: Optional[float] = None
    precision_at_1: Optional[float] = None
    false_positive_rate_at_1: Optional[float] = None
    f1_score_at_1: Optional[float] = None
    confusion_matrix: Optional[ConfusionMatrix] = None

    def to_dict(self):
        
        results = {}
        results["confidenceThreshold"] = self.confidence_threshold
        if self.recall is not None:
            results["recall"] = self.recall
        if self.precision is not None:
            results["precision"] = self.precision
        if self.f1_score is not None:
            results["f1Score"] = self.f1_score
        if self.max_predictions is not None:
            results["maxPredictions"] = self.max_predictions
        if self.false_positive_rate is not None:
            results["falsePositiveRate"] = self.false_positive_rate
        if self.accuracy is not None:
            results["accuracy"] = self.accuracy
        if self.true_positive_count is not None:
            results["truePositiveCount"] = self.true_positive_count
        if self.false_positive_count is not None:
            results["falsePositiveCount"] = self.false_positive_count
        if self.false_negative_count is not None:
            results["falseNegativeCount"] = self.false_negative_count
        if self.true_negative_count is not None:
            results["trueNegativeCount"] = self.true_negative_count
        if self.recall_at_1 is not None:
            results["recallAt1"] = self.recall_at_1
        if self.precision_at_1 is not None:
            results["precisionAt1"] = self.precision_at_1
        if self.false_positive_rate_at_1 is not None:
            results["falsePositiveRateAt1"] = self.false_positive_rate_at_1
        if self.f1_score_at_1 is not None:
            results["f1ScoreAt1"] = self.f1_score_at_1
        if self.confusion_matrix:
            results["confusionMatrix"] = self.confusion_matrix.to_dict()

        return results


def create_uri_from_resource_name(resource_name: str) -> str:
    
    
    match_results = re.match(
        r"^projects\/(?P<project>[\w-]+)\/locations\/(?P<location>[\w-]+)(\/metadataStores\/(?P<store>[\w-]+))?\/[\w-]+\/(?P<id>[\w-]+)(?P<version>@[\w-]+)?$",
        resource_name,
    )
    if not match_results:
        raise ValueError(f"Invalid resource_name format for {resource_name}.")

    location = match_results["location"]
    return f"https://{location}-aiplatform.googleapis.com/v1/{resource_name}"
