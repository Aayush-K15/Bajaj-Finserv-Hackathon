
















import abc

from typing import Any, Dict, List, Optional, Union

from google.auth import credentials as auth_credentials

from google.cloud.aiplatform import models
from google.cloud.aiplatform.compat.types import execution as gca_execution
from google.cloud.aiplatform.constants import base as base_constants
from google.cloud.aiplatform.metadata import artifact
from google.cloud.aiplatform.metadata import constants
from google.cloud.aiplatform.metadata import execution
from google.cloud.aiplatform.metadata import metadata


class BaseExecutionSchema(execution.Execution):
    

    @property
    @classmethod
    @abc.abstractmethod
    def schema_title(cls) -> str:
        
        pass

    def __init__(
        self,
        *,
        state: Optional[
            gca_execution.Execution.State
        ] = gca_execution.Execution.State.RUNNING,
        execution_id: Optional[str] = None,
        display_name: Optional[str] = None,
        schema_version: Optional[str] = None,
        metadata: Optional[Dict] = None,
        description: Optional[str] = None,
    ):

        
        
        self._exception = None
        
        
        
        self.execution_id = execution_id

        
        self._gca_resource = gca_execution.Execution()
        self._gca_resource.state = state
        self._gca_resource.display_name = display_name
        self._gca_resource.schema_version = (
            schema_version or constants._DEFAULT_SCHEMA_VERSION
        )
        
        metadata = metadata if metadata else {}
        self._nested_update_metadata(self._gca_resource, metadata)
        self._gca_resource.description = description

    
    def _init_with_resource_name(
        self,
        *,
        execution_name: str,
    ):

        
        
        
        if not base_constants.USER_AGENT_SDK_COMMAND:
            base_constants.USER_AGENT_SDK_COMMAND = "aiplatform.metadata.schema.base_execution.BaseExecutionSchema._init_with_resource_name"

        super(BaseExecutionSchema, self).__init__(execution_name=execution_name)

    def create(
        self,
        *,
        metadata_store_id: Optional[str] = "default",
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ) -> "execution.Execution":
        
        
        
        base_constants.USER_AGENT_SDK_COMMAND = (
            "aiplatform.metadata.schema.base_execution.BaseExecutionSchema.create"
        )

        
        metadata = None
        if self._gca_resource.metadata:
            metadata = self.metadata

        new_execution_instance = execution.Execution.create(
            resource_id=self.execution_id,
            schema_title=self.schema_title,
            display_name=self.display_name,
            schema_version=self.schema_version,
            description=self.description,
            metadata=metadata,
            state=self.state,
            metadata_store_id=metadata_store_id,
            project=project,
            location=location,
            credentials=credentials,
        )
        
        self._init_with_resource_name(
            execution_name=new_execution_instance.resource_name
        )
        return self

    @classmethod
    def list(
        cls,
        filter: Optional[str] = None,  
        metadata_store_id: str = "default",
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
        order_by: Optional[str] = None,
    ) -> List["BaseExecutionSchema"]:
        
        schema_filter = f'schema_title="{cls.schema_title}"'
        if filter:
            filter = f"{filter} AND {schema_filter}"
        else:
            filter = schema_filter

        return super().list(
            filter=filter,
            metadata_store_id=metadata_store_id,
            project=project,
            location=location,
            credentials=credentials,
        )

    def start_execution(
        self,
        *,
        metadata_store_id: Optional[str] = "default",
        resume: bool = False,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ) -> "execution.Execution":
        
        
        

        base_constants.USER_AGENT_SDK_COMMAND = "aiplatform.metadata.schema.base_execution.BaseExecutionSchema.start_execution"

        if metadata_store_id != "default":
            raise ValueError(
                f"metadata_store_id {metadata_store_id} is not supported. Only the default MetadataStore ID is supported."
            )

        new_execution_instance = metadata._ExperimentTracker().start_execution(
            schema_title=self.schema_title,
            display_name=self.display_name,
            resource_id=self.execution_id,
            metadata=self.metadata,
            schema_version=self.schema_version,
            description=self.description,
            
            resume=resume,
            project=project,
            location=location,
            credentials=credentials,
        )

        
        self._init_with_resource_name(
            execution_name=new_execution_instance.resource_name
        )
        return self

    def assign_input_artifacts(
        self, artifacts: List[Union[artifact.Artifact, models.Model]]
    ):
        
        if self._gca_resource.name:
            super().assign_input_artifacts(artifacts)
        else:
            raise RuntimeError(
                f"{self.__class__.__name__} resource has not been created."
            )

    def assign_output_artifacts(
        self, artifacts: List[Union[artifact.Artifact, models.Model]]
    ):
        
        if self._gca_resource.name:
            super().assign_output_artifacts(artifacts)
        else:
            raise RuntimeError(
                f"{self.__class__.__name__} resource has not been created."
            )

    def get_input_artifacts(self) -> List[artifact.Artifact]:
        
        if self._gca_resource.name:
            return super().get_input_artifacts()
        else:
            raise RuntimeError(
                f"{self.__class__.__name__} resource has not been created."
            )

    def get_output_artifacts(self) -> List[artifact.Artifact]:
        
        if self._gca_resource.name:
            return super().get_output_artifacts()
        else:
            raise RuntimeError(
                f"{self.__class__.__name__} resource has not been created."
            )

    def update(
        self,
        state: Optional[gca_execution.Execution.State] = None,
        description: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ):
        
        if self._gca_resource.name:
            super().update(
                state=state,
                description=description,
                metadata=metadata,
            )
        else:
            raise RuntimeError(
                f"{self.__class__.__name__} resource has not been created."
            )

    def __repr__(self) -> str:
        if self._gca_resource.name:
            return super().__repr__()
        else:
            return f"{object.__repr__(self)}\nschema_title: {self.schema_title}"
