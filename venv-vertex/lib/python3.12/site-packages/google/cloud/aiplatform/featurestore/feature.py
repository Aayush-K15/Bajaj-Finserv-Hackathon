
















from typing import Dict, List, Optional, Sequence, Tuple

from google.auth import credentials as auth_credentials
from google.protobuf import field_mask_pb2

from google.cloud.aiplatform import base
from google.cloud.aiplatform.compat.types import feature as gca_feature
from google.cloud.aiplatform import featurestore
from google.cloud.aiplatform import initializer
from google.cloud.aiplatform import utils
from google.cloud.aiplatform.utils import featurestore_utils

_LOGGER = base.Logger(__name__)


class Feature(base.VertexAiResourceNounWithFutureManager):
    

    client_class = utils.FeaturestoreClientWithOverride

    _resource_noun = "features"
    _getter_method = "get_feature"
    _list_method = "list_features"
    _delete_method = "delete_feature"
    _parse_resource_name_method = "parse_feature_path"
    _format_resource_name_method = "feature_path"

    @staticmethod
    def _resource_id_validator(resource_id: str):
        
        featurestore_utils.validate_feature_id(resource_id)

    def __init__(
        self,
        feature_name: str,
        featurestore_id: Optional[str] = None,
        entity_type_id: Optional[str] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ):
        

        if bool(featurestore_id) != bool(entity_type_id):
            raise ValueError(
                "featurestore_id and entity_type_id must both be provided or ommitted."
            )

        super().__init__(
            project=project,
            location=location,
            credentials=credentials,
            resource_name=feature_name,
        )
        self._gca_resource = self._get_gca_resource(
            resource_name=feature_name,
            parent_resource_name_fields={
                featurestore.Featurestore._resource_noun: featurestore_id,
                featurestore.EntityType._resource_noun: entity_type_id,
            }
            if featurestore_id
            else featurestore_id,
        )

    def _get_featurestore_name(self) -> str:
        
        feature_path_components = self._parse_resource_name(self.resource_name)
        return featurestore.Featurestore._format_resource_name(
            project=feature_path_components["project"],
            location=feature_path_components["location"],
            featurestore=feature_path_components["featurestore"],
        )

    @property
    def featurestore_name(self) -> str:
        
        self.wait()
        return self._get_featurestore_name()

    def get_featurestore(self) -> "featurestore.Featurestore":
        
        return featurestore.Featurestore(featurestore_name=self.featurestore_name)

    def _get_entity_type_name(self) -> str:
        
        feature_path_components = self._parse_resource_name(self.resource_name)
        return featurestore.EntityType._format_resource_name(
            project=feature_path_components["project"],
            location=feature_path_components["location"],
            featurestore=feature_path_components["featurestore"],
            entity_type=feature_path_components["entity_type"],
        )

    @property
    def entity_type_name(self) -> str:
        
        self.wait()
        return self._get_entity_type_name()

    def get_entity_type(self) -> "featurestore.EntityType":
        
        return featurestore.EntityType(entity_type_name=self.entity_type_name)

    def update(
        self,
        description: Optional[str] = None,
        labels: Optional[Dict[str, str]] = None,
        request_metadata: Optional[Sequence[Tuple[str, str]]] = (),
        update_request_timeout: Optional[float] = None,
    ) -> "Feature":
        
        self.wait()
        update_mask = list()

        if description:
            update_mask.append("description")

        if labels:
            utils.validate_labels(labels)
            update_mask.append("labels")

        update_mask = field_mask_pb2.FieldMask(paths=update_mask)

        gapic_feature = gca_feature.Feature(
            name=self.resource_name,
            description=description,
            labels=labels,
        )

        _LOGGER.log_action_start_against_resource(
            "Updating",
            "feature",
            self,
        )

        self._gca_resource = self.api_client.update_feature(
            feature=gapic_feature,
            update_mask=update_mask,
            metadata=request_metadata,
            timeout=update_request_timeout,
        )
        return self

    @classmethod
    def list(
        cls,
        entity_type_name: str,
        featurestore_id: Optional[str] = None,
        filter: Optional[str] = None,
        order_by: Optional[str] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ) -> List["Feature"]:
        

        return cls._list(
            filter=filter,
            order_by=order_by,
            project=project,
            location=location,
            credentials=credentials,
            parent=utils.full_resource_name(
                resource_name=entity_type_name,
                resource_noun=featurestore.EntityType._resource_noun,
                parse_resource_name_method=featurestore.EntityType._parse_resource_name,
                format_resource_name_method=featurestore.EntityType._format_resource_name,
                parent_resource_name_fields={
                    featurestore.Featurestore._resource_noun: featurestore_id
                }
                if featurestore_id
                else featurestore_id,
                project=project,
                location=location,
                resource_id_validator=featurestore.EntityType._resource_id_validator,
            ),
        )

    @classmethod
    def search(
        cls,
        query: Optional[str] = None,
        page_size: Optional[int] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ) -> List["Feature"]:
        
        resource = cls._empty_constructor(
            project=project, location=location, credentials=credentials
        )

        
        creds = resource.credentials

        search_features_request = {
            "location": initializer.global_config.common_location_path(
                project=project, location=location
            ),
            "query": query,
        }

        if page_size:
            search_features_request["page_size"] = page_size

        resource_list = (
            resource.api_client.search_features(request=search_features_request) or []
        )

        return [
            cls._construct_sdk_resource_from_gapic(
                gapic_resource, project=project, location=location, credentials=creds
            )
            for gapic_resource in resource_list
        ]

    @classmethod
    @base.optional_sync()
    def create(
        cls,
        feature_id: str,
        value_type: str,
        entity_type_name: str,
        featurestore_id: Optional[str] = None,
        description: Optional[str] = None,
        labels: Optional[Dict[str, str]] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
        request_metadata: Optional[Sequence[Tuple[str, str]]] = (),
        sync: bool = True,
        create_request_timeout: Optional[float] = None,
    ) -> "Feature":
        
        entity_type_name = utils.full_resource_name(
            resource_name=entity_type_name,
            resource_noun=featurestore.EntityType._resource_noun,
            parse_resource_name_method=featurestore.EntityType._parse_resource_name,
            format_resource_name_method=featurestore.EntityType._format_resource_name,
            parent_resource_name_fields={
                featurestore.Featurestore._resource_noun: featurestore_id
            }
            if featurestore_id
            else featurestore_id,
            project=project,
            location=location,
            resource_id_validator=featurestore.EntityType._resource_id_validator,
        )
        entity_type_name_components = featurestore.EntityType._parse_resource_name(
            entity_type_name
        )

        feature_config = featurestore_utils._FeatureConfig(
            feature_id=feature_id,
            value_type=value_type,
            description=description,
            labels=labels,
        )

        create_feature_request = feature_config.get_create_feature_request()
        create_feature_request.parent = entity_type_name

        api_client = cls._instantiate_client(
            location=entity_type_name_components["location"],
            credentials=credentials,
        )

        created_feature_lro = api_client.create_feature(
            request=create_feature_request,
            metadata=request_metadata,
            timeout=create_request_timeout,
        )

        _LOGGER.log_create_with_lro(cls, created_feature_lro)

        created_feature = created_feature_lro.result()

        _LOGGER.log_create_complete(cls, created_feature, "feature")

        feature_obj = cls(
            feature_name=created_feature.name,
            project=project,
            location=location,
            credentials=credentials,
        )

        return feature_obj
