
















from typing import Dict, List, Optional, Sequence, Tuple, Union

from google.auth import credentials as auth_credentials
from google.protobuf import field_mask_pb2
from google.protobuf import timestamp_pb2

from google.cloud.aiplatform import base
from google.cloud.aiplatform import initializer
from google.cloud.aiplatform import utils
from google.cloud.aiplatform.compat.types import (
    tensorboard as gca_tensorboard,
)
from google.cloud.aiplatform.compat.types import (
    tensorboard_data as gca_tensorboard_data,
)
from google.cloud.aiplatform.compat.types import (
    tensorboard_experiment as gca_tensorboard_experiment,
)
from google.cloud.aiplatform.compat.types import (
    tensorboard_run as gca_tensorboard_run,
)
from google.cloud.aiplatform.compat.types import (
    tensorboard_service as gca_tensorboard_service,
)
from google.cloud.aiplatform.compat.types import (
    tensorboard_time_series as gca_tensorboard_time_series,
)

_LOGGER = base.Logger(__name__)


class _TensorboardServiceResource(base.VertexAiResourceNounWithFutureManager):
    client_class = utils.TensorboardClientWithOverride


class Tensorboard(_TensorboardServiceResource):
    

    _resource_noun = "tensorboards"
    _getter_method = "get_tensorboard"
    _list_method = "list_tensorboards"
    _delete_method = "delete_tensorboard"
    _parse_resource_name_method = "parse_tensorboard_path"
    _format_resource_name_method = "tensorboard_path"

    def __init__(
        self,
        tensorboard_name: str,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ):
        

        super().__init__(
            project=project,
            location=location,
            credentials=credentials,
            resource_name=tensorboard_name,
        )
        self._gca_resource = self._get_gca_resource(resource_name=tensorboard_name)

    @classmethod
    def create(
        cls,
        display_name: Optional[str] = None,
        description: Optional[str] = None,
        labels: Optional[Dict[str, str]] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
        request_metadata: Optional[Sequence[Tuple[str, str]]] = (),
        encryption_spec_key_name: Optional[str] = None,
        create_request_timeout: Optional[float] = None,
        is_default: bool = False,
    ) -> "Tensorboard":
        
        if not display_name:
            display_name = cls._generate_display_name()

        utils.validate_display_name(display_name)
        if labels:
            utils.validate_labels(labels)

        api_client = cls._instantiate_client(location=location, credentials=credentials)

        parent = initializer.global_config.common_location_path(
            project=project, location=location
        )

        encryption_spec = initializer.global_config.get_encryption_spec(
            encryption_spec_key_name=encryption_spec_key_name
        )

        gapic_tensorboard = gca_tensorboard.Tensorboard(
            display_name=display_name,
            description=description,
            labels=labels,
            is_default=is_default,
            encryption_spec=encryption_spec,
        )

        create_tensorboard_lro = api_client.create_tensorboard(
            parent=parent,
            tensorboard=gapic_tensorboard,
            metadata=request_metadata,
            timeout=create_request_timeout,
        )

        _LOGGER.log_create_with_lro(cls, create_tensorboard_lro)

        created_tensorboard = create_tensorboard_lro.result()

        _LOGGER.log_create_complete(cls, created_tensorboard, "tb")

        return cls(
            tensorboard_name=created_tensorboard.name,
            credentials=credentials,
        )

    def update(
        self,
        display_name: Optional[str] = None,
        description: Optional[str] = None,
        labels: Optional[Dict[str, str]] = None,
        request_metadata: Optional[Sequence[Tuple[str, str]]] = (),
        encryption_spec_key_name: Optional[str] = None,
        is_default: Optional[bool] = None,
    ) -> "Tensorboard":
        
        update_mask = list()

        if display_name:
            utils.validate_display_name(display_name)
            update_mask.append("display_name")

        if description:
            update_mask.append("description")

        if labels:
            utils.validate_labels(labels)
            update_mask.append("labels")

        if is_default is not None:
            update_mask.append("is_default")

        encryption_spec = None
        if encryption_spec_key_name:
            encryption_spec = initializer.global_config.get_encryption_spec(
                encryption_spec_key_name=encryption_spec_key_name,
            )
            update_mask.append("encryption_spec")

        update_mask = field_mask_pb2.FieldMask(paths=update_mask)

        gapic_tensorboard = gca_tensorboard.Tensorboard(
            name=self.resource_name,
            display_name=display_name,
            description=description,
            labels=labels,
            is_default=is_default,
            encryption_spec=encryption_spec,
        )

        _LOGGER.log_action_start_against_resource(
            "Updating",
            "tensorboard",
            self,
        )

        update_tensorboard_lro = self.api_client.update_tensorboard(
            tensorboard=gapic_tensorboard,
            update_mask=update_mask,
            metadata=request_metadata,
        )

        _LOGGER.log_action_started_against_resource_with_lro(
            "Update", "tensorboard", self.__class__, update_tensorboard_lro
        )

        update_tensorboard_lro.result()

        _LOGGER.log_action_completed_against_resource("tensorboard", "updated", self)

        return self


class TensorboardExperiment(_TensorboardServiceResource):
    

    _resource_noun = "experiments"
    _getter_method = "get_tensorboard_experiment"
    _list_method = "list_tensorboard_experiments"
    _delete_method = "delete_tensorboard_experiment"
    _parse_resource_name_method = "parse_tensorboard_experiment_path"
    _format_resource_name_method = "tensorboard_experiment_path"

    def __init__(
        self,
        tensorboard_experiment_name: str,
        tensorboard_id: Optional[str] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ):
        

        super().__init__(
            project=project,
            location=location,
            credentials=credentials,
            resource_name=tensorboard_experiment_name,
        )
        self._gca_resource = self._get_gca_resource(
            resource_name=tensorboard_experiment_name,
            parent_resource_name_fields={Tensorboard._resource_noun: tensorboard_id}
            if tensorboard_id
            else tensorboard_id,
        )

    @classmethod
    def create(
        cls,
        tensorboard_experiment_id: str,
        tensorboard_name: str,
        display_name: Optional[str] = None,
        description: Optional[str] = None,
        labels: Optional[Dict[str, str]] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
        request_metadata: Sequence[Tuple[str, str]] = (),
        create_request_timeout: Optional[float] = None,
    ) -> "TensorboardExperiment":
        

        if display_name:
            utils.validate_display_name(display_name)

        if labels:
            utils.validate_labels(labels)

        api_client = cls._instantiate_client(location=location, credentials=credentials)

        parent = utils.full_resource_name(
            resource_name=tensorboard_name,
            resource_noun=Tensorboard._resource_noun,
            parse_resource_name_method=Tensorboard._parse_resource_name,
            format_resource_name_method=Tensorboard._format_resource_name,
            project=project,
            location=location,
        )

        gapic_tensorboard_experiment = gca_tensorboard_experiment.TensorboardExperiment(
            display_name=display_name,
            description=description,
            labels=labels,
        )

        _LOGGER.log_create_with_lro(cls)

        tensorboard_experiment = api_client.create_tensorboard_experiment(
            parent=parent,
            tensorboard_experiment=gapic_tensorboard_experiment,
            tensorboard_experiment_id=tensorboard_experiment_id,
            metadata=request_metadata,
            timeout=create_request_timeout,
        )

        _LOGGER.log_create_complete(cls, tensorboard_experiment, "tb experiment")

        return cls(
            tensorboard_experiment_name=tensorboard_experiment.name,
            credentials=credentials,
        )

    @classmethod
    def list(
        cls,
        tensorboard_name: str,
        filter: Optional[str] = None,
        order_by: Optional[str] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ) -> List["TensorboardExperiment"]:
        

        parent = utils.full_resource_name(
            resource_name=tensorboard_name,
            resource_noun=Tensorboard._resource_noun,
            parse_resource_name_method=Tensorboard._parse_resource_name,
            format_resource_name_method=Tensorboard._format_resource_name,
            project=project,
            location=location,
        )

        return super()._list(
            filter=filter,
            order_by=order_by,
            project=project,
            location=location,
            credentials=credentials,
            parent=parent,
        )


class TensorboardRun(_TensorboardServiceResource):
    

    _resource_noun = "runs"
    _getter_method = "get_tensorboard_run"
    _list_method = "list_tensorboard_runs"
    _delete_method = "delete_tensorboard_run"
    _parse_resource_name_method = "parse_tensorboard_run_path"
    _format_resource_name_method = "tensorboard_run_path"
    READ_TIME_SERIES_BATCH_SIZE = 20

    def __init__(
        self,
        tensorboard_run_name: str,
        tensorboard_id: Optional[str] = None,
        tensorboard_experiment_id: Optional[str] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ):
        
        if bool(tensorboard_id) != bool(tensorboard_experiment_id):
            raise ValueError(
                "Both tensorboard_id and tensorboard_experiment_id must be provided or neither should be provided."
            )

        super().__init__(
            project=project,
            location=location,
            credentials=credentials,
            resource_name=tensorboard_run_name,
        )
        self._gca_resource = self._get_gca_resource(
            resource_name=tensorboard_run_name,
            parent_resource_name_fields={
                Tensorboard._resource_noun: tensorboard_id,
                TensorboardExperiment._resource_noun: tensorboard_experiment_id,
            }
            if tensorboard_id
            else tensorboard_id,
        )

        self._time_series_display_name_to_id_mapping = (
            self._get_time_series_display_name_to_id_mapping()
        )

    @classmethod
    def create(
        cls,
        tensorboard_run_id: str,
        tensorboard_experiment_name: str,
        tensorboard_id: Optional[str] = None,
        display_name: Optional[str] = None,
        description: Optional[str] = None,
        labels: Optional[Dict[str, str]] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
        request_metadata: Sequence[Tuple[str, str]] = (),
        create_request_timeout: Optional[float] = None,
    ) -> "TensorboardRun":
        
        if display_name:
            utils.validate_display_name(display_name)

        if labels:
            utils.validate_labels(labels)

        display_name = display_name or tensorboard_run_id

        api_client = cls._instantiate_client(location=location, credentials=credentials)

        parent = utils.full_resource_name(
            resource_name=tensorboard_experiment_name,
            resource_noun=TensorboardExperiment._resource_noun,
            parse_resource_name_method=TensorboardExperiment._parse_resource_name,
            format_resource_name_method=TensorboardExperiment._format_resource_name,
            parent_resource_name_fields={Tensorboard._resource_noun: tensorboard_id},
            project=project,
            location=location,
        )

        gapic_tensorboard_run = gca_tensorboard_run.TensorboardRun(
            display_name=display_name,
            description=description,
            labels=labels,
        )

        _LOGGER.log_create_with_lro(cls)

        tensorboard_run = api_client.create_tensorboard_run(
            parent=parent,
            tensorboard_run=gapic_tensorboard_run,
            tensorboard_run_id=tensorboard_run_id,
            metadata=request_metadata,
            timeout=create_request_timeout,
        )

        _LOGGER.log_create_complete(cls, tensorboard_run, "tb_run")

        return cls(
            tensorboard_run_name=tensorboard_run.name,
            credentials=credentials,
        )

    @classmethod
    def list(
        cls,
        tensorboard_experiment_name: str,
        tensorboard_id: Optional[str] = None,
        filter: Optional[str] = None,
        order_by: Optional[str] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ) -> List["TensorboardRun"]:
        

        parent = utils.full_resource_name(
            resource_name=tensorboard_experiment_name,
            resource_noun=TensorboardExperiment._resource_noun,
            parse_resource_name_method=TensorboardExperiment._parse_resource_name,
            format_resource_name_method=TensorboardExperiment._format_resource_name,
            parent_resource_name_fields={Tensorboard._resource_noun: tensorboard_id},
            project=project,
            location=location,
        )

        tensorboard_runs = super()._list(
            filter=filter,
            order_by=order_by,
            project=project,
            location=location,
            credentials=credentials,
            parent=parent,
        )

        for tensorboard_run in tensorboard_runs:
            tensorboard_run._sync_time_series_display_name_to_id_mapping()

        return tensorboard_runs

    def write_tensorboard_scalar_data(
        self,
        time_series_data: Dict[str, float],
        step: int,
        wall_time: Optional[timestamp_pb2.Timestamp] = None,
    ):
        

        if not wall_time:
            wall_time = utils.get_timestamp_proto()

        ts_data = []

        if any(
            key not in self._time_series_display_name_to_id_mapping
            for key in time_series_data.keys()
        ):
            self._sync_time_series_display_name_to_id_mapping()

        for display_name, value in time_series_data.items():
            time_series_id = self._time_series_display_name_to_id_mapping.get(
                display_name
            )

            if not time_series_id:
                raise RuntimeError(
                    f"TensorboardTimeSeries with display name {display_name} has not been created in TensorboardRun {self.resource_name}."
                )

            ts_data.append(
                gca_tensorboard_data.TimeSeriesData(
                    tensorboard_time_series_id=time_series_id,
                    value_type=gca_tensorboard_time_series.TensorboardTimeSeries.ValueType.SCALAR,
                    values=[
                        gca_tensorboard_data.TimeSeriesDataPoint(
                            scalar=gca_tensorboard_data.Scalar(value=value),
                            wall_time=wall_time,
                            step=step,
                        )
                    ],
                )
            )

        self.api_client.write_tensorboard_run_data(
            tensorboard_run=self.resource_name, time_series_data=ts_data
        )

    def _get_time_series_display_name_to_id_mapping(self) -> Dict[str, str]:
        
        time_series = TensorboardTimeSeries.list(
            tensorboard_run_name=self.resource_name, credentials=self.credentials
        )

        return {ts.display_name: ts.name for ts in time_series}

    def _sync_time_series_display_name_to_id_mapping(self):
        
        self._time_series_display_name_to_id_mapping = (
            self._get_time_series_display_name_to_id_mapping()
        )

    def create_tensorboard_time_series(
        self,
        display_name: str,
        value_type: Union[
            gca_tensorboard_time_series.TensorboardTimeSeries.ValueType, str
        ] = "SCALAR",
        plugin_name: str = "scalars",
        plugin_data: Optional[bytes] = None,
        description: Optional[str] = None,
    ) -> "TensorboardTimeSeries":
        

        tb_time_series = TensorboardTimeSeries.create(
            display_name=display_name,
            tensorboard_run_name=self.resource_name,
            value_type=value_type,
            plugin_name=plugin_name,
            plugin_data=plugin_data,
            description=description,
            credentials=self.credentials,
        )

        self._time_series_display_name_to_id_mapping[
            tb_time_series.display_name
        ] = tb_time_series.name

        return tb_time_series

    def read_time_series_data(self) -> Dict[str, gca_tensorboard_data.TimeSeriesData]:
        
        self._sync_time_series_display_name_to_id_mapping()

        resource_name_parts = self._parse_resource_name(self.resource_name)
        inverted_mapping = {
            resource_id: display_name
            for display_name, resource_id in self._time_series_display_name_to_id_mapping.items()
        }

        time_series_resource_names = [
            TensorboardTimeSeries._format_resource_name(
                time_series=resource_id, **resource_name_parts
            )
            for resource_id in inverted_mapping.keys()
        ]

        resource_name_parts.pop("experiment")
        resource_name_parts.pop("run")

        tensorboard_resource_name = Tensorboard._format_resource_name(
            **resource_name_parts
        )

        batch_size = self.READ_TIME_SERIES_BATCH_SIZE
        time_series_data_dict = {}
        for i in range(0, len(time_series_resource_names), batch_size):
            one_batch_time_series_names = time_series_resource_names[i : i + batch_size]
            read_response = self.api_client.batch_read_tensorboard_time_series_data(
                request=gca_tensorboard_service.BatchReadTensorboardTimeSeriesDataRequest(
                    tensorboard=tensorboard_resource_name,
                    time_series=one_batch_time_series_names,
                )
            )

            time_series_data_dict.update(
                {
                    inverted_mapping[data.tensorboard_time_series_id]: data
                    for data in read_response.time_series_data
                }
            )
        return time_series_data_dict


class TensorboardTimeSeries(_TensorboardServiceResource):
    

    _resource_noun = "timeSeries"
    _getter_method = "get_tensorboard_time_series"
    _list_method = "list_tensorboard_time_series"
    _delete_method = "delete_tensorboard_time_series"
    _parse_resource_name_method = "parse_tensorboard_time_series_path"
    _format_resource_name_method = "tensorboard_time_series_path"

    def __init__(
        self,
        tensorboard_time_series_name: str,
        tensorboard_id: Optional[str] = None,
        tensorboard_experiment_id: Optional[str] = None,
        tensorboard_run_id: Optional[str] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ):
        
        if not (
            bool(tensorboard_id)
            == bool(tensorboard_experiment_id)
            == bool(tensorboard_run_id)
        ):
            raise ValueError(
                "tensorboard_id, tensorboard_experiment_id, tensorboard_run_id must all be provided or none should be provided."
            )

        super().__init__(
            project=project,
            location=location,
            credentials=credentials,
            resource_name=tensorboard_time_series_name,
        )
        self._gca_resource = self._get_gca_resource(
            resource_name=tensorboard_time_series_name,
            parent_resource_name_fields={
                Tensorboard._resource_noun: tensorboard_id,
                TensorboardExperiment._resource_noun: tensorboard_experiment_id,
                TensorboardRun._resource_noun: tensorboard_run_id,
            }
            if tensorboard_id
            else tensorboard_id,
        )

    @classmethod
    def create(
        cls,
        display_name: str,
        tensorboard_run_name: str,
        tensorboard_id: Optional[str] = None,
        tensorboard_experiment_id: Optional[str] = None,
        value_type: Union[
            gca_tensorboard_time_series.TensorboardTimeSeries.ValueType, str
        ] = "SCALAR",
        plugin_name: str = "scalars",
        plugin_data: Optional[bytes] = None,
        description: Optional[str] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ) -> "TensorboardTimeSeries":
        

        if isinstance(value_type, str):
            value_type = getattr(
                gca_tensorboard_time_series.TensorboardTimeSeries.ValueType, value_type
            )

        api_client = cls._instantiate_client(location=location, credentials=credentials)

        parent = utils.full_resource_name(
            resource_name=tensorboard_run_name,
            resource_noun=TensorboardRun._resource_noun,
            parse_resource_name_method=TensorboardRun._parse_resource_name,
            format_resource_name_method=TensorboardRun._format_resource_name,
            parent_resource_name_fields={
                Tensorboard._resource_noun: tensorboard_id,
                TensorboardExperiment._resource_noun: tensorboard_experiment_id,
            },
            project=project,
            location=location,
        )

        gapic_tensorboard_time_series = (
            gca_tensorboard_time_series.TensorboardTimeSeries(
                display_name=display_name,
                description=description,
                value_type=value_type,
                plugin_name=plugin_name,
                plugin_data=plugin_data,
            )
        )

        _LOGGER.log_create_with_lro(cls)

        tensorboard_time_series = api_client.create_tensorboard_time_series(
            parent=parent, tensorboard_time_series=gapic_tensorboard_time_series
        )

        _LOGGER.log_create_complete(cls, tensorboard_time_series, "tb_time_series")

        self = cls._empty_constructor(
            project=project, location=location, credentials=credentials
        )
        self._gca_resource = tensorboard_time_series

        return self

    @classmethod
    def list(
        cls,
        tensorboard_run_name: str,
        tensorboard_id: Optional[str] = None,
        tensorboard_experiment_id: Optional[str] = None,
        filter: Optional[str] = None,
        order_by: Optional[str] = None,
        project: Optional[str] = None,
        location: Optional[str] = None,
        credentials: Optional[auth_credentials.Credentials] = None,
    ) -> List["TensorboardTimeSeries"]:
        

        parent = utils.full_resource_name(
            resource_name=tensorboard_run_name,
            resource_noun=TensorboardRun._resource_noun,
            parse_resource_name_method=TensorboardRun._parse_resource_name,
            format_resource_name_method=TensorboardRun._format_resource_name,
            parent_resource_name_fields={
                Tensorboard._resource_noun: tensorboard_id,
                TensorboardExperiment._resource_noun: tensorboard_experiment_id,
            },
            project=project,
            location=location,
        )

        return super()._list(
            filter=filter,
            order_by=order_by,
            project=project,
            location=location,
            credentials=credentials,
            parent=parent,
        )
