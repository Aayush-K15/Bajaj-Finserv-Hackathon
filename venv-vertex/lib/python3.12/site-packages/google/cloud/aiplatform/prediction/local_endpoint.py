
















import logging
from pathlib import Path
import requests
import time
from typing import Any, Dict, List, Optional, Sequence

from google.auth.exceptions import GoogleAuthError

from google.cloud.aiplatform import initializer
from google.cloud.aiplatform.constants import prediction
from google.cloud.aiplatform.docker_utils import run
from google.cloud.aiplatform.docker_utils.errors import DockerError
from google.cloud.aiplatform.utils import prediction_utils

_logger = logging.getLogger(__name__)

_DEFAULT_CONTAINER_READY_TIMEOUT = 300
_DEFAULT_CONTAINER_READY_CHECK_INTERVAL = 1

_GCLOUD_PROJECT_ENV = "GOOGLE_CLOUD_PROJECT"


class LocalEndpoint:
    

    def __init__(
        self,
        serving_container_image_uri: str,
        artifact_uri: Optional[str] = None,
        serving_container_predict_route: Optional[str] = None,
        serving_container_health_route: Optional[str] = None,
        serving_container_command: Optional[Sequence[str]] = None,
        serving_container_args: Optional[Sequence[str]] = None,
        serving_container_environment_variables: Optional[Dict[str, str]] = None,
        serving_container_ports: Optional[Sequence[int]] = None,
        credential_path: Optional[str] = None,
        host_port: Optional[str] = None,
        gpu_count: Optional[int] = None,
        gpu_device_ids: Optional[List[str]] = None,
        gpu_capabilities: Optional[List[List[str]]] = None,
        container_ready_timeout: Optional[int] = None,
        container_ready_check_interval: Optional[int] = None,
    ):
        
        self.container = None
        self.container_is_running = False
        self.log_start_index = 0
        self.serving_container_image_uri = serving_container_image_uri
        self.artifact_uri = artifact_uri
        self.serving_container_predict_route = (
            serving_container_predict_route or prediction.DEFAULT_LOCAL_PREDICT_ROUTE
        )
        self.serving_container_health_route = (
            serving_container_health_route or prediction.DEFAULT_LOCAL_HEALTH_ROUTE
        )
        self.serving_container_command = serving_container_command
        self.serving_container_args = serving_container_args
        self.serving_container_environment_variables = (
            serving_container_environment_variables
        )
        self.serving_container_ports = serving_container_ports
        self.container_port = prediction_utils.get_prediction_aip_http_port(
            serving_container_ports
        )

        self.credential_path = credential_path
        self.host_port = host_port
        
        
        self.assigned_host_port = host_port

        self.gpu_count = gpu_count
        self.gpu_device_ids = gpu_device_ids
        self.gpu_capabilities = gpu_capabilities

        if self.gpu_count and self.gpu_device_ids:
            raise ValueError(
                "At most one gpu_count or gpu_device_ids can be set but both are set."
            )
        if (self.gpu_count or self.gpu_device_ids) and self.gpu_capabilities is None:
            self.gpu_capabilities = prediction.DEFAULT_LOCAL_RUN_GPU_CAPABILITIES
        if self.gpu_capabilities and not self.gpu_count and not self.gpu_device_ids:
            self.gpu_count = prediction.DEFAULT_LOCAL_RUN_GPU_COUNT

        self.container_ready_timeout = (
            container_ready_timeout or _DEFAULT_CONTAINER_READY_TIMEOUT
        )
        self.container_ready_check_interval = (
            container_ready_check_interval or _DEFAULT_CONTAINER_READY_CHECK_INTERVAL
        )

    def __enter__(self):
        
        try:
            self.serve()
        except Exception as exception:
            _logger.error(f"Exception during entering a context: {exception}.")
            raise
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback):
        
        self.stop()

    def __del__(self):
        
        self.stop()

    def serve(self):
        
        if self.container and self.container_is_running:
            _logger.warning(
                "The local endpoint has started serving traffic. "
                "No need to call `serve()` again."
            )
            return

        try:
            try:
                project_id = initializer.global_config.project
                _logger.info(
                    f"Got the project id from the global config: {project_id}."
                )
            except (GoogleAuthError, ValueError):
                project_id = None

            envs = (
                dict(self.serving_container_environment_variables)
                if self.serving_container_environment_variables is not None
                else {}
            )
            if project_id is not None:
                envs[_GCLOUD_PROJECT_ENV] = project_id

            self.container = run.run_prediction_container(
                self.serving_container_image_uri,
                artifact_uri=self.artifact_uri,
                serving_container_predict_route=self.serving_container_predict_route,
                serving_container_health_route=self.serving_container_health_route,
                serving_container_command=self.serving_container_command,
                serving_container_args=self.serving_container_args,
                serving_container_environment_variables=envs,
                serving_container_ports=self.serving_container_ports,
                credential_path=self.credential_path,
                host_port=self.host_port,
                gpu_count=self.gpu_count,
                gpu_device_ids=self.gpu_device_ids,
                gpu_capabilities=self.gpu_capabilities,
            )

            
            self._wait_until_container_runs()
            if self.host_port is None:
                self.container.reload()
                self.assigned_host_port = self.container.ports[
                    f"{self.container_port}/tcp"
                ][0]["HostPort"]
            self.container_is_running = True
            
            self._wait_until_health_check_succeeds()
        except Exception as exception:
            _logger.error(f"Exception during starting serving: {exception}.")
            self._stop_container_if_exists()
            self.container_is_running = False
            raise

    def stop(self) -> None:
        
        self._stop_container_if_exists()
        self.container_is_running = False

    def _wait_until_container_runs(self) -> None:
        
        elapsed_time = 0
        while (
            self.get_container_status() != run.CONTAINER_RUNNING_STATUS
            and elapsed_time < self.container_ready_timeout
        ):
            time.sleep(self.container_ready_check_interval)
            elapsed_time += self.container_ready_check_interval

        if elapsed_time >= self.container_ready_timeout:
            raise DockerError("The container never starts running.", "", 1)

    def _wait_until_health_check_succeeds(self):
        
        elapsed_time = 0
        try:
            response = self.run_health_check(verbose=False)
        except requests.exceptions.RequestException:
            response = None

        while elapsed_time < self.container_ready_timeout and (
            response is None or response.status_code != 200
        ):
            time.sleep(self.container_ready_check_interval)
            elapsed_time += self.container_ready_check_interval
            try:
                response = self.run_health_check(verbose=False)
            except requests.exceptions.RequestException:
                response = None

            if self.get_container_status() != run.CONTAINER_RUNNING_STATUS:
                self.print_container_logs(
                    show_all=True,
                    message="Container already exited, all container logs:",
                )
                raise DockerError(
                    "Container exited before the first health check succeeded.", "", 1
                )

        if elapsed_time >= self.container_ready_timeout:
            self.print_container_logs(
                show_all=True,
                message="Health check never succeeds, all container logs:",
            )
            raise DockerError("The health check never succeeded.", "", 1)

    def _stop_container_if_exists(self):
        
        if self.container is not None:
            self.container.stop()

    def predict(
        self,
        request: Optional[Any] = None,
        request_file: Optional[str] = None,
        headers: Optional[Dict] = None,
        verbose: bool = True,
    ) -> requests.models.Response:
        
        if self.container_is_running is False:
            raise RuntimeError(
                "The local endpoint is not serving traffic. Please call `serve()`."
            )

        if request is not None and request_file is not None:
            raise ValueError(
                "request and request_file can not be specified at the same time."
            )
        if request is None and request_file is None:
            raise ValueError("One of request and request_file needs to be specified.")

        try:
            url = f"http://localhost:{self.assigned_host_port}{self.serving_container_predict_route}"
            if request is not None:
                response = requests.post(url, data=request, headers=headers)
            elif request_file is not None:
                if not Path(request_file).expanduser().resolve().exists():
                    raise ValueError(f"request_file does not exist: {request_file}.")
                with open(request_file) as data:
                    response = requests.post(url, data=data, headers=headers)
            return response
        except requests.exceptions.RequestException as exception:
            if verbose:
                _logger.warning(f"Exception during prediction: {exception}")
            raise

    def run_health_check(self, verbose: bool = True) -> requests.models.Response:
        
        if self.container_is_running is False:
            raise RuntimeError(
                "The local endpoint is not serving traffic. Please call `serve()`."
            )

        try:
            url = f"http://localhost:{self.assigned_host_port}{self.serving_container_health_route}"
            response = requests.get(url)
            return response
        except requests.exceptions.RequestException as exception:
            if verbose:
                _logger.warning(f"Exception during health check: {exception}")
            raise

    def print_container_logs(
        self, show_all: bool = False, message: Optional[str] = None
    ) -> None:
        
        start_index = None if show_all else self.log_start_index
        self.log_start_index = run.print_container_logs(
            self.container, start_index=start_index, message=message
        )

    def print_container_logs_if_container_is_not_running(
        self, show_all: bool = False, message: Optional[str] = None
    ) -> None:
        
        if self.get_container_status() != run.CONTAINER_RUNNING_STATUS:
            self.print_container_logs(show_all=show_all, message=message)

    def get_container_status(self) -> str:
        
        self.container.reload()
        return self.container.status
