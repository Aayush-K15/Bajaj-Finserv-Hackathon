















import collections
import collections.abc
import json
import os
import platform
from typing import Optional
from urllib.parse import urlencode
import warnings

from google.api_core.client_info import ClientInfo
from google.cloud import exceptions
from google.cloud import version


API_BASE_URL = "https://www.googleapis.com"


DEFAULT_USER_AGENT = "gcloud-python/{0}".format(version.__version__)


CLIENT_INFO_HEADER = "X-Goog-API-Client"
CLIENT_INFO_TEMPLATE = "gl-python/" + platform.python_version() + " gccl/{}"

_USER_AGENT_ALL_CAPS_DEPRECATED = 

_EXTRA_HEADERS_ALL_CAPS_DEPRECATED = 

_DEFAULT_TIMEOUT = 60  


class Connection(object):
    

    _user_agent = DEFAULT_USER_AGENT

    def __init__(self, client, client_info=None):
        self._client = client

        if client_info is None:
            client_info = ClientInfo()

        self._client_info = client_info
        self._extra_headers = {}

    @property
    def USER_AGENT(self):
        
        warnings.warn(_USER_AGENT_ALL_CAPS_DEPRECATED, DeprecationWarning, stacklevel=2)
        return self.user_agent

    @USER_AGENT.setter
    def USER_AGENT(self, value):
        warnings.warn(_USER_AGENT_ALL_CAPS_DEPRECATED, DeprecationWarning, stacklevel=2)
        self.user_agent = value

    @property
    def user_agent(self):
        
        return self._client_info.to_user_agent()

    @user_agent.setter
    def user_agent(self, value):
        self._client_info.user_agent = value

    @property
    def _EXTRA_HEADERS(self):
        
        warnings.warn(
            _EXTRA_HEADERS_ALL_CAPS_DEPRECATED, DeprecationWarning, stacklevel=2
        )
        return self.extra_headers

    @_EXTRA_HEADERS.setter
    def _EXTRA_HEADERS(self, value):
        warnings.warn(
            _EXTRA_HEADERS_ALL_CAPS_DEPRECATED, DeprecationWarning, stacklevel=2
        )
        self.extra_headers = value

    @property
    def extra_headers(self):
        
        return self._extra_headers

    @extra_headers.setter
    def extra_headers(self, value):
        self._extra_headers = value

    @property
    def credentials(self):
        
        return self._client._credentials

    @property
    def http(self):
        
        return self._client._http


class JSONConnection(Connection):
    

    API_BASE_URL: Optional[str] = None
    

    API_BASE_MTLS_URL: Optional[str] = None
    

    ALLOW_AUTO_SWITCH_TO_MTLS_URL = False
    

    API_VERSION: Optional[str] = None
    

    API_URL_TEMPLATE: Optional[str] = None
    

    def get_api_base_url_for_mtls(self, api_base_url=None):
        
        if api_base_url:
            return api_base_url

        env = os.getenv("GOOGLE_API_USE_MTLS_ENDPOINT", "auto")
        if env == "always":
            url_to_use = self.API_BASE_MTLS_URL
        elif env == "never":
            url_to_use = self.API_BASE_URL
        else:
            if self.ALLOW_AUTO_SWITCH_TO_MTLS_URL:
                url_to_use = (
                    self.API_BASE_MTLS_URL if self.http.is_mtls else self.API_BASE_URL
                )
            else:
                url_to_use = self.API_BASE_URL
        return url_to_use

    def build_api_url(
        self, path, query_params=None, api_base_url=None, api_version=None
    ):
        
        url = self.API_URL_TEMPLATE.format(
            api_base_url=self.get_api_base_url_for_mtls(api_base_url),
            api_version=(api_version or self.API_VERSION),
            path=path,
        )

        query_params = query_params or {}

        if isinstance(query_params, collections.abc.Mapping):
            query_params = query_params.copy()
        else:
            query_params_dict = collections.defaultdict(list)
            for key, value in query_params:
                query_params_dict[key].append(value)
            query_params = query_params_dict

        query_params.setdefault("prettyPrint", "false")

        url += "?" + urlencode(query_params, doseq=True)

        return url

    def _make_request(
        self,
        method,
        url,
        data=None,
        content_type=None,
        headers=None,
        target_object=None,
        timeout=_DEFAULT_TIMEOUT,
        extra_api_info=None,
    ):
        
        headers = headers or {}
        headers.update(self.extra_headers)
        headers["Accept-Encoding"] = "gzip"

        if content_type:
            headers["Content-Type"] = content_type

        if extra_api_info:
            headers[CLIENT_INFO_HEADER] = f"{self.user_agent} {extra_api_info}"
        else:
            headers[CLIENT_INFO_HEADER] = self.user_agent
        headers["User-Agent"] = self.user_agent

        return self._do_request(
            method, url, headers, data, target_object, timeout=timeout
        )

    def _do_request(
        self, method, url, headers, data, target_object, timeout=_DEFAULT_TIMEOUT
    ):  
        
        return self.http.request(
            url=url, method=method, headers=headers, data=data, timeout=timeout
        )

    def api_request(
        self,
        method,
        path,
        query_params=None,
        data=None,
        content_type=None,
        headers=None,
        api_base_url=None,
        api_version=None,
        expect_json=True,
        _target_object=None,
        timeout=_DEFAULT_TIMEOUT,
        extra_api_info=None,
    ):
        
        url = self.build_api_url(
            path=path,
            query_params=query_params,
            api_base_url=api_base_url,
            api_version=api_version,
        )

        
        
        if data and isinstance(data, dict):
            data = json.dumps(data)
            content_type = "application/json"

        response = self._make_request(
            method=method,
            url=url,
            data=data,
            content_type=content_type,
            headers=headers,
            target_object=_target_object,
            timeout=timeout,
            extra_api_info=extra_api_info,
        )

        if not 200 <= response.status_code < 300:
            raise exceptions.from_http_response(response)

        if expect_json and response.content:
            return response.json()
        else:
            return response.content
