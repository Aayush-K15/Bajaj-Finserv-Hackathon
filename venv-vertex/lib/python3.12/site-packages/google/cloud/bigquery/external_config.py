















from __future__ import absolute_import, annotations

import base64
import copy
import typing
from typing import Any, Dict, FrozenSet, Iterable, Optional, Union

from google.cloud.bigquery._helpers import _to_bytes
from google.cloud.bigquery._helpers import _bytes_to_json
from google.cloud.bigquery._helpers import _int_or_none
from google.cloud.bigquery._helpers import _str_or_none
from google.cloud.bigquery import _helpers
from google.cloud.bigquery.enums import SourceColumnMatch
from google.cloud.bigquery.format_options import AvroOptions, ParquetOptions
from google.cloud.bigquery import schema
from google.cloud.bigquery.schema import SchemaField


class ExternalSourceFormat(object):
    

    CSV = "CSV"
    

    GOOGLE_SHEETS = "GOOGLE_SHEETS"
    

    NEWLINE_DELIMITED_JSON = "NEWLINE_DELIMITED_JSON"
    

    AVRO = "AVRO"
    

    DATASTORE_BACKUP = "DATASTORE_BACKUP"
    

    ORC = "ORC"
    

    PARQUET = "PARQUET"
    

    BIGTABLE = "BIGTABLE"
    


class BigtableColumn(object):
    

    def __init__(self):
        self._properties = {}

    @property
    def encoding(self):
        
        return self._properties.get("encoding")

    @encoding.setter
    def encoding(self, value):
        self._properties["encoding"] = value

    @property
    def field_name(self):
        
        return self._properties.get("fieldName")

    @field_name.setter
    def field_name(self, value):
        self._properties["fieldName"] = value

    @property
    def only_read_latest(self):
        
        return self._properties.get("onlyReadLatest")

    @only_read_latest.setter
    def only_read_latest(self, value):
        self._properties["onlyReadLatest"] = value

    @property
    def qualifier_encoded(self):
        
        prop = self._properties.get("qualifierEncoded")
        if prop is None:
            return None
        return base64.standard_b64decode(_to_bytes(prop))

    @qualifier_encoded.setter
    def qualifier_encoded(self, value):
        self._properties["qualifierEncoded"] = _bytes_to_json(value)

    @property
    def qualifier_string(self):
        
        return self._properties.get("qualifierString")

    @qualifier_string.setter
    def qualifier_string(self, value):
        self._properties["qualifierString"] = value

    @property
    def type_(self):
        
        return self._properties.get("type")

    @type_.setter
    def type_(self, value):
        self._properties["type"] = value

    def to_api_repr(self) -> dict:
        
        return copy.deepcopy(self._properties)

    @classmethod
    def from_api_repr(cls, resource: dict) -> "BigtableColumn":
        
        config = cls()
        config._properties = copy.deepcopy(resource)
        return config


class BigtableColumnFamily(object):
    

    def __init__(self):
        self._properties = {}

    @property
    def encoding(self):
        
        return self._properties.get("encoding")

    @encoding.setter
    def encoding(self, value):
        self._properties["encoding"] = value

    @property
    def family_id(self):
        
        return self._properties.get("familyId")

    @family_id.setter
    def family_id(self, value):
        self._properties["familyId"] = value

    @property
    def only_read_latest(self):
        
        return self._properties.get("onlyReadLatest")

    @only_read_latest.setter
    def only_read_latest(self, value):
        self._properties["onlyReadLatest"] = value

    @property
    def type_(self):
        
        return self._properties.get("type")

    @type_.setter
    def type_(self, value):
        self._properties["type"] = value

    @property
    def columns(self):
        
        prop = self._properties.get("columns", [])
        return [BigtableColumn.from_api_repr(col) for col in prop]

    @columns.setter
    def columns(self, value):
        self._properties["columns"] = [col.to_api_repr() for col in value]

    def to_api_repr(self) -> dict:
        
        return copy.deepcopy(self._properties)

    @classmethod
    def from_api_repr(cls, resource: dict) -> "BigtableColumnFamily":
        
        config = cls()
        config._properties = copy.deepcopy(resource)
        return config


class BigtableOptions(object):
    

    _SOURCE_FORMAT = "BIGTABLE"
    _RESOURCE_NAME = "bigtableOptions"

    def __init__(self):
        self._properties = {}

    @property
    def ignore_unspecified_column_families(self):
        
        return self._properties.get("ignoreUnspecifiedColumnFamilies")

    @ignore_unspecified_column_families.setter
    def ignore_unspecified_column_families(self, value):
        self._properties["ignoreUnspecifiedColumnFamilies"] = value

    @property
    def read_rowkey_as_string(self):
        
        return self._properties.get("readRowkeyAsString")

    @read_rowkey_as_string.setter
    def read_rowkey_as_string(self, value):
        self._properties["readRowkeyAsString"] = value

    @property
    def column_families(self):
        
        prop = self._properties.get("columnFamilies", [])
        return [BigtableColumnFamily.from_api_repr(cf) for cf in prop]

    @column_families.setter
    def column_families(self, value):
        self._properties["columnFamilies"] = [cf.to_api_repr() for cf in value]

    def to_api_repr(self) -> dict:
        
        return copy.deepcopy(self._properties)

    @classmethod
    def from_api_repr(cls, resource: dict) -> "BigtableOptions":
        
        config = cls()
        config._properties = copy.deepcopy(resource)
        return config


class CSVOptions(object):
    

    _SOURCE_FORMAT = "CSV"
    _RESOURCE_NAME = "csvOptions"

    def __init__(self):
        self._properties = {}

    @property
    def allow_jagged_rows(self):
        
        return self._properties.get("allowJaggedRows")

    @allow_jagged_rows.setter
    def allow_jagged_rows(self, value):
        self._properties["allowJaggedRows"] = value

    @property
    def allow_quoted_newlines(self):
        
        return self._properties.get("allowQuotedNewlines")

    @allow_quoted_newlines.setter
    def allow_quoted_newlines(self, value):
        self._properties["allowQuotedNewlines"] = value

    @property
    def encoding(self):
        
        return self._properties.get("encoding")

    @encoding.setter
    def encoding(self, value):
        self._properties["encoding"] = value

    @property
    def preserve_ascii_control_characters(self):
        
        return self._properties.get("preserveAsciiControlCharacters")

    @preserve_ascii_control_characters.setter
    def preserve_ascii_control_characters(self, value):
        self._properties["preserveAsciiControlCharacters"] = value

    @property
    def field_delimiter(self):
        
        return self._properties.get("fieldDelimiter")

    @field_delimiter.setter
    def field_delimiter(self, value):
        self._properties["fieldDelimiter"] = value

    @property
    def quote_character(self):
        
        return self._properties.get("quote")

    @quote_character.setter
    def quote_character(self, value):
        self._properties["quote"] = value

    @property
    def skip_leading_rows(self):
        
        return _int_or_none(self._properties.get("skipLeadingRows"))

    @skip_leading_rows.setter
    def skip_leading_rows(self, value):
        self._properties["skipLeadingRows"] = str(value)

    @property
    def source_column_match(self) -> Optional[SourceColumnMatch]:
        

        value = self._properties.get("sourceColumnMatch")
        return SourceColumnMatch(value) if value is not None else None

    @source_column_match.setter
    def source_column_match(self, value: Union[SourceColumnMatch, str, None]):
        if value is not None and not isinstance(value, (SourceColumnMatch, str)):
            raise TypeError(
                "value must be a google.cloud.bigquery.enums.SourceColumnMatch, str, or None"
            )
        if isinstance(value, SourceColumnMatch):
            value = value.value
        self._properties["sourceColumnMatch"] = value if value else None

    @property
    def null_markers(self) -> Optional[Iterable[str]]:
        
        return self._properties.get("nullMarkers")

    @null_markers.setter
    def null_markers(self, value: Optional[Iterable[str]]):
        self._properties["nullMarkers"] = value

    def to_api_repr(self) -> dict:
        
        return copy.deepcopy(self._properties)

    @classmethod
    def from_api_repr(cls, resource: dict) -> "CSVOptions":
        
        config = cls()
        config._properties = copy.deepcopy(resource)
        return config


class GoogleSheetsOptions(object):
    

    _SOURCE_FORMAT = "GOOGLE_SHEETS"
    _RESOURCE_NAME = "googleSheetsOptions"

    def __init__(self):
        self._properties = {}

    @property
    def skip_leading_rows(self):
        
        return _int_or_none(self._properties.get("skipLeadingRows"))

    @skip_leading_rows.setter
    def skip_leading_rows(self, value):
        self._properties["skipLeadingRows"] = str(value)

    @property
    def range(self):
        
        return _str_or_none(self._properties.get("range"))

    @range.setter
    def range(self, value):
        self._properties["range"] = value

    def to_api_repr(self) -> dict:
        
        return copy.deepcopy(self._properties)

    @classmethod
    def from_api_repr(cls, resource: dict) -> "GoogleSheetsOptions":
        
        config = cls()
        config._properties = copy.deepcopy(resource)
        return config


_OPTION_CLASSES = (
    AvroOptions,
    BigtableOptions,
    CSVOptions,
    GoogleSheetsOptions,
    ParquetOptions,
)

OptionsType = Union[
    AvroOptions,
    BigtableOptions,
    CSVOptions,
    GoogleSheetsOptions,
    ParquetOptions,
]


class HivePartitioningOptions(object):
    

    def __init__(self) -> None:
        self._properties: Dict[str, Any] = {}

    @property
    def mode(self):
        
        return self._properties.get("mode")

    @mode.setter
    def mode(self, value):
        self._properties["mode"] = value

    @property
    def source_uri_prefix(self):
        
        return self._properties.get("sourceUriPrefix")

    @source_uri_prefix.setter
    def source_uri_prefix(self, value):
        self._properties["sourceUriPrefix"] = value

    @property
    def require_partition_filter(self):
        
        return self._properties.get("requirePartitionFilter")

    @require_partition_filter.setter
    def require_partition_filter(self, value):
        self._properties["requirePartitionFilter"] = value

    def to_api_repr(self) -> dict:
        
        return copy.deepcopy(self._properties)

    @classmethod
    def from_api_repr(cls, resource: dict) -> "HivePartitioningOptions":
        
        config = cls()
        config._properties = copy.deepcopy(resource)
        return config


class ExternalConfig(object):
    

    def __init__(self, source_format) -> None:
        self._properties = {"sourceFormat": source_format}

    @property
    def source_format(self):
        
        return self._properties["sourceFormat"]

    @property
    def options(self) -> Optional[OptionsType]:
        
        for optcls in _OPTION_CLASSES:
            
            if self.source_format == optcls._SOURCE_FORMAT:  
                options: OptionsType = optcls()  
                options._properties = self._properties.setdefault(
                    optcls._RESOURCE_NAME, {}  
                )
                return options

        
        return None

    @property
    def autodetect(self):
        
        return self._properties.get("autodetect")

    @autodetect.setter
    def autodetect(self, value):
        self._properties["autodetect"] = value

    @property
    def compression(self):
        
        return self._properties.get("compression")

    @compression.setter
    def compression(self, value):
        self._properties["compression"] = value

    @property
    def decimal_target_types(self) -> Optional[FrozenSet[str]]:
        
        prop = self._properties.get("decimalTargetTypes")
        if prop is not None:
            prop = frozenset(prop)
        return prop

    @decimal_target_types.setter
    def decimal_target_types(self, value: Optional[Iterable[str]]):
        if value is not None:
            self._properties["decimalTargetTypes"] = list(value)
        else:
            if "decimalTargetTypes" in self._properties:
                del self._properties["decimalTargetTypes"]

    @property
    def hive_partitioning(self):
        
        prop = self._properties.get("hivePartitioningOptions")
        if prop is None:
            return None
        return HivePartitioningOptions.from_api_repr(prop)

    @hive_partitioning.setter
    def hive_partitioning(self, value):
        prop = value.to_api_repr() if value is not None else None
        self._properties["hivePartitioningOptions"] = prop

    @property
    def reference_file_schema_uri(self):
        
        return self._properties.get("referenceFileSchemaUri")

    @reference_file_schema_uri.setter
    def reference_file_schema_uri(self, value):
        self._properties["referenceFileSchemaUri"] = value

    @property
    def ignore_unknown_values(self):
        
        return self._properties.get("ignoreUnknownValues")

    @ignore_unknown_values.setter
    def ignore_unknown_values(self, value):
        self._properties["ignoreUnknownValues"] = value

    @property
    def max_bad_records(self):
        
        return self._properties.get("maxBadRecords")

    @max_bad_records.setter
    def max_bad_records(self, value):
        self._properties["maxBadRecords"] = value

    @property
    def source_uris(self):
        
        return self._properties.get("sourceUris", [])

    @source_uris.setter
    def source_uris(self, value):
        self._properties["sourceUris"] = value

    @property
    def schema(self):
        
        prop: Dict[str, Any] = typing.cast(
            Dict[str, Any], self._properties.get("schema", {})
        )
        return [SchemaField.from_api_repr(field) for field in prop.get("fields", [])]

    @schema.setter
    def schema(self, value):
        prop = value
        if value is not None:
            prop = {"fields": [field.to_api_repr() for field in value]}
        self._properties["schema"] = prop

    @property
    def date_format(self) -> Optional[str]:
        
        result = self._properties.get("dateFormat")
        return typing.cast(str, result)

    @date_format.setter
    def date_format(self, value: Optional[str]):
        self._properties["dateFormat"] = value

    @property
    def datetime_format(self) -> Optional[str]:
        
        result = self._properties.get("datetimeFormat")
        return typing.cast(str, result)

    @datetime_format.setter
    def datetime_format(self, value: Optional[str]):
        self._properties["datetimeFormat"] = value

    @property
    def time_zone(self) -> Optional[str]:
        

        result = self._properties.get("timeZone")
        return typing.cast(str, result)

    @time_zone.setter
    def time_zone(self, value: Optional[str]):
        self._properties["timeZone"] = value

    @property
    def time_format(self) -> Optional[str]:
        
        result = self._properties.get("timeFormat")
        return typing.cast(str, result)

    @time_format.setter
    def time_format(self, value: Optional[str]):
        self._properties["timeFormat"] = value

    @property
    def timestamp_format(self) -> Optional[str]:
        
        result = self._properties.get("timestampFormat")
        return typing.cast(str, result)

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[str]):
        self._properties["timestampFormat"] = value

    @property
    def connection_id(self):
        
        return self._properties.get("connectionId")

    @connection_id.setter
    def connection_id(self, value):
        self._properties["connectionId"] = value

    @property
    def avro_options(self) -> Optional[AvroOptions]:
        
        if self.source_format == ExternalSourceFormat.AVRO:
            self._properties.setdefault(AvroOptions._RESOURCE_NAME, {})
        resource = self._properties.get(AvroOptions._RESOURCE_NAME)
        if resource is None:
            return None
        options = AvroOptions()
        options._properties = resource
        return options

    @avro_options.setter
    def avro_options(self, value):
        if self.source_format != ExternalSourceFormat.AVRO:
            msg = f"Cannot set Avro options, source format is {self.source_format}"
            raise TypeError(msg)
        self._properties[AvroOptions._RESOURCE_NAME] = value._properties

    @property
    def bigtable_options(self) -> Optional[BigtableOptions]:
        
        if self.source_format == ExternalSourceFormat.BIGTABLE:
            self._properties.setdefault(BigtableOptions._RESOURCE_NAME, {})
        resource = self._properties.get(BigtableOptions._RESOURCE_NAME)
        if resource is None:
            return None
        options = BigtableOptions()
        options._properties = resource
        return options

    @bigtable_options.setter
    def bigtable_options(self, value):
        if self.source_format != ExternalSourceFormat.BIGTABLE:
            msg = f"Cannot set Bigtable options, source format is {self.source_format}"
            raise TypeError(msg)
        self._properties[BigtableOptions._RESOURCE_NAME] = value._properties

    @property
    def csv_options(self) -> Optional[CSVOptions]:
        
        if self.source_format == ExternalSourceFormat.CSV:
            self._properties.setdefault(CSVOptions._RESOURCE_NAME, {})
        resource = self._properties.get(CSVOptions._RESOURCE_NAME)
        if resource is None:
            return None
        options = CSVOptions()
        options._properties = resource
        return options

    @csv_options.setter
    def csv_options(self, value):
        if self.source_format != ExternalSourceFormat.CSV:
            msg = f"Cannot set CSV options, source format is {self.source_format}"
            raise TypeError(msg)
        self._properties[CSVOptions._RESOURCE_NAME] = value._properties

    @property
    def google_sheets_options(self) -> Optional[GoogleSheetsOptions]:
        
        if self.source_format == ExternalSourceFormat.GOOGLE_SHEETS:
            self._properties.setdefault(GoogleSheetsOptions._RESOURCE_NAME, {})
        resource = self._properties.get(GoogleSheetsOptions._RESOURCE_NAME)
        if resource is None:
            return None
        options = GoogleSheetsOptions()
        options._properties = resource
        return options

    @google_sheets_options.setter
    def google_sheets_options(self, value):
        if self.source_format != ExternalSourceFormat.GOOGLE_SHEETS:
            msg = f"Cannot set Google Sheets options, source format is {self.source_format}"
            raise TypeError(msg)
        self._properties[GoogleSheetsOptions._RESOURCE_NAME] = value._properties

    @property
    def parquet_options(self) -> Optional[ParquetOptions]:
        
        if self.source_format == ExternalSourceFormat.PARQUET:
            self._properties.setdefault(ParquetOptions._RESOURCE_NAME, {})
        resource = self._properties.get(ParquetOptions._RESOURCE_NAME)
        if resource is None:
            return None
        options = ParquetOptions()
        options._properties = resource
        return options

    @parquet_options.setter
    def parquet_options(self, value):
        if self.source_format != ExternalSourceFormat.PARQUET:
            msg = f"Cannot set Parquet options, source format is {self.source_format}"
            raise TypeError(msg)
        self._properties[ParquetOptions._RESOURCE_NAME] = value._properties

    def to_api_repr(self) -> dict:
        
        config = copy.deepcopy(self._properties)
        return config

    @classmethod
    def from_api_repr(cls, resource: dict) -> "ExternalConfig":
        
        config = cls(resource["sourceFormat"])
        config._properties = copy.deepcopy(resource)
        return config


class ExternalCatalogDatasetOptions:
    

    def __init__(
        self,
        default_storage_location_uri: Optional[str] = None,
        parameters: Optional[Dict[str, Any]] = None,
    ):
        self._properties: Dict[str, Any] = {}
        self.default_storage_location_uri = default_storage_location_uri
        self.parameters = parameters

    @property
    def default_storage_location_uri(self) -> Optional[str]:
        

        return self._properties.get("defaultStorageLocationUri")

    @default_storage_location_uri.setter
    def default_storage_location_uri(self, value: Optional[str]):
        value = _helpers._isinstance_or_raise(value, str, none_allowed=True)
        self._properties["defaultStorageLocationUri"] = value

    @property
    def parameters(self) -> Optional[Dict[str, Any]]:
        

        return self._properties.get("parameters")

    @parameters.setter
    def parameters(self, value: Optional[Dict[str, Any]]):
        value = _helpers._isinstance_or_raise(value, dict, none_allowed=True)
        self._properties["parameters"] = value

    def to_api_repr(self) -> dict:
        
        return self._properties

    @classmethod
    def from_api_repr(cls, api_repr: dict) -> ExternalCatalogDatasetOptions:
        
        config = cls()
        config._properties = api_repr
        return config


class ExternalCatalogTableOptions:
    

    def __init__(
        self,
        connection_id: Optional[str] = None,
        parameters: Union[Dict[str, Any], None] = None,
        storage_descriptor: Optional[schema.StorageDescriptor] = None,
    ):
        self._properties: Dict[str, Any] = {}
        self.connection_id = connection_id
        self.parameters = parameters
        self.storage_descriptor = storage_descriptor

    @property
    def connection_id(self) -> Optional[str]:
        

        return self._properties.get("connectionId")

    @connection_id.setter
    def connection_id(self, value: Optional[str]):
        value = _helpers._isinstance_or_raise(value, str, none_allowed=True)
        self._properties["connectionId"] = value

    @property
    def parameters(self) -> Union[Dict[str, Any], None]:
        

        return self._properties.get("parameters")

    @parameters.setter
    def parameters(self, value: Union[Dict[str, Any], None]):
        value = _helpers._isinstance_or_raise(value, dict, none_allowed=True)
        self._properties["parameters"] = value

    @property
    def storage_descriptor(self) -> Any:
        

        prop = _helpers._get_sub_prop(self._properties, ["storageDescriptor"])

        if prop is not None:
            return schema.StorageDescriptor.from_api_repr(prop)
        return None

    @storage_descriptor.setter
    def storage_descriptor(self, value: Union[schema.StorageDescriptor, dict, None]):
        value = _helpers._isinstance_or_raise(
            value, (schema.StorageDescriptor, dict), none_allowed=True
        )
        if isinstance(value, schema.StorageDescriptor):
            self._properties["storageDescriptor"] = value.to_api_repr()
        else:
            self._properties["storageDescriptor"] = value

    def to_api_repr(self) -> dict:
        

        return self._properties

    @classmethod
    def from_api_repr(cls, api_repr: dict) -> ExternalCatalogTableOptions:
        
        config = cls()
        config._properties = api_repr
        return config
