















from __future__ import annotations
import enum
import typing
from typing import Any, cast, Dict, Iterable, Optional, Union, Sequence

from google.cloud.bigquery import _helpers
from google.cloud.bigquery import standard_sql
from google.cloud.bigquery import enums
from google.cloud.bigquery.enums import StandardSqlTypeNames


_STRUCT_TYPES = ("RECORD", "STRUCT")




LEGACY_TO_STANDARD_TYPES = {
    "STRING": StandardSqlTypeNames.STRING,
    "BYTES": StandardSqlTypeNames.BYTES,
    "INTEGER": StandardSqlTypeNames.INT64,
    "INT64": StandardSqlTypeNames.INT64,
    "FLOAT": StandardSqlTypeNames.FLOAT64,
    "FLOAT64": StandardSqlTypeNames.FLOAT64,
    "NUMERIC": StandardSqlTypeNames.NUMERIC,
    "BIGNUMERIC": StandardSqlTypeNames.BIGNUMERIC,
    "BOOLEAN": StandardSqlTypeNames.BOOL,
    "BOOL": StandardSqlTypeNames.BOOL,
    "GEOGRAPHY": StandardSqlTypeNames.GEOGRAPHY,
    "RECORD": StandardSqlTypeNames.STRUCT,
    "STRUCT": StandardSqlTypeNames.STRUCT,
    "TIMESTAMP": StandardSqlTypeNames.TIMESTAMP,
    "DATE": StandardSqlTypeNames.DATE,
    "TIME": StandardSqlTypeNames.TIME,
    "DATETIME": StandardSqlTypeNames.DATETIME,
    "FOREIGN": StandardSqlTypeNames.FOREIGN,
    
}



class _DefaultSentinel(enum.Enum):
    

    DEFAULT_VALUE = object()


_DEFAULT_VALUE = _DefaultSentinel.DEFAULT_VALUE


class FieldElementType(object):
    

    def __init__(self, element_type: str):
        self._properties = {}
        self._properties["type"] = element_type.upper()

    @property
    def element_type(self):
        return self._properties.get("type")

    @classmethod
    def from_api_repr(cls, api_repr: Optional[dict]) -> Optional["FieldElementType"]:
        
        if not api_repr:
            return None
        return cls(api_repr["type"].upper())

    def to_api_repr(self) -> dict:
        
        return self._properties


class SchemaField(object):
    

    def __init__(
        self,
        name: str,
        field_type: str,
        mode: str = "NULLABLE",
        default_value_expression: Optional[str] = None,
        description: Union[str, _DefaultSentinel] = _DEFAULT_VALUE,
        fields: Iterable["SchemaField"] = (),
        policy_tags: Union["PolicyTagList", None, _DefaultSentinel] = _DEFAULT_VALUE,
        precision: Union[int, _DefaultSentinel] = _DEFAULT_VALUE,
        scale: Union[int, _DefaultSentinel] = _DEFAULT_VALUE,
        max_length: Union[int, _DefaultSentinel] = _DEFAULT_VALUE,
        range_element_type: Union[FieldElementType, str, None] = None,
        rounding_mode: Union[enums.RoundingMode, str, None] = None,
        foreign_type_definition: Optional[str] = None,
    ):
        self._properties: Dict[str, Any] = {
            "name": name,
            "type": field_type,
        }
        self._properties["name"] = name
        if mode is not None:
            self._properties["mode"] = mode.upper()
        if description is not _DEFAULT_VALUE:
            self._properties["description"] = description
        if default_value_expression is not None:
            self._properties["defaultValueExpression"] = default_value_expression
        if precision is not _DEFAULT_VALUE:
            self._properties["precision"] = precision
        if scale is not _DEFAULT_VALUE:
            self._properties["scale"] = scale
        if max_length is not _DEFAULT_VALUE:
            self._properties["maxLength"] = max_length
        if policy_tags is not _DEFAULT_VALUE:
            self._properties["policyTags"] = (
                policy_tags.to_api_repr()
                if isinstance(policy_tags, PolicyTagList)
                else None
            )
        if isinstance(range_element_type, str):
            self._properties["rangeElementType"] = {"type": range_element_type}
        if isinstance(range_element_type, FieldElementType):
            self._properties["rangeElementType"] = range_element_type.to_api_repr()
        if rounding_mode is not None:
            self._properties["roundingMode"] = rounding_mode
        if foreign_type_definition is not None:
            self._properties["foreignTypeDefinition"] = foreign_type_definition

        if fields:  
            self._properties["fields"] = [field.to_api_repr() for field in fields]

    @classmethod
    def from_api_repr(cls, api_repr: dict) -> "SchemaField":
        
        placeholder = cls("this_will_be_replaced", "PLACEHOLDER")

        
        
        
        placeholder._properties = api_repr

        
        
        
        if "mode" not in placeholder._properties:
            placeholder._properties["mode"] = "NULLABLE"

        return placeholder

    @property
    def name(self):
        
        return self._properties.get("name", "")

    @property
    def field_type(self) -> str:
        
        type_ = self._properties.get("type")
        return cast(str, type_).upper()

    @property
    def mode(self):
        
        return cast(str, self._properties.get("mode", "NULLABLE")).upper()

    @property
    def is_nullable(self):
        
        return self.mode == "NULLABLE"

    @property
    def default_value_expression(self):
        
        return self._properties.get("defaultValueExpression")

    @property
    def description(self):
        
        return self._properties.get("description")

    @property
    def precision(self):
        
        return _helpers._int_or_none(self._properties.get("precision"))

    @property
    def scale(self):
        
        return _helpers._int_or_none(self._properties.get("scale"))

    @property
    def max_length(self):
        
        return _helpers._int_or_none(self._properties.get("maxLength"))

    @property
    def range_element_type(self):
        
        if self._properties.get("rangeElementType"):
            ret = self._properties.get("rangeElementType")
            return FieldElementType.from_api_repr(ret)

    @property
    def rounding_mode(self):
        
        return self._properties.get("roundingMode")

    @property
    def foreign_type_definition(self):
        
        return self._properties.get("foreignTypeDefinition")

    @property
    def fields(self):
        
        return tuple(_to_schema_fields(self._properties.get("fields", [])))

    @property
    def policy_tags(self):
        
        resource = self._properties.get("policyTags")
        return PolicyTagList.from_api_repr(resource) if resource is not None else None

    def to_api_repr(self) -> dict:
        
        
        
        
        return self._properties

    def _key(self):
        
        field_type = self.field_type
        if field_type == "STRING" or field_type == "BYTES":
            if self.max_length is not None:
                field_type = f"{field_type}({self.max_length})"
        elif field_type.endswith("NUMERIC"):
            if self.precision is not None:
                if self.scale is not None:
                    field_type = f"{field_type}({self.precision}, {self.scale})"
                else:
                    field_type = f"{field_type}({self.precision})"

        policy_tags = (
            None if self.policy_tags is None else tuple(sorted(self.policy_tags.names))
        )

        return (
            self.name,
            field_type,
            
            self.mode.upper(),  
            self.default_value_expression,
            self.description,
            self.fields,
            policy_tags,
        )

    def to_standard_sql(self) -> standard_sql.StandardSqlField:
        
        sql_type = standard_sql.StandardSqlDataType()

        if self.mode == "REPEATED":
            sql_type.type_kind = StandardSqlTypeNames.ARRAY
        else:
            sql_type.type_kind = LEGACY_TO_STANDARD_TYPES.get(
                self.field_type,
                StandardSqlTypeNames.TYPE_KIND_UNSPECIFIED,
            )

        if sql_type.type_kind == StandardSqlTypeNames.ARRAY:  
            array_element_type = LEGACY_TO_STANDARD_TYPES.get(
                self.field_type,
                StandardSqlTypeNames.TYPE_KIND_UNSPECIFIED,
            )
            sql_type.array_element_type = standard_sql.StandardSqlDataType(
                type_kind=array_element_type
            )

            
            
            if array_element_type == StandardSqlTypeNames.STRUCT:  
                sql_type.array_element_type.struct_type = (
                    standard_sql.StandardSqlStructType(
                        fields=(field.to_standard_sql() for field in self.fields)
                    )
                )
        elif sql_type.type_kind == StandardSqlTypeNames.STRUCT:  
            sql_type.struct_type = standard_sql.StandardSqlStructType(
                fields=(field.to_standard_sql() for field in self.fields)
            )

        return standard_sql.StandardSqlField(name=self.name, type=sql_type)

    def __eq__(self, other):
        if not isinstance(other, SchemaField):
            return NotImplemented
        return self._key() == other._key()

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash(self._key())

    def __repr__(self):
        key = self._key()
        policy_tags = key[-1]
        policy_tags_inst = None if policy_tags is None else PolicyTagList(policy_tags)
        adjusted_key = key[:-1] + (policy_tags_inst,)
        return f"{self.__class__.__name__}{adjusted_key}"


def _parse_schema_resource(info):
    
    if isinstance(info, list):
        return [SchemaField.from_api_repr(f) for f in info]
    return [SchemaField.from_api_repr(f) for f in info.get("fields", ())]


def _build_schema_resource(fields):
    
    if isinstance(fields, Sequence):
        
        return [field.to_api_repr() for field in fields]

    else:
        raise TypeError("Schema must be a Sequence (e.g. a list) or None.")


def _to_schema_fields(schema):
    

    if isinstance(schema, Sequence):
        
        return [
            field
            if isinstance(field, SchemaField)
            else SchemaField.from_api_repr(field)
            for field in schema
        ]

    else:
        raise TypeError("Schema must be a Sequence (e.g. a list) or None.")


class PolicyTagList(object):
    

    def __init__(self, names: Iterable[str] = ()):
        self._properties = {}
        self._properties["names"] = tuple(names)

    @property
    def names(self):
        
        return self._properties.get("names", ())

    def _key(self):
        
        return tuple(sorted(self._properties.get("names", ())))

    def __eq__(self, other):
        if not isinstance(other, PolicyTagList):
            return NotImplemented
        return self._key() == other._key()

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash(self._key())

    def __repr__(self):
        return f"{self.__class__.__name__}(names={self._key()})"

    @classmethod
    def from_api_repr(cls, api_repr: dict) -> "PolicyTagList":
        
        if api_repr is None:
            return None
        names = api_repr.get("names", ())
        return cls(names=names)

    def to_api_repr(self) -> dict:
        
        answer = {"names": list(self.names)}
        return answer


class ForeignTypeInfo:
    

    def __init__(self, type_system: Optional[str] = None):
        self._properties: Dict[str, Any] = {}
        self.type_system = type_system

    @property
    def type_system(self) -> Optional[str]:
        

        return self._properties.get("typeSystem")

    @type_system.setter
    def type_system(self, value: Optional[str]):
        value = _helpers._isinstance_or_raise(value, str, none_allowed=True)
        self._properties["typeSystem"] = value

    def to_api_repr(self) -> dict:
        

        return self._properties

    @classmethod
    def from_api_repr(cls, api_repr: Dict[str, Any]) -> "ForeignTypeInfo":
        

        config = cls()
        config._properties = api_repr
        return config


class SerDeInfo:
    

    def __init__(
        self,
        serialization_library: str,
        name: Optional[str] = None,
        parameters: Optional[dict[str, str]] = None,
    ):
        self._properties: Dict[str, Any] = {}
        self.serialization_library = serialization_library
        self.name = name
        self.parameters = parameters

    @property
    def serialization_library(self) -> str:
        

        return typing.cast(str, self._properties.get("serializationLibrary"))

    @serialization_library.setter
    def serialization_library(self, value: str):
        value = _helpers._isinstance_or_raise(value, str, none_allowed=False)
        self._properties["serializationLibrary"] = value

    @property
    def name(self) -> Optional[str]:
        

        return self._properties.get("name")

    @name.setter
    def name(self, value: Optional[str] = None):
        value = _helpers._isinstance_or_raise(value, str, none_allowed=True)
        self._properties["name"] = value

    @property
    def parameters(self) -> Optional[dict[str, str]]:
        

        return self._properties.get("parameters")

    @parameters.setter
    def parameters(self, value: Optional[dict[str, str]] = None):
        value = _helpers._isinstance_or_raise(value, dict, none_allowed=True)
        self._properties["parameters"] = value

    def to_api_repr(self) -> dict:
        
        return self._properties

    @classmethod
    def from_api_repr(cls, api_repr: dict) -> SerDeInfo:
        
        config = cls("PLACEHOLDER")
        config._properties = api_repr
        return config


class StorageDescriptor:
    

    def __init__(
        self,
        input_format: Optional[str] = None,
        location_uri: Optional[str] = None,
        output_format: Optional[str] = None,
        serde_info: Union[SerDeInfo, dict, None] = None,
    ):
        self._properties: Dict[str, Any] = {}
        self.input_format = input_format
        self.location_uri = location_uri
        self.output_format = output_format
        
        
        
        self.serde_info = typing.cast(Optional[SerDeInfo], serde_info)

    @property
    def input_format(self) -> Optional[str]:
        

        return self._properties.get("inputFormat")

    @input_format.setter
    def input_format(self, value: Optional[str]):
        value = _helpers._isinstance_or_raise(value, str, none_allowed=True)
        self._properties["inputFormat"] = value

    @property
    def location_uri(self) -> Optional[str]:
        

        return self._properties.get("locationUri")

    @location_uri.setter
    def location_uri(self, value: Optional[str]):
        value = _helpers._isinstance_or_raise(value, str, none_allowed=True)
        self._properties["locationUri"] = value

    @property
    def output_format(self) -> Optional[str]:
        

        return self._properties.get("outputFormat")

    @output_format.setter
    def output_format(self, value: Optional[str]):
        value = _helpers._isinstance_or_raise(value, str, none_allowed=True)
        self._properties["outputFormat"] = value

    @property
    def serde_info(self) -> Optional[SerDeInfo]:
        

        prop = _helpers._get_sub_prop(self._properties, ["serDeInfo"])
        if prop is not None:
            return typing.cast(SerDeInfo, SerDeInfo.from_api_repr(prop))
        return None

    @serde_info.setter
    def serde_info(self, value: Union[SerDeInfo, dict, None]):
        value = _helpers._isinstance_or_raise(
            value, (SerDeInfo, dict), none_allowed=True
        )

        if isinstance(value, SerDeInfo):
            self._properties["serDeInfo"] = value.to_api_repr()
        else:
            self._properties["serDeInfo"] = value

    def to_api_repr(self) -> dict:
        
        return self._properties

    @classmethod
    def from_api_repr(cls, resource: dict) -> StorageDescriptor:
        
        config = cls()
        config._properties = resource
        return config
