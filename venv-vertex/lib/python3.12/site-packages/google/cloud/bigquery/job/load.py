















import typing
from typing import FrozenSet, List, Iterable, Optional, Union

from google.cloud.bigquery.encryption_configuration import EncryptionConfiguration
from google.cloud.bigquery.enums import SourceColumnMatch
from google.cloud.bigquery.external_config import HivePartitioningOptions
from google.cloud.bigquery.format_options import ParquetOptions
from google.cloud.bigquery import _helpers
from google.cloud.bigquery.schema import SchemaField
from google.cloud.bigquery.schema import _to_schema_fields
from google.cloud.bigquery.table import RangePartitioning
from google.cloud.bigquery.table import TableReference
from google.cloud.bigquery.table import TimePartitioning
from google.cloud.bigquery.job.base import _AsyncJob
from google.cloud.bigquery.job.base import _JobConfig
from google.cloud.bigquery.job.base import _JobReference
from google.cloud.bigquery.query import ConnectionProperty


class ColumnNameCharacterMap:
    

    COLUMN_NAME_CHARACTER_MAP_UNSPECIFIED = "COLUMN_NAME_CHARACTER_MAP_UNSPECIFIED"
    

    STRICT = "STRICT"
    

    V1 = "V1"
    

    V2 = "V2"
    


class LoadJobConfig(_JobConfig):
    

    def __init__(self, **kwargs) -> None:
        super(LoadJobConfig, self).__init__("load", **kwargs)

    @property
    def allow_jagged_rows(self):
        
        return self._get_sub_prop("allowJaggedRows")

    @allow_jagged_rows.setter
    def allow_jagged_rows(self, value):
        self._set_sub_prop("allowJaggedRows", value)

    @property
    def allow_quoted_newlines(self):
        
        return self._get_sub_prop("allowQuotedNewlines")

    @allow_quoted_newlines.setter
    def allow_quoted_newlines(self, value):
        self._set_sub_prop("allowQuotedNewlines", value)

    @property
    def autodetect(self):
        
        return self._get_sub_prop("autodetect")

    @autodetect.setter
    def autodetect(self, value):
        self._set_sub_prop("autodetect", value)

    @property
    def clustering_fields(self):
        
        prop = self._get_sub_prop("clustering")
        if prop is not None:
            return list(prop.get("fields", ()))

    @clustering_fields.setter
    def clustering_fields(self, value):
        
        if value is not None:
            self._set_sub_prop("clustering", {"fields": value})
        else:
            self._del_sub_prop("clustering")

    @property
    def connection_properties(self) -> List[ConnectionProperty]:
        
        resource = self._get_sub_prop("connectionProperties", [])
        return [ConnectionProperty.from_api_repr(prop) for prop in resource]

    @connection_properties.setter
    def connection_properties(self, value: Iterable[ConnectionProperty]):
        self._set_sub_prop(
            "connectionProperties",
            [prop.to_api_repr() for prop in value],
        )

    @property
    def create_disposition(self):
        
        return self._get_sub_prop("createDisposition")

    @create_disposition.setter
    def create_disposition(self, value):
        self._set_sub_prop("createDisposition", value)

    @property
    def create_session(self) -> Optional[bool]:
        
        return self._get_sub_prop("createSession")

    @create_session.setter
    def create_session(self, value: Optional[bool]):
        self._set_sub_prop("createSession", value)

    @property
    def decimal_target_types(self) -> Optional[FrozenSet[str]]:
        
        prop = self._get_sub_prop("decimalTargetTypes")
        if prop is not None:
            prop = frozenset(prop)
        return prop

    @decimal_target_types.setter
    def decimal_target_types(self, value: Optional[Iterable[str]]):
        if value is not None:
            self._set_sub_prop("decimalTargetTypes", list(value))
        else:
            self._del_sub_prop("decimalTargetTypes")

    @property
    def destination_encryption_configuration(self):
        
        prop = self._get_sub_prop("destinationEncryptionConfiguration")
        if prop is not None:
            prop = EncryptionConfiguration.from_api_repr(prop)
        return prop

    @destination_encryption_configuration.setter
    def destination_encryption_configuration(self, value):
        api_repr = value
        if value is not None:
            api_repr = value.to_api_repr()
            self._set_sub_prop("destinationEncryptionConfiguration", api_repr)
        else:
            self._del_sub_prop("destinationEncryptionConfiguration")

    @property
    def destination_table_description(self):
        
        prop = self._get_sub_prop("destinationTableProperties")
        if prop is not None:
            return prop["description"]

    @destination_table_description.setter
    def destination_table_description(self, value):
        keys = [self._job_type, "destinationTableProperties", "description"]
        if value is not None:
            _helpers._set_sub_prop(self._properties, keys, value)
        else:
            _helpers._del_sub_prop(self._properties, keys)

    @property
    def destination_table_friendly_name(self):
        
        prop = self._get_sub_prop("destinationTableProperties")
        if prop is not None:
            return prop["friendlyName"]

    @destination_table_friendly_name.setter
    def destination_table_friendly_name(self, value):
        keys = [self._job_type, "destinationTableProperties", "friendlyName"]
        if value is not None:
            _helpers._set_sub_prop(self._properties, keys, value)
        else:
            _helpers._del_sub_prop(self._properties, keys)

    @property
    def encoding(self):
        
        return self._get_sub_prop("encoding")

    @encoding.setter
    def encoding(self, value):
        self._set_sub_prop("encoding", value)

    @property
    def field_delimiter(self):
        
        return self._get_sub_prop("fieldDelimiter")

    @field_delimiter.setter
    def field_delimiter(self, value):
        self._set_sub_prop("fieldDelimiter", value)

    @property
    def hive_partitioning(self):
        
        prop = self._get_sub_prop("hivePartitioningOptions")
        if prop is None:
            return None
        return HivePartitioningOptions.from_api_repr(prop)

    @hive_partitioning.setter
    def hive_partitioning(self, value):
        if value is not None:
            if isinstance(value, HivePartitioningOptions):
                value = value.to_api_repr()
            else:
                raise TypeError("Expected a HivePartitioningOptions instance or None.")

        self._set_sub_prop("hivePartitioningOptions", value)

    @property
    def ignore_unknown_values(self):
        
        return self._get_sub_prop("ignoreUnknownValues")

    @ignore_unknown_values.setter
    def ignore_unknown_values(self, value):
        self._set_sub_prop("ignoreUnknownValues", value)

    @property
    def json_extension(self):
        
        return self._get_sub_prop("jsonExtension")

    @json_extension.setter
    def json_extension(self, value):
        self._set_sub_prop("jsonExtension", value)

    @property
    def max_bad_records(self):
        
        return _helpers._int_or_none(self._get_sub_prop("maxBadRecords"))

    @max_bad_records.setter
    def max_bad_records(self, value):
        self._set_sub_prop("maxBadRecords", value)

    @property
    def null_marker(self):
        
        return self._get_sub_prop("nullMarker")

    @null_marker.setter
    def null_marker(self, value):
        self._set_sub_prop("nullMarker", value)

    @property
    def null_markers(self) -> Optional[List[str]]:
        
        return self._get_sub_prop("nullMarkers")

    @null_markers.setter
    def null_markers(self, value: Optional[List[str]]):
        self._set_sub_prop("nullMarkers", value)

    @property
    def preserve_ascii_control_characters(self):
        
        return self._get_sub_prop("preserveAsciiControlCharacters")

    @preserve_ascii_control_characters.setter
    def preserve_ascii_control_characters(self, value):
        self._set_sub_prop("preserveAsciiControlCharacters", bool(value))

    @property
    def projection_fields(self) -> Optional[List[str]]:
        
        return self._get_sub_prop("projectionFields")

    @projection_fields.setter
    def projection_fields(self, value: Optional[List[str]]):
        self._set_sub_prop("projectionFields", value)

    @property
    def quote_character(self):
        
        return self._get_sub_prop("quote")

    @quote_character.setter
    def quote_character(self, value):
        self._set_sub_prop("quote", value)

    @property
    def range_partitioning(self):
        
        resource = self._get_sub_prop("rangePartitioning")
        if resource is not None:
            return RangePartitioning(_properties=resource)

    @range_partitioning.setter
    def range_partitioning(self, value):
        resource = value
        if isinstance(value, RangePartitioning):
            resource = value._properties
        elif value is not None:
            raise ValueError(
                "Expected value to be RangePartitioning or None, got {}.".format(value)
            )
        self._set_sub_prop("rangePartitioning", resource)

    @property
    def reference_file_schema_uri(self):
        
        return self._get_sub_prop("referenceFileSchemaUri")

    @reference_file_schema_uri.setter
    def reference_file_schema_uri(self, value):
        return self._set_sub_prop("referenceFileSchemaUri", value)

    @property
    def schema(self):
        
        schema = _helpers._get_sub_prop(self._properties, ["load", "schema", "fields"])
        if schema is None:
            return
        return [SchemaField.from_api_repr(field) for field in schema]

    @schema.setter
    def schema(self, value):
        if value is None:
            self._del_sub_prop("schema")
            return

        value = _to_schema_fields(value)

        _helpers._set_sub_prop(
            self._properties,
            ["load", "schema", "fields"],
            [field.to_api_repr() for field in value],
        )

    @property
    def schema_update_options(self):
        
        return self._get_sub_prop("schemaUpdateOptions")

    @schema_update_options.setter
    def schema_update_options(self, values):
        self._set_sub_prop("schemaUpdateOptions", values)

    @property
    def skip_leading_rows(self):
        
        return _helpers._int_or_none(self._get_sub_prop("skipLeadingRows"))

    @skip_leading_rows.setter
    def skip_leading_rows(self, value):
        self._set_sub_prop("skipLeadingRows", str(value))

    @property
    def source_format(self):
        
        return self._get_sub_prop("sourceFormat")

    @source_format.setter
    def source_format(self, value):
        self._set_sub_prop("sourceFormat", value)

    @property
    def source_column_match(self) -> Optional[SourceColumnMatch]:
        
        value = self._get_sub_prop("sourceColumnMatch")
        return SourceColumnMatch(value) if value is not None else None

    @source_column_match.setter
    def source_column_match(self, value: Union[SourceColumnMatch, str, None]):
        if value is not None and not isinstance(value, (SourceColumnMatch, str)):
            raise TypeError(
                "value must be a google.cloud.bigquery.enums.SourceColumnMatch, str, or None"
            )
        if isinstance(value, SourceColumnMatch):
            value = value.value
        self._set_sub_prop("sourceColumnMatch", value if value else None)

    @property
    def date_format(self) -> Optional[str]:
        
        return self._get_sub_prop("dateFormat")

    @date_format.setter
    def date_format(self, value: Optional[str]):
        self._set_sub_prop("dateFormat", value)

    @property
    def datetime_format(self) -> Optional[str]:
        
        return self._get_sub_prop("datetimeFormat")

    @datetime_format.setter
    def datetime_format(self, value: Optional[str]):
        self._set_sub_prop("datetimeFormat", value)

    @property
    def time_zone(self) -> Optional[str]:
        
        return self._get_sub_prop("timeZone")

    @time_zone.setter
    def time_zone(self, value: Optional[str]):
        self._set_sub_prop("timeZone", value)

    @property
    def time_format(self) -> Optional[str]:
        
        return self._get_sub_prop("timeFormat")

    @time_format.setter
    def time_format(self, value: Optional[str]):
        self._set_sub_prop("timeFormat", value)

    @property
    def timestamp_format(self) -> Optional[str]:
        
        return self._get_sub_prop("timestampFormat")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[str]):
        self._set_sub_prop("timestampFormat", value)

    @property
    def time_partitioning(self):
        
        prop = self._get_sub_prop("timePartitioning")
        if prop is not None:
            prop = TimePartitioning.from_api_repr(prop)
        return prop

    @time_partitioning.setter
    def time_partitioning(self, value):
        api_repr = value
        if value is not None:
            api_repr = value.to_api_repr()
            self._set_sub_prop("timePartitioning", api_repr)
        else:
            self._del_sub_prop("timePartitioning")

    @property
    def use_avro_logical_types(self):
        
        return self._get_sub_prop("useAvroLogicalTypes")

    @use_avro_logical_types.setter
    def use_avro_logical_types(self, value):
        self._set_sub_prop("useAvroLogicalTypes", bool(value))

    @property
    def write_disposition(self):
        
        return self._get_sub_prop("writeDisposition")

    @write_disposition.setter
    def write_disposition(self, value):
        self._set_sub_prop("writeDisposition", value)

    @property
    def parquet_options(self):
        
        prop = self._get_sub_prop("parquetOptions")
        if prop is not None:
            prop = ParquetOptions.from_api_repr(prop)
        return prop

    @parquet_options.setter
    def parquet_options(self, value):
        if value is not None:
            self._set_sub_prop("parquetOptions", value.to_api_repr())
        else:
            self._del_sub_prop("parquetOptions")

    @property
    def column_name_character_map(self) -> str:
        
        return self._get_sub_prop(
            "columnNameCharacterMap",
            ColumnNameCharacterMap.COLUMN_NAME_CHARACTER_MAP_UNSPECIFIED,
        )

    @column_name_character_map.setter
    def column_name_character_map(self, value: Optional[str]):
        if value is None:
            value = ColumnNameCharacterMap.COLUMN_NAME_CHARACTER_MAP_UNSPECIFIED
        self._set_sub_prop("columnNameCharacterMap", value)


class LoadJob(_AsyncJob):
    

    _JOB_TYPE = "load"
    _CONFIG_CLASS = LoadJobConfig

    def __init__(self, job_id, source_uris, destination, client, job_config=None):
        super(LoadJob, self).__init__(job_id, client)

        if job_config is not None:
            self._properties["configuration"] = job_config._properties

        if source_uris is not None:
            _helpers._set_sub_prop(
                self._properties, ["configuration", "load", "sourceUris"], source_uris
            )

        if destination is not None:
            _helpers._set_sub_prop(
                self._properties,
                ["configuration", "load", "destinationTable"],
                destination.to_api_repr(),
            )

    @property
    def configuration(self) -> LoadJobConfig:
        
        return typing.cast(LoadJobConfig, super().configuration)

    @property
    def destination(self):
        
        dest_config = _helpers._get_sub_prop(
            self._properties, ["configuration", "load", "destinationTable"]
        )
        return TableReference.from_api_repr(dest_config)

    @property
    def source_uris(self):
        
        return _helpers._get_sub_prop(
            self._properties, ["configuration", "load", "sourceUris"]
        )

    @property
    def allow_jagged_rows(self):
        
        return self.configuration.allow_jagged_rows

    @property
    def allow_quoted_newlines(self):
        
        return self.configuration.allow_quoted_newlines

    @property
    def autodetect(self):
        
        return self.configuration.autodetect

    @property
    def connection_properties(self) -> List[ConnectionProperty]:
        
        return self.configuration.connection_properties

    @property
    def create_disposition(self):
        
        return self.configuration.create_disposition

    @property
    def create_session(self) -> Optional[bool]:
        
        return self.configuration.create_session

    @property
    def encoding(self):
        
        return self.configuration.encoding

    @property
    def field_delimiter(self):
        
        return self.configuration.field_delimiter

    @property
    def ignore_unknown_values(self):
        
        return self.configuration.ignore_unknown_values

    @property
    def max_bad_records(self):
        
        return self.configuration.max_bad_records

    @property
    def null_marker(self):
        
        return self.configuration.null_marker

    @property
    def null_markers(self):
        
        return self.configuration.null_markers

    @property
    def quote_character(self):
        
        return self.configuration.quote_character

    @property
    def reference_file_schema_uri(self):
        
        return self.configuration.reference_file_schema_uri

    @property
    def skip_leading_rows(self):
        
        return self.configuration.skip_leading_rows

    @property
    def source_format(self):
        
        return self.configuration.source_format

    @property
    def write_disposition(self):
        
        return self.configuration.write_disposition

    @property
    def schema(self):
        
        return self.configuration.schema

    @property
    def destination_encryption_configuration(self):
        
        return self.configuration.destination_encryption_configuration

    @property
    def destination_table_description(self):
        
        return self.configuration.destination_table_description

    @property
    def destination_table_friendly_name(self):
        
        return self.configuration.destination_table_friendly_name

    @property
    def range_partitioning(self):
        
        return self.configuration.range_partitioning

    @property
    def time_partitioning(self):
        
        return self.configuration.time_partitioning

    @property
    def use_avro_logical_types(self):
        
        return self.configuration.use_avro_logical_types

    @property
    def clustering_fields(self):
        
        return self.configuration.clustering_fields

    @property
    def source_column_match(self) -> Optional[SourceColumnMatch]:
        
        return self.configuration.source_column_match

    @property
    def date_format(self):
        
        return self.configuration.date_format

    @property
    def datetime_format(self):
        
        return self.configuration.datetime_format

    @property
    def time_zone(self):
        
        return self.configuration.time_zone

    @property
    def time_format(self):
        
        return self.configuration.time_format

    @property
    def timestamp_format(self):
        
        return self.configuration.timestamp_format

    @property
    def schema_update_options(self):
        
        return self.configuration.schema_update_options

    @property
    def input_file_bytes(self):
        
        return _helpers._int_or_none(
            _helpers._get_sub_prop(
                self._properties, ["statistics", "load", "inputFileBytes"]
            )
        )

    @property
    def input_files(self):
        
        return _helpers._int_or_none(
            _helpers._get_sub_prop(
                self._properties, ["statistics", "load", "inputFiles"]
            )
        )

    @property
    def output_bytes(self):
        
        return _helpers._int_or_none(
            _helpers._get_sub_prop(
                self._properties, ["statistics", "load", "outputBytes"]
            )
        )

    @property
    def output_rows(self):
        
        return _helpers._int_or_none(
            _helpers._get_sub_prop(
                self._properties, ["statistics", "load", "outputRows"]
            )
        )

    def to_api_repr(self):
        
        
        return {
            "jobReference": self._properties["jobReference"],
            "configuration": self._properties["configuration"],
        }

    @classmethod
    def from_api_repr(cls, resource: dict, client) -> "LoadJob":
        
        cls._check_resource_config(resource)
        job_ref = _JobReference._from_api_repr(resource["jobReference"])
        job = cls(job_ref, None, None, client)
        job._set_properties(resource)
        return job
