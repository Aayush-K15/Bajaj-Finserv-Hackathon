















from collections import namedtuple
import copy
import http
import threading
import typing
from typing import ClassVar, Dict, Optional, Sequence

from google.api_core import retry as retries
from google.api_core import exceptions
import google.api_core.future.polling

from google.cloud.bigquery import _helpers
from google.cloud.bigquery._helpers import _int_or_none
from google.cloud.bigquery.retry import (
    DEFAULT_GET_JOB_TIMEOUT,
    DEFAULT_RETRY,
)


_DONE_STATE = "DONE"
_STOPPED_REASON = "stopped"
_ERROR_REASON_TO_EXCEPTION = {
    "accessDenied": http.client.FORBIDDEN,
    "backendError": http.client.INTERNAL_SERVER_ERROR,
    "billingNotEnabled": http.client.FORBIDDEN,
    "billingTierLimitExceeded": http.client.BAD_REQUEST,
    "blocked": http.client.FORBIDDEN,
    "duplicate": http.client.CONFLICT,
    "internalError": http.client.INTERNAL_SERVER_ERROR,
    "invalid": http.client.BAD_REQUEST,
    "invalidQuery": http.client.BAD_REQUEST,
    "notFound": http.client.NOT_FOUND,
    "notImplemented": http.client.NOT_IMPLEMENTED,
    "policyViolation": http.client.FORBIDDEN,
    "quotaExceeded": http.client.FORBIDDEN,
    "rateLimitExceeded": http.client.TOO_MANY_REQUESTS,
    "resourceInUse": http.client.BAD_REQUEST,
    "resourcesExceeded": http.client.BAD_REQUEST,
    "responseTooLarge": http.client.FORBIDDEN,
    "stopped": http.client.OK,
    "tableUnavailable": http.client.BAD_REQUEST,
}


def _error_result_to_exception(error_result, errors=None):
    
    reason = error_result.get("reason")
    status_code = _ERROR_REASON_TO_EXCEPTION.get(
        reason, http.client.INTERNAL_SERVER_ERROR
    )
    
    
    concatenated_errors = ""
    if errors:
        concatenated_errors = "; "
        for err in errors:
            concatenated_errors += ", ".join(
                [f"{key}: {value}" for key, value in err.items()]
            )
            concatenated_errors += "; "

        
        concatenated_errors = concatenated_errors[:-2]

    error_message = error_result.get("message", "") + concatenated_errors

    return exceptions.from_http_status(
        status_code, error_message, errors=[error_result]
    )


ReservationUsage = namedtuple("ReservationUsage", "name slot_ms")
ReservationUsage.__doc__ = "Job resource usage for a reservation."
ReservationUsage.name.__doc__ = (
    'Reservation name or "unreserved" for on-demand resources usage.'
)
ReservationUsage.slot_ms.__doc__ = (
    "Total slot milliseconds used by the reservation for a particular job."
)


class TransactionInfo(typing.NamedTuple):
    

    transaction_id: str
    

    @classmethod
    def from_api_repr(cls, transaction_info: Dict[str, str]) -> "TransactionInfo":
        return cls(transaction_info["transactionId"])


class _JobReference(object):
    

    def __init__(self, job_id, project, location):
        self._properties = {"jobId": job_id, "projectId": project}
        
        if location:
            self._properties["location"] = location

    @property
    def job_id(self):
        
        return self._properties.get("jobId")

    @property
    def project(self):
        
        return self._properties.get("projectId")

    @property
    def location(self):
        
        return self._properties.get("location")

    def _to_api_repr(self):
        
        return copy.deepcopy(self._properties)

    @classmethod
    def _from_api_repr(cls, resource):
        
        job_id = resource.get("jobId")
        project = resource.get("projectId")
        location = resource.get("location")
        job_ref = cls(job_id, project, location)
        return job_ref


class _JobConfig(object):
    

    def __init__(self, job_type, **kwargs):
        self._job_type = job_type
        self._properties = {job_type: {}}
        for prop, val in kwargs.items():
            setattr(self, prop, val)

    def __setattr__(self, name, value):
        
        if not name.startswith("_") and not hasattr(type(self), name):
            raise AttributeError(
                "Property {} is unknown for {}.".format(name, type(self))
            )
        super(_JobConfig, self).__setattr__(name, value)

    @property
    def job_timeout_ms(self):
        

        
        if self._properties.get("jobTimeoutMs"):
            return self._properties["jobTimeoutMs"]
        return None

    @job_timeout_ms.setter
    def job_timeout_ms(self, value):
        try:
            value = _int_or_none(value)
        except ValueError as err:
            raise ValueError("Pass an int for jobTimeoutMs, e.g. 5000").with_traceback(
                err.__traceback__
            )

        if value is not None:
            
            self._properties["jobTimeoutMs"] = str(value)
        else:
            self._properties.pop("jobTimeoutMs", None)

    @property
    def reservation(self):
        
        return self._properties.setdefault("reservation", None)

    @reservation.setter
    def reservation(self, value):
        if value and not isinstance(value, str):
            raise ValueError("Reservation must be None or a string.")
        self._properties["reservation"] = value

    @property
    def labels(self):
        
        return self._properties.setdefault("labels", {})

    @labels.setter
    def labels(self, value):
        if not isinstance(value, dict):
            raise ValueError("Pass a dict")
        self._properties["labels"] = value

    def _get_sub_prop(self, key, default=None):
        
        return _helpers._get_sub_prop(
            self._properties, [self._job_type, key], default=default
        )

    def _set_sub_prop(self, key, value):
        
        _helpers._set_sub_prop(self._properties, [self._job_type, key], value)

    def _del_sub_prop(self, key):
        
        _helpers._del_sub_prop(self._properties, [self._job_type, key])

    def to_api_repr(self) -> dict:
        
        return copy.deepcopy(self._properties)

    def _fill_from_default(self, default_job_config=None):
        
        if not default_job_config:
            new_job_config = copy.deepcopy(self)
            return new_job_config

        if self._job_type != default_job_config._job_type:
            raise TypeError(
                "attempted to merge two incompatible job types: "
                + repr(self._job_type)
                + ", "
                + repr(default_job_config._job_type)
            )

        
        
        
        new_job_config = self.__class__()  

        default_job_properties = copy.deepcopy(default_job_config._properties)
        for key in self._properties:
            if key != self._job_type:
                default_job_properties[key] = self._properties[key]

        default_job_properties[self._job_type].update(self._properties[self._job_type])
        new_job_config._properties = default_job_properties

        return new_job_config

    @classmethod
    def from_api_repr(cls, resource: dict) -> "_JobConfig":
        
        
        
        
        job_config = cls()  
        job_config._properties = resource
        return job_config


class _AsyncJob(google.api_core.future.polling.PollingFuture):
    

    _JOB_TYPE = "unknown"
    _CONFIG_CLASS: ClassVar

    def __init__(self, job_id, client):
        super(_AsyncJob, self).__init__()

        
        
        
        job_ref = job_id
        if not isinstance(job_id, _JobReference):
            job_ref = _JobReference(job_id, client.project, None)
        self._properties = {"jobReference": job_ref._to_api_repr()}

        self._client = client
        self._result_set = False
        self._completion_lock = threading.Lock()

    @property
    def configuration(self) -> _JobConfig:
        
        configuration: _JobConfig = self._CONFIG_CLASS()  
        configuration._properties = self._properties.setdefault("configuration", {})
        return configuration

    @property
    def job_id(self):
        
        return _helpers._get_sub_prop(self._properties, ["jobReference", "jobId"])

    @property
    def parent_job_id(self):
        
        return _helpers._get_sub_prop(self._properties, ["statistics", "parentJobId"])

    @property
    def script_statistics(self) -> Optional["ScriptStatistics"]:
        
        resource = _helpers._get_sub_prop(
            self._properties, ["statistics", "scriptStatistics"]
        )
        if resource is None:
            return None
        return ScriptStatistics(resource)

    @property
    def session_info(self) -> Optional["SessionInfo"]:
        
        resource = _helpers._get_sub_prop(
            self._properties, ["statistics", "sessionInfo"]
        )
        if resource is None:
            return None
        return SessionInfo(resource)

    @property
    def num_child_jobs(self):
        
        count = _helpers._get_sub_prop(self._properties, ["statistics", "numChildJobs"])
        return int(count) if count is not None else 0

    @property
    def project(self):
        
        return _helpers._get_sub_prop(self._properties, ["jobReference", "projectId"])

    @property
    def location(self):
        
        return _helpers._get_sub_prop(self._properties, ["jobReference", "location"])

    @property
    def reservation_id(self):
        
        return _helpers._get_sub_prop(
            self._properties, ["statistics", "reservation_id"]
        )

    def _require_client(self, client):
        
        if client is None:
            client = self._client
        return client

    @property
    def job_type(self):
        
        return self._JOB_TYPE

    @property
    def path(self):
        
        return "/projects/%s/jobs/%s" % (self.project, self.job_id)

    @property
    def labels(self):
        
        return self._properties.setdefault("configuration", {}).setdefault("labels", {})

    @property
    def etag(self):
        
        return self._properties.get("etag")

    @property
    def self_link(self):
        
        return self._properties.get("selfLink")

    @property
    def user_email(self):
        
        return self._properties.get("user_email")

    @property
    def created(self):
        
        millis = _helpers._get_sub_prop(
            self._properties, ["statistics", "creationTime"]
        )
        if millis is not None:
            return _helpers._datetime_from_microseconds(millis * 1000.0)

    @property
    def started(self):
        
        millis = _helpers._get_sub_prop(self._properties, ["statistics", "startTime"])
        if millis is not None:
            return _helpers._datetime_from_microseconds(millis * 1000.0)

    @property
    def ended(self):
        
        millis = _helpers._get_sub_prop(self._properties, ["statistics", "endTime"])
        if millis is not None:
            return _helpers._datetime_from_microseconds(millis * 1000.0)

    def _job_statistics(self):
        
        statistics = self._properties.get("statistics", {})
        return statistics.get(self._JOB_TYPE, {})

    @property
    def reservation_usage(self):
        
        usage_stats_raw = _helpers._get_sub_prop(
            self._properties, ["statistics", "reservationUsage"], default=()
        )
        return [
            ReservationUsage(name=usage["name"], slot_ms=int(usage["slotMs"]))
            for usage in usage_stats_raw
        ]

    @property
    def transaction_info(self) -> Optional[TransactionInfo]:
        
        info = self._properties.get("statistics", {}).get("transactionInfo")
        if info is None:
            return None
        else:
            return TransactionInfo.from_api_repr(info)

    @property
    def error_result(self):
        
        status = self._properties.get("status")
        if status is not None:
            return status.get("errorResult")

    @property
    def errors(self):
        
        status = self._properties.get("status")
        if status is not None:
            return status.get("errors")

    @property
    def state(self):
        
        status = self._properties.get("status", {})
        return status.get("state")

    def _set_properties(self, api_response):
        
        cleaned = api_response.copy()
        statistics = cleaned.setdefault("statistics", {})
        if "creationTime" in statistics:
            statistics["creationTime"] = float(statistics["creationTime"])
        if "startTime" in statistics:
            statistics["startTime"] = float(statistics["startTime"])
        if "endTime" in statistics:
            statistics["endTime"] = float(statistics["endTime"])

        self._properties = cleaned

        
        self._set_future_result()

    @classmethod
    def _check_resource_config(cls, resource):
        
        if "jobReference" not in resource or "jobId" not in resource["jobReference"]:
            raise KeyError(
                "Resource lacks required identity information: "
                '["jobReference"]["jobId"]'
            )
        if (
            "configuration" not in resource
            or cls._JOB_TYPE not in resource["configuration"]
        ):
            raise KeyError(
                "Resource lacks required configuration: "
                '["configuration"]["%s"]' % cls._JOB_TYPE
            )

    def to_api_repr(self):
        
        return copy.deepcopy(self._properties)

    _build_resource = to_api_repr  

    def _begin(self, client=None, retry=DEFAULT_RETRY, timeout=None):
        
        if self.state is not None:
            raise ValueError("Job already begun.")

        client = self._require_client(client)
        path = "/projects/%s/jobs" % (self.project,)

        
        
        span_attributes = {"path": path}
        api_response = client._call_api(
            retry,
            span_name="BigQuery.job.begin",
            span_attributes=span_attributes,
            job_ref=self,
            method="POST",
            path=path,
            data=self.to_api_repr(),
            timeout=timeout,
        )
        self._set_properties(api_response)

    def exists(
        self,
        client=None,
        retry: "retries.Retry" = DEFAULT_RETRY,
        timeout: Optional[float] = None,
    ) -> bool:
        
        client = self._require_client(client)

        extra_params = {"fields": "id"}
        if self.location:
            extra_params["location"] = self.location

        try:
            span_attributes = {"path": self.path}

            client._call_api(
                retry,
                span_name="BigQuery.job.exists",
                span_attributes=span_attributes,
                job_ref=self,
                method="GET",
                path=self.path,
                query_params=extra_params,
                timeout=timeout,
            )
        except exceptions.NotFound:
            return False
        else:
            return True

    def reload(
        self,
        client=None,
        retry: "retries.Retry" = DEFAULT_RETRY,
        timeout: Optional[float] = DEFAULT_GET_JOB_TIMEOUT,
    ):
        
        client = self._require_client(client)

        got_job = client.get_job(
            self,
            project=self.project,
            location=self.location,
            retry=retry,
            timeout=timeout,
        )
        self._set_properties(got_job._properties)

    def cancel(
        self,
        client=None,
        retry: Optional[retries.Retry] = DEFAULT_RETRY,
        timeout: Optional[float] = None,
    ) -> bool:
        
        client = self._require_client(client)

        extra_params = {}
        if self.location:
            extra_params["location"] = self.location

        path = "{}/cancel".format(self.path)
        span_attributes = {"path": path}

        api_response = client._call_api(
            retry,
            span_name="BigQuery.job.cancel",
            span_attributes=span_attributes,
            job_ref=self,
            method="POST",
            path=path,
            query_params=extra_params,
            timeout=timeout,
        )
        self._set_properties(api_response["job"])
        
        
        return True

    
    
    
    

    def _set_future_result(self):
        
        
        
        
        with self._completion_lock:
            
            
            
            
            if not self.done(reload=False) or self._result_set:
                return

            if self.error_result is not None:
                exception = _error_result_to_exception(
                    self.error_result, self.errors or ()
                )
                self.set_exception(exception)
            else:
                self.set_result(self)

    def done(
        self,
        retry: "retries.Retry" = DEFAULT_RETRY,
        timeout: Optional[float] = DEFAULT_GET_JOB_TIMEOUT,
        reload: bool = True,
    ) -> bool:
        
        
        
        if self.state != _DONE_STATE and reload:
            self.reload(retry=retry, timeout=timeout)
        return self.state == _DONE_STATE

    def result(  
        self,
        retry: Optional[retries.Retry] = DEFAULT_RETRY,
        timeout: Optional[float] = None,
    ) -> "_AsyncJob":
        
        if self.state is None:
            self._begin(retry=retry, timeout=timeout)

        kwargs = {} if retry is DEFAULT_RETRY else {"retry": retry}
        return super(_AsyncJob, self).result(timeout=timeout, **kwargs)

    def cancelled(self):
        
        return (
            self.error_result is not None
            and self.error_result.get("reason") == _STOPPED_REASON
        )

    def __repr__(self):
        result = (
            f"{self.__class__.__name__}<"
            f"project={self.project}, location={self.location}, id={self.job_id}"
            ">"
        )
        return result


class ScriptStackFrame(object):
    

    def __init__(self, resource):
        self._properties = resource

    @property
    def procedure_id(self):
        
        return self._properties.get("procedureId")

    @property
    def text(self):
        
        return self._properties.get("text")

    @property
    def start_line(self):
        
        return _helpers._int_or_none(self._properties.get("startLine"))

    @property
    def start_column(self):
        
        return _helpers._int_or_none(self._properties.get("startColumn"))

    @property
    def end_line(self):
        
        return _helpers._int_or_none(self._properties.get("endLine"))

    @property
    def end_column(self):
        
        return _helpers._int_or_none(self._properties.get("endColumn"))


class ScriptStatistics(object):
    

    def __init__(self, resource):
        self._properties = resource

    @property
    def stack_frames(self) -> Sequence[ScriptStackFrame]:
        
        return [
            ScriptStackFrame(frame) for frame in self._properties.get("stackFrames", [])
        ]

    @property
    def evaluation_kind(self) -> Optional[str]:
        
        return self._properties.get("evaluationKind")


class SessionInfo:
    

    def __init__(self, resource):
        self._properties = resource

    @property
    def session_id(self) -> Optional[str]:
        
        return self._properties.get("sessionId")


class UnknownJob(_AsyncJob):
    

    @classmethod
    def from_api_repr(cls, resource: dict, client) -> "UnknownJob":
        
        job_ref_properties = resource.get(
            "jobReference", {"projectId": client.project, "jobId": None}
        )
        job_ref = _JobReference._from_api_repr(job_ref_properties)
        job = cls(job_ref, client)
        
        
        resource["jobReference"] = job_ref_properties
        job._properties = resource
        return job
