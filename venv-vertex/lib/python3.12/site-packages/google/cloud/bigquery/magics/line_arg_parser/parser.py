













from google.cloud.bigquery.magics.line_arg_parser import DuplicateQueryParamsError
from google.cloud.bigquery.magics.line_arg_parser import ParseError
from google.cloud.bigquery.magics.line_arg_parser import QueryParamsParseError
from google.cloud.bigquery.magics.line_arg_parser import TokenType


class ParseNode(object):
    


class InputLine(ParseNode):
    def __init__(self, destination_var, option_list):
        self.destination_var = destination_var
        self.option_list = option_list


class DestinationVar(ParseNode):
    def __init__(self, token):
        
        self.token = token
        self.name = token.lexeme if token is not None else None


class CmdOptionList(ParseNode):
    def __init__(self, option_nodes):
        self.options = [node for node in option_nodes]  


class CmdOption(ParseNode):
    def __init__(self, name, value):
        self.name = name  
        self.value = value  


class ParamsOption(CmdOption):
    def __init__(self, value):
        super(ParamsOption, self).__init__("params", value)


class CmdOptionValue(ParseNode):
    def __init__(self, token):
        
        self.token = token
        self.value = token.lexeme


class PyVarExpansion(ParseNode):
    def __init__(self, token):
        self.token = token
        self.raw_value = token.lexeme


class PyDict(ParseNode):
    def __init__(self, dict_items):
        self.items = [item for item in dict_items]  


class PyDictItem(ParseNode):
    def __init__(self, key, value):
        self.key = key
        self.value = value


class PyDictKey(ParseNode):
    def __init__(self, token):
        self.token = token
        self.key_value = token.lexeme


class PyScalarValue(ParseNode):
    def __init__(self, token, raw_value):
        self.token = token
        self.raw_value = raw_value


class PyTuple(ParseNode):
    def __init__(self, tuple_items):
        self.items = [item for item in tuple_items]  


class PyList(ParseNode):
    def __init__(self, list_items):
        self.items = [item for item in list_items]  


class Parser(object):
    

    def __init__(self, lexer):
        self._lexer = lexer
        self._tokens_iter = iter(self._lexer)
        self.get_next_token()

    def get_next_token(self):
        
        token = next(self._tokens_iter)
        self._current_token = token

    def consume(self, expected_type, exc_type=ParseError):
        
        if self._current_token.type_ == expected_type:
            if expected_type != TokenType.EOL:
                self.get_next_token()
        else:
            if self._current_token.type_ == TokenType.EOL:
                msg = "Unexpected end of input, expected {}.".format(expected_type)
            else:
                msg = "Expected token type {}, but found {} at position {}.".format(
                    expected_type, self._current_token.lexeme, self._current_token.pos
                )
            self.error(message=msg, exc_type=exc_type)

    def error(self, message="Syntax error.", exc_type=ParseError):
        
        raise exc_type(message)

    def input_line(self):
        
        dest_var = self.destination_var()
        options = self.option_list()

        token = self._current_token

        if token.type_ != TokenType.EOL:
            msg = "Unexpected input at position {}: {}".format(token.pos, token.lexeme)
            self.error(msg)

        return InputLine(dest_var, options)

    def destination_var(self):
        
        token = self._current_token

        if token.type_ == TokenType.DEST_VAR:
            self.consume(TokenType.DEST_VAR)
            result = DestinationVar(token)
        elif token.type_ == TokenType.UNKNOWN:
            msg = "Unknown input at position {}: {}".format(token.pos, token.lexeme)
            self.error(msg)
        else:
            result = DestinationVar(None)

        return result

    def option_list(self):
        
        all_options = []

        def parse_nonparams_options():
            while self._current_token.type_ == TokenType.OPTION_SPEC:
                token = self._current_token
                self.consume(TokenType.OPTION_SPEC)

                opt_name = token.lexeme[2:]  

                
                if self._current_token.type_ == TokenType.OPTION_EQ:
                    self.consume(TokenType.OPTION_EQ)

                opt_value = self.option_value()
                option = CmdOption(opt_name, opt_value)
                all_options.append(option)

        parse_nonparams_options()

        token = self._current_token

        if token.type_ == TokenType.PARAMS_OPT_SPEC:
            option = self.params_option()
            all_options.append(option)

        parse_nonparams_options()

        if self._current_token.type_ == TokenType.PARAMS_OPT_SPEC:
            self.error(
                message="Duplicate --params option", exc_type=DuplicateQueryParamsError
            )

        return CmdOptionList(all_options)

    def option_value(self):
        
        token = self._current_token

        if token.type_ == TokenType.OPT_VAL:
            self.consume(TokenType.OPT_VAL)
            result = CmdOptionValue(token)
        elif token.type_ == TokenType.UNKNOWN:
            msg = "Unknown input at position {}: {}".format(token.pos, token.lexeme)
            self.error(msg)
        else:
            result = None

        return result

    def params_option(self):
        
        self.consume(TokenType.PARAMS_OPT_SPEC)

        
        if self._current_token.type_ == TokenType.PARAMS_OPT_EQ:
            self.consume(TokenType.PARAMS_OPT_EQ)

        if self._current_token.type_ == TokenType.DOLLAR_PY_ID:
            token = self._current_token
            self.consume(TokenType.DOLLAR_PY_ID)
            opt_value = PyVarExpansion(token)
        elif self._current_token.type_ == TokenType.PY_STRING:
            token = self._current_token
            self.consume(TokenType.PY_STRING, exc_type=QueryParamsParseError)
            opt_value = PyScalarValue(token, token.lexeme)
        else:
            opt_value = self.py_dict()

        result = ParamsOption(opt_value)

        return result

    def py_dict(self):
        
        self.consume(TokenType.LCURL, exc_type=QueryParamsParseError)
        dict_items = self.dict_items()
        self.consume(TokenType.RCURL, exc_type=QueryParamsParseError)

        return PyDict(dict_items)

    def dict_items(self):
        
        result = []

        item = self.dict_item()
        if item is not None:
            result.append(item)

        while self._current_token.type_ == TokenType.COMMA:
            self.consume(TokenType.COMMA, exc_type=QueryParamsParseError)
            item = self.dict_item()
            if item is not None:
                result.append(item)

        return result

    def dict_item(self):
        
        token = self._current_token

        if token.type_ == TokenType.PY_STRING:
            key = self.dict_key()
            self.consume(TokenType.COLON, exc_type=QueryParamsParseError)
            value = self.py_value()
            result = PyDictItem(key, value)
        elif token.type_ == TokenType.UNKNOWN:
            msg = "Unknown input at position {}: {}".format(token.pos, token.lexeme)
            self.error(msg, exc_type=QueryParamsParseError)
        else:
            result = None

        return result

    def dict_key(self):
        
        token = self._current_token
        self.consume(TokenType.PY_STRING, exc_type=QueryParamsParseError)
        return PyDictKey(token)

    def py_value(self):
        
        token = self._current_token

        if token.type_ == TokenType.PY_BOOL:
            self.consume(TokenType.PY_BOOL, exc_type=QueryParamsParseError)
            return PyScalarValue(token, token.lexeme)
        elif token.type_ == TokenType.PY_NUMBER:
            self.consume(TokenType.PY_NUMBER, exc_type=QueryParamsParseError)
            return PyScalarValue(token, token.lexeme)
        elif token.type_ == TokenType.PY_STRING:
            self.consume(TokenType.PY_STRING, exc_type=QueryParamsParseError)
            return PyScalarValue(token, token.lexeme)
        elif token.type_ == TokenType.LPAREN:
            tuple_node = self.py_tuple()
            return tuple_node
        elif token.type_ == TokenType.LSQUARE:
            list_node = self.py_list()
            return list_node
        elif token.type_ == TokenType.LCURL:
            dict_node = self.py_dict()
            return dict_node
        else:
            msg = "Unexpected token type {} at position {}.".format(
                token.type_, token.pos
            )
            self.error(msg, exc_type=QueryParamsParseError)

    def py_tuple(self):
        
        self.consume(TokenType.LPAREN, exc_type=QueryParamsParseError)
        items = self.collection_items()
        self.consume(TokenType.RPAREN, exc_type=QueryParamsParseError)

        return PyTuple(items)

    def py_list(self):
        
        self.consume(TokenType.LSQUARE, exc_type=QueryParamsParseError)
        items = self.collection_items()
        self.consume(TokenType.RSQUARE, exc_type=QueryParamsParseError)

        return PyList(items)

    def collection_items(self):
        
        result = []

        item = self.collection_item()
        if item is not None:
            result.append(item)

        while self._current_token.type_ == TokenType.COMMA:
            self.consume(TokenType.COMMA, exc_type=QueryParamsParseError)
            item = self.collection_item()
            if item is not None:
                result.append(item)

        return result

    def collection_item(self):
        
        if self._current_token.type_ not in {TokenType.RPAREN, TokenType.RSQUARE}:
            result = self.py_value()
        else:
            result = None  

        return result
