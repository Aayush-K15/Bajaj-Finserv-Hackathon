













from collections import namedtuple
from collections import OrderedDict
import itertools
import re

import enum


Token = namedtuple("Token", ("type_", "lexeme", "pos"))
StateTransition = namedtuple("StateTransition", ("new_state", "total_offset"))





























token_types = OrderedDict(
    state_parse_pos_args=OrderedDict(
        GOTO_PARSE_NON_PARAMS_OPTIONS=r"(?P<GOTO_PARSE_NON_PARAMS_OPTIONS>(?=--))",  
        DEST_VAR=r"(?P<DEST_VAR>[^\d\W]\w*)",  
    ),
    state_parse_non_params_options=OrderedDict(
        GOTO_PARSE_PARAMS_OPTION=r"(?P<GOTO_PARSE_PARAMS_OPTION>(?=--params(?:\s|=|--|$)))",  
        OPTION_SPEC=r"(?P<OPTION_SPEC>--\w+)",
        OPTION_EQ=r"(?P<OPTION_EQ>=)",
        OPT_VAL=r"(?P<OPT_VAL>\S+?(?=\s|--|$))",
    ),
    state_parse_params_option=OrderedDict(
        PY_STRING=r"(?P<PY_STRING>(?:{})|(?:{}))".format(  
            r"'(?:[^'\\]|\.)*'", r'"(?:[^"\\]|\.)*"'
        ),
        PARAMS_OPT_SPEC=r"(?P<PARAMS_OPT_SPEC>--params(?=\s|=|--|$))",
        PARAMS_OPT_EQ=r"(?P<PARAMS_OPT_EQ>=)",
        GOTO_PARSE_NON_PARAMS_OPTIONS=r"(?P<GOTO_PARSE_NON_PARAMS_OPTIONS>(?=--\w+))",  
        PY_BOOL=r"(?P<PY_BOOL>True|False)",
        DOLLAR_PY_ID=r"(?P<DOLLAR_PY_ID>\$[^\d\W]\w*)",
        PY_NUMBER=r"(?P<PY_NUMBER>-?[1-9]\d*(?:\.\d+)?(:?[e|E][+-]?\d+)?)",
        SQUOTE=r"(?P<SQUOTE>')",
        DQUOTE=r'(?P<DQUOTE>")',
        COLON=r"(?P<COLON>:)",
        COMMA=r"(?P<COMMA>,)",
        LCURL=r"(?P<LCURL>\{)",
        RCURL=r"(?P<RCURL>})",
        LSQUARE=r"(?P<LSQUARE>\[)",
        RSQUARE=r"(?P<RSQUARE>])",
        LPAREN=r"(?P<LPAREN>\()",
        RPAREN=r"(?P<RPAREN>\))",
    ),
    common=OrderedDict(
        WS=r"(?P<WS>\s+)",
        EOL=r"(?P<EOL>$)",
        UNKNOWN=r"(?P<UNKNOWN>\S+)",  
    ),
)


class AutoStrEnum(str, enum.Enum):
    

    def _generate_next_value_(name, start, count, last_values):
        return name


TokenType = AutoStrEnum(  
    "TokenType",
    [
        (name, enum.auto())
        for name in itertools.chain.from_iterable(token_types.values())
        if not name.startswith("GOTO_")
    ],
)


class LexerState(AutoStrEnum):
    PARSE_POS_ARGS = enum.auto()  
    PARSE_NON_PARAMS_OPTIONS = enum.auto()  
    PARSE_PARAMS_OPTION = enum.auto()  
    STATE_END = enum.auto()


class Lexer(object):
    

    _GRAND_PATTERNS = {
        LexerState.PARSE_POS_ARGS: re.compile(
            "|".join(
                itertools.chain(
                    token_types["state_parse_pos_args"].values(),
                    token_types["common"].values(),
                )
            )
        ),
        LexerState.PARSE_NON_PARAMS_OPTIONS: re.compile(
            "|".join(
                itertools.chain(
                    token_types["state_parse_non_params_options"].values(),
                    token_types["common"].values(),
                )
            )
        ),
        LexerState.PARSE_PARAMS_OPTION: re.compile(
            "|".join(
                itertools.chain(
                    token_types["state_parse_params_option"].values(),
                    token_types["common"].values(),
                )
            )
        ),
    }

    def __init__(self, input_text):
        self._text = input_text

    def __iter__(self):
        
        
        
        
        
        
        state = LexerState.PARSE_POS_ARGS
        offset = 0  

        while state != LexerState.STATE_END:
            token_stream = self._find_state_tokens(state, offset)

            for maybe_token in token_stream:  
                if isinstance(maybe_token, StateTransition):
                    state = maybe_token.new_state
                    offset = maybe_token.total_offset
                    break

                if maybe_token.type_ != TokenType.WS:
                    yield maybe_token

                if maybe_token.type_ == TokenType.EOL:
                    state = LexerState.STATE_END
                    break

    def _find_state_tokens(self, state, current_offset):
        
        pattern = self._GRAND_PATTERNS[state]
        scanner = pattern.finditer(self._text, current_offset)

        for match in scanner:  
            token_type = match.lastgroup

            if token_type.startswith("GOTO_"):
                yield StateTransition(
                    new_state=getattr(LexerState, token_type[5:]),  
                    total_offset=match.start(),
                )

            yield Token(token_type, match.group(), match.start())
