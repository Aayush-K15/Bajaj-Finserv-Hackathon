

















from __future__ import annotations  

import copy
import datetime
import typing
from typing import Any, Dict, Optional, Sequence, Union

import google.cloud._helpers  
from google.cloud.bigquery import _helpers
from google.cloud.bigquery import standard_sql
from google.cloud.bigquery.encryption_configuration import EncryptionConfiguration


class Model:
    

    _PROPERTY_TO_API_FIELD = {
        "expires": "expirationTime",
        "friendly_name": "friendlyName",
        
        
        
        "labels": "labels",
        "description": "description",
        "encryption_configuration": "encryptionConfiguration",
    }

    def __init__(self, model_ref: Union["ModelReference", str, None]):
        
        
        
        
        self._properties: Dict[str, Any] = {}

        if isinstance(model_ref, str):
            model_ref = ModelReference.from_string(model_ref)

        if model_ref:
            self._properties["modelReference"] = model_ref.to_api_repr()

    @property
    def reference(self) -> Optional["ModelReference"]:
        
        resource = self._properties.get("modelReference")
        if resource is None:
            return None
        else:
            return ModelReference.from_api_repr(resource)

    @property
    def project(self) -> Optional[str]:
        
        ref = self.reference
        return ref.project if ref is not None else None

    @property
    def dataset_id(self) -> Optional[str]:
        
        ref = self.reference
        return ref.dataset_id if ref is not None else None

    @property
    def model_id(self) -> Optional[str]:
        
        ref = self.reference
        return ref.model_id if ref is not None else None

    @property
    def path(self) -> Optional[str]:
        
        ref = self.reference
        return ref.path if ref is not None else None

    @property
    def location(self) -> Optional[str]:
        
        return typing.cast(Optional[str], self._properties.get("location"))

    @property
    def etag(self) -> Optional[str]:
        
        return typing.cast(Optional[str], self._properties.get("etag"))

    @property
    def created(self) -> Optional[datetime.datetime]:
        
        value = typing.cast(Optional[float], self._properties.get("creationTime"))
        if value is None:
            return None
        else:
            
            return google.cloud._helpers._datetime_from_microseconds(
                1000.0 * float(value)
            )

    @property
    def modified(self) -> Optional[datetime.datetime]:
        
        value = typing.cast(Optional[float], self._properties.get("lastModifiedTime"))
        if value is None:
            return None
        else:
            
            return google.cloud._helpers._datetime_from_microseconds(
                1000.0 * float(value)
            )

    @property
    def model_type(self) -> str:
        
        return typing.cast(
            str, self._properties.get("modelType", "MODEL_TYPE_UNSPECIFIED")
        )

    @property
    def training_runs(self) -> Sequence[Dict[str, Any]]:
        
        return typing.cast(
            Sequence[Dict[str, Any]], self._properties.get("trainingRuns", [])
        )

    @property
    def feature_columns(self) -> Sequence[standard_sql.StandardSqlField]:
        
        resource: Sequence[Dict[str, Any]] = typing.cast(
            Sequence[Dict[str, Any]], self._properties.get("featureColumns", [])
        )
        return [
            standard_sql.StandardSqlField.from_api_repr(column) for column in resource
        ]

    @property
    def transform_columns(self) -> Sequence[TransformColumn]:
        
        resources: Sequence[Dict[str, Any]] = typing.cast(
            Sequence[Dict[str, Any]], self._properties.get("transformColumns", [])
        )
        return [TransformColumn(resource) for resource in resources]

    @property
    def label_columns(self) -> Sequence[standard_sql.StandardSqlField]:
        
        resource: Sequence[Dict[str, Any]] = typing.cast(
            Sequence[Dict[str, Any]], self._properties.get("labelColumns", [])
        )
        return [
            standard_sql.StandardSqlField.from_api_repr(column) for column in resource
        ]

    @property
    def best_trial_id(self) -> Optional[int]:
        
        value = typing.cast(Optional[int], self._properties.get("bestTrialId"))
        if value is not None:
            value = int(value)
        return value

    @property
    def expires(self) -> Optional[datetime.datetime]:
        
        value = typing.cast(Optional[float], self._properties.get("expirationTime"))
        if value is None:
            return None
        else:
            
            return google.cloud._helpers._datetime_from_microseconds(
                1000.0 * float(value)
            )

    @expires.setter
    def expires(self, value: Optional[datetime.datetime]):
        if value is None:
            value_to_store: Optional[str] = None
        else:
            value_to_store = str(google.cloud._helpers._millis_from_datetime(value))
        
        self._properties["expirationTime"] = value_to_store  

    @property
    def description(self) -> Optional[str]:
        
        return typing.cast(Optional[str], self._properties.get("description"))

    @description.setter
    def description(self, value: Optional[str]):
        
        self._properties["description"] = value  

    @property
    def friendly_name(self) -> Optional[str]:
        
        return typing.cast(Optional[str], self._properties.get("friendlyName"))

    @friendly_name.setter
    def friendly_name(self, value: Optional[str]):
        
        self._properties["friendlyName"] = value  

    @property
    def labels(self) -> Dict[str, str]:
        
        return self._properties.setdefault("labels", {})

    @labels.setter
    def labels(self, value: Optional[Dict[str, str]]):
        if value is None:
            value = {}
        self._properties["labels"] = value

    @property
    def encryption_configuration(self) -> Optional[EncryptionConfiguration]:
        
        prop = self._properties.get("encryptionConfiguration")
        if prop:
            prop = EncryptionConfiguration.from_api_repr(prop)
        return typing.cast(Optional[EncryptionConfiguration], prop)

    @encryption_configuration.setter
    def encryption_configuration(self, value: Optional[EncryptionConfiguration]):
        api_repr = value.to_api_repr() if value else value
        self._properties["encryptionConfiguration"] = api_repr

    @classmethod
    def from_api_repr(cls, resource: Dict[str, Any]) -> "Model":
        
        this = cls(None)
        resource = copy.deepcopy(resource)
        this._properties = resource
        return this

    def _build_resource(self, filter_fields):
        
        return _helpers._build_resource_from_properties(self, filter_fields)

    def __repr__(self):
        return f"Model(reference={self.reference!r})"

    def to_api_repr(self) -> Dict[str, Any]:
        
        return copy.deepcopy(self._properties)


class ModelReference:
    

    def __init__(self):
        self._properties = {}

    @property
    def project(self):
        
        return self._properties.get("projectId")

    @property
    def dataset_id(self):
        
        return self._properties.get("datasetId")

    @property
    def model_id(self):
        
        return self._properties.get("modelId")

    @property
    def path(self) -> str:
        
        return f"/projects/{self.project}/datasets/{self.dataset_id}/models/{self.model_id}"

    @classmethod
    def from_api_repr(cls, resource: Dict[str, Any]) -> "ModelReference":
        
        ref = cls()
        ref._properties = resource
        return ref

    @classmethod
    def from_string(
        cls, model_id: str, default_project: Optional[str] = None
    ) -> "ModelReference":
        
        proj, dset, model = _helpers._parse_3_part_id(
            model_id, default_project=default_project, property_name="model_id"
        )
        return cls.from_api_repr(
            {"projectId": proj, "datasetId": dset, "modelId": model}
        )

    def to_api_repr(self) -> Dict[str, Any]:
        
        return copy.deepcopy(self._properties)

    def _key(self):
        
        return self.project, self.dataset_id, self.model_id

    def __eq__(self, other):
        if not isinstance(other, ModelReference):
            return NotImplemented
        return self._properties == other._properties

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash(self._key())

    def __repr__(self):
        return "ModelReference(project_id='{}', dataset_id='{}', model_id='{}')".format(
            self.project, self.dataset_id, self.model_id
        )


class TransformColumn:
    

    def __init__(self, resource: Dict[str, Any]):
        self._properties = resource

    @property
    def name(self) -> Optional[str]:
        
        return self._properties.get("name")

    @property
    def type_(self) -> Optional[standard_sql.StandardSqlDataType]:
        
        type_json = self._properties.get("type")
        if type_json is None:
            return None
        return standard_sql.StandardSqlDataType.from_api_repr(type_json)

    @property
    def transform_sql(self) -> Optional[str]:
        
        return self._properties.get("transformSql")

    @classmethod
    def from_api_repr(cls, resource: Dict[str, Any]) -> "TransformColumn":
        
        this = cls({})
        resource = copy.deepcopy(resource)
        this._properties = resource
        return this


def _model_arg_to_model_ref(value, default_project=None):
    
    if isinstance(value, str):
        return ModelReference.from_string(value, default_project=default_project)
    if isinstance(value, Model):
        return value.reference
    return value
