













import asyncio
import random
import time

from google.auth import exceptions


_DEFAULT_RETRY_TOTAL_ATTEMPTS = 3


_DEFAULT_INITIAL_INTERVAL_SECONDS = 1.0



_DEFAULT_RANDOMIZATION_FACTOR = 0.1


_DEFAULT_MULTIPLIER = 2.0




class _BaseExponentialBackoff:
    

    def __init__(
        self,
        total_attempts=_DEFAULT_RETRY_TOTAL_ATTEMPTS,
        initial_wait_seconds=_DEFAULT_INITIAL_INTERVAL_SECONDS,
        randomization_factor=_DEFAULT_RANDOMIZATION_FACTOR,
        multiplier=_DEFAULT_MULTIPLIER,
    ):
        if total_attempts < 1:
            raise exceptions.InvalidValue(
                f"total_attempts must be greater than or equal to 1 but was {total_attempts}"
            )

        self._total_attempts = total_attempts
        self._initial_wait_seconds = initial_wait_seconds

        self._current_wait_in_seconds = self._initial_wait_seconds

        self._randomization_factor = randomization_factor
        self._multiplier = multiplier
        self._backoff_count = 0

    @property
    def total_attempts(self):
        
        return self._total_attempts

    @property
    def backoff_count(self):
        
        return self._backoff_count

    def _reset(self):
        self._backoff_count = 0
        self._current_wait_in_seconds = self._initial_wait_seconds

    def _calculate_jitter(self):
        jitter_variance = self._current_wait_in_seconds * self._randomization_factor
        jitter = random.uniform(
            self._current_wait_in_seconds - jitter_variance,
            self._current_wait_in_seconds + jitter_variance,
        )

        return jitter


class ExponentialBackoff(_BaseExponentialBackoff):
    

    def __init__(self, *args, **kwargs):
        super(ExponentialBackoff, self).__init__(*args, **kwargs)

    def __iter__(self):
        self._reset()
        return self

    def __next__(self):
        if self._backoff_count >= self._total_attempts:
            raise StopIteration
        self._backoff_count += 1

        if self._backoff_count <= 1:
            return self._backoff_count

        jitter = self._calculate_jitter()

        time.sleep(jitter)

        self._current_wait_in_seconds *= self._multiplier
        return self._backoff_count


class AsyncExponentialBackoff(_BaseExponentialBackoff):
    

    def __init__(self, *args, **kwargs):
        super(AsyncExponentialBackoff, self).__init__(*args, **kwargs)

    def __aiter__(self):
        self._reset()
        return self

    async def __anext__(self):
        if self._backoff_count >= self._total_attempts:
            raise StopAsyncIteration
        self._backoff_count += 1

        if self._backoff_count <= 1:
            return self._backoff_count

        jitter = self._calculate_jitter()

        await asyncio.sleep(jitter)

        self._current_wait_in_seconds *= self._multiplier
        return self._backoff_count
