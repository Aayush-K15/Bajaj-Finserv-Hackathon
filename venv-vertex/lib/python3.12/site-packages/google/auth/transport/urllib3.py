















from __future__ import absolute_import

import logging
import os
import warnings







try:
    import certifi
except ImportError:  
    certifi = None  

try:
    import urllib3  
    import urllib3.exceptions  
    from packaging import version  
except ImportError as caught_exc:  
    raise ImportError(
        ""
        f"Error: {caught_exc}."
        " The 'google-auth' library requires the extras installed "
        "for urllib3 network transport."
        "\n"
        "Please install the necessary dependencies using pip:\n"
        "  pip install google-auth[urllib3]\n"
        "\n"
        "(Note: Using '[urllib3]' ensures the specific dependencies needed for this feature are installed. "
        "We recommend running this command in your virtual environment.)"
    ) from caught_exc


from google.auth import _helpers
from google.auth import environment_vars
from google.auth import exceptions
from google.auth import transport
from google.oauth2 import service_account

if version.parse(urllib3.__version__) >= version.parse("2.0.0"):  
    RequestMethods = urllib3._request_methods.RequestMethods  
else:  
    RequestMethods = urllib3.request.RequestMethods  

_LOGGER = logging.getLogger(__name__)


class _Response(transport.Response):
    

    def __init__(self, response):
        self._response = response

    @property
    def status(self):
        return self._response.status

    @property
    def headers(self):
        return self._response.headers

    @property
    def data(self):
        return self._response.data


class Request(transport.Request):
    

    def __init__(self, http):
        self.http = http

    def __call__(
        self, url, method="GET", body=None, headers=None, timeout=None, **kwargs
    ):
        
        
        
        if timeout is not None:
            kwargs["timeout"] = timeout

        try:
            _helpers.request_log(_LOGGER, method, url, body, headers)
            response = self.http.request(
                method, url, body=body, headers=headers, **kwargs
            )
            _helpers.response_log(_LOGGER, response)
            return _Response(response)
        except urllib3.exceptions.HTTPError as caught_exc:
            new_exc = exceptions.TransportError(caught_exc)
            raise new_exc from caught_exc


def _make_default_http():
    if certifi is not None:
        return urllib3.PoolManager(cert_reqs="CERT_REQUIRED", ca_certs=certifi.where())
    else:
        return urllib3.PoolManager()


def _make_mutual_tls_http(cert, key):
    
    import certifi
    from OpenSSL import crypto
    import urllib3.contrib.pyopenssl  

    urllib3.contrib.pyopenssl.inject_into_urllib3()
    ctx = urllib3.util.ssl_.create_urllib3_context()
    ctx.load_verify_locations(cafile=certifi.where())

    pkey = crypto.load_privatekey(crypto.FILETYPE_PEM, key)
    x509 = crypto.load_certificate(crypto.FILETYPE_PEM, cert)

    ctx._ctx.use_certificate(x509)
    ctx._ctx.use_privatekey(pkey)

    http = urllib3.PoolManager(ssl_context=ctx)
    return http


class AuthorizedHttp(RequestMethods):  
    

    def __init__(
        self,
        credentials,
        http=None,
        refresh_status_codes=transport.DEFAULT_REFRESH_STATUS_CODES,
        max_refresh_attempts=transport.DEFAULT_MAX_REFRESH_ATTEMPTS,
        default_host=None,
    ):
        if http is None:
            self.http = _make_default_http()
            self._has_user_provided_http = False
        else:
            self.http = http
            self._has_user_provided_http = True

        self.credentials = credentials
        self._refresh_status_codes = refresh_status_codes
        self._max_refresh_attempts = max_refresh_attempts
        self._default_host = default_host
        
        
        self._request = Request(self.http)

        
        
        if isinstance(self.credentials, service_account.Credentials):
            self.credentials._create_self_signed_jwt(
                "https://{}/".format(self._default_host) if self._default_host else None
            )

        super(AuthorizedHttp, self).__init__()

    def configure_mtls_channel(self, client_cert_callback=None):
        
        use_client_cert = os.getenv(
            environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE, "false"
        )
        if use_client_cert != "true":
            return False

        try:
            import OpenSSL
        except ImportError as caught_exc:
            new_exc = exceptions.MutualTLSChannelError(caught_exc)
            raise new_exc from caught_exc

        try:
            found_cert_key, cert, key = transport._mtls_helper.get_client_cert_and_key(
                client_cert_callback
            )

            if found_cert_key:
                self.http = _make_mutual_tls_http(cert, key)
            else:
                self.http = _make_default_http()
        except (
            exceptions.ClientCertError,
            ImportError,
            OpenSSL.crypto.Error,
        ) as caught_exc:
            new_exc = exceptions.MutualTLSChannelError(caught_exc)
            raise new_exc from caught_exc

        if self._has_user_provided_http:
            self._has_user_provided_http = False
            warnings.warn(
                "`http` provided in the constructor is overwritten", UserWarning
            )

        return found_cert_key

    def urlopen(self, method, url, body=None, headers=None, **kwargs):
        
        
        
        
        

        
        
        _credential_refresh_attempt = kwargs.pop("_credential_refresh_attempt", 0)

        if headers is None:
            headers = self.headers

        
        
        request_headers = headers.copy()

        self.credentials.before_request(self._request, method, url, request_headers)

        response = self.http.urlopen(
            method, url, body=body, headers=request_headers, **kwargs
        )

        
        
        
        
        
        
        
        if (
            response.status in self._refresh_status_codes
            and _credential_refresh_attempt < self._max_refresh_attempts
        ):

            _LOGGER.info(
                "Refreshing credentials due to a %s response. Attempt %s/%s.",
                response.status,
                _credential_refresh_attempt + 1,
                self._max_refresh_attempts,
            )

            self.credentials.refresh(self._request)

            
            return self.urlopen(
                method,
                url,
                body=body,
                headers=headers,
                _credential_refresh_attempt=_credential_refresh_attempt + 1,
                **kwargs,
            )

        return response

    

    def __enter__(self):
        
        return self.http.__enter__()

    def __exit__(self, exc_type, exc_val, exc_tb):
        
        return self.http.__exit__(exc_type, exc_val, exc_tb)

    def __del__(self):
        if hasattr(self, "http") and self.http is not None:
            self.http.clear()

    @property
    def headers(self):
        
        return self.http.headers

    @headers.setter
    def headers(self, value):
        
        self.http.headers = value
