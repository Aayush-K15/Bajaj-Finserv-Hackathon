
















import abc
from enum import Enum
import os

from google.auth import _helpers, environment_vars
from google.auth import exceptions
from google.auth import metrics
from google.auth._credentials_base import _BaseCredentials
from google.auth._refresh_worker import RefreshThreadManager

DEFAULT_UNIVERSE_DOMAIN = "googleapis.com"


class Credentials(_BaseCredentials):
    

    def __init__(self):
        super(Credentials, self).__init__()

        self.expiry = None
        
        self._quota_project_id = None
        
        self._trust_boundary = None
        
        self._universe_domain = DEFAULT_UNIVERSE_DOMAIN
        

        self._use_non_blocking_refresh = False
        self._refresh_worker = RefreshThreadManager()

    @property
    def expired(self):
        
        if not self.expiry:
            return False
        
        
        skewed_expiry = self.expiry - _helpers.REFRESH_THRESHOLD
        return _helpers.utcnow() >= skewed_expiry

    @property
    def valid(self):
        
        return self.token is not None and not self.expired

    @property
    def token_state(self):
        
        if self.token is None:
            return TokenState.INVALID

        
        if self.expiry is None:
            return TokenState.FRESH

        expired = _helpers.utcnow() >= self.expiry
        if expired:
            return TokenState.INVALID

        is_stale = _helpers.utcnow() >= (self.expiry - _helpers.REFRESH_THRESHOLD)
        if is_stale:
            return TokenState.STALE

        return TokenState.FRESH

    @property
    def quota_project_id(self):
        
        return self._quota_project_id

    @property
    def universe_domain(self):
        
        return self._universe_domain

    def get_cred_info(self):
        
        return None

    @abc.abstractmethod
    def refresh(self, request):
        
        
        
        raise NotImplementedError("Refresh must be implemented")

    def _metric_header_for_usage(self):
        
        return None

    def apply(self, headers, token=None):
        
        self._apply(headers, token=token)
        
        if self._trust_boundary is not None:
            headers["x-allowed-locations"] = self._trust_boundary["encoded_locations"]
        if self.quota_project_id:
            headers["x-goog-user-project"] = self.quota_project_id

    def _blocking_refresh(self, request):
        if not self.valid:
            self.refresh(request)

    def _non_blocking_refresh(self, request):
        use_blocking_refresh_fallback = False

        if self.token_state == TokenState.STALE:
            use_blocking_refresh_fallback = not self._refresh_worker.start_refresh(
                self, request
            )

        if self.token_state == TokenState.INVALID or use_blocking_refresh_fallback:
            self.refresh(request)
            
            
            
            self._refresh_worker.clear_error()

    def before_request(self, request, method, url, headers):
        
        
        
        
        if self._use_non_blocking_refresh:
            self._non_blocking_refresh(request)
        else:
            self._blocking_refresh(request)

        metrics.add_metric_header(headers, self._metric_header_for_usage())
        self.apply(headers)

    def with_non_blocking_refresh(self):
        self._use_non_blocking_refresh = True


class CredentialsWithQuotaProject(Credentials):
    

    def with_quota_project(self, quota_project_id):
        
        raise NotImplementedError("This credential does not support quota project.")

    def with_quota_project_from_environment(self):
        quota_from_env = os.environ.get(environment_vars.GOOGLE_CLOUD_QUOTA_PROJECT)
        if quota_from_env:
            return self.with_quota_project(quota_from_env)
        return self


class CredentialsWithTokenUri(Credentials):
    

    def with_token_uri(self, token_uri):
        
        raise NotImplementedError("This credential does not use token uri.")


class CredentialsWithUniverseDomain(Credentials):
    

    def with_universe_domain(self, universe_domain):
        
        raise NotImplementedError(
            "This credential does not support with_universe_domain."
        )


class AnonymousCredentials(Credentials):
    

    @property
    def expired(self):
        
        return False

    @property
    def valid(self):
        
        return True

    def refresh(self, request):
        
        raise exceptions.InvalidOperation("Anonymous credentials cannot be refreshed.")

    def apply(self, headers, token=None):
        
        if token is not None:
            raise exceptions.InvalidValue("Anonymous credentials don't support tokens.")

    def before_request(self, request, method, url, headers):
        


class ReadOnlyScoped(metaclass=abc.ABCMeta):
    

    def __init__(self):
        super(ReadOnlyScoped, self).__init__()
        self._scopes = None
        self._default_scopes = None

    @property
    def scopes(self):
        
        return self._scopes

    @property
    def default_scopes(self):
        
        return self._default_scopes

    @abc.abstractproperty
    def requires_scopes(self):
        
        return False

    def has_scopes(self, scopes):
        
        credential_scopes = (
            self._scopes if self._scopes is not None else self._default_scopes
        )
        return set(scopes).issubset(set(credential_scopes or []))


class Scoped(ReadOnlyScoped):
    

    @abc.abstractmethod
    def with_scopes(self, scopes, default_scopes=None):
        
        raise NotImplementedError("This class does not require scoping.")


def with_scopes_if_required(credentials, scopes, default_scopes=None):
    
    if isinstance(credentials, Scoped) and credentials.requires_scopes:
        return credentials.with_scopes(scopes, default_scopes=default_scopes)
    else:
        return credentials


class Signing(metaclass=abc.ABCMeta):
    

    @abc.abstractmethod
    def sign_bytes(self, message):
        
        
        
        raise NotImplementedError("Sign bytes must be implemented.")

    @abc.abstractproperty
    def signer_email(self):
        
        
        
        raise NotImplementedError("Signer email must be implemented.")

    @abc.abstractproperty
    def signer(self):
        
        
        
        raise NotImplementedError("Signer must be implemented.")


class TokenState(Enum):
    

    FRESH = 1
    STALE = 2
    INVALID = 3
