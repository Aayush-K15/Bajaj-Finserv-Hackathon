















import abc
import copy
from dataclasses import dataclass
import datetime
import functools
import io
import json
import re

from google.auth import _helpers
from google.auth import credentials
from google.auth import exceptions
from google.auth import impersonated_credentials
from google.auth import metrics
from google.oauth2 import sts
from google.oauth2 import utils


_EXTERNAL_ACCOUNT_JSON_TYPE = "external_account"

_STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange"

_STS_REQUESTED_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token"

_CLOUD_RESOURCE_MANAGER = "https://cloudresourcemanager.googleapis.com/v1/projects/"

_DEFAULT_TOKEN_URL = "https://sts.{universe_domain}/v1/token"


@dataclass
class SupplierContext:
    

    subject_token_type: str
    audience: str


class Credentials(
    credentials.Scoped,
    credentials.CredentialsWithQuotaProject,
    credentials.CredentialsWithTokenUri,
    metaclass=abc.ABCMeta,
):
    

    def __init__(
        self,
        audience,
        subject_token_type,
        token_url,
        credential_source,
        service_account_impersonation_url=None,
        service_account_impersonation_options=None,
        client_id=None,
        client_secret=None,
        token_info_url=None,
        quota_project_id=None,
        scopes=None,
        default_scopes=None,
        workforce_pool_user_project=None,
        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,
        trust_boundary=None,
    ):
        
        super(Credentials, self).__init__()
        self._audience = audience
        self._subject_token_type = subject_token_type
        self._universe_domain = universe_domain
        self._token_url = token_url
        if self._token_url == _DEFAULT_TOKEN_URL:
            self._token_url = self._token_url.replace(
                "{universe_domain}", self._universe_domain
            )
        self._token_info_url = token_info_url
        self._credential_source = credential_source
        self._service_account_impersonation_url = service_account_impersonation_url
        self._service_account_impersonation_options = (
            service_account_impersonation_options or {}
        )
        self._client_id = client_id
        self._client_secret = client_secret
        self._quota_project_id = quota_project_id
        self._scopes = scopes
        self._default_scopes = default_scopes
        self._workforce_pool_user_project = workforce_pool_user_project
        self._trust_boundary = {
            "locations": [],
            "encoded_locations": "0x0",
        }  

        if self._client_id:
            self._client_auth = utils.ClientAuthentication(
                utils.ClientAuthType.basic, self._client_id, self._client_secret
            )
        else:
            self._client_auth = None
        self._sts_client = sts.Client(self._token_url, self._client_auth)

        self._metrics_options = self._create_default_metrics_options()

        self._impersonated_credentials = None
        self._project_id = None
        self._supplier_context = SupplierContext(
            self._subject_token_type, self._audience
        )
        self._cred_file_path = None

        if not self.is_workforce_pool and self._workforce_pool_user_project:
            
            raise exceptions.InvalidValue(
                "workforce_pool_user_project should not be set for non-workforce pool "
                "credentials"
            )

    @property
    def info(self):
        
        config_info = self._constructor_args()
        config_info.update(
            type=_EXTERNAL_ACCOUNT_JSON_TYPE,
            service_account_impersonation=config_info.pop(
                "service_account_impersonation_options", None
            ),
        )
        config_info.pop("scopes", None)
        config_info.pop("default_scopes", None)
        return {key: value for key, value in config_info.items() if value is not None}

    def _constructor_args(self):
        args = {
            "audience": self._audience,
            "subject_token_type": self._subject_token_type,
            "token_url": self._token_url,
            "token_info_url": self._token_info_url,
            "service_account_impersonation_url": self._service_account_impersonation_url,
            "service_account_impersonation_options": copy.deepcopy(
                self._service_account_impersonation_options
            )
            or None,
            "credential_source": copy.deepcopy(self._credential_source),
            "quota_project_id": self._quota_project_id,
            "client_id": self._client_id,
            "client_secret": self._client_secret,
            "workforce_pool_user_project": self._workforce_pool_user_project,
            "scopes": self._scopes,
            "default_scopes": self._default_scopes,
            "universe_domain": self._universe_domain,
        }
        if not self.is_workforce_pool:
            args.pop("workforce_pool_user_project")
        return args

    @property
    def service_account_email(self):
        
        if self._service_account_impersonation_url:
            
            
            url = self._service_account_impersonation_url
            start_index = url.rfind("/")
            end_index = url.find(":generateAccessToken")
            if start_index != -1 and end_index != -1 and start_index < end_index:
                start_index = start_index + 1
                return url[start_index:end_index]
        return None

    @property
    def is_user(self):
        
        
        
        if self._service_account_impersonation_url:
            return False
        return self.is_workforce_pool

    @property
    def is_workforce_pool(self):
        
        
        
        p = re.compile(r"//iam\.googleapis\.com/locations/[^/]+/workforcePools/")
        return p.match(self._audience or "") is not None

    @property
    def requires_scopes(self):
        
        return not self._scopes and not self._default_scopes

    @property
    def project_number(self):
        

        
        
        components = self._audience.split("/")
        try:
            project_index = components.index("projects")
            if project_index + 1 < len(components):
                return components[project_index + 1] or None
        except ValueError:
            return None

    @property
    def token_info_url(self):
        

        return self._token_info_url

    @_helpers.copy_docstring(credentials.Credentials)
    def get_cred_info(self):
        if self._cred_file_path:
            cred_info_json = {
                "credential_source": self._cred_file_path,
                "credential_type": "external account credentials",
            }
            if self.service_account_email:
                cred_info_json["principal"] = self.service_account_email
            return cred_info_json
        return None

    @_helpers.copy_docstring(credentials.Scoped)
    def with_scopes(self, scopes, default_scopes=None):
        kwargs = self._constructor_args()
        kwargs.update(scopes=scopes, default_scopes=default_scopes)
        scoped = self.__class__(**kwargs)
        scoped._cred_file_path = self._cred_file_path
        scoped._metrics_options = self._metrics_options
        return scoped

    @abc.abstractmethod
    def retrieve_subject_token(self, request):
        
        
        
        raise NotImplementedError("retrieve_subject_token must be implemented")

    def get_project_id(self, request):
        
        if self._project_id:
            
            return self._project_id
        scopes = self._scopes if self._scopes is not None else self._default_scopes
        
        project_number = self.project_number or self._workforce_pool_user_project
        if project_number and scopes:
            headers = {}
            url = _CLOUD_RESOURCE_MANAGER + project_number
            self.before_request(request, "GET", url, headers)
            response = request(url=url, method="GET", headers=headers)

            response_body = (
                response.data.decode("utf-8")
                if hasattr(response.data, "decode")
                else response.data
            )
            response_data = json.loads(response_body)

            if response.status == 200:
                
                self._project_id = response_data.get("projectId")
                return self._project_id

        return None

    @_helpers.copy_docstring(credentials.Credentials)
    def refresh(self, request):
        scopes = self._scopes if self._scopes is not None else self._default_scopes

        
        if self._mtls_required():
            request = functools.partial(
                request, cert=self._get_mtls_cert_and_key_paths()
            )

        if self._should_initialize_impersonated_credentials():
            self._impersonated_credentials = self._initialize_impersonated_credentials()

        if self._impersonated_credentials:
            self._impersonated_credentials.refresh(request)
            self.token = self._impersonated_credentials.token
            self.expiry = self._impersonated_credentials.expiry
        else:
            now = _helpers.utcnow()
            additional_options = None
            
            
            if self._workforce_pool_user_project and not self._client_id:
                additional_options = {"userProject": self._workforce_pool_user_project}
            additional_headers = {
                metrics.API_CLIENT_HEADER: metrics.byoid_metrics_header(
                    self._metrics_options
                )
            }
            response_data = self._sts_client.exchange_token(
                request=request,
                grant_type=_STS_GRANT_TYPE,
                subject_token=self.retrieve_subject_token(request),
                subject_token_type=self._subject_token_type,
                audience=self._audience,
                scopes=scopes,
                requested_token_type=_STS_REQUESTED_TOKEN_TYPE,
                additional_options=additional_options,
                additional_headers=additional_headers,
            )
            self.token = response_data.get("access_token")
            expires_in = response_data.get("expires_in")
            
            
            if isinstance(expires_in, str):
                expires_in = int(expires_in)

            lifetime = datetime.timedelta(seconds=expires_in)

            self.expiry = now + lifetime

    def _make_copy(self):
        kwargs = self._constructor_args()
        new_cred = self.__class__(**kwargs)
        new_cred._cred_file_path = self._cred_file_path
        new_cred._metrics_options = self._metrics_options
        return new_cred

    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)
    def with_quota_project(self, quota_project_id):
        
        cred = self._make_copy()
        cred._quota_project_id = quota_project_id
        return cred

    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)
    def with_token_uri(self, token_uri):
        cred = self._make_copy()
        cred._token_url = token_uri
        return cred

    @_helpers.copy_docstring(credentials.CredentialsWithUniverseDomain)
    def with_universe_domain(self, universe_domain):
        cred = self._make_copy()
        cred._universe_domain = universe_domain
        return cred

    def _should_initialize_impersonated_credentials(self):
        return (
            self._service_account_impersonation_url is not None
            and self._impersonated_credentials is None
        )

    def _initialize_impersonated_credentials(self):
        
        
        kwargs = self._constructor_args()
        kwargs.update(
            service_account_impersonation_url=None,
            service_account_impersonation_options={},
        )
        source_credentials = self.__class__(**kwargs)
        source_credentials._metrics_options = self._metrics_options

        
        target_principal = self.service_account_email
        if not target_principal:
            raise exceptions.RefreshError(
                "Unable to determine target principal from service account impersonation URL."
            )

        scopes = self._scopes if self._scopes is not None else self._default_scopes
        
        return impersonated_credentials.Credentials(
            source_credentials=source_credentials,
            target_principal=target_principal,
            target_scopes=scopes,
            quota_project_id=self._quota_project_id,
            iam_endpoint_override=self._service_account_impersonation_url,
            lifetime=self._service_account_impersonation_options.get(
                "token_lifetime_seconds"
            ),
        )

    def _create_default_metrics_options(self):
        metrics_options = {}
        if self._service_account_impersonation_url:
            metrics_options["sa-impersonation"] = "true"
        else:
            metrics_options["sa-impersonation"] = "false"
        if self._service_account_impersonation_options.get("token_lifetime_seconds"):
            metrics_options["config-lifetime"] = "true"
        else:
            metrics_options["config-lifetime"] = "false"

        return metrics_options

    def _mtls_required(self):
        
        return False

    def _get_mtls_cert_and_key_paths(self):
        
        raise NotImplementedError(
            "_get_mtls_cert_and_key_location must be implemented."
        )

    @classmethod
    def from_info(cls, info, **kwargs):
        
        return cls(
            audience=info.get("audience"),
            subject_token_type=info.get("subject_token_type"),
            token_url=info.get("token_url"),
            token_info_url=info.get("token_info_url"),
            service_account_impersonation_url=info.get(
                "service_account_impersonation_url"
            ),
            service_account_impersonation_options=info.get(
                "service_account_impersonation"
            )
            or {},
            client_id=info.get("client_id"),
            client_secret=info.get("client_secret"),
            credential_source=info.get("credential_source"),
            quota_project_id=info.get("quota_project_id"),
            workforce_pool_user_project=info.get("workforce_pool_user_project"),
            universe_domain=info.get(
                "universe_domain", credentials.DEFAULT_UNIVERSE_DOMAIN
            ),
            **kwargs
        )

    @classmethod
    def from_file(cls, filename, **kwargs):
        
        with io.open(filename, "r", encoding="utf-8") as json_file:
            data = json.load(json_file)
            return cls.from_info(data, **kwargs)
