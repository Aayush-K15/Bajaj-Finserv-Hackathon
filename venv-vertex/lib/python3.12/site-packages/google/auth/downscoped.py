















import datetime

from google.auth import _helpers
from google.auth import credentials
from google.auth import exceptions
from google.oauth2 import sts



_MAX_ACCESS_BOUNDARY_RULES_COUNT = 10

_STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange"

_STS_REQUESTED_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token"

_STS_TOKEN_URL_PATTERN = "https://sts.{}/v1/token"


_STS_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token"


class CredentialAccessBoundary(object):
    

    def __init__(self, rules=[]):
        
        self.rules = rules

    @property
    def rules(self):
        
        return tuple(self._rules)

    @rules.setter
    def rules(self, value):
        
        if len(value) > _MAX_ACCESS_BOUNDARY_RULES_COUNT:
            raise exceptions.InvalidValue(
                "Credential access boundary rules can have a maximum of {} rules.".format(
                    _MAX_ACCESS_BOUNDARY_RULES_COUNT
                )
            )
        for access_boundary_rule in value:
            if not isinstance(access_boundary_rule, AccessBoundaryRule):
                raise exceptions.InvalidType(
                    "List of rules provided do not contain a valid 'google.auth.downscoped.AccessBoundaryRule'."
                )
        
        self._rules = list(value)

    def add_rule(self, rule):
        
        if len(self.rules) == _MAX_ACCESS_BOUNDARY_RULES_COUNT:
            raise exceptions.InvalidValue(
                "Credential access boundary rules can have a maximum of {} rules.".format(
                    _MAX_ACCESS_BOUNDARY_RULES_COUNT
                )
            )
        if not isinstance(rule, AccessBoundaryRule):
            raise exceptions.InvalidType(
                "The provided rule does not contain a valid 'google.auth.downscoped.AccessBoundaryRule'."
            )
        self._rules.append(rule)

    def to_json(self):
        
        rules = []
        for access_boundary_rule in self.rules:
            rules.append(access_boundary_rule.to_json())

        return {"accessBoundary": {"accessBoundaryRules": rules}}


class AccessBoundaryRule(object):
    

    def __init__(
        self, available_resource, available_permissions, availability_condition=None
    ):
        
        self.available_resource = available_resource
        self.available_permissions = available_permissions
        self.availability_condition = availability_condition

    @property
    def available_resource(self):
        
        return self._available_resource

    @available_resource.setter
    def available_resource(self, value):
        
        if not isinstance(value, str):
            raise exceptions.InvalidType(
                "The provided available_resource is not a string."
            )
        self._available_resource = value

    @property
    def available_permissions(self):
        
        return tuple(self._available_permissions)

    @available_permissions.setter
    def available_permissions(self, value):
        
        for available_permission in value:
            if not isinstance(available_permission, str):
                raise exceptions.InvalidType(
                    "Provided available_permissions are not a list of strings."
                )
            if available_permission.find("inRole:") != 0:
                raise exceptions.InvalidValue(
                    "available_permissions must be prefixed with 'inRole:'."
                )
        
        self._available_permissions = list(value)

    @property
    def availability_condition(self):
        
        return self._availability_condition

    @availability_condition.setter
    def availability_condition(self, value):
        
        if not isinstance(value, AvailabilityCondition) and value is not None:
            raise exceptions.InvalidType(
                "The provided availability_condition is not a 'google.auth.downscoped.AvailabilityCondition' or None."
            )
        self._availability_condition = value

    def to_json(self):
        
        json = {
            "availablePermissions": list(self.available_permissions),
            "availableResource": self.available_resource,
        }
        if self.availability_condition:
            json["availabilityCondition"] = self.availability_condition.to_json()
        return json


class AvailabilityCondition(object):
    

    def __init__(self, expression, title=None, description=None):
        
        self.expression = expression
        self.title = title
        self.description = description

    @property
    def expression(self):
        
        return self._expression

    @expression.setter
    def expression(self, value):
        
        if not isinstance(value, str):
            raise exceptions.InvalidType("The provided expression is not a string.")
        self._expression = value

    @property
    def title(self):
        
        return self._title

    @title.setter
    def title(self, value):
        
        if not isinstance(value, str) and value is not None:
            raise exceptions.InvalidType("The provided title is not a string or None.")
        self._title = value

    @property
    def description(self):
        
        return self._description

    @description.setter
    def description(self, value):
        
        if not isinstance(value, str) and value is not None:
            raise exceptions.InvalidType(
                "The provided description is not a string or None."
            )
        self._description = value

    def to_json(self):
        
        json = {"expression": self.expression}
        if self.title:
            json["title"] = self.title
        if self.description:
            json["description"] = self.description
        return json


class Credentials(credentials.CredentialsWithQuotaProject):
    

    def __init__(
        self,
        source_credentials,
        credential_access_boundary,
        quota_project_id=None,
        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,
    ):
        

        super(Credentials, self).__init__()
        self._source_credentials = source_credentials
        self._credential_access_boundary = credential_access_boundary
        self._quota_project_id = quota_project_id
        self._universe_domain = universe_domain or credentials.DEFAULT_UNIVERSE_DOMAIN
        self._sts_client = sts.Client(
            _STS_TOKEN_URL_PATTERN.format(self.universe_domain)
        )

    @_helpers.copy_docstring(credentials.Credentials)
    def refresh(self, request):
        
        self._source_credentials.refresh(request)
        now = _helpers.utcnow()
        
        response_data = self._sts_client.exchange_token(
            request=request,
            grant_type=_STS_GRANT_TYPE,
            subject_token=self._source_credentials.token,
            subject_token_type=_STS_SUBJECT_TOKEN_TYPE,
            requested_token_type=_STS_REQUESTED_TOKEN_TYPE,
            additional_options=self._credential_access_boundary.to_json(),
        )
        self.token = response_data.get("access_token")
        
        
        
        
        
        if response_data.get("expires_in"):
            lifetime = datetime.timedelta(seconds=response_data.get("expires_in"))
            self.expiry = now + lifetime
        else:
            self.expiry = self._source_credentials.expiry

    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)
    def with_quota_project(self, quota_project_id):
        return self.__class__(
            self._source_credentials,
            self._credential_access_boundary,
            quota_project_id=quota_project_id,
        )
