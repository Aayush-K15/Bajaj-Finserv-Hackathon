















import http.client

_SLEEP_RETRY_ERROR_MSG = (
    "At most one of `max_cumulative_retry` and `max_retries` " "can be specified."
)

UPLOAD_CHUNK_SIZE = 262144  


PERMANENT_REDIRECT = http.client.PERMANENT_REDIRECT  


TOO_MANY_REQUESTS = http.client.TOO_MANY_REQUESTS


MAX_SLEEP = 64.0


MAX_CUMULATIVE_RETRY = 600.0


RETRYABLE = (
    http.client.TOO_MANY_REQUESTS,  
    http.client.REQUEST_TIMEOUT,  
    http.client.INTERNAL_SERVER_ERROR,  
    http.client.BAD_GATEWAY,  
    http.client.SERVICE_UNAVAILABLE,  
    http.client.GATEWAY_TIMEOUT,  
)



class InvalidResponse(Exception):
    

    def __init__(self, response, *args):
        super(InvalidResponse, self).__init__(*args)
        self.response = response
        


class DataCorruption(Exception):
    

    def __init__(self, response, *args):
        super(DataCorruption, self).__init__(*args)
        self.response = response
        


class RetryStrategy(object):
    

    def __init__(
        self,
        max_sleep=MAX_SLEEP,
        max_cumulative_retry=None,
        max_retries=None,
        initial_delay=1.0,
        multiplier=2.0,
    ):
        if max_cumulative_retry is not None and max_retries is not None:
            raise ValueError(_SLEEP_RETRY_ERROR_MSG)
        if max_cumulative_retry is None and max_retries is None:
            max_cumulative_retry = MAX_CUMULATIVE_RETRY

        self.max_sleep = max_sleep
        self.max_cumulative_retry = max_cumulative_retry
        self.max_retries = max_retries
        self.initial_delay = initial_delay
        self.multiplier = multiplier

    def retry_allowed(self, total_sleep, num_retries):
        
        if self.max_cumulative_retry is None:
            return num_retries <= self.max_retries
        else:
            return total_sleep <= self.max_cumulative_retry
