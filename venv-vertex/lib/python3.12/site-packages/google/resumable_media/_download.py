
















import http.client
import re

from google.resumable_media import _helpers
from google.resumable_media import common


_CONTENT_RANGE_RE = re.compile(
    r"bytes (?P<start_byte>\d+)-(?P<end_byte>\d+)/(?P<total_bytes>\d+)",
    flags=re.IGNORECASE,
)
_ACCEPTABLE_STATUS_CODES = (http.client.OK, http.client.PARTIAL_CONTENT)
_GET = "GET"
_ZERO_CONTENT_RANGE_HEADER = "bytes */0"


class DownloadBase(object):
    

    def __init__(self, media_url, stream=None, start=None, end=None, headers=None):
        self.media_url = media_url
        self._stream = stream
        self.start = start
        self.end = end
        if headers is None:
            headers = {}
        self._headers = headers
        self._finished = False
        self._retry_strategy = common.RetryStrategy()

    @property
    def finished(self):
        
        return self._finished

    @staticmethod
    def _get_status_code(response):
        
        raise NotImplementedError("This implementation is virtual.")

    @staticmethod
    def _get_headers(response):
        
        raise NotImplementedError("This implementation is virtual.")

    @staticmethod
    def _get_body(response):
        
        raise NotImplementedError("This implementation is virtual.")


class Download(DownloadBase):
    

    def __init__(
        self, media_url, stream=None, start=None, end=None, headers=None, checksum="md5"
    ):
        super(Download, self).__init__(
            media_url, stream=stream, start=start, end=end, headers=headers
        )
        self.checksum = checksum
        self._bytes_downloaded = 0
        self._expected_checksum = None
        self._checksum_object = None
        self._object_generation = None

    def _prepare_request(self):
        
        if self.finished:
            raise ValueError("A download can only be used once.")

        add_bytes_range(self.start, self.end, self._headers)
        return _GET, self.media_url, None, self._headers

    def _process_response(self, response):
        
        
        self._finished = True
        _helpers.require_status_code(
            response, _ACCEPTABLE_STATUS_CODES, self._get_status_code
        )

    def consume(self, transport, timeout=None):
        
        raise NotImplementedError("This implementation is virtual.")


class ChunkedDownload(DownloadBase):
    

    def __init__(self, media_url, chunk_size, stream, start=0, end=None, headers=None):
        if start < 0:
            raise ValueError(
                "On a chunked download the starting " "value cannot be negative."
            )
        super(ChunkedDownload, self).__init__(
            media_url, stream=stream, start=start, end=end, headers=headers
        )
        self.chunk_size = chunk_size
        self._bytes_downloaded = 0
        self._total_bytes = None
        self._invalid = False

    @property
    def bytes_downloaded(self):
        
        return self._bytes_downloaded

    @property
    def total_bytes(self):
        
        return self._total_bytes

    @property
    def invalid(self):
        
        return self._invalid

    def _get_byte_range(self):
        
        curr_start = self.start + self.bytes_downloaded
        curr_end = curr_start + self.chunk_size - 1
        
        if self.end is not None:
            curr_end = min(curr_end, self.end)
        
        if self.total_bytes is not None:
            curr_end = min(curr_end, self.total_bytes - 1)
        return curr_start, curr_end

    def _prepare_request(self):
        
        if self.finished:
            raise ValueError("Download has finished.")
        if self.invalid:
            raise ValueError("Download is invalid and cannot be re-used.")

        curr_start, curr_end = self._get_byte_range()
        add_bytes_range(curr_start, curr_end, self._headers)
        return _GET, self.media_url, None, self._headers

    def _make_invalid(self):
        
        self._invalid = True

    def _process_response(self, response):
        
        
        if _check_for_zero_content_range(
            response, self._get_status_code, self._get_headers
        ):
            self._finished = True
            return

        _helpers.require_status_code(
            response,
            _ACCEPTABLE_STATUS_CODES,
            self._get_status_code,
            callback=self._make_invalid,
        )
        headers = self._get_headers(response)
        response_body = self._get_body(response)

        start_byte, end_byte, total_bytes = get_range_info(
            response, self._get_headers, callback=self._make_invalid
        )

        transfer_encoding = headers.get("transfer-encoding")

        if transfer_encoding is None:
            content_length = _helpers.header_required(
                response,
                "content-length",
                self._get_headers,
                callback=self._make_invalid,
            )
            num_bytes = int(content_length)
            if len(response_body) != num_bytes:
                self._make_invalid()
                raise common.InvalidResponse(
                    response,
                    "Response is different size than content-length",
                    "Expected",
                    num_bytes,
                    "Received",
                    len(response_body),
                )
        else:
            
            num_bytes = end_byte - start_byte + 1

        
        self._bytes_downloaded += num_bytes
        
        if self.end is not None and end_byte >= self.end:
            self._finished = True
        elif end_byte >= total_bytes - 1:
            self._finished = True
        
        if self.total_bytes is None:
            self._total_bytes = total_bytes
        
        self._stream.write(response_body)

    def consume_next_chunk(self, transport, timeout=None):
        
        raise NotImplementedError("This implementation is virtual.")


def add_bytes_range(start, end, headers):
    
    if start is None:
        if end is None:
            
            return
        else:
            
            bytes_range = "0-{:d}".format(end)
    else:
        if end is None:
            if start < 0:
                bytes_range = "{:d}".format(start)
            else:
                bytes_range = "{:d}-".format(start)
        else:
            
            bytes_range = "{:d}-{:d}".format(start, end)

    headers[_helpers.RANGE_HEADER] = "bytes=" + bytes_range


def get_range_info(response, get_headers, callback=_helpers.do_nothing):
    
    content_range = _helpers.header_required(
        response, _helpers.CONTENT_RANGE_HEADER, get_headers, callback=callback
    )
    match = _CONTENT_RANGE_RE.match(content_range)
    if match is None:
        callback()
        raise common.InvalidResponse(
            response,
            "Unexpected content-range header",
            content_range,
            'Expected to be of the form "bytes {start}-{end}/{total}"',
        )

    return (
        int(match.group("start_byte")),
        int(match.group("end_byte")),
        int(match.group("total_bytes")),
    )


def _check_for_zero_content_range(response, get_status_code, get_headers):
    
    if get_status_code(response) == http.client.REQUESTED_RANGE_NOT_SATISFIABLE:
        content_range = _helpers.header_required(
            response,
            _helpers.CONTENT_RANGE_HEADER,
            get_headers,
            callback=_helpers.do_nothing,
        )
        if content_range == _ZERO_CONTENT_RANGE_HEADER:
            return True
    return False
