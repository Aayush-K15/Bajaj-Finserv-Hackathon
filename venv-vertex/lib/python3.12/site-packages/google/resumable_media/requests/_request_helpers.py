















import http.client
import requests.exceptions
import urllib3.exceptions  

import time

from google.resumable_media import common
from google.resumable_media import _helpers

_DEFAULT_RETRY_STRATEGY = common.RetryStrategy()
_SINGLE_GET_CHUNK_SIZE = 8192



_DEFAULT_CONNECT_TIMEOUT = 61

_DEFAULT_READ_TIMEOUT = 60

_CONNECTION_ERROR_CLASSES = (
    http.client.BadStatusLine,
    http.client.IncompleteRead,
    http.client.ResponseNotReady,
    requests.exceptions.ConnectionError,
    requests.exceptions.ChunkedEncodingError,
    requests.exceptions.Timeout,
    urllib3.exceptions.PoolError,
    urllib3.exceptions.ProtocolError,
    urllib3.exceptions.SSLError,
    urllib3.exceptions.TimeoutError,
    ConnectionError,  
)


class RequestsMixin(object):
    

    @staticmethod
    def _get_status_code(response):
        
        return response.status_code

    @staticmethod
    def _get_headers(response):
        
        return response.headers

    @staticmethod
    def _get_body(response):
        
        return response.content


class RawRequestsMixin(RequestsMixin):
    @staticmethod
    def _get_body(response):
        
        if response._content is False:
            response._content = b"".join(
                response.raw.stream(_SINGLE_GET_CHUNK_SIZE, decode_content=False)
            )
            response._content_consumed = True
        return response._content


def wait_and_retry(func, get_status_code, retry_strategy):
    
    total_sleep = 0.0
    num_retries = 0
    
    base_wait = float(retry_strategy.initial_delay) / retry_strategy.multiplier

    
    
    

    while True:  
        error = None
        try:
            response = func()
        except _CONNECTION_ERROR_CLASSES as e:
            error = e  
        except common.InvalidResponse as e:
            
            
            
            if get_status_code(e.response) in common.RETRYABLE:
                error = e  
            else:
                raise  
        else:
            return response

        base_wait, wait_time = _helpers.calculate_retry_wait(
            base_wait, retry_strategy.max_sleep, retry_strategy.multiplier
        )
        num_retries += 1
        total_sleep += wait_time

        
        
        if not retry_strategy.retry_allowed(total_sleep, num_retries):
            raise error

        time.sleep(wait_time)
