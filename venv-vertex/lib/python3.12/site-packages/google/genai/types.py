
















from abc import ABC, abstractmethod
import datetime
from enum import Enum, EnumMeta
import inspect
import json
import logging
import sys
import types as builtin_types
import typing
from typing import Any, Callable, Literal, Optional, Sequence, Union, _UnionGenericAlias  
import pydantic
from pydantic import Field
from typing_extensions import Self, TypedDict
from . import _common

if sys.version_info >= (3, 10):
  
  VersionedUnionType = Union[builtin_types.UnionType, _UnionGenericAlias]
  _UNION_TYPES = (typing.Union, builtin_types.UnionType)
else:
  
  VersionedUnionType = _UnionGenericAlias
  _UNION_TYPES = (typing.Union,)

_is_pillow_image_imported = False
if typing.TYPE_CHECKING:
  from ._api_client import BaseApiClient
  import PIL.Image

  PIL_Image = PIL.Image.Image
  _is_pillow_image_imported = True
else:
  PIL_Image: typing.Type = Any
  try:
    import PIL.Image

    PIL_Image = PIL.Image.Image
    _is_pillow_image_imported = True
  except ImportError:
    PIL_Image = None

_is_mcp_imported = False
if typing.TYPE_CHECKING:
  from mcp import types as mcp_types
  from mcp import ClientSession as McpClientSession
  from mcp.types import CallToolResult as McpCallToolResult

  _is_mcp_imported = True
else:
  McpClientSession: typing.Type = Any
  McpCallToolResult: typing.Type = Any
  try:
    from mcp import types as mcp_types
    from mcp import ClientSession as McpClientSession
    from mcp.types import CallToolResult as McpCallToolResult

    _is_mcp_imported = True
  except ImportError:
    McpClientSession = None
    McpCallToolResult = None

logger = logging.getLogger('google_genai.types')

T = typing.TypeVar('T', bound='GenerateContentResponse')


class Outcome(_common.CaseInSensitiveEnum):
  

  OUTCOME_UNSPECIFIED = 'OUTCOME_UNSPECIFIED'
  
  OUTCOME_OK = 'OUTCOME_OK'
  
  OUTCOME_FAILED = 'OUTCOME_FAILED'
  
  OUTCOME_DEADLINE_EXCEEDED = 'OUTCOME_DEADLINE_EXCEEDED'
  


class Language(_common.CaseInSensitiveEnum):
  

  LANGUAGE_UNSPECIFIED = 'LANGUAGE_UNSPECIFIED'
  
  PYTHON = 'PYTHON'
  


class Type(_common.CaseInSensitiveEnum):
  

  TYPE_UNSPECIFIED = 'TYPE_UNSPECIFIED'
  
  STRING = 'STRING'
  
  NUMBER = 'NUMBER'
  
  INTEGER = 'INTEGER'
  
  BOOLEAN = 'BOOLEAN'
  
  ARRAY = 'ARRAY'
  
  OBJECT = 'OBJECT'
  
  NULL = 'NULL'
  


class HarmCategory(_common.CaseInSensitiveEnum):
  

  HARM_CATEGORY_UNSPECIFIED = 'HARM_CATEGORY_UNSPECIFIED'
  
  HARM_CATEGORY_HATE_SPEECH = 'HARM_CATEGORY_HATE_SPEECH'
  
  HARM_CATEGORY_DANGEROUS_CONTENT = 'HARM_CATEGORY_DANGEROUS_CONTENT'
  
  HARM_CATEGORY_HARASSMENT = 'HARM_CATEGORY_HARASSMENT'
  
  HARM_CATEGORY_SEXUALLY_EXPLICIT = 'HARM_CATEGORY_SEXUALLY_EXPLICIT'
  
  HARM_CATEGORY_CIVIC_INTEGRITY = 'HARM_CATEGORY_CIVIC_INTEGRITY'
  
  HARM_CATEGORY_IMAGE_HATE = 'HARM_CATEGORY_IMAGE_HATE'
  
  HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT = (
      'HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT'
  )
  
  HARM_CATEGORY_IMAGE_HARASSMENT = 'HARM_CATEGORY_IMAGE_HARASSMENT'
  
  HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT = (
      'HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT'
  )
  


class HarmBlockMethod(_common.CaseInSensitiveEnum):
  

  HARM_BLOCK_METHOD_UNSPECIFIED = 'HARM_BLOCK_METHOD_UNSPECIFIED'
  
  SEVERITY = 'SEVERITY'
  
  PROBABILITY = 'PROBABILITY'
  


class HarmBlockThreshold(_common.CaseInSensitiveEnum):
  

  HARM_BLOCK_THRESHOLD_UNSPECIFIED = 'HARM_BLOCK_THRESHOLD_UNSPECIFIED'
  
  BLOCK_LOW_AND_ABOVE = 'BLOCK_LOW_AND_ABOVE'
  
  BLOCK_MEDIUM_AND_ABOVE = 'BLOCK_MEDIUM_AND_ABOVE'
  
  BLOCK_ONLY_HIGH = 'BLOCK_ONLY_HIGH'
  
  BLOCK_NONE = 'BLOCK_NONE'
  
  OFF = 'OFF'
  


class Mode(_common.CaseInSensitiveEnum):
  

  MODE_UNSPECIFIED = 'MODE_UNSPECIFIED'
  
  MODE_DYNAMIC = 'MODE_DYNAMIC'
  


class AuthType(_common.CaseInSensitiveEnum):
  

  AUTH_TYPE_UNSPECIFIED = 'AUTH_TYPE_UNSPECIFIED'
  NO_AUTH = 'NO_AUTH'
  
  API_KEY_AUTH = 'API_KEY_AUTH'
  
  HTTP_BASIC_AUTH = 'HTTP_BASIC_AUTH'
  
  GOOGLE_SERVICE_ACCOUNT_AUTH = 'GOOGLE_SERVICE_ACCOUNT_AUTH'
  
  OAUTH = 'OAUTH'
  
  OIDC_AUTH = 'OIDC_AUTH'
  


class ApiSpec(_common.CaseInSensitiveEnum):
  

  API_SPEC_UNSPECIFIED = 'API_SPEC_UNSPECIFIED'
  
  SIMPLE_SEARCH = 'SIMPLE_SEARCH'
  
  ELASTIC_SEARCH = 'ELASTIC_SEARCH'
  


class Environment(_common.CaseInSensitiveEnum):
  

  ENVIRONMENT_UNSPECIFIED = 'ENVIRONMENT_UNSPECIFIED'
  
  ENVIRONMENT_BROWSER = 'ENVIRONMENT_BROWSER'
  


class UrlRetrievalStatus(_common.CaseInSensitiveEnum):
  

  URL_RETRIEVAL_STATUS_UNSPECIFIED = 'URL_RETRIEVAL_STATUS_UNSPECIFIED'
  
  URL_RETRIEVAL_STATUS_SUCCESS = 'URL_RETRIEVAL_STATUS_SUCCESS'
  
  URL_RETRIEVAL_STATUS_ERROR = 'URL_RETRIEVAL_STATUS_ERROR'
  


class FinishReason(_common.CaseInSensitiveEnum):
  

  FINISH_REASON_UNSPECIFIED = 'FINISH_REASON_UNSPECIFIED'
  
  STOP = 'STOP'
  
  MAX_TOKENS = 'MAX_TOKENS'
  
  SAFETY = 'SAFETY'
  
  RECITATION = 'RECITATION'
  
  LANGUAGE = 'LANGUAGE'
  
  OTHER = 'OTHER'
  
  BLOCKLIST = 'BLOCKLIST'
  
  PROHIBITED_CONTENT = 'PROHIBITED_CONTENT'
  
  SPII = 'SPII'
  
  MALFORMED_FUNCTION_CALL = 'MALFORMED_FUNCTION_CALL'
  
  IMAGE_SAFETY = 'IMAGE_SAFETY'
  
  UNEXPECTED_TOOL_CALL = 'UNEXPECTED_TOOL_CALL'
  


class HarmProbability(_common.CaseInSensitiveEnum):
  

  HARM_PROBABILITY_UNSPECIFIED = 'HARM_PROBABILITY_UNSPECIFIED'
  
  NEGLIGIBLE = 'NEGLIGIBLE'
  
  LOW = 'LOW'
  
  MEDIUM = 'MEDIUM'
  
  HIGH = 'HIGH'
  


class HarmSeverity(_common.CaseInSensitiveEnum):
  

  HARM_SEVERITY_UNSPECIFIED = 'HARM_SEVERITY_UNSPECIFIED'
  
  HARM_SEVERITY_NEGLIGIBLE = 'HARM_SEVERITY_NEGLIGIBLE'
  
  HARM_SEVERITY_LOW = 'HARM_SEVERITY_LOW'
  
  HARM_SEVERITY_MEDIUM = 'HARM_SEVERITY_MEDIUM'
  
  HARM_SEVERITY_HIGH = 'HARM_SEVERITY_HIGH'
  


class BlockedReason(_common.CaseInSensitiveEnum):
  

  BLOCKED_REASON_UNSPECIFIED = 'BLOCKED_REASON_UNSPECIFIED'
  
  SAFETY = 'SAFETY'
  
  OTHER = 'OTHER'
  
  BLOCKLIST = 'BLOCKLIST'
  
  PROHIBITED_CONTENT = 'PROHIBITED_CONTENT'
  
  IMAGE_SAFETY = 'IMAGE_SAFETY'
  


class TrafficType(_common.CaseInSensitiveEnum):
  

  TRAFFIC_TYPE_UNSPECIFIED = 'TRAFFIC_TYPE_UNSPECIFIED'
  
  ON_DEMAND = 'ON_DEMAND'
  
  PROVISIONED_THROUGHPUT = 'PROVISIONED_THROUGHPUT'
  


class Modality(_common.CaseInSensitiveEnum):
  

  MODALITY_UNSPECIFIED = 'MODALITY_UNSPECIFIED'
  
  TEXT = 'TEXT'
  
  IMAGE = 'IMAGE'
  
  AUDIO = 'AUDIO'
  


class MediaResolution(_common.CaseInSensitiveEnum):
  

  MEDIA_RESOLUTION_UNSPECIFIED = 'MEDIA_RESOLUTION_UNSPECIFIED'
  
  MEDIA_RESOLUTION_LOW = 'MEDIA_RESOLUTION_LOW'
  
  MEDIA_RESOLUTION_MEDIUM = 'MEDIA_RESOLUTION_MEDIUM'
  
  MEDIA_RESOLUTION_HIGH = 'MEDIA_RESOLUTION_HIGH'
  


class JobState(_common.CaseInSensitiveEnum):
  

  JOB_STATE_UNSPECIFIED = 'JOB_STATE_UNSPECIFIED'
  
  JOB_STATE_QUEUED = 'JOB_STATE_QUEUED'
  
  JOB_STATE_PENDING = 'JOB_STATE_PENDING'
  
  JOB_STATE_RUNNING = 'JOB_STATE_RUNNING'
  
  JOB_STATE_SUCCEEDED = 'JOB_STATE_SUCCEEDED'
  
  JOB_STATE_FAILED = 'JOB_STATE_FAILED'
  
  JOB_STATE_CANCELLING = 'JOB_STATE_CANCELLING'
  
  JOB_STATE_CANCELLED = 'JOB_STATE_CANCELLED'
  
  JOB_STATE_PAUSED = 'JOB_STATE_PAUSED'
  
  JOB_STATE_EXPIRED = 'JOB_STATE_EXPIRED'
  
  JOB_STATE_UPDATING = 'JOB_STATE_UPDATING'
  
  JOB_STATE_PARTIALLY_SUCCEEDED = 'JOB_STATE_PARTIALLY_SUCCEEDED'
  


class AdapterSize(_common.CaseInSensitiveEnum):
  

  ADAPTER_SIZE_UNSPECIFIED = 'ADAPTER_SIZE_UNSPECIFIED'
  
  ADAPTER_SIZE_ONE = 'ADAPTER_SIZE_ONE'
  
  ADAPTER_SIZE_TWO = 'ADAPTER_SIZE_TWO'
  
  ADAPTER_SIZE_FOUR = 'ADAPTER_SIZE_FOUR'
  
  ADAPTER_SIZE_EIGHT = 'ADAPTER_SIZE_EIGHT'
  
  ADAPTER_SIZE_SIXTEEN = 'ADAPTER_SIZE_SIXTEEN'
  
  ADAPTER_SIZE_THIRTY_TWO = 'ADAPTER_SIZE_THIRTY_TWO'
  


class FeatureSelectionPreference(_common.CaseInSensitiveEnum):
  

  FEATURE_SELECTION_PREFERENCE_UNSPECIFIED = (
      'FEATURE_SELECTION_PREFERENCE_UNSPECIFIED'
  )
  PRIORITIZE_QUALITY = 'PRIORITIZE_QUALITY'
  BALANCED = 'BALANCED'
  PRIORITIZE_COST = 'PRIORITIZE_COST'


class Behavior(_common.CaseInSensitiveEnum):
  

  UNSPECIFIED = 'UNSPECIFIED'
  
  BLOCKING = 'BLOCKING'
  
  NON_BLOCKING = 'NON_BLOCKING'
  


class DynamicRetrievalConfigMode(_common.CaseInSensitiveEnum):
  

  MODE_UNSPECIFIED = 'MODE_UNSPECIFIED'
  
  MODE_DYNAMIC = 'MODE_DYNAMIC'
  


class FunctionCallingConfigMode(_common.CaseInSensitiveEnum):
  

  MODE_UNSPECIFIED = 'MODE_UNSPECIFIED'
  
  AUTO = 'AUTO'
  
  ANY = 'ANY'
  
  NONE = 'NONE'
  


class SafetyFilterLevel(_common.CaseInSensitiveEnum):
  

  BLOCK_LOW_AND_ABOVE = 'BLOCK_LOW_AND_ABOVE'
  BLOCK_MEDIUM_AND_ABOVE = 'BLOCK_MEDIUM_AND_ABOVE'
  BLOCK_ONLY_HIGH = 'BLOCK_ONLY_HIGH'
  BLOCK_NONE = 'BLOCK_NONE'


class PersonGeneration(_common.CaseInSensitiveEnum):
  

  DONT_ALLOW = 'DONT_ALLOW'
  
  ALLOW_ADULT = 'ALLOW_ADULT'
  
  ALLOW_ALL = 'ALLOW_ALL'
  


class ImagePromptLanguage(_common.CaseInSensitiveEnum):
  

  auto = 'auto'
  
  en = 'en'
  
  ja = 'ja'
  
  ko = 'ko'
  
  hi = 'hi'
  
  zh = 'zh'
  
  pt = 'pt'
  
  es = 'es'
  


class MaskReferenceMode(_common.CaseInSensitiveEnum):
  

  MASK_MODE_DEFAULT = 'MASK_MODE_DEFAULT'
  MASK_MODE_USER_PROVIDED = 'MASK_MODE_USER_PROVIDED'
  MASK_MODE_BACKGROUND = 'MASK_MODE_BACKGROUND'
  MASK_MODE_FOREGROUND = 'MASK_MODE_FOREGROUND'
  MASK_MODE_SEMANTIC = 'MASK_MODE_SEMANTIC'


class ControlReferenceType(_common.CaseInSensitiveEnum):
  

  CONTROL_TYPE_DEFAULT = 'CONTROL_TYPE_DEFAULT'
  CONTROL_TYPE_CANNY = 'CONTROL_TYPE_CANNY'
  CONTROL_TYPE_SCRIBBLE = 'CONTROL_TYPE_SCRIBBLE'
  CONTROL_TYPE_FACE_MESH = 'CONTROL_TYPE_FACE_MESH'


class SubjectReferenceType(_common.CaseInSensitiveEnum):
  

  SUBJECT_TYPE_DEFAULT = 'SUBJECT_TYPE_DEFAULT'
  SUBJECT_TYPE_PERSON = 'SUBJECT_TYPE_PERSON'
  SUBJECT_TYPE_ANIMAL = 'SUBJECT_TYPE_ANIMAL'
  SUBJECT_TYPE_PRODUCT = 'SUBJECT_TYPE_PRODUCT'


class EditMode(_common.CaseInSensitiveEnum):
  

  EDIT_MODE_DEFAULT = 'EDIT_MODE_DEFAULT'
  EDIT_MODE_INPAINT_REMOVAL = 'EDIT_MODE_INPAINT_REMOVAL'
  EDIT_MODE_INPAINT_INSERTION = 'EDIT_MODE_INPAINT_INSERTION'
  EDIT_MODE_OUTPAINT = 'EDIT_MODE_OUTPAINT'
  EDIT_MODE_CONTROLLED_EDITING = 'EDIT_MODE_CONTROLLED_EDITING'
  EDIT_MODE_STYLE = 'EDIT_MODE_STYLE'
  EDIT_MODE_BGSWAP = 'EDIT_MODE_BGSWAP'
  EDIT_MODE_PRODUCT_IMAGE = 'EDIT_MODE_PRODUCT_IMAGE'


class VideoCompressionQuality(_common.CaseInSensitiveEnum):
  

  OPTIMIZED = 'OPTIMIZED'
  
  LOSSLESS = 'LOSSLESS'
  


class FileState(_common.CaseInSensitiveEnum):
  

  STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
  PROCESSING = 'PROCESSING'
  ACTIVE = 'ACTIVE'
  FAILED = 'FAILED'


class FileSource(_common.CaseInSensitiveEnum):
  

  SOURCE_UNSPECIFIED = 'SOURCE_UNSPECIFIED'
  UPLOADED = 'UPLOADED'
  GENERATED = 'GENERATED'


class MediaModality(_common.CaseInSensitiveEnum):
  

  MODALITY_UNSPECIFIED = 'MODALITY_UNSPECIFIED'
  
  TEXT = 'TEXT'
  
  IMAGE = 'IMAGE'
  
  VIDEO = 'VIDEO'
  
  AUDIO = 'AUDIO'
  
  DOCUMENT = 'DOCUMENT'
  


class StartSensitivity(_common.CaseInSensitiveEnum):
  

  START_SENSITIVITY_UNSPECIFIED = 'START_SENSITIVITY_UNSPECIFIED'
  
  START_SENSITIVITY_HIGH = 'START_SENSITIVITY_HIGH'
  
  START_SENSITIVITY_LOW = 'START_SENSITIVITY_LOW'
  


class EndSensitivity(_common.CaseInSensitiveEnum):
  

  END_SENSITIVITY_UNSPECIFIED = 'END_SENSITIVITY_UNSPECIFIED'
  
  END_SENSITIVITY_HIGH = 'END_SENSITIVITY_HIGH'
  
  END_SENSITIVITY_LOW = 'END_SENSITIVITY_LOW'
  


class ActivityHandling(_common.CaseInSensitiveEnum):
  

  ACTIVITY_HANDLING_UNSPECIFIED = 'ACTIVITY_HANDLING_UNSPECIFIED'
  
  START_OF_ACTIVITY_INTERRUPTS = 'START_OF_ACTIVITY_INTERRUPTS'
  
  NO_INTERRUPTION = 'NO_INTERRUPTION'
  


class TurnCoverage(_common.CaseInSensitiveEnum):
  

  TURN_COVERAGE_UNSPECIFIED = 'TURN_COVERAGE_UNSPECIFIED'
  
  TURN_INCLUDES_ONLY_ACTIVITY = 'TURN_INCLUDES_ONLY_ACTIVITY'
  
  TURN_INCLUDES_ALL_INPUT = 'TURN_INCLUDES_ALL_INPUT'
  


class FunctionResponseScheduling(_common.CaseInSensitiveEnum):
  

  SCHEDULING_UNSPECIFIED = 'SCHEDULING_UNSPECIFIED'
  
  SILENT = 'SILENT'
  
  WHEN_IDLE = 'WHEN_IDLE'
  
  INTERRUPT = 'INTERRUPT'
  


class Scale(_common.CaseInSensitiveEnum):
  

  SCALE_UNSPECIFIED = 'SCALE_UNSPECIFIED'
  
  C_MAJOR_A_MINOR = 'C_MAJOR_A_MINOR'
  
  D_FLAT_MAJOR_B_FLAT_MINOR = 'D_FLAT_MAJOR_B_FLAT_MINOR'
  
  D_MAJOR_B_MINOR = 'D_MAJOR_B_MINOR'
  
  E_FLAT_MAJOR_C_MINOR = 'E_FLAT_MAJOR_C_MINOR'
  
  E_MAJOR_D_FLAT_MINOR = 'E_MAJOR_D_FLAT_MINOR'
  
  F_MAJOR_D_MINOR = 'F_MAJOR_D_MINOR'
  
  G_FLAT_MAJOR_E_FLAT_MINOR = 'G_FLAT_MAJOR_E_FLAT_MINOR'
  
  G_MAJOR_E_MINOR = 'G_MAJOR_E_MINOR'
  
  A_FLAT_MAJOR_F_MINOR = 'A_FLAT_MAJOR_F_MINOR'
  
  A_MAJOR_G_FLAT_MINOR = 'A_MAJOR_G_FLAT_MINOR'
  
  B_FLAT_MAJOR_G_MINOR = 'B_FLAT_MAJOR_G_MINOR'
  
  B_MAJOR_A_FLAT_MINOR = 'B_MAJOR_A_FLAT_MINOR'
  


class LiveMusicPlaybackControl(_common.CaseInSensitiveEnum):
  

  PLAYBACK_CONTROL_UNSPECIFIED = 'PLAYBACK_CONTROL_UNSPECIFIED'
  
  PLAY = 'PLAY'
  
  PAUSE = 'PAUSE'
  
  STOP = 'STOP'
  
  RESET_CONTEXT = 'RESET_CONTEXT'
  


class VideoMetadata(_common.BaseModel):
  

  fps: Optional[float] = Field(
      default=None,
      description=,
  )
  end_offset: Optional[str] = Field(
      default=None, description=
  )
  start_offset: Optional[str] = Field(
      default=None, description=
  )


class VideoMetadataDict(TypedDict, total=False):
  

  fps: Optional[float]
  

  end_offset: Optional[str]
  

  start_offset: Optional[str]
  


VideoMetadataOrDict = Union[VideoMetadata, VideoMetadataDict]


class Blob(_common.BaseModel):
  

  display_name: Optional[str] = Field(
      default=None,
      description=,
  )
  data: Optional[bytes] = Field(
      default=None, description=
  )
  mime_type: Optional[str] = Field(
      default=None,
      description=,
  )


class BlobDict(TypedDict, total=False):
  

  display_name: Optional[str]
  

  data: Optional[bytes]
  

  mime_type: Optional[str]
  


BlobOrDict = Union[Blob, BlobDict]


class FileData(_common.BaseModel):
  

  display_name: Optional[str] = Field(
      default=None,
      description=,
  )
  file_uri: Optional[str] = Field(
      default=None, description=
  )
  mime_type: Optional[str] = Field(
      default=None,
      description=,
  )


class FileDataDict(TypedDict, total=False):
  

  display_name: Optional[str]
  

  file_uri: Optional[str]
  

  mime_type: Optional[str]
  


FileDataOrDict = Union[FileData, FileDataDict]


class CodeExecutionResult(_common.BaseModel):
  

  outcome: Optional[Outcome] = Field(
      default=None, description=
  )
  output: Optional[str] = Field(
      default=None,
      description=,
  )


class CodeExecutionResultDict(TypedDict, total=False):
  

  outcome: Optional[Outcome]
  

  output: Optional[str]
  


CodeExecutionResultOrDict = Union[CodeExecutionResult, CodeExecutionResultDict]


class ExecutableCode(_common.BaseModel):
  

  code: Optional[str] = Field(
      default=None, description=
  )
  language: Optional[Language] = Field(
      default=None,
      description=,
  )


class ExecutableCodeDict(TypedDict, total=False):
  

  code: Optional[str]
  

  language: Optional[Language]
  


ExecutableCodeOrDict = Union[ExecutableCode, ExecutableCodeDict]


class FunctionCall(_common.BaseModel):
  

  id: Optional[str] = Field(
      default=None,
      description=,
  )
  args: Optional[dict[str, Any]] = Field(
      default=None,
      description=,
  )
  name: Optional[str] = Field(
      default=None,
      description=,
  )


class FunctionCallDict(TypedDict, total=False):
  

  id: Optional[str]
  

  args: Optional[dict[str, Any]]
  

  name: Optional[str]
  


FunctionCallOrDict = Union[FunctionCall, FunctionCallDict]


class FunctionResponse(_common.BaseModel):
  

  will_continue: Optional[bool] = Field(
      default=None,
      description=,
  )
  scheduling: Optional[FunctionResponseScheduling] = Field(
      default=None,
      description=,
  )
  id: Optional[str] = Field(
      default=None,
      description=,
  )
  name: Optional[str] = Field(
      default=None,
      description=,
  )
  response: Optional[dict[str, Any]] = Field(
      default=None,
      description=,
  )

  @classmethod
  def from_mcp_response(
      cls, *, name: str, response: McpCallToolResult
  ) -> 'FunctionResponse':
    if not _is_mcp_imported:
      raise ValueError(
          'MCP response is not supported. Please ensure that the MCP library is'
          ' imported.'
      )

    if response.isError:
      return cls(name=name, response={'error': 'MCP response is error.'})
    else:
      return cls(name=name, response={'result': response.content})


class FunctionResponseDict(TypedDict, total=False):
  

  will_continue: Optional[bool]
  

  scheduling: Optional[FunctionResponseScheduling]
  

  id: Optional[str]
  

  name: Optional[str]
  

  response: Optional[dict[str, Any]]
  


FunctionResponseOrDict = Union[FunctionResponse, FunctionResponseDict]


class Part(_common.BaseModel):
  

  video_metadata: Optional[VideoMetadata] = Field(
      default=None, description=
  )
  thought: Optional[bool] = Field(
      default=None,
      description=,
  )
  inline_data: Optional[Blob] = Field(
      default=None, description=
  )
  file_data: Optional[FileData] = Field(
      default=None, description=
  )
  thought_signature: Optional[bytes] = Field(
      default=None,
      description=,
  )
  code_execution_result: Optional[CodeExecutionResult] = Field(
      default=None,
      description=,
  )
  executable_code: Optional[ExecutableCode] = Field(
      default=None,
      description=,
  )
  function_call: Optional[FunctionCall] = Field(
      default=None,
      description=,
  )
  function_response: Optional[FunctionResponse] = Field(
      default=None,
      description=,
  )
  text: Optional[str] = Field(
      default=None, description=
  )

  @classmethod
  def from_uri(
      cls, *, file_uri: str, mime_type: Optional[str] = None
  ) -> 'Part':
    
    if mime_type is None:
      import mimetypes

      mime_type, _ = mimetypes.guess_type(file_uri)
      if not mime_type:
        raise ValueError(f'Failed to determine mime type for file: {file_uri}')
    file_data = FileData(file_uri=file_uri, mime_type=mime_type)
    return cls(file_data=file_data)

  @classmethod
  def from_text(cls, *, text: str) -> 'Part':
    return cls(text=text)

  @classmethod
  def from_bytes(cls, *, data: bytes, mime_type: str) -> 'Part':
    inline_data = Blob(
        data=data,
        mime_type=mime_type,
    )
    return cls(inline_data=inline_data)

  @classmethod
  def from_function_call(cls, *, name: str, args: dict[str, Any]) -> 'Part':
    function_call = FunctionCall(name=name, args=args)
    return cls(function_call=function_call)

  @classmethod
  def from_function_response(
      cls, *, name: str, response: dict[str, Any]
  ) -> 'Part':
    function_response = FunctionResponse(name=name, response=response)
    return cls(function_response=function_response)

  @classmethod
  def from_executable_code(cls, *, code: str, language: Language) -> 'Part':
    executable_code = ExecutableCode(code=code, language=language)
    return cls(executable_code=executable_code)

  @classmethod
  def from_code_execution_result(
      cls, *, outcome: Outcome, output: str
  ) -> 'Part':
    code_execution_result = CodeExecutionResult(outcome=outcome, output=output)
    return cls(code_execution_result=code_execution_result)


class PartDict(TypedDict, total=False):
  

  video_metadata: Optional[VideoMetadataDict]
  

  thought: Optional[bool]
  

  inline_data: Optional[BlobDict]
  

  file_data: Optional[FileDataDict]
  

  thought_signature: Optional[bytes]
  

  code_execution_result: Optional[CodeExecutionResultDict]
  

  executable_code: Optional[ExecutableCodeDict]
  

  function_call: Optional[FunctionCallDict]
  

  function_response: Optional[FunctionResponseDict]
  

  text: Optional[str]
  


PartOrDict = Union[Part, PartDict]


class Content(_common.BaseModel):
  

  parts: Optional[list[Part]] = Field(
      default=None,
      description=,
  )
  role: Optional[str] = Field(
      default=None,
      description=,
  )


class UserContent(Content):
  

  role: Literal['user'] = Field(default='user', init=False, frozen=True)
  parts: list[Part] = Field()

  def __init__(
      self, parts: Union['PartUnionDict', list['PartUnionDict'], list['Part']]
  ):
    from . import _transformers as t

    super().__init__(parts=t.t_parts(parts=parts))


class ModelContent(Content):
  

  role: Literal['model'] = Field(default='model', init=False, frozen=True)
  parts: list[Part] = Field()

  def __init__(
      self, parts: Union['PartUnionDict', list['PartUnionDict'], list['Part']]
  ):
    from . import _transformers as t

    super().__init__(parts=t.t_parts(parts=parts))


class ContentDict(TypedDict, total=False):
  

  parts: Optional[list[PartDict]]
  

  role: Optional[str]
  


ContentOrDict = Union[Content, ContentDict]


class HttpRetryOptions(_common.BaseModel):
  

  attempts: Optional[int] = Field(
      default=None,
      description=,
  )
  initial_delay: Optional[float] = Field(
      default=None,
      description=,
  )
  max_delay: Optional[float] = Field(
      default=None,
      description=,
  )
  exp_base: Optional[float] = Field(
      default=None,
      description=,
  )
  jitter: Optional[float] = Field(
      default=None, description=
  )
  http_status_codes: Optional[list[int]] = Field(
      default=None,
      description=,
  )


class HttpRetryOptionsDict(TypedDict, total=False):
  

  attempts: Optional[int]
  

  initial_delay: Optional[float]
  

  max_delay: Optional[float]
  

  exp_base: Optional[float]
  

  jitter: Optional[float]
  

  http_status_codes: Optional[list[int]]
  


HttpRetryOptionsOrDict = Union[HttpRetryOptions, HttpRetryOptionsDict]


class HttpOptions(_common.BaseModel):
  

  base_url: Optional[str] = Field(
      default=None,
      description=,
  )
  api_version: Optional[str] = Field(
      default=None, description=
  )
  headers: Optional[dict[str, str]] = Field(
      default=None,
      description=,
  )
  timeout: Optional[int] = Field(
      default=None, description=
  )
  client_args: Optional[dict[str, Any]] = Field(
      default=None, description=
  )
  async_client_args: Optional[dict[str, Any]] = Field(
      default=None, description=
  )
  extra_body: Optional[dict[str, Any]] = Field(
      default=None,
      description=,
  )
  retry_options: Optional[HttpRetryOptions] = Field(
      default=None, description=
  )


class HttpOptionsDict(TypedDict, total=False):
  

  base_url: Optional[str]
  

  api_version: Optional[str]
  

  headers: Optional[dict[str, str]]
  

  timeout: Optional[int]
  

  client_args: Optional[dict[str, Any]]
  

  async_client_args: Optional[dict[str, Any]]
  

  extra_body: Optional[dict[str, Any]]
  

  retry_options: Optional[HttpRetryOptionsDict]
  


HttpOptionsOrDict = Union[HttpOptions, HttpOptionsDict]


class JSONSchemaType(Enum):
  

  NULL = 'null'
  BOOLEAN = 'boolean'
  OBJECT = 'object'
  ARRAY = 'array'
  NUMBER = 'number'
  INTEGER = 'integer'
  STRING = 'string'


class JSONSchema(pydantic.BaseModel):
  

  type: Optional[Union[JSONSchemaType, list[JSONSchemaType]]] = Field(
      default=None,
      description=,
  )
  format: Optional[str] = Field(
      default=None,
      description='Define semantic information about a string instance.',
  )
  title: Optional[str] = Field(
      default=None,
      description=(
          'A preferably short description about the purpose of the instance'
          ' described by the schema.'
      ),
  )
  description: Optional[str] = Field(
      default=None,
      description=(
          'An explanation about the purpose of the instance described by the'
          ' schema.'
      ),
  )
  default: Optional[Any] = Field(
      default=None,
      description=(
          'This keyword can be used to supply a default JSON value associated'
          ' with a particular schema.'
      ),
  )
  items: Optional['JSONSchema'] = Field(
      default=None,
      description=(
          'Validation succeeds if each element of the instance not covered by'
          ' prefixItems validates against this schema.'
      ),
  )
  min_items: Optional[int] = Field(
      default=None,
      description=(
          'An array instance is valid if its size is greater than, or equal to,'
          ' the value of this keyword.'
      ),
  )
  max_items: Optional[int] = Field(
      default=None,
      description=(
          'An array instance is valid if its size is less than, or equal to,'
          ' the value of this keyword.'
      ),
  )
  enum: Optional[list[Any]] = Field(
      default=None,
      description=(
          'Validation succeeds if the instance is equal to one of the elements'
          ' in this keyword’s array value.'
      ),
  )
  properties: Optional[dict[str, 'JSONSchema']] = Field(
      default=None,
      description=(
          'Validation succeeds if, for each name that appears in both the'
          ' instance and as a name within this keyword’s value, the child'
          ' instance for that name successfully validates against the'
          ' corresponding schema.'
      ),
  )
  required: Optional[list[str]] = Field(
      default=None,
      description=(
          'An object instance is valid against this keyword if every item in'
          ' the array is the name of a property in the instance.'
      ),
  )
  min_properties: Optional[int] = Field(
      default=None,
      description=(
          'An object instance is valid if its number of properties is greater'
          ' than, or equal to, the value of this keyword.'
      ),
  )
  max_properties: Optional[int] = Field(
      default=None,
      description=(
          'An object instance is valid if its number of properties is less'
          ' than, or equal to, the value of this keyword.'
      ),
  )
  minimum: Optional[float] = Field(
      default=None,
      description=(
          'Validation succeeds if the numeric instance is greater than or equal'
          ' to the given number.'
      ),
  )
  maximum: Optional[float] = Field(
      default=None,
      description=(
          'Validation succeeds if the numeric instance is less than or equal to'
          ' the given number.'
      ),
  )
  min_length: Optional[int] = Field(
      default=None,
      description=(
          'A string instance is valid against this keyword if its length is'
          ' greater than, or equal to, the value of this keyword.'
      ),
  )
  max_length: Optional[int] = Field(
      default=None,
      description=(
          'A string instance is valid against this keyword if its length is'
          ' less than, or equal to, the value of this keyword.'
      ),
  )
  pattern: Optional[str] = Field(
      default=None,
      description=(
          'A string instance is considered valid if the regular expression'
          ' matches the instance successfully.'
      ),
  )
  any_of: Optional[list['JSONSchema']] = Field(
      default=None,
      description=(
          'An instance validates successfully against this keyword if it'
          ' validates successfully against at least one schema defined by this'
          ' keyword’s value.'
      ),
  )


class Schema(_common.BaseModel):
  

  additional_properties: Optional[Any] = Field(
      default=None,
      description=,
  )
  defs: Optional[dict[str, 'Schema']] = Field(
      default=None,
      description=,
  )
  ref: Optional[str] = Field(
      default=None,
      description=Optional. The value should be validated against any (one or more) of the subschemas in the list.Optional. Default value of the data.Optional. The description of the data.Optional. Possible values of the element of primitive type with enum format. Examples: 1. We can define direction as : {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]} 2. We can define apartment number as : {type:INTEGER, format:enum, enum:["101", "201", "301"]}Optional. Example of the object. Will only populated when the object is the root.Optional. The format of the data. Supported formats: for NUMBER type: "float", "double" for INTEGER type: "int32", "int64" for STRING type: "email", "byte", etcOptional. SCHEMA FIELDS FOR TYPE ARRAY Schema of the elements of Type.ARRAY.Optional. Maximum number of the elements for Type.ARRAY.Optional. Maximum length of the Type.STRINGOptional. Maximum number of the properties for Type.OBJECT.Optional. Maximum value of the Type.INTEGER and Type.NUMBEROptional. Minimum number of the elements for Type.ARRAY.Optional. SCHEMA FIELDS FOR TYPE STRING Minimum length of the Type.STRINGOptional. Minimum number of the properties for Type.OBJECT.Optional. SCHEMA FIELDS FOR TYPE INTEGER and NUMBER Minimum value of the Type.INTEGER and Type.NUMBEROptional. Indicates if the value may be null.Optional. Pattern of the Type.STRING to restrict a string to a regular expression.Optional. SCHEMA FIELDS FOR TYPE OBJECT Properties of Type.OBJECT.Optional. The order of the properties. Not a standard field in open api spec. Only used to support the order of the properties.Optional. Required properties of Type.OBJECT.Optional. The title of the Schema.Optional. The type of the data.Converts the Schema object to a JSONSchema object, that is compatible with 2020-12 JSON Schema draft.

    If a Schema field is not supported by JSONSchema, it will be ignored.
    Converts a JSONSchema object to a Schema object.

    The JSONSchema is compatible with 2020-12 JSON Schema draft, specified by
    OpenAPI 3.1.

    Args:
        json_schema: JSONSchema object to be converted.
        api_option: API option to be used. If set to 'VERTEX_AI', the JSONSchema
          will be converted to a Schema object that is compatible with Vertex AI
          API. If set to 'GEMINI_API', the JSONSchema will be converted to a
          Schema object that is compatible with Gemini API. Default is
          'GEMINI_API'.
        raise_error_on_unsupported_field: If set to True, an error will be
          raised if the JSONSchema contains any unsupported fields. Default is
          False.

    Returns:
        Schema object that is compatible with the specified API option.
    Raises:
        ValueError: If the JSONSchema contains any unsupported fields and
          raise_error_on_unsupported_field is set to True. Or if the JSONSchema
          is not compatible with the specified API option.
    Returns (non_null_types, nullable)Raises an error if the JSONSchema cannot be converted to the specified Schema object.Copies the fields from json_schema_dict to sub_schema_in_any_of.Schema is used to define the format of input/output data.

  Represents a select subset of an [OpenAPI 3.0 schema
  object](https://spec.openapis.org/oas/v3.0.3
  be added in the future as needed.
  Optional. Can either be a boolean or an object; controls the presence of additional properties.Optional. A map of definitions for use by `ref` Only allowed at the root of the schema.Optional. Allows indirect references between schema nodes. The value should be a valid reference to a child of the root `defs`. For example, the following schema defines a reference to a schema node named "Pet": type: object properties: pet: ref: 

  any_of: Optional[list['SchemaDict']]
  

  default: Optional[Any]
  

  description: Optional[str]
  

  enum: Optional[list[str]]
  

  example: Optional[Any]
  

  format: Optional[str]
  

  items: Optional['SchemaDict']
  

  max_items: Optional[int]
  

  max_length: Optional[int]
  

  max_properties: Optional[int]
  

  maximum: Optional[float]
  

  min_items: Optional[int]
  

  min_length: Optional[int]
  

  min_properties: Optional[int]
  

  minimum: Optional[float]
  

  nullable: Optional[bool]
  

  pattern: Optional[str]
  

  properties: Optional[dict[str, 'SchemaDict']]
  

  property_ordering: Optional[list[str]]
  

  required: Optional[list[str]]
  

  title: Optional[str]
  

  type: Optional[Type]
  


SchemaOrDict = Union[Schema, SchemaDict]


class ModelSelectionConfig(_common.BaseModel):
  

  feature_selection_preference: Optional[FeatureSelectionPreference] = Field(
      default=None, description=
  )


class ModelSelectionConfigDict(TypedDict, total=False):
  

  feature_selection_preference: Optional[FeatureSelectionPreference]
  


ModelSelectionConfigOrDict = Union[
    ModelSelectionConfig, ModelSelectionConfigDict
]


class SafetySetting(_common.BaseModel):
  

  method: Optional[HarmBlockMethod] = Field(
      default=None,
      description=,
  )
  category: Optional[HarmCategory] = Field(
      default=None, description=
  )
  threshold: Optional[HarmBlockThreshold] = Field(
      default=None, description=
  )


class SafetySettingDict(TypedDict, total=False):
  

  method: Optional[HarmBlockMethod]
  

  category: Optional[HarmCategory]
  

  threshold: Optional[HarmBlockThreshold]
  


SafetySettingOrDict = Union[SafetySetting, SafetySettingDict]


class FunctionDeclaration(_common.BaseModel):
  

  behavior: Optional[Behavior] = Field(
      default=None, description=
  )
  description: Optional[str] = Field(
      default=None,
      description=,
  )
  name: Optional[str] = Field(
      default=None,
      description=,
  )
  parameters: Optional[Schema] = Field(
      default=None,
      description=,
  )
  parameters_json_schema: Optional[Any] = Field(
      default=None,
      description=,
  )
  response: Optional[Schema] = Field(
      default=None,
      description=,
  )
  response_json_schema: Optional[Any] = Field(
      default=None,
      description=,
  )

  @classmethod
  def from_callable_with_api_option(
      cls,
      *,
      callable: Callable[..., Any],
      api_option: Literal['VERTEX_AI', 'GEMINI_API'] = 'GEMINI_API',
      behavior: Optional[Behavior] = None,
  ) -> 'FunctionDeclaration':
    
    supported_api_options = ['VERTEX_AI', 'GEMINI_API']
    if api_option not in supported_api_options:
      raise ValueError(
          f'Unsupported api_option value: {api_option}. Supported api_option'
          f' value is one of: {supported_api_options}.'
      )
    from . import _automatic_function_calling_util

    parameters_properties = {}
    annotation_under_future = typing.get_type_hints(callable)
    for name, param in inspect.signature(callable).parameters.items():
      if param.kind in (
          inspect.Parameter.POSITIONAL_OR_KEYWORD,
          inspect.Parameter.KEYWORD_ONLY,
          inspect.Parameter.POSITIONAL_ONLY,
      ):
        
        if isinstance(param.annotation, str):
          param = param.replace(annotation=annotation_under_future[name])
        schema = _automatic_function_calling_util._parse_schema_from_parameter(
            api_option, param, callable.__name__
        )
        parameters_properties[name] = schema
    declaration = FunctionDeclaration(
        name=callable.__name__,
        description=inspect.cleandoc(callable.__doc__)
        if callable.__doc__
        else callable.__doc__,
        behavior=behavior,
    )
    if parameters_properties:
      declaration.parameters = Schema(
          type='OBJECT',
          properties=parameters_properties,
      )
      declaration.parameters.required = (
          _automatic_function_calling_util._get_required_fields(
              declaration.parameters
          )
      )
    
    if api_option == 'GEMINI_API':
      return declaration

    return_annotation = inspect.signature(callable).return_annotation
    if return_annotation is inspect._empty:
      return declaration

    return_value = inspect.Parameter(
        'return_value',
        inspect.Parameter.POSITIONAL_OR_KEYWORD,
        annotation=return_annotation,
    )

    
    if isinstance(return_value.annotation, str):
      return_value = return_value.replace(
          annotation=annotation_under_future['return']
      )
    declaration.response = (
        _automatic_function_calling_util._parse_schema_from_parameter(
            api_option,
            return_value,
            callable.__name__,
        )
    )
    return declaration

  @classmethod
  def from_callable(
      cls,
      *,
      client: 'BaseApiClient',
      callable: Callable[..., Any],
      behavior: Optional[Behavior] = None,
  ) -> 'FunctionDeclaration':
    
    if client.vertexai:
      return cls.from_callable_with_api_option(
          callable=callable, api_option='VERTEX_AI', behavior=behavior
      )
    else:
      return cls.from_callable_with_api_option(
          callable=callable, api_option='GEMINI_API', behavior=behavior
      )


class FunctionDeclarationDict(TypedDict, total=False):
  

  behavior: Optional[Behavior]
  

  description: Optional[str]
  

  name: Optional[str]
  

  parameters: Optional[SchemaDict]
  

  parameters_json_schema: Optional[Any]
  

  response: Optional[SchemaDict]
  

  response_json_schema: Optional[Any]
  


FunctionDeclarationOrDict = Union[FunctionDeclaration, FunctionDeclarationDict]


class Interval(_common.BaseModel):
  

  start_time: Optional[datetime.datetime] = Field(
      default=None, description=
  )
  end_time: Optional[datetime.datetime] = Field(
      default=None, description=
  )


class IntervalDict(TypedDict, total=False):
  

  start_time: Optional[datetime.datetime]
  

  end_time: Optional[datetime.datetime]
  


IntervalOrDict = Union[Interval, IntervalDict]


class GoogleSearch(_common.BaseModel):
  

  time_range_filter: Optional[Interval] = Field(
      default=None,
      description=,
  )


class GoogleSearchDict(TypedDict, total=False):
  

  time_range_filter: Optional[IntervalDict]
  


GoogleSearchOrDict = Union[GoogleSearch, GoogleSearchDict]


class DynamicRetrievalConfig(_common.BaseModel):
  

  mode: Optional[DynamicRetrievalConfigMode] = Field(
      default=None,
      description=,
  )
  dynamic_threshold: Optional[float] = Field(
      default=None,
      description=,
  )


class DynamicRetrievalConfigDict(TypedDict, total=False):
  

  mode: Optional[DynamicRetrievalConfigMode]
  

  dynamic_threshold: Optional[float]
  


DynamicRetrievalConfigOrDict = Union[
    DynamicRetrievalConfig, DynamicRetrievalConfigDict
]


class GoogleSearchRetrieval(_common.BaseModel):
  

  dynamic_retrieval_config: Optional[DynamicRetrievalConfig] = Field(
      default=None,
      description=,
  )


class GoogleSearchRetrievalDict(TypedDict, total=False):
  

  dynamic_retrieval_config: Optional[DynamicRetrievalConfigDict]
  


GoogleSearchRetrievalOrDict = Union[
    GoogleSearchRetrieval, GoogleSearchRetrievalDict
]


class EnterpriseWebSearch(_common.BaseModel):
  

  pass


class EnterpriseWebSearchDict(TypedDict, total=False):
  

  pass


EnterpriseWebSearchOrDict = Union[EnterpriseWebSearch, EnterpriseWebSearchDict]


class ApiKeyConfig(_common.BaseModel):
  

  api_key_string: Optional[str] = Field(
      default=None,
      description=,
  )


class ApiKeyConfigDict(TypedDict, total=False):
  

  api_key_string: Optional[str]
  


ApiKeyConfigOrDict = Union[ApiKeyConfig, ApiKeyConfigDict]


class AuthConfigGoogleServiceAccountConfig(_common.BaseModel):
  

  service_account: Optional[str] = Field(
      default=None,
      description=Config for Google Service Account Authentication.Optional. The service account that the extension execution service runs as. - If the service account is specified, the `iam.serviceAccounts.getAccessToken` permission should be granted to Vertex AI Extension Service Agent (https://cloud.google.com/vertex-ai/docs/general/access-control


AuthConfigGoogleServiceAccountConfigOrDict = Union[
    AuthConfigGoogleServiceAccountConfig,
    AuthConfigGoogleServiceAccountConfigDict,
]


class AuthConfigHttpBasicAuthConfig(_common.BaseModel):
  

  credential_secret: Optional[str] = Field(
      default=None,
      description=Config for HTTP Basic Authentication.Required. The name of the SecretManager secret version resource storing the base64 encoded credentials. Format: `projects/{project}/secrets/{secrete}/versions/{version}` - If specified, the `secretmanager.versions.access` permission should be granted to Vertex AI Extension Service Agent (https://cloud.google.com/vertex-ai/docs/general/access-control


AuthConfigHttpBasicAuthConfigOrDict = Union[
    AuthConfigHttpBasicAuthConfig, AuthConfigHttpBasicAuthConfigDict
]


class AuthConfigOauthConfig(_common.BaseModel):
  

  access_token: Optional[str] = Field(
      default=None,
      description=,
  )
  service_account: Optional[str] = Field(
      default=None,
      description=Config for user oauth.Access token for extension endpoint. Only used to propagate token from [[ExecuteExtensionRequest.runtime_auth_config]] at request time.The service account used to generate access tokens for executing the Extension. - If the service account is specified, the `iam.serviceAccounts.getAccessToken` permission should be granted to Vertex AI Extension Service Agent (https://cloud.google.com/vertex-ai/docs/general/access-control


AuthConfigOauthConfigOrDict = Union[
    AuthConfigOauthConfig, AuthConfigOauthConfigDict
]


class AuthConfigOidcConfig(_common.BaseModel):
  

  id_token: Optional[str] = Field(
      default=None,
      description=,
  )
  service_account: Optional[str] = Field(
      default=None,
      description=Config for user OIDC auth.OpenID Connect formatted ID token for extension endpoint. Only used to propagate token from [[ExecuteExtensionRequest.runtime_auth_config]] at request time.The service account used to generate an OpenID Connect (OIDC)-compatible JWT token signed by the Google OIDC Provider (accounts.google.com) for extension endpoint (https://cloud.google.com/iam/docs/create-short-lived-credentials-direct


AuthConfigOidcConfigOrDict = Union[
    AuthConfigOidcConfig, AuthConfigOidcConfigDict
]


class AuthConfig(_common.BaseModel):
  

  api_key_config: Optional[ApiKeyConfig] = Field(
      default=None, description=
  )
  auth_type: Optional[AuthType] = Field(
      default=None, description=
  )
  google_service_account_config: Optional[
      AuthConfigGoogleServiceAccountConfig
  ] = Field(
      default=None, description=
  )
  http_basic_auth_config: Optional[AuthConfigHttpBasicAuthConfig] = Field(
      default=None, description=
  )
  oauth_config: Optional[AuthConfigOauthConfig] = Field(
      default=None, description=
  )
  oidc_config: Optional[AuthConfigOidcConfig] = Field(
      default=None, description=
  )


class AuthConfigDict(TypedDict, total=False):
  

  api_key_config: Optional[ApiKeyConfigDict]
  

  auth_type: Optional[AuthType]
  

  google_service_account_config: Optional[
      AuthConfigGoogleServiceAccountConfigDict
  ]
  

  http_basic_auth_config: Optional[AuthConfigHttpBasicAuthConfigDict]
  

  oauth_config: Optional[AuthConfigOauthConfigDict]
  

  oidc_config: Optional[AuthConfigOidcConfigDict]
  


AuthConfigOrDict = Union[AuthConfig, AuthConfigDict]


class GoogleMaps(_common.BaseModel):
  

  auth_config: Optional[AuthConfig] = Field(
      default=None,
      description=,
  )


class GoogleMapsDict(TypedDict, total=False):
  

  auth_config: Optional[AuthConfigDict]
  


GoogleMapsOrDict = Union[GoogleMaps, GoogleMapsDict]


class UrlContext(_common.BaseModel):
  

  pass


class UrlContextDict(TypedDict, total=False):
  

  pass


UrlContextOrDict = Union[UrlContext, UrlContextDict]


class ApiAuthApiKeyConfig(_common.BaseModel):
  

  api_key_secret_version: Optional[str] = Field(
      default=None,
      description=,
  )
  api_key_string: Optional[str] = Field(
      default=None,
      description=,
  )


class ApiAuthApiKeyConfigDict(TypedDict, total=False):
  

  api_key_secret_version: Optional[str]
  

  api_key_string: Optional[str]
  


ApiAuthApiKeyConfigOrDict = Union[ApiAuthApiKeyConfig, ApiAuthApiKeyConfigDict]


class ApiAuth(_common.BaseModel):
  

  api_key_config: Optional[ApiAuthApiKeyConfig] = Field(
      default=None, description=
  )


class ApiAuthDict(TypedDict, total=False):
  

  api_key_config: Optional[ApiAuthApiKeyConfigDict]
  


ApiAuthOrDict = Union[ApiAuth, ApiAuthDict]


class ExternalApiElasticSearchParams(_common.BaseModel):
  

  index: Optional[str] = Field(
      default=None, description=
  )
  num_hits: Optional[int] = Field(
      default=None,
      description=,
  )
  search_template: Optional[str] = Field(
      default=None, description=
  )


class ExternalApiElasticSearchParamsDict(TypedDict, total=False):
  

  index: Optional[str]
  

  num_hits: Optional[int]
  

  search_template: Optional[str]
  


ExternalApiElasticSearchParamsOrDict = Union[
    ExternalApiElasticSearchParams, ExternalApiElasticSearchParamsDict
]


class ExternalApiSimpleSearchParams(_common.BaseModel):
  

  pass


class ExternalApiSimpleSearchParamsDict(TypedDict, total=False):
  

  pass


ExternalApiSimpleSearchParamsOrDict = Union[
    ExternalApiSimpleSearchParams, ExternalApiSimpleSearchParamsDict
]


class ExternalApi(_common.BaseModel):
  

  api_auth: Optional[ApiAuth] = Field(
      default=None,
      description=,
  )
  api_spec: Optional[ApiSpec] = Field(
      default=None,
      description=,
  )
  auth_config: Optional[AuthConfig] = Field(
      default=None,
      description=,
  )
  elastic_search_params: Optional[ExternalApiElasticSearchParams] = Field(
      default=None, description=
  )
  endpoint: Optional[str] = Field(
      default=None,
      description=,
  )
  simple_search_params: Optional[ExternalApiSimpleSearchParams] = Field(
      default=None, description=
  )


class ExternalApiDict(TypedDict, total=False):
  

  api_auth: Optional[ApiAuthDict]
  

  api_spec: Optional[ApiSpec]
  

  auth_config: Optional[AuthConfigDict]
  

  elastic_search_params: Optional[ExternalApiElasticSearchParamsDict]
  

  endpoint: Optional[str]
  

  simple_search_params: Optional[ExternalApiSimpleSearchParamsDict]
  


ExternalApiOrDict = Union[ExternalApi, ExternalApiDict]


class VertexAISearchDataStoreSpec(_common.BaseModel):
  

  data_store: Optional[str] = Field(
      default=None,
      description=,
  )
  filter: Optional[str] = Field(
      default=None,
      description=,
  )


class VertexAISearchDataStoreSpecDict(TypedDict, total=False):
  

  data_store: Optional[str]
  

  filter: Optional[str]
  


VertexAISearchDataStoreSpecOrDict = Union[
    VertexAISearchDataStoreSpec, VertexAISearchDataStoreSpecDict
]


class VertexAISearch(_common.BaseModel):
  

  data_store_specs: Optional[list[VertexAISearchDataStoreSpec]] = Field(
      default=None,
      description=,
  )
  datastore: Optional[str] = Field(
      default=None,
      description=,
  )
  engine: Optional[str] = Field(
      default=None,
      description=,
  )
  filter: Optional[str] = Field(
      default=None,
      description=,
  )
  max_results: Optional[int] = Field(
      default=None,
      description=,
  )


class VertexAISearchDict(TypedDict, total=False):
  

  data_store_specs: Optional[list[VertexAISearchDataStoreSpecDict]]
  

  datastore: Optional[str]
  

  engine: Optional[str]
  

  filter: Optional[str]
  

  max_results: Optional[int]
  


VertexAISearchOrDict = Union[VertexAISearch, VertexAISearchDict]


class VertexRagStoreRagResource(_common.BaseModel):
  

  rag_corpus: Optional[str] = Field(
      default=None,
      description=,
  )
  rag_file_ids: Optional[list[str]] = Field(
      default=None,
      description=,
  )


class VertexRagStoreRagResourceDict(TypedDict, total=False):
  

  rag_corpus: Optional[str]
  

  rag_file_ids: Optional[list[str]]
  


VertexRagStoreRagResourceOrDict = Union[
    VertexRagStoreRagResource, VertexRagStoreRagResourceDict
]


class RagRetrievalConfigFilter(_common.BaseModel):
  

  metadata_filter: Optional[str] = Field(
      default=None, description=
  )
  vector_distance_threshold: Optional[float] = Field(
      default=None,
      description=,
  )
  vector_similarity_threshold: Optional[float] = Field(
      default=None,
      description=,
  )


class RagRetrievalConfigFilterDict(TypedDict, total=False):
  

  metadata_filter: Optional[str]
  

  vector_distance_threshold: Optional[float]
  

  vector_similarity_threshold: Optional[float]
  


RagRetrievalConfigFilterOrDict = Union[
    RagRetrievalConfigFilter, RagRetrievalConfigFilterDict
]


class RagRetrievalConfigHybridSearch(_common.BaseModel):
  

  alpha: Optional[float] = Field(
      default=None,
      description=,
  )


class RagRetrievalConfigHybridSearchDict(TypedDict, total=False):
  

  alpha: Optional[float]
  


RagRetrievalConfigHybridSearchOrDict = Union[
    RagRetrievalConfigHybridSearch, RagRetrievalConfigHybridSearchDict
]


class RagRetrievalConfigRankingLlmRanker(_common.BaseModel):
  

  model_name: Optional[str] = Field(
      default=None,
      description=Config for LlmRanker.Optional. The model name used for ranking. See [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/inference


RagRetrievalConfigRankingLlmRankerOrDict = Union[
    RagRetrievalConfigRankingLlmRanker, RagRetrievalConfigRankingLlmRankerDict
]


class RagRetrievalConfigRankingRankService(_common.BaseModel):
  

  model_name: Optional[str] = Field(
      default=None,
      description=,
  )


class RagRetrievalConfigRankingRankServiceDict(TypedDict, total=False):
  

  model_name: Optional[str]
  


RagRetrievalConfigRankingRankServiceOrDict = Union[
    RagRetrievalConfigRankingRankService,
    RagRetrievalConfigRankingRankServiceDict,
]


class RagRetrievalConfigRanking(_common.BaseModel):
  

  llm_ranker: Optional[RagRetrievalConfigRankingLlmRanker] = Field(
      default=None, description=
  )
  rank_service: Optional[RagRetrievalConfigRankingRankService] = Field(
      default=None, description=
  )


class RagRetrievalConfigRankingDict(TypedDict, total=False):
  

  llm_ranker: Optional[RagRetrievalConfigRankingLlmRankerDict]
  

  rank_service: Optional[RagRetrievalConfigRankingRankServiceDict]
  


RagRetrievalConfigRankingOrDict = Union[
    RagRetrievalConfigRanking, RagRetrievalConfigRankingDict
]


class RagRetrievalConfig(_common.BaseModel):
  

  filter: Optional[RagRetrievalConfigFilter] = Field(
      default=None, description=
  )
  hybrid_search: Optional[RagRetrievalConfigHybridSearch] = Field(
      default=None, description=
  )
  ranking: Optional[RagRetrievalConfigRanking] = Field(
      default=None,
      description=,
  )
  top_k: Optional[int] = Field(
      default=None,
      description=,
  )


class RagRetrievalConfigDict(TypedDict, total=False):
  

  filter: Optional[RagRetrievalConfigFilterDict]
  

  hybrid_search: Optional[RagRetrievalConfigHybridSearchDict]
  

  ranking: Optional[RagRetrievalConfigRankingDict]
  

  top_k: Optional[int]
  


RagRetrievalConfigOrDict = Union[RagRetrievalConfig, RagRetrievalConfigDict]


class VertexRagStore(_common.BaseModel):
  

  rag_corpora: Optional[list[str]] = Field(
      default=None,
      description=,
  )
  rag_resources: Optional[list[VertexRagStoreRagResource]] = Field(
      default=None,
      description=,
  )
  rag_retrieval_config: Optional[RagRetrievalConfig] = Field(
      default=None,
      description=,
  )
  similarity_top_k: Optional[int] = Field(
      default=None,
      description=,
  )
  store_context: Optional[bool] = Field(
      default=None,
      description=,
  )
  vector_distance_threshold: Optional[float] = Field(
      default=None,
      description=,
  )


class VertexRagStoreDict(TypedDict, total=False):
  

  rag_corpora: Optional[list[str]]
  

  rag_resources: Optional[list[VertexRagStoreRagResourceDict]]
  

  rag_retrieval_config: Optional[RagRetrievalConfigDict]
  

  similarity_top_k: Optional[int]
  

  store_context: Optional[bool]
  

  vector_distance_threshold: Optional[float]
  


VertexRagStoreOrDict = Union[VertexRagStore, VertexRagStoreDict]


class Retrieval(_common.BaseModel):
  

  disable_attribution: Optional[bool] = Field(
      default=None,
      description=,
  )
  external_api: Optional[ExternalApi] = Field(
      default=None,
      description=,
  )
  vertex_ai_search: Optional[VertexAISearch] = Field(
      default=None,
      description=,
  )
  vertex_rag_store: Optional[VertexRagStore] = Field(
      default=None,
      description=,
  )


class RetrievalDict(TypedDict, total=False):
  

  disable_attribution: Optional[bool]
  

  external_api: Optional[ExternalApiDict]
  

  vertex_ai_search: Optional[VertexAISearchDict]
  

  vertex_rag_store: Optional[VertexRagStoreDict]
  


RetrievalOrDict = Union[Retrieval, RetrievalDict]


class ToolCodeExecution(_common.BaseModel):
  

  pass


class ToolCodeExecutionDict(TypedDict, total=False):
  

  pass


ToolCodeExecutionOrDict = Union[ToolCodeExecution, ToolCodeExecutionDict]


class ToolComputerUse(_common.BaseModel):
  

  environment: Optional[Environment] = Field(
      default=None, description=
  )


class ToolComputerUseDict(TypedDict, total=False):
  

  environment: Optional[Environment]
  


ToolComputerUseOrDict = Union[ToolComputerUse, ToolComputerUseDict]


class Tool(_common.BaseModel):
  

  function_declarations: Optional[list[FunctionDeclaration]] = Field(
      default=None,
      description=,
  )
  retrieval: Optional[Retrieval] = Field(
      default=None,
      description=,
  )
  google_search: Optional[GoogleSearch] = Field(
      default=None,
      description=,
  )
  google_search_retrieval: Optional[GoogleSearchRetrieval] = Field(
      default=None,
      description=,
  )
  enterprise_web_search: Optional[EnterpriseWebSearch] = Field(
      default=None,
      description=,
  )
  google_maps: Optional[GoogleMaps] = Field(
      default=None,
      description=,
  )
  url_context: Optional[UrlContext] = Field(
      default=None,
      description=,
  )
  code_execution: Optional[ToolCodeExecution] = Field(
      default=None,
      description=,
  )
  computer_use: Optional[ToolComputerUse] = Field(
      default=None,
      description=,
  )


class ToolDict(TypedDict, total=False):
  

  function_declarations: Optional[list[FunctionDeclarationDict]]
  

  retrieval: Optional[RetrievalDict]
  

  google_search: Optional[GoogleSearchDict]
  

  google_search_retrieval: Optional[GoogleSearchRetrievalDict]
  

  enterprise_web_search: Optional[EnterpriseWebSearchDict]
  

  google_maps: Optional[GoogleMapsDict]
  

  url_context: Optional[UrlContextDict]
  

  code_execution: Optional[ToolCodeExecutionDict]
  

  computer_use: Optional[ToolComputerUseDict]
  


ToolOrDict = Union[Tool, ToolDict]
if _is_mcp_imported:
  ToolUnion = Union[Tool, Callable[..., Any], mcp_types.Tool, McpClientSession]
  ToolUnionDict = Union[
      ToolDict, Callable[..., Any], mcp_types.Tool, McpClientSession
  ]
else:
  ToolUnion = Union[Tool, Callable[..., Any]]  
  ToolUnionDict = Union[ToolDict, Callable[..., Any]]  

ToolListUnion = list[ToolUnion]
ToolListUnionDict = list[ToolUnionDict]

SchemaUnion = Union[
    dict[Any, Any], type, Schema, builtin_types.GenericAlias, VersionedUnionType  
]
SchemaUnionDict = Union[SchemaUnion, SchemaDict]


class FunctionCallingConfig(_common.BaseModel):
  

  mode: Optional[FunctionCallingConfigMode] = Field(
      default=None, description=
  )
  allowed_function_names: Optional[list[str]] = Field(
      default=None,
      description=,
  )


class FunctionCallingConfigDict(TypedDict, total=False):
  

  mode: Optional[FunctionCallingConfigMode]
  

  allowed_function_names: Optional[list[str]]
  


FunctionCallingConfigOrDict = Union[
    FunctionCallingConfig, FunctionCallingConfigDict
]


class LatLng(_common.BaseModel):
  

  latitude: Optional[float] = Field(
      default=None,
      description=,
  )
  longitude: Optional[float] = Field(
      default=None,
      description=,
  )


class LatLngDict(TypedDict, total=False):
  

  latitude: Optional[float]
  

  longitude: Optional[float]
  


LatLngOrDict = Union[LatLng, LatLngDict]


class RetrievalConfig(_common.BaseModel):
  

  lat_lng: Optional[LatLng] = Field(
      default=None, description=
  )
  language_code: Optional[str] = Field(
      default=None, description=
  )


class RetrievalConfigDict(TypedDict, total=False):
  

  lat_lng: Optional[LatLngDict]
  

  language_code: Optional[str]
  


RetrievalConfigOrDict = Union[RetrievalConfig, RetrievalConfigDict]


class ToolConfig(_common.BaseModel):
  

  function_calling_config: Optional[FunctionCallingConfig] = Field(
      default=None, description=
  )
  retrieval_config: Optional[RetrievalConfig] = Field(
      default=None, description=
  )


class ToolConfigDict(TypedDict, total=False):
  

  function_calling_config: Optional[FunctionCallingConfigDict]
  

  retrieval_config: Optional[RetrievalConfigDict]
  


ToolConfigOrDict = Union[ToolConfig, ToolConfigDict]


class PrebuiltVoiceConfig(_common.BaseModel):
  

  voice_name: Optional[str] = Field(
      default=None, description=
  )


class PrebuiltVoiceConfigDict(TypedDict, total=False):
  

  voice_name: Optional[str]
  


PrebuiltVoiceConfigOrDict = Union[PrebuiltVoiceConfig, PrebuiltVoiceConfigDict]


class VoiceConfig(_common.BaseModel):
  

  prebuilt_voice_config: Optional[PrebuiltVoiceConfig] = Field(
      default=None,
      description=,
  )


class VoiceConfigDict(TypedDict, total=False):
  

  prebuilt_voice_config: Optional[PrebuiltVoiceConfigDict]
  


VoiceConfigOrDict = Union[VoiceConfig, VoiceConfigDict]


class SpeakerVoiceConfig(_common.BaseModel):
  

  speaker: Optional[str] = Field(
      default=None,
      description=,
  )
  voice_config: Optional[VoiceConfig] = Field(
      default=None, description=
  )


class SpeakerVoiceConfigDict(TypedDict, total=False):
  

  speaker: Optional[str]
  

  voice_config: Optional[VoiceConfigDict]
  


SpeakerVoiceConfigOrDict = Union[SpeakerVoiceConfig, SpeakerVoiceConfigDict]


class MultiSpeakerVoiceConfig(_common.BaseModel):
  

  speaker_voice_configs: Optional[list[SpeakerVoiceConfig]] = Field(
      default=None, description=
  )


class MultiSpeakerVoiceConfigDict(TypedDict, total=False):
  

  speaker_voice_configs: Optional[list[SpeakerVoiceConfigDict]]
  


MultiSpeakerVoiceConfigOrDict = Union[
    MultiSpeakerVoiceConfig, MultiSpeakerVoiceConfigDict
]


class SpeechConfig(_common.BaseModel):
  

  voice_config: Optional[VoiceConfig] = Field(
      default=None,
      description=,
  )
  multi_speaker_voice_config: Optional[MultiSpeakerVoiceConfig] = Field(
      default=None,
      description=,
  )
  language_code: Optional[str] = Field(
      default=None,
      description=,
  )


class SpeechConfigDict(TypedDict, total=False):
  

  voice_config: Optional[VoiceConfigDict]
  

  multi_speaker_voice_config: Optional[MultiSpeakerVoiceConfigDict]
  

  language_code: Optional[str]
  


SpeechConfigOrDict = Union[SpeechConfig, SpeechConfigDict]


class AutomaticFunctionCallingConfig(_common.BaseModel):
  

  disable: Optional[bool] = Field(
      default=None,
      description=,
  )
  maximum_remote_calls: Optional[int] = Field(
      default=10,
      description=,
  )
  ignore_call_history: Optional[bool] = Field(
      default=None,
      description=,
  )


class AutomaticFunctionCallingConfigDict(TypedDict, total=False):
  

  disable: Optional[bool]
  

  maximum_remote_calls: Optional[int]
  

  ignore_call_history: Optional[bool]
  


AutomaticFunctionCallingConfigOrDict = Union[
    AutomaticFunctionCallingConfig, AutomaticFunctionCallingConfigDict
]


class ThinkingConfig(_common.BaseModel):
  

  include_thoughts: Optional[bool] = Field(
      default=None,
      description=,
  )
  thinking_budget: Optional[int] = Field(
      default=None,
      description=,
  )


class ThinkingConfigDict(TypedDict, total=False):
  

  include_thoughts: Optional[bool]
  

  thinking_budget: Optional[int]
  


ThinkingConfigOrDict = Union[ThinkingConfig, ThinkingConfigDict]


class FileStatus(_common.BaseModel):
  

  details: Optional[list[dict[str, Any]]] = Field(
      default=None,
      description=,
  )
  message: Optional[str] = Field(
      default=None,
      description=,
  )
  code: Optional[int] = Field(
      default=None, description=
  )


class FileStatusDict(TypedDict, total=False):
  

  details: Optional[list[dict[str, Any]]]
  

  message: Optional[str]
  

  code: Optional[int]
  


FileStatusOrDict = Union[FileStatus, FileStatusDict]


class File(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  display_name: Optional[str] = Field(
      default=None,
      description=,
  )
  mime_type: Optional[str] = Field(
      default=None, description=
  )
  size_bytes: Optional[int] = Field(
      default=None, description=
  )
  create_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  expiration_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  update_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  sha256_hash: Optional[str] = Field(
      default=None,
      description=,
  )
  uri: Optional[str] = Field(
      default=None, description=
  )
  download_uri: Optional[str] = Field(
      default=None,
      description=,
  )
  state: Optional[FileState] = Field(
      default=None, description=
  )
  source: Optional[FileSource] = Field(
      default=None, description=
  )
  video_metadata: Optional[dict[str, Any]] = Field(
      default=None, description=
  )
  error: Optional[FileStatus] = Field(
      default=None,
      description=,
  )


class FileDict(TypedDict, total=False):
  

  name: Optional[str]
  

  display_name: Optional[str]
  

  mime_type: Optional[str]
  

  size_bytes: Optional[int]
  

  create_time: Optional[datetime.datetime]
  

  expiration_time: Optional[datetime.datetime]
  

  update_time: Optional[datetime.datetime]
  

  sha256_hash: Optional[str]
  

  uri: Optional[str]
  

  download_uri: Optional[str]
  

  state: Optional[FileState]
  

  source: Optional[FileSource]
  

  video_metadata: Optional[dict[str, Any]]
  

  error: Optional[FileStatusDict]
  


FileOrDict = Union[File, FileDict]

if _is_pillow_image_imported:
  PartUnion = Union[File, Part, PIL_Image, str]
else:
  PartUnion = Union[File, Part, str]  


PartUnionDict = Union[PartUnion, PartDict]


ContentUnion = Union[Content, list[PartUnion], PartUnion]


ContentUnionDict = Union[ContentUnion, ContentDict]


class GenerationConfigRoutingConfigAutoRoutingMode(_common.BaseModel):
  

  model_routing_preference: Optional[
      Literal['UNKNOWN', 'PRIORITIZE_QUALITY', 'BALANCED', 'PRIORITIZE_COST']
  ] = Field(default=None, description=)


class GenerationConfigRoutingConfigAutoRoutingModeDict(TypedDict, total=False):
  

  model_routing_preference: Optional[
      Literal['UNKNOWN', 'PRIORITIZE_QUALITY', 'BALANCED', 'PRIORITIZE_COST']
  ]
  


GenerationConfigRoutingConfigAutoRoutingModeOrDict = Union[
    GenerationConfigRoutingConfigAutoRoutingMode,
    GenerationConfigRoutingConfigAutoRoutingModeDict,
]


class GenerationConfigRoutingConfigManualRoutingMode(_common.BaseModel):
  

  model_name: Optional[str] = Field(
      default=None,
      description=When manual routing is set, the specified model will be used directly.The model name to use. Only the public LLM models are accepted. See [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/inference


GenerationConfigRoutingConfigManualRoutingModeOrDict = Union[
    GenerationConfigRoutingConfigManualRoutingMode,
    GenerationConfigRoutingConfigManualRoutingModeDict,
]


class GenerationConfigRoutingConfig(_common.BaseModel):
  

  auto_mode: Optional[GenerationConfigRoutingConfigAutoRoutingMode] = Field(
      default=None, description=
  )
  manual_mode: Optional[GenerationConfigRoutingConfigManualRoutingMode] = Field(
      default=None, description=
  )


class GenerationConfigRoutingConfigDict(TypedDict, total=False):
  

  auto_mode: Optional[GenerationConfigRoutingConfigAutoRoutingModeDict]
  

  manual_mode: Optional[GenerationConfigRoutingConfigManualRoutingModeDict]
  


GenerationConfigRoutingConfigOrDict = Union[
    GenerationConfigRoutingConfig, GenerationConfigRoutingConfigDict
]


SpeechConfigUnion = Union[SpeechConfig, str]


SpeechConfigUnionDict = Union[SpeechConfigUnion, SpeechConfigDict]


class GenerateContentConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  system_instruction: Optional[ContentUnion] = Field(
      default=None,
      description=,
  )
  temperature: Optional[float] = Field(
      default=None,
      description=,
  )
  top_p: Optional[float] = Field(
      default=None,
      description=,
  )
  top_k: Optional[float] = Field(
      default=None,
      description=,
  )
  candidate_count: Optional[int] = Field(
      default=None,
      description=,
  )
  max_output_tokens: Optional[int] = Field(
      default=None,
      description=,
  )
  stop_sequences: Optional[list[str]] = Field(
      default=None,
      description=,
  )
  response_logprobs: Optional[bool] = Field(
      default=None,
      description=,
  )
  logprobs: Optional[int] = Field(
      default=None,
      description=,
  )
  presence_penalty: Optional[float] = Field(
      default=None,
      description=,
  )
  frequency_penalty: Optional[float] = Field(
      default=None,
      description=,
  )
  seed: Optional[int] = Field(
      default=None,
      description=,
  )
  response_mime_type: Optional[str] = Field(
      default=None,
      description=,
  )
  response_schema: Optional[SchemaUnion] = Field(
      default=None,
      description=,
  )
  response_json_schema: Optional[Any] = Field(
      default=None,
      description=,
  )
  routing_config: Optional[GenerationConfigRoutingConfig] = Field(
      default=None,
      description=,
  )
  model_selection_config: Optional[ModelSelectionConfig] = Field(
      default=None,
      description=,
  )
  safety_settings: Optional[list[SafetySetting]] = Field(
      default=None,
      description=,
  )
  tools: Optional[ToolListUnion] = Field(
      default=None,
      description=,
  )
  tool_config: Optional[ToolConfig] = Field(
      default=None,
      description=,
  )
  labels: Optional[dict[str, str]] = Field(
      default=None,
      description=,
  )
  cached_content: Optional[str] = Field(
      default=None,
      description=,
  )
  response_modalities: Optional[list[str]] = Field(
      default=None,
      description=,
  )
  media_resolution: Optional[MediaResolution] = Field(
      default=None,
      description=,
  )
  speech_config: Optional[SpeechConfigUnion] = Field(
      default=None,
      description=,
  )
  audio_timestamp: Optional[bool] = Field(
      default=None,
      description=,
  )
  automatic_function_calling: Optional[AutomaticFunctionCallingConfig] = Field(
      default=None,
      description=,
  )
  thinking_config: Optional[ThinkingConfig] = Field(
      default=None,
      description=,
  )

  @pydantic.field_validator('response_schema', mode='before')
  @classmethod
  def _convert_literal_to_enum(cls, value: Any) -> Union[Any, EnumMeta]:
    if typing.get_origin(value) is typing.Literal:
      enum_vals = typing.get_args(value)
      if not all(isinstance(arg, str) for arg in enum_vals):
        
        
        raise ValueError(f'Literal type {value} must be a list of strings.')
      
      
      return Enum('PlaceholderLiteralEnum', {s: s for s in enum_vals})
    return value


class GenerateContentConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  system_instruction: Optional[ContentUnionDict]
  

  temperature: Optional[float]
  

  top_p: Optional[float]
  

  top_k: Optional[float]
  

  candidate_count: Optional[int]
  

  max_output_tokens: Optional[int]
  

  stop_sequences: Optional[list[str]]
  

  response_logprobs: Optional[bool]
  

  logprobs: Optional[int]
  

  presence_penalty: Optional[float]
  

  frequency_penalty: Optional[float]
  

  seed: Optional[int]
  

  response_mime_type: Optional[str]
  

  response_schema: Optional[SchemaUnionDict]
  

  response_json_schema: Optional[Any]
  

  routing_config: Optional[GenerationConfigRoutingConfigDict]
  

  model_selection_config: Optional[ModelSelectionConfigDict]
  

  safety_settings: Optional[list[SafetySettingDict]]
  

  tools: Optional[ToolListUnionDict]
  

  tool_config: Optional[ToolConfigDict]
  

  labels: Optional[dict[str, str]]
  

  cached_content: Optional[str]
  

  response_modalities: Optional[list[str]]
  

  media_resolution: Optional[MediaResolution]
  

  speech_config: Optional[SpeechConfigUnionDict]
  

  audio_timestamp: Optional[bool]
  

  automatic_function_calling: Optional[AutomaticFunctionCallingConfigDict]
  

  thinking_config: Optional[ThinkingConfigDict]
  


GenerateContentConfigOrDict = Union[
    GenerateContentConfig, GenerateContentConfigDict
]


ContentListUnion = Union[list[ContentUnion], ContentUnion]


ContentListUnionDict = Union[list[ContentUnionDict], ContentUnionDict]


class _GenerateContentParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  contents: Optional[ContentListUnion] = Field(
      default=None,
      description=,
  )
  config: Optional[GenerateContentConfig] = Field(
      default=None,
      description=,
  )


class _GenerateContentParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  contents: Optional[ContentListUnionDict]
  

  config: Optional[GenerateContentConfigDict]
  


_GenerateContentParametersOrDict = Union[
    _GenerateContentParameters, _GenerateContentParametersDict
]


class HttpResponse(_common.BaseModel):
  

  headers: Optional[dict[str, str]] = Field(
      default=None,
      description=,
  )
  body: Optional[str] = Field(
      default=None,
      description=,
  )


class HttpResponseDict(TypedDict, total=False):
  

  headers: Optional[dict[str, str]]
  

  body: Optional[str]
  


HttpResponseOrDict = Union[HttpResponse, HttpResponseDict]


class GoogleTypeDate(_common.BaseModel):
  

  day: Optional[int] = Field(
      default=None,
      description=,
  )
  month: Optional[int] = Field(
      default=None,
      description=,
  )
  year: Optional[int] = Field(
      default=None,
      description=,
  )


class GoogleTypeDateDict(TypedDict, total=False):
  

  day: Optional[int]
  

  month: Optional[int]
  

  year: Optional[int]
  


GoogleTypeDateOrDict = Union[GoogleTypeDate, GoogleTypeDateDict]


class Citation(_common.BaseModel):
  

  end_index: Optional[int] = Field(
      default=None, description=
  )
  license: Optional[str] = Field(
      default=None, description=
  )
  publication_date: Optional[GoogleTypeDate] = Field(
      default=None,
      description=,
  )
  start_index: Optional[int] = Field(
      default=None, description=
  )
  title: Optional[str] = Field(
      default=None, description=
  )
  uri: Optional[str] = Field(
      default=None,
      description=,
  )


class CitationDict(TypedDict, total=False):
  

  end_index: Optional[int]
  

  license: Optional[str]
  

  publication_date: Optional[GoogleTypeDateDict]
  

  start_index: Optional[int]
  

  title: Optional[str]
  

  uri: Optional[str]
  


CitationOrDict = Union[Citation, CitationDict]


class CitationMetadata(_common.BaseModel):
  

  citations: Optional[list[Citation]] = Field(
      default=None,
      description=,
  )


class CitationMetadataDict(TypedDict, total=False):
  

  citations: Optional[list[CitationDict]]
  


CitationMetadataOrDict = Union[CitationMetadata, CitationMetadataDict]


class UrlMetadata(_common.BaseModel):
  

  retrieved_url: Optional[str] = Field(
      default=None, description=
  )
  url_retrieval_status: Optional[UrlRetrievalStatus] = Field(
      default=None, description=
  )


class UrlMetadataDict(TypedDict, total=False):
  

  retrieved_url: Optional[str]
  

  url_retrieval_status: Optional[UrlRetrievalStatus]
  


UrlMetadataOrDict = Union[UrlMetadata, UrlMetadataDict]


class UrlContextMetadata(_common.BaseModel):
  

  url_metadata: Optional[list[UrlMetadata]] = Field(
      default=None, description=
  )


class UrlContextMetadataDict(TypedDict, total=False):
  

  url_metadata: Optional[list[UrlMetadataDict]]
  


UrlContextMetadataOrDict = Union[UrlContextMetadata, UrlContextMetadataDict]


class RagChunkPageSpan(_common.BaseModel):
  

  first_page: Optional[int] = Field(
      default=None,
      description=,
  )
  last_page: Optional[int] = Field(
      default=None,
      description=,
  )


class RagChunkPageSpanDict(TypedDict, total=False):
  

  first_page: Optional[int]
  

  last_page: Optional[int]
  


RagChunkPageSpanOrDict = Union[RagChunkPageSpan, RagChunkPageSpanDict]


class RagChunk(_common.BaseModel):
  

  page_span: Optional[RagChunkPageSpan] = Field(
      default=None,
      description=,
  )
  text: Optional[str] = Field(
      default=None, description=
  )


class RagChunkDict(TypedDict, total=False):
  

  page_span: Optional[RagChunkPageSpanDict]
  

  text: Optional[str]
  


RagChunkOrDict = Union[RagChunk, RagChunkDict]


class GroundingChunkRetrievedContext(_common.BaseModel):
  

  rag_chunk: Optional[RagChunk] = Field(
      default=None,
      description=,
  )
  text: Optional[str] = Field(
      default=None, description=
  )
  title: Optional[str] = Field(
      default=None, description=
  )
  uri: Optional[str] = Field(
      default=None, description=
  )


class GroundingChunkRetrievedContextDict(TypedDict, total=False):
  

  rag_chunk: Optional[RagChunkDict]
  

  text: Optional[str]
  

  title: Optional[str]
  

  uri: Optional[str]
  


GroundingChunkRetrievedContextOrDict = Union[
    GroundingChunkRetrievedContext, GroundingChunkRetrievedContextDict
]


class GroundingChunkWeb(_common.BaseModel):
  

  domain: Optional[str] = Field(
      default=None, description=
  )
  title: Optional[str] = Field(
      default=None, description=
  )
  uri: Optional[str] = Field(
      default=None, description=
  )


class GroundingChunkWebDict(TypedDict, total=False):
  

  domain: Optional[str]
  

  title: Optional[str]
  

  uri: Optional[str]
  


GroundingChunkWebOrDict = Union[GroundingChunkWeb, GroundingChunkWebDict]


class GroundingChunk(_common.BaseModel):
  

  retrieved_context: Optional[GroundingChunkRetrievedContext] = Field(
      default=None,
      description=,
  )
  web: Optional[GroundingChunkWeb] = Field(
      default=None, description=
  )


class GroundingChunkDict(TypedDict, total=False):
  

  retrieved_context: Optional[GroundingChunkRetrievedContextDict]
  

  web: Optional[GroundingChunkWebDict]
  


GroundingChunkOrDict = Union[GroundingChunk, GroundingChunkDict]


class Segment(_common.BaseModel):
  

  end_index: Optional[int] = Field(
      default=None,
      description=,
  )
  part_index: Optional[int] = Field(
      default=None,
      description=,
  )
  start_index: Optional[int] = Field(
      default=None,
      description=,
  )
  text: Optional[str] = Field(
      default=None,
      description=,
  )


class SegmentDict(TypedDict, total=False):
  

  end_index: Optional[int]
  

  part_index: Optional[int]
  

  start_index: Optional[int]
  

  text: Optional[str]
  


SegmentOrDict = Union[Segment, SegmentDict]


class GroundingSupport(_common.BaseModel):
  

  confidence_scores: Optional[list[float]] = Field(
      default=None,
      description=,
  )
  grounding_chunk_indices: Optional[list[int]] = Field(
      default=None,
      description=,
  )
  segment: Optional[Segment] = Field(
      default=None,
      description=,
  )


class GroundingSupportDict(TypedDict, total=False):
  

  confidence_scores: Optional[list[float]]
  

  grounding_chunk_indices: Optional[list[int]]
  

  segment: Optional[SegmentDict]
  


GroundingSupportOrDict = Union[GroundingSupport, GroundingSupportDict]


class RetrievalMetadata(_common.BaseModel):
  

  google_search_dynamic_retrieval_score: Optional[float] = Field(
      default=None,
      description=,
  )


class RetrievalMetadataDict(TypedDict, total=False):
  

  google_search_dynamic_retrieval_score: Optional[float]
  


RetrievalMetadataOrDict = Union[RetrievalMetadata, RetrievalMetadataDict]


class SearchEntryPoint(_common.BaseModel):
  

  rendered_content: Optional[str] = Field(
      default=None,
      description=,
  )
  sdk_blob: Optional[bytes] = Field(
      default=None,
      description=,
  )


class SearchEntryPointDict(TypedDict, total=False):
  

  rendered_content: Optional[str]
  

  sdk_blob: Optional[bytes]
  


SearchEntryPointOrDict = Union[SearchEntryPoint, SearchEntryPointDict]


class GroundingMetadata(_common.BaseModel):
  

  grounding_chunks: Optional[list[GroundingChunk]] = Field(
      default=None,
      description=,
  )
  grounding_supports: Optional[list[GroundingSupport]] = Field(
      default=None, description=
  )
  retrieval_metadata: Optional[RetrievalMetadata] = Field(
      default=None, description=
  )
  retrieval_queries: Optional[list[str]] = Field(
      default=None,
      description=,
  )
  search_entry_point: Optional[SearchEntryPoint] = Field(
      default=None,
      description=,
  )
  web_search_queries: Optional[list[str]] = Field(
      default=None,
      description=,
  )


class GroundingMetadataDict(TypedDict, total=False):
  

  grounding_chunks: Optional[list[GroundingChunkDict]]
  

  grounding_supports: Optional[list[GroundingSupportDict]]
  

  retrieval_metadata: Optional[RetrievalMetadataDict]
  

  retrieval_queries: Optional[list[str]]
  

  search_entry_point: Optional[SearchEntryPointDict]
  

  web_search_queries: Optional[list[str]]
  


GroundingMetadataOrDict = Union[GroundingMetadata, GroundingMetadataDict]


class LogprobsResultCandidate(_common.BaseModel):
  

  log_probability: Optional[float] = Field(
      default=None, description=
  )
  token: Optional[str] = Field(
      default=None, description=
  )
  token_id: Optional[int] = Field(
      default=None, description=
  )


class LogprobsResultCandidateDict(TypedDict, total=False):
  

  log_probability: Optional[float]
  

  token: Optional[str]
  

  token_id: Optional[int]
  


LogprobsResultCandidateOrDict = Union[
    LogprobsResultCandidate, LogprobsResultCandidateDict
]


class LogprobsResultTopCandidates(_common.BaseModel):
  

  candidates: Optional[list[LogprobsResultCandidate]] = Field(
      default=None,
      description=,
  )


class LogprobsResultTopCandidatesDict(TypedDict, total=False):
  

  candidates: Optional[list[LogprobsResultCandidateDict]]
  


LogprobsResultTopCandidatesOrDict = Union[
    LogprobsResultTopCandidates, LogprobsResultTopCandidatesDict
]


class LogprobsResult(_common.BaseModel):
  

  chosen_candidates: Optional[list[LogprobsResultCandidate]] = Field(
      default=None,
      description=,
  )
  top_candidates: Optional[list[LogprobsResultTopCandidates]] = Field(
      default=None, description=
  )


class LogprobsResultDict(TypedDict, total=False):
  

  chosen_candidates: Optional[list[LogprobsResultCandidateDict]]
  

  top_candidates: Optional[list[LogprobsResultTopCandidatesDict]]
  


LogprobsResultOrDict = Union[LogprobsResult, LogprobsResultDict]


class SafetyRating(_common.BaseModel):
  

  blocked: Optional[bool] = Field(
      default=None,
      description=,
  )
  category: Optional[HarmCategory] = Field(
      default=None, description=
  )
  overwritten_threshold: Optional[HarmBlockThreshold] = Field(
      default=None,
      description=,
  )
  probability: Optional[HarmProbability] = Field(
      default=None,
      description=,
  )
  probability_score: Optional[float] = Field(
      default=None, description=
  )
  severity: Optional[HarmSeverity] = Field(
      default=None,
      description=,
  )
  severity_score: Optional[float] = Field(
      default=None, description=
  )


class SafetyRatingDict(TypedDict, total=False):
  

  blocked: Optional[bool]
  

  category: Optional[HarmCategory]
  

  overwritten_threshold: Optional[HarmBlockThreshold]
  

  probability: Optional[HarmProbability]
  

  probability_score: Optional[float]
  

  severity: Optional[HarmSeverity]
  

  severity_score: Optional[float]
  


SafetyRatingOrDict = Union[SafetyRating, SafetyRatingDict]


class Candidate(_common.BaseModel):
  

  content: Optional[Content] = Field(
      default=None,
      description=,
  )
  citation_metadata: Optional[CitationMetadata] = Field(
      default=None,
      description=,
  )
  finish_message: Optional[str] = Field(
      default=None,
      description=,
  )
  token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  finish_reason: Optional[FinishReason] = Field(
      default=None,
      description=,
  )
  url_context_metadata: Optional[UrlContextMetadata] = Field(
      default=None,
      description=,
  )
  avg_logprobs: Optional[float] = Field(
      default=None,
      description=,
  )
  grounding_metadata: Optional[GroundingMetadata] = Field(
      default=None,
      description=,
  )
  index: Optional[int] = Field(
      default=None, description=
  )
  logprobs_result: Optional[LogprobsResult] = Field(
      default=None,
      description=,
  )
  safety_ratings: Optional[list[SafetyRating]] = Field(
      default=None,
      description=,
  )


class CandidateDict(TypedDict, total=False):
  

  content: Optional[ContentDict]
  

  citation_metadata: Optional[CitationMetadataDict]
  

  finish_message: Optional[str]
  

  token_count: Optional[int]
  

  finish_reason: Optional[FinishReason]
  

  url_context_metadata: Optional[UrlContextMetadataDict]
  

  avg_logprobs: Optional[float]
  

  grounding_metadata: Optional[GroundingMetadataDict]
  

  index: Optional[int]
  

  logprobs_result: Optional[LogprobsResultDict]
  

  safety_ratings: Optional[list[SafetyRatingDict]]
  


CandidateOrDict = Union[Candidate, CandidateDict]


class GenerateContentResponsePromptFeedback(_common.BaseModel):
  

  block_reason: Optional[BlockedReason] = Field(
      default=None, description=
  )
  block_reason_message: Optional[str] = Field(
      default=None,
      description=,
  )
  safety_ratings: Optional[list[SafetyRating]] = Field(
      default=None, description=
  )


class GenerateContentResponsePromptFeedbackDict(TypedDict, total=False):
  

  block_reason: Optional[BlockedReason]
  

  block_reason_message: Optional[str]
  

  safety_ratings: Optional[list[SafetyRatingDict]]
  


GenerateContentResponsePromptFeedbackOrDict = Union[
    GenerateContentResponsePromptFeedback,
    GenerateContentResponsePromptFeedbackDict,
]


class ModalityTokenCount(_common.BaseModel):
  

  modality: Optional[MediaModality] = Field(
      default=None,
      description=,
  )
  token_count: Optional[int] = Field(
      default=None, description=
  )


class ModalityTokenCountDict(TypedDict, total=False):
  

  modality: Optional[MediaModality]
  

  token_count: Optional[int]
  


ModalityTokenCountOrDict = Union[ModalityTokenCount, ModalityTokenCountDict]


class GenerateContentResponseUsageMetadata(_common.BaseModel):
  

  cache_tokens_details: Optional[list[ModalityTokenCount]] = Field(
      default=None,
      description=,
  )
  cached_content_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  candidates_token_count: Optional[int] = Field(
      default=None, description=
  )
  candidates_tokens_details: Optional[list[ModalityTokenCount]] = Field(
      default=None,
      description=,
  )
  prompt_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  prompt_tokens_details: Optional[list[ModalityTokenCount]] = Field(
      default=None,
      description=,
  )
  thoughts_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  tool_use_prompt_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  tool_use_prompt_tokens_details: Optional[list[ModalityTokenCount]] = Field(
      default=None,
      description=,
  )
  total_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  traffic_type: Optional[TrafficType] = Field(
      default=None,
      description=,
  )


class GenerateContentResponseUsageMetadataDict(TypedDict, total=False):
  

  cache_tokens_details: Optional[list[ModalityTokenCountDict]]
  

  cached_content_token_count: Optional[int]
  

  candidates_token_count: Optional[int]
  

  candidates_tokens_details: Optional[list[ModalityTokenCountDict]]
  

  prompt_token_count: Optional[int]
  

  prompt_tokens_details: Optional[list[ModalityTokenCountDict]]
  

  thoughts_token_count: Optional[int]
  

  tool_use_prompt_token_count: Optional[int]
  

  tool_use_prompt_tokens_details: Optional[list[ModalityTokenCountDict]]
  

  total_token_count: Optional[int]
  

  traffic_type: Optional[TrafficType]
  


GenerateContentResponseUsageMetadataOrDict = Union[
    GenerateContentResponseUsageMetadata,
    GenerateContentResponseUsageMetadataDict,
]


class GenerateContentResponse(_common.BaseModel):
  

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  candidates: Optional[list[Candidate]] = Field(
      default=None,
      description=,
  )
  create_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  response_id: Optional[str] = Field(
      default=None,
      description=,
  )
  model_version: Optional[str] = Field(
      default=None,
      description=,
  )
  prompt_feedback: Optional[GenerateContentResponsePromptFeedback] = Field(
      default=None,
      description=,
  )
  usage_metadata: Optional[GenerateContentResponseUsageMetadata] = Field(
      default=None, description=
  )
  automatic_function_calling_history: Optional[list[Content]] = None
  parsed: Optional[Union[pydantic.BaseModel, dict[Any, Any], Enum]] = Field(
      default=None,
      description=,
  )

  def _get_text(self, warn_property: str = 'text') -> Optional[str]:
    
    if (
        not self.candidates
        or not self.candidates[0].content
        or not self.candidates[0].content.parts
    ):
      return None
    if len(self.candidates) > 1:
      logger.warning(
          f'there are {len(self.candidates)} candidates, returning'
          f' {warn_property} result from the first candidate. Access'
          ' response.candidates directly to get the result from other'
          ' candidates.'
      )
    text = ''
    any_text_part_text = False
    non_text_parts = []
    for part in self.candidates[0].content.parts:
      for field_name, field_value in part.model_dump(
          exclude={'text', 'thought'}
      ).items():
        if field_value is not None:
          non_text_parts.append(field_name)
      if isinstance(part.text, str):
        if isinstance(part.thought, bool) and part.thought:
          continue
        any_text_part_text = True
        text += part.text
    if non_text_parts:
      logger.warning(
          'Warning: there are non-text parts in the response:'
          f' {non_text_parts}, returning concatenated {warn_property} result'
          ' from text parts. Check the full candidates.content.parts accessor'
          ' to get the full model response.'
      )
    
    return text if any_text_part_text else None

  @property
  def text(self) -> Optional[str]:
    
    return self._get_text(warn_property='text')

  @property
  def function_calls(self) -> Optional[list[FunctionCall]]:
    
    if (
        not self.candidates
        or not self.candidates[0].content
        or not self.candidates[0].content.parts
    ):
      return None
    if len(self.candidates) > 1:
      logger.warning(
          'Warning: there are multiple candidates in the response, returning'
          ' function calls from the first one.'
      )
    function_calls = [
        part.function_call
        for part in self.candidates[0].content.parts
        if part.function_call is not None
    ]

    return function_calls if function_calls else None

  @property
  def executable_code(self) -> Optional[str]:
    
    if (
        not self.candidates
        or not self.candidates[0].content
        or not self.candidates[0].content.parts
    ):
      return None
    if len(self.candidates) > 1:
      logging.warning(
          'Warning: there are multiple candidates in the response, returning'
          ' executable code from the first one.'
      )
    for part in self.candidates[0].content.parts:
      if part.executable_code is not None:
        return part.executable_code.code
    return None

  @property
  def code_execution_result(self) -> Optional[str]:
    
    if (
        not self.candidates
        or not self.candidates[0].content
        or not self.candidates[0].content.parts
    ):
      return None
    if len(self.candidates) > 1:
      logging.warning(
          'Warning: there are multiple candidates in the response, returning'
          ' code execution result from the first one.'
      )
    for part in self.candidates[0].content.parts:
      if part.code_execution_result is not None:
        return part.code_execution_result.output
    return None

  @classmethod
  def _from_response(
      cls: typing.Type[T],
      *,
      response: dict[str, object],
      kwargs: dict[str, object],
  ) -> T:
    result = super()._from_response(response=response, kwargs=kwargs)

    
    response_schema = _common.get_value_by_path(
        kwargs, ['config', 'response_schema']
    )
    
    
    if response_schema is None:
      response_schema = _common.get_value_by_path(
          kwargs, ['config', 'response_json_schema']
      )
    if (
        inspect.isclass(response_schema)
        and not (
            isinstance(response_schema, builtin_types.GenericAlias)
        )  
        and issubclass(response_schema, pydantic.BaseModel)
    ):
      
      try:
        result_text = result._get_text(warn_property='parsed')
        if result_text is not None:
          result.parsed = response_schema.model_validate_json(result_text)
      
      except pydantic.ValidationError:
        pass
      except json.decoder.JSONDecodeError:
        pass
    elif (
        isinstance(response_schema, EnumMeta)
        and result._get_text(warn_property='parsed') is not None
    ):
      
      result_text = result._get_text(warn_property='parsed')
      if result_text is None:
        raise ValueError('Response is empty.')
      enum_value = result_text.replace('"', '')
      try:
        result.parsed = response_schema(enum_value)
        if (
            hasattr(response_schema, '__name__')
            and response_schema.__name__ == 'PlaceholderLiteralEnum'
        ):
          result.parsed = str(response_schema(enum_value).name)  
      except ValueError:
        pass
    elif isinstance(response_schema, builtin_types.GenericAlias) or isinstance(
        response_schema, type
    ):

      class Placeholder(pydantic.BaseModel):
        placeholder: response_schema  

      try:
        result_text = result._get_text(warn_property='parsed')
        if result_text is not None:
          parsed = {'placeholder': json.loads(result_text)}
          placeholder = Placeholder.model_validate(parsed)
          result.parsed = placeholder.placeholder
      except json.decoder.JSONDecodeError:
        pass
      except pydantic.ValidationError:
        pass

    elif isinstance(response_schema, dict) or isinstance(
        response_schema, Schema
    ):
      
      
      
      try:
        result_text = result._get_text(warn_property='parsed')
        if result_text is not None:
          result.parsed = json.loads(result_text)
      
      except json.decoder.JSONDecodeError:
        pass
    elif typing.get_origin(response_schema) in _UNION_TYPES:
      
      union_types = typing.get_args(response_schema)
      for union_type in union_types:
        if issubclass(union_type, pydantic.BaseModel):
          try:
            result_text = result._get_text(warn_property='parsed')
            if result_text is not None:

              class Placeholder(pydantic.BaseModel):  
                placeholder: response_schema  

              parsed = {'placeholder': json.loads(result_text)}
              placeholder = Placeholder.model_validate(parsed)
              result.parsed = placeholder.placeholder
          except json.decoder.JSONDecodeError:
            pass
          except pydantic.ValidationError:
            pass
        else:
          try:
            result_text = result._get_text(warn_property='parsed')
            if result_text is not None:
              result.parsed = json.loads(result_text)
          
          except json.decoder.JSONDecodeError:
            pass

    return result


class GenerateContentResponseDict(TypedDict, total=False):
  

  sdk_http_response: Optional[HttpResponseDict]
  

  candidates: Optional[list[CandidateDict]]
  

  create_time: Optional[datetime.datetime]
  

  response_id: Optional[str]
  

  model_version: Optional[str]
  

  prompt_feedback: Optional[GenerateContentResponsePromptFeedbackDict]
  

  usage_metadata: Optional[GenerateContentResponseUsageMetadataDict]
  


GenerateContentResponseOrDict = Union[
    GenerateContentResponse, GenerateContentResponseDict
]


class EmbedContentConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  task_type: Optional[str] = Field(
      default=None,
      description=,
  )
  title: Optional[str] = Field(
      default=None,
      description=,
  )
  output_dimensionality: Optional[int] = Field(
      default=None,
      description=,
  )
  mime_type: Optional[str] = Field(
      default=None,
      description=,
  )
  auto_truncate: Optional[bool] = Field(
      default=None,
      description=,
  )


class EmbedContentConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  task_type: Optional[str]
  

  title: Optional[str]
  

  output_dimensionality: Optional[int]
  

  mime_type: Optional[str]
  

  auto_truncate: Optional[bool]
  


EmbedContentConfigOrDict = Union[EmbedContentConfig, EmbedContentConfigDict]


class _EmbedContentParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  contents: Optional[ContentListUnion] = Field(
      default=None,
      description=,
  )
  config: Optional[EmbedContentConfig] = Field(
      default=None,
      description=,
  )


class _EmbedContentParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  contents: Optional[ContentListUnionDict]
  

  config: Optional[EmbedContentConfigDict]
  


_EmbedContentParametersOrDict = Union[
    _EmbedContentParameters, _EmbedContentParametersDict
]


class ContentEmbeddingStatistics(_common.BaseModel):
  

  truncated: Optional[bool] = Field(
      default=None,
      description=,
  )
  token_count: Optional[float] = Field(
      default=None,
      description=,
  )


class ContentEmbeddingStatisticsDict(TypedDict, total=False):
  

  truncated: Optional[bool]
  

  token_count: Optional[float]
  


ContentEmbeddingStatisticsOrDict = Union[
    ContentEmbeddingStatistics, ContentEmbeddingStatisticsDict
]


class ContentEmbedding(_common.BaseModel):
  

  values: Optional[list[float]] = Field(
      default=None,
      description=,
  )
  statistics: Optional[ContentEmbeddingStatistics] = Field(
      default=None,
      description=,
  )


class ContentEmbeddingDict(TypedDict, total=False):
  

  values: Optional[list[float]]
  

  statistics: Optional[ContentEmbeddingStatisticsDict]
  


ContentEmbeddingOrDict = Union[ContentEmbedding, ContentEmbeddingDict]


class EmbedContentMetadata(_common.BaseModel):
  

  billable_character_count: Optional[int] = Field(
      default=None,
      description=,
  )


class EmbedContentMetadataDict(TypedDict, total=False):
  

  billable_character_count: Optional[int]
  


EmbedContentMetadataOrDict = Union[
    EmbedContentMetadata, EmbedContentMetadataDict
]


class EmbedContentResponse(_common.BaseModel):
  

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  embeddings: Optional[list[ContentEmbedding]] = Field(
      default=None,
      description=,
  )
  metadata: Optional[EmbedContentMetadata] = Field(
      default=None,
      description=,
  )


class EmbedContentResponseDict(TypedDict, total=False):
  

  sdk_http_response: Optional[HttpResponseDict]
  

  embeddings: Optional[list[ContentEmbeddingDict]]
  

  metadata: Optional[EmbedContentMetadataDict]
  


EmbedContentResponseOrDict = Union[
    EmbedContentResponse, EmbedContentResponseDict
]


class GenerateImagesConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  output_gcs_uri: Optional[str] = Field(
      default=None,
      description=,
  )
  negative_prompt: Optional[str] = Field(
      default=None,
      description=,
  )
  number_of_images: Optional[int] = Field(
      default=None,
      description=,
  )
  aspect_ratio: Optional[str] = Field(
      default=None,
      description=,
  )
  guidance_scale: Optional[float] = Field(
      default=None,
      description=,
  )
  seed: Optional[int] = Field(
      default=None,
      description=,
  )
  safety_filter_level: Optional[SafetyFilterLevel] = Field(
      default=None,
      description=,
  )
  person_generation: Optional[PersonGeneration] = Field(
      default=None,
      description=,
  )
  include_safety_attributes: Optional[bool] = Field(
      default=None,
      description=,
  )
  include_rai_reason: Optional[bool] = Field(
      default=None,
      description=,
  )
  language: Optional[ImagePromptLanguage] = Field(
      default=None,
      description=,
  )
  output_mime_type: Optional[str] = Field(
      default=None,
      description=,
  )
  output_compression_quality: Optional[int] = Field(
      default=None,
      description=,
  )
  add_watermark: Optional[bool] = Field(
      default=None,
      description=,
  )
  image_size: Optional[str] = Field(
      default=None,
      description=,
  )
  enhance_prompt: Optional[bool] = Field(
      default=None,
      description=,
  )


class GenerateImagesConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  output_gcs_uri: Optional[str]
  

  negative_prompt: Optional[str]
  

  number_of_images: Optional[int]
  

  aspect_ratio: Optional[str]
  

  guidance_scale: Optional[float]
  

  seed: Optional[int]
  

  safety_filter_level: Optional[SafetyFilterLevel]
  

  person_generation: Optional[PersonGeneration]
  

  include_safety_attributes: Optional[bool]
  

  include_rai_reason: Optional[bool]
  

  language: Optional[ImagePromptLanguage]
  

  output_mime_type: Optional[str]
  

  output_compression_quality: Optional[int]
  

  add_watermark: Optional[bool]
  

  image_size: Optional[str]
  

  enhance_prompt: Optional[bool]
  


GenerateImagesConfigOrDict = Union[
    GenerateImagesConfig, GenerateImagesConfigDict
]


class _GenerateImagesParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  prompt: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[GenerateImagesConfig] = Field(
      default=None,
      description=,
  )


class _GenerateImagesParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  prompt: Optional[str]
  

  config: Optional[GenerateImagesConfigDict]
  


_GenerateImagesParametersOrDict = Union[
    _GenerateImagesParameters, _GenerateImagesParametersDict
]


class Image(_common.BaseModel):
  

  gcs_uri: Optional[str] = Field(
      default=None,
      description=,
  )
  image_bytes: Optional[bytes] = Field(
      default=None,
      description=,
  )
  mime_type: Optional[str] = Field(
      default=None, description=
  )

  _loaded_image: Optional['PIL_Image'] = None

  

  @classmethod
  def from_file(
      cls, *, location: str, mime_type: Optional[str] = None
  ) -> 'Image':
    
    import urllib
    import pathlib
    import mimetypes

    parsed_url = urllib.parse.urlparse(location)
    if (
        parsed_url.scheme == 'https'
        and parsed_url.netloc == 'storage.googleapis.com'
    ):
      parsed_url = parsed_url._replace(
          scheme='gs',
          netloc='',
          path=f'/{urllib.parse.unquote(parsed_url.path)}',
      )
      location = urllib.parse.urlunparse(parsed_url)

    if parsed_url.scheme == 'gs':
      return cls(gcs_uri=location)

    
    image_bytes = pathlib.Path(location).read_bytes()

    if not mime_type:
      mime_type, _ = mimetypes.guess_type(location)
    image = cls(image_bytes=image_bytes, mime_type=mime_type)
    return image

  def show(self) -> None:
    
    try:
      from IPython import display as IPython_display
    except ImportError:
      IPython_display = None

    if IPython_display:
      IPython_display.display(self._pil_image)

  @property
  def _pil_image(self) -> Optional['PIL_Image']:
    PIL_Image: Optional[builtin_types.ModuleType]
    try:
      from PIL import Image as PIL_Image
    except ImportError:
      PIL_Image = None
    import io

    if self._loaded_image is None:
      if not PIL_Image:
        raise RuntimeError(
            'The PIL module is not available. Please install the Pillow'
            ' package. `pip install pillow`'
        )
      if self.image_bytes is None:
        raise ValueError('The image bytes are not set.')
      self._loaded_image = PIL_Image.open(io.BytesIO(self.image_bytes))
    return self._loaded_image

  def save(self, location: str) -> None:
    
    import pathlib

    if self.image_bytes is None:
      raise ValueError('The image bytes are not set.')
    pathlib.Path(location).write_bytes(self.image_bytes)


JOB_STATES_SUCCEEDED_VERTEX = [
    'JOB_STATE_SUCCEEDED',
]

JOB_STATES_SUCCEEDED_MLDEV = [
    'ACTIVE',
]

JOB_STATES_SUCCEEDED = JOB_STATES_SUCCEEDED_VERTEX + JOB_STATES_SUCCEEDED_MLDEV


JOB_STATES_ENDED_VERTEX = [
    'JOB_STATE_SUCCEEDED',
    'JOB_STATE_FAILED',
    'JOB_STATE_CANCELLED',
    'JOB_STATE_EXPIRED',
]

JOB_STATES_ENDED_MLDEV = [
    'ACTIVE',
    'FAILED',
]

JOB_STATES_ENDED = JOB_STATES_ENDED_VERTEX + JOB_STATES_ENDED_MLDEV


class ImageDict(TypedDict, total=False):
  

  gcs_uri: Optional[str]
  

  image_bytes: Optional[bytes]
  

  mime_type: Optional[str]
  


ImageOrDict = Union[Image, ImageDict]


class SafetyAttributes(_common.BaseModel):
  

  categories: Optional[list[str]] = Field(
      default=None,
      description=,
  )
  scores: Optional[list[float]] = Field(
      default=None,
      description=,
  )
  content_type: Optional[str] = Field(
      default=None,
      description=,
  )


class SafetyAttributesDict(TypedDict, total=False):
  

  categories: Optional[list[str]]
  

  scores: Optional[list[float]]
  

  content_type: Optional[str]
  


SafetyAttributesOrDict = Union[SafetyAttributes, SafetyAttributesDict]


class GeneratedImage(_common.BaseModel):
  

  image: Optional[Image] = Field(
      default=None,
      description=,
  )
  rai_filtered_reason: Optional[str] = Field(
      default=None,
      description=,
  )
  safety_attributes: Optional[SafetyAttributes] = Field(
      default=None,
      description=,
  )
  enhanced_prompt: Optional[str] = Field(
      default=None,
      description=,
  )


class GeneratedImageDict(TypedDict, total=False):
  

  image: Optional[ImageDict]
  

  rai_filtered_reason: Optional[str]
  

  safety_attributes: Optional[SafetyAttributesDict]
  

  enhanced_prompt: Optional[str]
  


GeneratedImageOrDict = Union[GeneratedImage, GeneratedImageDict]


class GenerateImagesResponse(_common.BaseModel):
  

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  generated_images: Optional[list[GeneratedImage]] = Field(
      default=None,
      description=,
  )
  positive_prompt_safety_attributes: Optional[SafetyAttributes] = Field(
      default=None,
      description=,
  )

  @property
  def images(self) -> list[Optional[Image]]:
    
    if not self.generated_images:
      return []
    return [generated_image.image for generated_image in self.generated_images]


class GenerateImagesResponseDict(TypedDict, total=False):
  

  sdk_http_response: Optional[HttpResponseDict]
  

  generated_images: Optional[list[GeneratedImageDict]]
  

  positive_prompt_safety_attributes: Optional[SafetyAttributesDict]
  


GenerateImagesResponseOrDict = Union[
    GenerateImagesResponse, GenerateImagesResponseDict
]


class MaskReferenceConfig(_common.BaseModel):
  

  mask_mode: Optional[MaskReferenceMode] = Field(
      default=None,
      description=,
  )
  segmentation_classes: Optional[list[int]] = Field(
      default=None,
      description=,
  )
  mask_dilation: Optional[float] = Field(
      default=None,
      description=,
  )


class MaskReferenceConfigDict(TypedDict, total=False):
  

  mask_mode: Optional[MaskReferenceMode]
  

  segmentation_classes: Optional[list[int]]
  

  mask_dilation: Optional[float]
  


MaskReferenceConfigOrDict = Union[MaskReferenceConfig, MaskReferenceConfigDict]


class ControlReferenceConfig(_common.BaseModel):
  

  control_type: Optional[ControlReferenceType] = Field(
      default=None,
      description=,
  )
  enable_control_image_computation: Optional[bool] = Field(
      default=None,
      description=,
  )


class ControlReferenceConfigDict(TypedDict, total=False):
  

  control_type: Optional[ControlReferenceType]
  

  enable_control_image_computation: Optional[bool]
  


ControlReferenceConfigOrDict = Union[
    ControlReferenceConfig, ControlReferenceConfigDict
]


class StyleReferenceConfig(_common.BaseModel):
  

  style_description: Optional[str] = Field(
      default=None,
      description=,
  )


class StyleReferenceConfigDict(TypedDict, total=False):
  

  style_description: Optional[str]
  


StyleReferenceConfigOrDict = Union[
    StyleReferenceConfig, StyleReferenceConfigDict
]


class SubjectReferenceConfig(_common.BaseModel):
  

  subject_type: Optional[SubjectReferenceType] = Field(
      default=None,
      description=,
  )
  subject_description: Optional[str] = Field(
      default=None, description=
  )


class SubjectReferenceConfigDict(TypedDict, total=False):
  

  subject_type: Optional[SubjectReferenceType]
  

  subject_description: Optional[str]
  


SubjectReferenceConfigOrDict = Union[
    SubjectReferenceConfig, SubjectReferenceConfigDict
]


class _ReferenceImageAPI(_common.BaseModel):
  

  reference_image: Optional[Image] = Field(
      default=None,
      description=,
  )
  reference_id: Optional[int] = Field(
      default=None, description=
  )
  reference_type: Optional[str] = Field(
      default=None,
      description=,
  )
  mask_image_config: Optional[MaskReferenceConfig] = Field(
      default=None,
      description=,
  )
  control_image_config: Optional[ControlReferenceConfig] = Field(
      default=None,
      description=,
  )
  style_image_config: Optional[StyleReferenceConfig] = Field(
      default=None,
      description=,
  )
  subject_image_config: Optional[SubjectReferenceConfig] = Field(
      default=None,
      description=,
  )


class _ReferenceImageAPIDict(TypedDict, total=False):
  

  reference_image: Optional[ImageDict]
  

  reference_id: Optional[int]
  

  reference_type: Optional[str]
  

  mask_image_config: Optional[MaskReferenceConfigDict]
  

  control_image_config: Optional[ControlReferenceConfigDict]
  

  style_image_config: Optional[StyleReferenceConfigDict]
  

  subject_image_config: Optional[SubjectReferenceConfigDict]
  


_ReferenceImageAPIOrDict = Union[_ReferenceImageAPI, _ReferenceImageAPIDict]


class EditImageConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  output_gcs_uri: Optional[str] = Field(
      default=None,
      description=,
  )
  negative_prompt: Optional[str] = Field(
      default=None,
      description=,
  )
  number_of_images: Optional[int] = Field(
      default=None,
      description=,
  )
  aspect_ratio: Optional[str] = Field(
      default=None,
      description=,
  )
  guidance_scale: Optional[float] = Field(
      default=None,
      description=,
  )
  seed: Optional[int] = Field(
      default=None,
      description=,
  )
  safety_filter_level: Optional[SafetyFilterLevel] = Field(
      default=None,
      description=,
  )
  person_generation: Optional[PersonGeneration] = Field(
      default=None,
      description=,
  )
  include_safety_attributes: Optional[bool] = Field(
      default=None,
      description=,
  )
  include_rai_reason: Optional[bool] = Field(
      default=None,
      description=,
  )
  language: Optional[ImagePromptLanguage] = Field(
      default=None,
      description=,
  )
  output_mime_type: Optional[str] = Field(
      default=None,
      description=,
  )
  output_compression_quality: Optional[int] = Field(
      default=None,
      description=,
  )
  add_watermark: Optional[bool] = Field(
      default=None,
      description=,
  )
  edit_mode: Optional[EditMode] = Field(
      default=None,
      description=,
  )
  base_steps: Optional[int] = Field(
      default=None,
      description=,
  )


class EditImageConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  output_gcs_uri: Optional[str]
  

  negative_prompt: Optional[str]
  

  number_of_images: Optional[int]
  

  aspect_ratio: Optional[str]
  

  guidance_scale: Optional[float]
  

  seed: Optional[int]
  

  safety_filter_level: Optional[SafetyFilterLevel]
  

  person_generation: Optional[PersonGeneration]
  

  include_safety_attributes: Optional[bool]
  

  include_rai_reason: Optional[bool]
  

  language: Optional[ImagePromptLanguage]
  

  output_mime_type: Optional[str]
  

  output_compression_quality: Optional[int]
  

  add_watermark: Optional[bool]
  

  edit_mode: Optional[EditMode]
  

  base_steps: Optional[int]
  


EditImageConfigOrDict = Union[EditImageConfig, EditImageConfigDict]


class _EditImageParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None, description=
  )
  prompt: Optional[str] = Field(
      default=None,
      description=,
  )
  reference_images: Optional[list[_ReferenceImageAPI]] = Field(
      default=None, description=
  )
  config: Optional[EditImageConfig] = Field(
      default=None, description=
  )


class _EditImageParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  prompt: Optional[str]
  

  reference_images: Optional[list[_ReferenceImageAPIDict]]
  

  config: Optional[EditImageConfigDict]
  


_EditImageParametersOrDict = Union[
    _EditImageParameters, _EditImageParametersDict
]


class EditImageResponse(_common.BaseModel):
  

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  generated_images: Optional[list[GeneratedImage]] = Field(
      default=None, description=
  )


class EditImageResponseDict(TypedDict, total=False):
  

  sdk_http_response: Optional[HttpResponseDict]
  

  generated_images: Optional[list[GeneratedImageDict]]
  


EditImageResponseOrDict = Union[EditImageResponse, EditImageResponseDict]


class _UpscaleImageAPIConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  include_rai_reason: Optional[bool] = Field(
      default=None,
      description=,
  )
  output_mime_type: Optional[str] = Field(
      default=None,
      description=,
  )
  output_compression_quality: Optional[int] = Field(
      default=None,
      description=,
  )
  enhance_input_image: Optional[bool] = Field(
      default=None,
      description=,
  )
  image_preservation_factor: Optional[float] = Field(
      default=None,
      description=,
  )
  number_of_images: Optional[int] = Field(default=None, description=)
  mode: Optional[str] = Field(default=None, description=)


class _UpscaleImageAPIConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  include_rai_reason: Optional[bool]
  

  output_mime_type: Optional[str]
  

  output_compression_quality: Optional[int]
  

  enhance_input_image: Optional[bool]
  

  image_preservation_factor: Optional[float]
  

  number_of_images: Optional[int]
  

  mode: Optional[str]
  


_UpscaleImageAPIConfigOrDict = Union[
    _UpscaleImageAPIConfig, _UpscaleImageAPIConfigDict
]


class _UpscaleImageAPIParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None, description=
  )
  image: Optional[Image] = Field(
      default=None, description=
  )
  upscale_factor: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[_UpscaleImageAPIConfig] = Field(
      default=None, description=
  )


class _UpscaleImageAPIParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  image: Optional[ImageDict]
  

  upscale_factor: Optional[str]
  

  config: Optional[_UpscaleImageAPIConfigDict]
  


_UpscaleImageAPIParametersOrDict = Union[
    _UpscaleImageAPIParameters, _UpscaleImageAPIParametersDict
]


class UpscaleImageResponse(_common.BaseModel):

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  generated_images: Optional[list[GeneratedImage]] = Field(
      default=None, description=
  )


class UpscaleImageResponseDict(TypedDict, total=False):

  sdk_http_response: Optional[HttpResponseDict]
  

  generated_images: Optional[list[GeneratedImageDict]]
  


UpscaleImageResponseOrDict = Union[
    UpscaleImageResponse, UpscaleImageResponseDict
]


class GetModelConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class GetModelConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  


GetModelConfigOrDict = Union[GetModelConfig, GetModelConfigDict]


class _GetModelParameters(_common.BaseModel):

  model: Optional[str] = Field(default=None, description=)
  config: Optional[GetModelConfig] = Field(
      default=None, description=
  )


class _GetModelParametersDict(TypedDict, total=False):

  model: Optional[str]
  

  config: Optional[GetModelConfigDict]
  


_GetModelParametersOrDict = Union[_GetModelParameters, _GetModelParametersDict]


class Endpoint(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None, description=
  )
  deployed_model_id: Optional[str] = Field(
      default=None,
      description=,
  )


class EndpointDict(TypedDict, total=False):
  

  name: Optional[str]
  

  deployed_model_id: Optional[str]
  


EndpointOrDict = Union[Endpoint, EndpointDict]


class TunedModelInfo(_common.BaseModel):
  

  base_model: Optional[str] = Field(
      default=None,
      description=,
  )
  create_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  update_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )


class TunedModelInfoDict(TypedDict, total=False):
  

  base_model: Optional[str]
  

  create_time: Optional[datetime.datetime]
  

  update_time: Optional[datetime.datetime]
  


TunedModelInfoOrDict = Union[TunedModelInfo, TunedModelInfoDict]


class Checkpoint(_common.BaseModel):
  

  checkpoint_id: Optional[str] = Field(
      default=None,
      description=,
  )
  epoch: Optional[int] = Field(
      default=None,
      description=,
  )
  step: Optional[int] = Field(
      default=None,
      description=,
  )


class CheckpointDict(TypedDict, total=False):
  

  checkpoint_id: Optional[str]
  

  epoch: Optional[int]
  

  step: Optional[int]
  


CheckpointOrDict = Union[Checkpoint, CheckpointDict]


class Model(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None, description=
  )
  display_name: Optional[str] = Field(
      default=None, description=
  )
  description: Optional[str] = Field(
      default=None, description=
  )
  version: Optional[str] = Field(
      default=None,
      description=,
  )
  endpoints: Optional[list[Endpoint]] = Field(
      default=None,
      description=,
  )
  labels: Optional[dict[str, str]] = Field(
      default=None,
      description=,
  )
  tuned_model_info: Optional[TunedModelInfo] = Field(
      default=None,
      description=,
  )
  input_token_limit: Optional[int] = Field(
      default=None,
      description=,
  )
  output_token_limit: Optional[int] = Field(
      default=None,
      description=,
  )
  supported_actions: Optional[list[str]] = Field(
      default=None,
      description=,
  )
  default_checkpoint_id: Optional[str] = Field(
      default=None,
      description=,
  )
  checkpoints: Optional[list[Checkpoint]] = Field(
      default=None, description=
  )


class ModelDict(TypedDict, total=False):
  

  name: Optional[str]
  

  display_name: Optional[str]
  

  description: Optional[str]
  

  version: Optional[str]
  

  endpoints: Optional[list[EndpointDict]]
  

  labels: Optional[dict[str, str]]
  

  tuned_model_info: Optional[TunedModelInfoDict]
  

  input_token_limit: Optional[int]
  

  output_token_limit: Optional[int]
  

  supported_actions: Optional[list[str]]
  

  default_checkpoint_id: Optional[str]
  

  checkpoints: Optional[list[CheckpointDict]]
  


ModelOrDict = Union[Model, ModelDict]


class ListModelsConfig(_common.BaseModel):

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  page_size: Optional[int] = Field(default=None, description=)
  page_token: Optional[str] = Field(default=None, description=)
  filter: Optional[str] = Field(default=None, description=)
  query_base: Optional[bool] = Field(
      default=None,
      description=,
  )


class ListModelsConfigDict(TypedDict, total=False):

  http_options: Optional[HttpOptionsDict]
  

  page_size: Optional[int]
  

  page_token: Optional[str]
  

  filter: Optional[str]
  

  query_base: Optional[bool]
  


ListModelsConfigOrDict = Union[ListModelsConfig, ListModelsConfigDict]


class _ListModelsParameters(_common.BaseModel):

  config: Optional[ListModelsConfig] = Field(default=None, description=)


class _ListModelsParametersDict(TypedDict, total=False):

  config: Optional[ListModelsConfigDict]
  


_ListModelsParametersOrDict = Union[
    _ListModelsParameters, _ListModelsParametersDict
]


class ListModelsResponse(_common.BaseModel):

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  next_page_token: Optional[str] = Field(default=None, description=)
  models: Optional[list[Model]] = Field(default=None, description=)


class ListModelsResponseDict(TypedDict, total=False):

  sdk_http_response: Optional[HttpResponseDict]
  

  next_page_token: Optional[str]
  

  models: Optional[list[ModelDict]]
  


ListModelsResponseOrDict = Union[ListModelsResponse, ListModelsResponseDict]


class UpdateModelConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  display_name: Optional[str] = Field(default=None, description=)
  description: Optional[str] = Field(default=None, description=)
  default_checkpoint_id: Optional[str] = Field(default=None, description=)


class UpdateModelConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  display_name: Optional[str]
  

  description: Optional[str]
  

  default_checkpoint_id: Optional[str]
  


UpdateModelConfigOrDict = Union[UpdateModelConfig, UpdateModelConfigDict]


class _UpdateModelParameters(_common.BaseModel):
  

  model: Optional[str] = Field(default=None, description=)
  config: Optional[UpdateModelConfig] = Field(default=None, description=)


class _UpdateModelParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  config: Optional[UpdateModelConfigDict]
  


_UpdateModelParametersOrDict = Union[
    _UpdateModelParameters, _UpdateModelParametersDict
]


class DeleteModelConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class DeleteModelConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  


DeleteModelConfigOrDict = Union[DeleteModelConfig, DeleteModelConfigDict]


class _DeleteModelParameters(_common.BaseModel):
  

  model: Optional[str] = Field(default=None, description=)
  config: Optional[DeleteModelConfig] = Field(
      default=None, description=
  )


class _DeleteModelParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  config: Optional[DeleteModelConfigDict]
  


_DeleteModelParametersOrDict = Union[
    _DeleteModelParameters, _DeleteModelParametersDict
]


class DeleteModelResponse(_common.BaseModel):

  pass


class DeleteModelResponseDict(TypedDict, total=False):

  pass


DeleteModelResponseOrDict = Union[DeleteModelResponse, DeleteModelResponseDict]


class GenerationConfigThinkingConfig(_common.BaseModel):
  

  include_thoughts: Optional[bool] = Field(
      default=None,
      description=,
  )
  thinking_budget: Optional[int] = Field(
      default=None,
      description=,
  )


class GenerationConfigThinkingConfigDict(TypedDict, total=False):
  

  include_thoughts: Optional[bool]
  

  thinking_budget: Optional[int]
  


GenerationConfigThinkingConfigOrDict = Union[
    GenerationConfigThinkingConfig, GenerationConfigThinkingConfigDict
]


class GenerationConfig(_common.BaseModel):
  

  model_selection_config: Optional[ModelSelectionConfig] = Field(
      default=None, description=
  )
  audio_timestamp: Optional[bool] = Field(
      default=None,
      description=,
  )
  candidate_count: Optional[int] = Field(
      default=None,
      description=,
  )
  enable_affective_dialog: Optional[bool] = Field(
      default=None,
      description=,
  )
  frequency_penalty: Optional[float] = Field(
      default=None, description=
  )
  logprobs: Optional[int] = Field(
      default=None, description=
  )
  max_output_tokens: Optional[int] = Field(
      default=None,
      description=,
  )
  media_resolution: Optional[MediaResolution] = Field(
      default=None,
      description=,
  )
  presence_penalty: Optional[float] = Field(
      default=None, description=
  )
  response_json_schema: Optional[Any] = Field(
      default=None,
      description=,
  )
  response_logprobs: Optional[bool] = Field(
      default=None,
      description=,
  )
  response_mime_type: Optional[str] = Field(
      default=None,
      description=,
  )
  response_modalities: Optional[list[Modality]] = Field(
      default=None, description=
  )
  response_schema: Optional[Schema] = Field(
      default=None,
      description=Optional. Routing configuration.Optional. Seed.Optional. The speech generation config.Optional. Stop sequences.Optional. Controls the randomness of predictions.Optional. Config for thinking features. An error will be returned if this field is set for models that don't support thinking.Optional. If specified, top-k sampling will be used.Optional. If specified, nucleus sampling will be used.Generation config.Optional. Config for model selection.Optional. If enabled, audio timestamp will be included in the request to the model.Optional. Number of candidates to generate.Optional. If enabled, the model will detect emotions and adapt its responses accordingly.Optional. Frequency penalties.Optional. Logit probabilities.Optional. The maximum number of output tokens to generate per message.Optional. If specified, the media resolution specified will be used.Optional. Positive penalties.Optional. Output schema of the generated response. This is an alternative to `response_schema` that accepts [JSON Schema](https://json-schema.org/). If set, `response_schema` must be omitted, but `response_mime_type` is required. While the full JSON Schema may be sent, not all features are supported. Specifically, only the following properties are supported: - `$id` - `$defs` - `$ref` - `$anchor` - `type` - `format` - `title` - `description` - `enum` (for strings and numbers) - `items` - `prefixItems` - `minItems` - `maxItems` - `minimum` - `maximum` - `anyOf` - `oneOf` (interpreted the same as `anyOf`) - `properties` - `additionalProperties` - `required` The non-standard `propertyOrdering` property may also be set. Cyclic references are unrolled to a limited degree and, as such, may only be used within non-required properties. (Nullable properties are not sufficient.) If `$ref` is set on a sub-schema, no other properties, except for than those starting as a `$`, may be set.Optional. If true, export the logprobs results in response.Optional. Output response mimetype of the generated candidate text. Supported mimetype: - `text/plain`: (default) Text output. - `application/json`: JSON response in the candidates. The model needs to be prompted to output the appropriate response type, otherwise the behavior is undefined. This is a preview feature.Optional. The modalities of the response.Optional. The `Schema` object allows the definition of input and output data types. These types can be objects, but also primitives and arrays. Represents a select subset of an [OpenAPI 3.0 schema object](https://spec.openapis.org/oas/v3.0.3

  routing_config: Optional[GenerationConfigRoutingConfigDict]
  

  seed: Optional[int]
  

  speech_config: Optional[SpeechConfigDict]
  

  stop_sequences: Optional[list[str]]
  

  temperature: Optional[float]
  

  thinking_config: Optional[GenerationConfigThinkingConfigDict]
  

  top_k: Optional[float]
  

  top_p: Optional[float]
  


GenerationConfigOrDict = Union[GenerationConfig, GenerationConfigDict]


class CountTokensConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  system_instruction: Optional[ContentUnion] = Field(
      default=None,
      description=,
  )
  tools: Optional[list[Tool]] = Field(
      default=None,
      description=,
  )
  generation_config: Optional[GenerationConfig] = Field(
      default=None,
      description=,
  )


class CountTokensConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  system_instruction: Optional[ContentUnionDict]
  

  tools: Optional[list[ToolDict]]
  

  generation_config: Optional[GenerationConfigDict]
  


CountTokensConfigOrDict = Union[CountTokensConfig, CountTokensConfigDict]


class _CountTokensParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  contents: Optional[ContentListUnion] = Field(
      default=None, description=
  )
  config: Optional[CountTokensConfig] = Field(
      default=None, description=
  )


class _CountTokensParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  contents: Optional[ContentListUnionDict]
  

  config: Optional[CountTokensConfigDict]
  


_CountTokensParametersOrDict = Union[
    _CountTokensParameters, _CountTokensParametersDict
]


class CountTokensResponse(_common.BaseModel):
  

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  total_tokens: Optional[int] = Field(
      default=None, description=
  )
  cached_content_token_count: Optional[int] = Field(
      default=None,
      description=,
  )


class CountTokensResponseDict(TypedDict, total=False):
  

  sdk_http_response: Optional[HttpResponseDict]
  

  total_tokens: Optional[int]
  

  cached_content_token_count: Optional[int]
  


CountTokensResponseOrDict = Union[CountTokensResponse, CountTokensResponseDict]


class ComputeTokensConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class ComputeTokensConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  


ComputeTokensConfigOrDict = Union[ComputeTokensConfig, ComputeTokensConfigDict]


class _ComputeTokensParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  contents: Optional[ContentListUnion] = Field(
      default=None, description=
  )
  config: Optional[ComputeTokensConfig] = Field(
      default=None,
      description=,
  )


class _ComputeTokensParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  contents: Optional[ContentListUnionDict]
  

  config: Optional[ComputeTokensConfigDict]
  


_ComputeTokensParametersOrDict = Union[
    _ComputeTokensParameters, _ComputeTokensParametersDict
]


class TokensInfo(_common.BaseModel):
  

  role: Optional[str] = Field(
      default=None,
      description=,
  )
  token_ids: Optional[list[int]] = Field(
      default=None, description=
  )
  tokens: Optional[list[bytes]] = Field(
      default=None, description=
  )


class TokensInfoDict(TypedDict, total=False):
  

  role: Optional[str]
  

  token_ids: Optional[list[int]]
  

  tokens: Optional[list[bytes]]
  


TokensInfoOrDict = Union[TokensInfo, TokensInfoDict]


class ComputeTokensResponse(_common.BaseModel):
  

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  tokens_info: Optional[list[TokensInfo]] = Field(
      default=None,
      description=,
  )


class ComputeTokensResponseDict(TypedDict, total=False):
  

  sdk_http_response: Optional[HttpResponseDict]
  

  tokens_info: Optional[list[TokensInfoDict]]
  


ComputeTokensResponseOrDict = Union[
    ComputeTokensResponse, ComputeTokensResponseDict
]


class Video(_common.BaseModel):
  

  uri: Optional[str] = Field(
      default=None, description=
  )
  video_bytes: Optional[bytes] = Field(
      default=None, description=
  )
  mime_type: Optional[str] = Field(
      default=None, description=
  )

  @classmethod
  def from_file(
      cls, *, location: str, mime_type: Optional[str] = None
  ) -> 'Video':
    
    import mimetypes  
    import pathlib  

    video_bytes = pathlib.Path(location).read_bytes()

    if not mime_type:
      mime_type, _ = mimetypes.guess_type(location)
    video = cls(video_bytes=video_bytes, mime_type=mime_type)
    return video

  def save(
      self,
      path: str,
  ) -> None:
    
    import pathlib  

    if not self.video_bytes:
      raise NotImplementedError('Saving remote videos is not supported.')

    pathlib.Path(path).write_bytes(self.video_bytes)

  def show(self) -> None:
    
    if self.uri and not self.video_bytes:
      raise ValueError('Showing remote videos is not supported.')
    if not self.video_bytes:
      raise ValueError('Video has no bytes.')

    mime_type = self.mime_type or 'video/mp4'

    try:
      from IPython import display as IPython_display
    except ImportError:
      IPython_display = None

    if IPython_display:
      IPython_display.display(
          IPython_display.Video(
              data=self.video_bytes, mimetype=mime_type, embed=True
          )
      )

  def __repr__(self) -> str:
    video_bytes = '<video_bytes>' if self.video_bytes else 'None'
    return (
        f'Video(uri={self.uri}, video_bytes={video_bytes},'
        f' mime_type={self.mime_type})'
    )


class VideoDict(TypedDict, total=False):
  

  uri: Optional[str]
  

  video_bytes: Optional[bytes]
  

  mime_type: Optional[str]
  


VideoOrDict = Union[Video, VideoDict]


class GenerateVideosConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  number_of_videos: Optional[int] = Field(
      default=None, description=
  )
  output_gcs_uri: Optional[str] = Field(
      default=None,
      description=,
  )
  fps: Optional[int] = Field(
      default=None, description=
  )
  duration_seconds: Optional[int] = Field(
      default=None,
      description=,
  )
  seed: Optional[int] = Field(
      default=None,
      description=,
  )
  aspect_ratio: Optional[str] = Field(
      default=None,
      description=,
  )
  resolution: Optional[str] = Field(
      default=None,
      description=,
  )
  person_generation: Optional[str] = Field(
      default=None,
      description=,
  )
  pubsub_topic: Optional[str] = Field(
      default=None,
      description=,
  )
  negative_prompt: Optional[str] = Field(
      default=None,
      description=,
  )
  enhance_prompt: Optional[bool] = Field(
      default=None, description=
  )
  generate_audio: Optional[bool] = Field(
      default=None,
      description=,
  )
  last_frame: Optional[Image] = Field(
      default=None,
      description=,
  )
  compression_quality: Optional[VideoCompressionQuality] = Field(
      default=None,
      description=,
  )


class GenerateVideosConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  number_of_videos: Optional[int]
  

  output_gcs_uri: Optional[str]
  

  fps: Optional[int]
  

  duration_seconds: Optional[int]
  

  seed: Optional[int]
  

  aspect_ratio: Optional[str]
  

  resolution: Optional[str]
  

  person_generation: Optional[str]
  

  pubsub_topic: Optional[str]
  

  negative_prompt: Optional[str]
  

  enhance_prompt: Optional[bool]
  

  generate_audio: Optional[bool]
  

  last_frame: Optional[ImageDict]
  

  compression_quality: Optional[VideoCompressionQuality]
  


GenerateVideosConfigOrDict = Union[
    GenerateVideosConfig, GenerateVideosConfigDict
]


class _GenerateVideosParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  prompt: Optional[str] = Field(
      default=None,
      description=,
  )
  image: Optional[Image] = Field(
      default=None,
      description=,
  )
  video: Optional[Video] = Field(
      default=None,
      description=,
  )
  config: Optional[GenerateVideosConfig] = Field(
      default=None, description=
  )


class _GenerateVideosParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  prompt: Optional[str]
  

  image: Optional[ImageDict]
  

  video: Optional[VideoDict]
  

  config: Optional[GenerateVideosConfigDict]
  


_GenerateVideosParametersOrDict = Union[
    _GenerateVideosParameters, _GenerateVideosParametersDict
]


class GeneratedVideo(_common.BaseModel):
  

  video: Optional[Video] = Field(
      default=None, description=
  )


class GeneratedVideoDict(TypedDict, total=False):
  

  video: Optional[VideoDict]
  


GeneratedVideoOrDict = Union[GeneratedVideo, GeneratedVideoDict]


class GenerateVideosResponse(_common.BaseModel):
  

  generated_videos: Optional[list[GeneratedVideo]] = Field(
      default=None, description=
  )
  rai_media_filtered_count: Optional[int] = Field(
      default=None,
      description=,
  )
  rai_media_filtered_reasons: Optional[list[str]] = Field(
      default=None, description=
  )


class Operation(ABC):
  

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  metadata: Optional[dict[str, Any]] = Field(
      default=None,
      description=,
  )
  done: Optional[bool] = Field(
      default=None,
      description=,
  )
  error: Optional[dict[str, Any]] = Field(
      default=None,
      description=,
  )

  @classmethod
  @abstractmethod
  def from_api_response(
      cls, api_response: Any, is_vertex_ai: bool = False
  ) -> Self:
    
    pass


class GenerateVideosOperation(_common.BaseModel, Operation):
  

  response: Optional[GenerateVideosResponse] = Field(
      default=None, description=
  )

  result: Optional[GenerateVideosResponse] = Field(
      default=None, description=
  )

  @classmethod
  def from_api_response(
      cls, api_response: Any, is_vertex_ai: bool = False
  ) -> Self:
    
    new_operation = cls()
    new_operation.name = api_response.get('name', None)
    new_operation.metadata = api_response.get('metadata', None)
    new_operation.done = api_response.get('done', None)
    new_operation.error = api_response.get('error', None)

    if is_vertex_ai:
      if api_response.get('response', None) is not None:
        new_operation.response = GenerateVideosResponse(
            generated_videos=[
                GeneratedVideo(
                    video=Video(
                        uri=video.get('gcsUri', None),
                        video_bytes=video.get('bytesBase64Encoded', None),
                        mime_type=video.get('mimeType', None),
                    )
                )
                for video in api_response.get('response', {}).get('videos', [])
            ],
            rai_media_filtered_count=api_response.get('response', {}).get(
                'raiMediaFilteredCount', None
            ),
            rai_media_filtered_reasons=api_response.get('response', {}).get(
                'raiMediaFilteredReasons', None
            ),
        )
    else:
      if api_response.get('response', None) is not None:
        new_operation.response = GenerateVideosResponse(
            generated_videos=[
                GeneratedVideo(
                    video=Video(
                        uri=video.get('video', {}).get('uri', None),
                        video_bytes=video.get('video', {}).get(
                            'encodedVideo', None
                        ),
                        mime_type=video.get('encoding', None),
                    )
                )
                for video in api_response.get('response', {})
                .get('generateVideoResponse', {})
                .get('generatedSamples', [])
            ],
            rai_media_filtered_count=api_response.get('response', {})
            .get('generateVideoResponse', {})
            .get('raiMediaFilteredCount', None),
            rai_media_filtered_reasons=api_response.get('response', {})
            .get('generateVideoResponse', {})
            .get('raiMediaFilteredReasons', None),
        )
    new_operation.result = new_operation.response
    return new_operation


class GenerateVideosResponseDict(TypedDict, total=False):
  

  generated_videos: Optional[list[GeneratedVideoDict]]
  

  rai_media_filtered_count: Optional[int]
  

  rai_media_filtered_reasons: Optional[list[str]]
  


GenerateVideosResponseOrDict = Union[
    GenerateVideosResponse, GenerateVideosResponseDict
]


class GetTuningJobConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class GetTuningJobConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  


GetTuningJobConfigOrDict = Union[GetTuningJobConfig, GetTuningJobConfigDict]


class _GetTuningJobParameters(_common.BaseModel):
  

  name: Optional[str] = Field(default=None, description=)
  config: Optional[GetTuningJobConfig] = Field(
      default=None, description=
  )


class _GetTuningJobParametersDict(TypedDict, total=False):
  

  name: Optional[str]
  

  config: Optional[GetTuningJobConfigDict]
  


_GetTuningJobParametersOrDict = Union[
    _GetTuningJobParameters, _GetTuningJobParametersDict
]


class TunedModelCheckpoint(_common.BaseModel):
  

  checkpoint_id: Optional[str] = Field(
      default=None,
      description=,
  )
  epoch: Optional[int] = Field(
      default=None,
      description=,
  )
  step: Optional[int] = Field(
      default=None,
      description=,
  )
  endpoint: Optional[str] = Field(
      default=None,
      description=,
  )


class TunedModelCheckpointDict(TypedDict, total=False):
  

  checkpoint_id: Optional[str]
  

  epoch: Optional[int]
  

  step: Optional[int]
  

  endpoint: Optional[str]
  


TunedModelCheckpointOrDict = Union[
    TunedModelCheckpoint, TunedModelCheckpointDict
]


class TunedModel(_common.BaseModel):

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  endpoint: Optional[str] = Field(
      default=None,
      description=,
  )
  checkpoints: Optional[list[TunedModelCheckpoint]] = Field(
      default=None,
      description=,
  )


class TunedModelDict(TypedDict, total=False):

  model: Optional[str]
  

  endpoint: Optional[str]
  

  checkpoints: Optional[list[TunedModelCheckpointDict]]
  


TunedModelOrDict = Union[TunedModel, TunedModelDict]


class GoogleRpcStatus(_common.BaseModel):
  

  code: Optional[int] = Field(
      default=None,
      description=,
  )
  details: Optional[list[dict[str, Any]]] = Field(
      default=None,
      description=,
  )
  message: Optional[str] = Field(
      default=None,
      description=,
  )


class GoogleRpcStatusDict(TypedDict, total=False):
  

  code: Optional[int]
  

  details: Optional[list[dict[str, Any]]]
  

  message: Optional[str]
  


GoogleRpcStatusOrDict = Union[GoogleRpcStatus, GoogleRpcStatusDict]


class SupervisedHyperParameters(_common.BaseModel):
  

  adapter_size: Optional[AdapterSize] = Field(
      default=None, description=
  )
  epoch_count: Optional[int] = Field(
      default=None,
      description=,
  )
  learning_rate_multiplier: Optional[float] = Field(
      default=None,
      description=,
  )


class SupervisedHyperParametersDict(TypedDict, total=False):
  

  adapter_size: Optional[AdapterSize]
  

  epoch_count: Optional[int]
  

  learning_rate_multiplier: Optional[float]
  


SupervisedHyperParametersOrDict = Union[
    SupervisedHyperParameters, SupervisedHyperParametersDict
]


class SupervisedTuningSpec(_common.BaseModel):
  

  export_last_checkpoint_only: Optional[bool] = Field(
      default=None,
      description=,
  )
  hyper_parameters: Optional[SupervisedHyperParameters] = Field(
      default=None, description=
  )
  training_dataset_uri: Optional[str] = Field(
      default=None,
      description=,
  )
  validation_dataset_uri: Optional[str] = Field(
      default=None,
      description=,
  )


class SupervisedTuningSpecDict(TypedDict, total=False):
  

  export_last_checkpoint_only: Optional[bool]
  

  hyper_parameters: Optional[SupervisedHyperParametersDict]
  

  training_dataset_uri: Optional[str]
  

  validation_dataset_uri: Optional[str]
  


SupervisedTuningSpecOrDict = Union[
    SupervisedTuningSpec, SupervisedTuningSpecDict
]


class DatasetDistributionDistributionBucket(_common.BaseModel):
  

  count: Optional[int] = Field(
      default=None,
      description=,
  )
  left: Optional[float] = Field(
      default=None, description=
  )
  right: Optional[float] = Field(
      default=None, description=
  )


class DatasetDistributionDistributionBucketDict(TypedDict, total=False):
  

  count: Optional[int]
  

  left: Optional[float]
  

  right: Optional[float]
  


DatasetDistributionDistributionBucketOrDict = Union[
    DatasetDistributionDistributionBucket,
    DatasetDistributionDistributionBucketDict,
]


class DatasetDistribution(_common.BaseModel):
  

  buckets: Optional[list[DatasetDistributionDistributionBucket]] = Field(
      default=None, description=
  )
  max: Optional[float] = Field(
      default=None,
      description=,
  )
  mean: Optional[float] = Field(
      default=None,
      description=,
  )
  median: Optional[float] = Field(
      default=None,
      description=,
  )
  min: Optional[float] = Field(
      default=None,
      description=,
  )
  p5: Optional[float] = Field(
      default=None,
      description=,
  )
  p95: Optional[float] = Field(
      default=None,
      description=,
  )
  sum: Optional[float] = Field(
      default=None,
      description=,
  )


class DatasetDistributionDict(TypedDict, total=False):
  

  buckets: Optional[list[DatasetDistributionDistributionBucketDict]]
  

  max: Optional[float]
  

  mean: Optional[float]
  

  median: Optional[float]
  

  min: Optional[float]
  

  p5: Optional[float]
  

  p95: Optional[float]
  

  sum: Optional[float]
  


DatasetDistributionOrDict = Union[DatasetDistribution, DatasetDistributionDict]


class DatasetStats(_common.BaseModel):
  

  total_billable_character_count: Optional[int] = Field(
      default=None,
      description=,
  )
  total_tuning_character_count: Optional[int] = Field(
      default=None,
      description=,
  )
  tuning_dataset_example_count: Optional[int] = Field(
      default=None,
      description=,
  )
  tuning_step_count: Optional[int] = Field(
      default=None,
      description=,
  )
  user_dataset_examples: Optional[list[Content]] = Field(
      default=None,
      description=,
  )
  user_input_token_distribution: Optional[DatasetDistribution] = Field(
      default=None,
      description=,
  )
  user_message_per_example_distribution: Optional[DatasetDistribution] = Field(
      default=None,
      description=,
  )
  user_output_token_distribution: Optional[DatasetDistribution] = Field(
      default=None,
      description=,
  )


class DatasetStatsDict(TypedDict, total=False):
  

  total_billable_character_count: Optional[int]
  

  total_tuning_character_count: Optional[int]
  

  tuning_dataset_example_count: Optional[int]
  

  tuning_step_count: Optional[int]
  

  user_dataset_examples: Optional[list[ContentDict]]
  

  user_input_token_distribution: Optional[DatasetDistributionDict]
  

  user_message_per_example_distribution: Optional[DatasetDistributionDict]
  

  user_output_token_distribution: Optional[DatasetDistributionDict]
  


DatasetStatsOrDict = Union[DatasetStats, DatasetStatsDict]


class DistillationDataStats(_common.BaseModel):
  

  training_dataset_stats: Optional[DatasetStats] = Field(
      default=None,
      description=,
  )


class DistillationDataStatsDict(TypedDict, total=False):
  

  training_dataset_stats: Optional[DatasetStatsDict]
  


DistillationDataStatsOrDict = Union[
    DistillationDataStats, DistillationDataStatsDict
]


class SupervisedTuningDatasetDistributionDatasetBucket(_common.BaseModel):
  

  count: Optional[float] = Field(
      default=None,
      description=,
  )
  left: Optional[float] = Field(
      default=None, description=
  )
  right: Optional[float] = Field(
      default=None, description=
  )


class SupervisedTuningDatasetDistributionDatasetBucketDict(
    TypedDict, total=False
):
  

  count: Optional[float]
  

  left: Optional[float]
  

  right: Optional[float]
  


SupervisedTuningDatasetDistributionDatasetBucketOrDict = Union[
    SupervisedTuningDatasetDistributionDatasetBucket,
    SupervisedTuningDatasetDistributionDatasetBucketDict,
]


class SupervisedTuningDatasetDistribution(_common.BaseModel):
  

  billable_sum: Optional[int] = Field(
      default=None,
      description=,
  )
  buckets: Optional[list[SupervisedTuningDatasetDistributionDatasetBucket]] = (
      Field(
          default=None,
          description=,
      )
  )
  max: Optional[float] = Field(
      default=None,
      description=,
  )
  mean: Optional[float] = Field(
      default=None,
      description=,
  )
  median: Optional[float] = Field(
      default=None,
      description=,
  )
  min: Optional[float] = Field(
      default=None,
      description=,
  )
  p5: Optional[float] = Field(
      default=None,
      description=,
  )
  p95: Optional[float] = Field(
      default=None,
      description=,
  )
  sum: Optional[int] = Field(
      default=None,
      description=,
  )


class SupervisedTuningDatasetDistributionDict(TypedDict, total=False):
  

  billable_sum: Optional[int]
  

  buckets: Optional[list[SupervisedTuningDatasetDistributionDatasetBucketDict]]
  

  max: Optional[float]
  

  mean: Optional[float]
  

  median: Optional[float]
  

  min: Optional[float]
  

  p5: Optional[float]
  

  p95: Optional[float]
  

  sum: Optional[int]
  


SupervisedTuningDatasetDistributionOrDict = Union[
    SupervisedTuningDatasetDistribution, SupervisedTuningDatasetDistributionDict
]


class SupervisedTuningDataStats(_common.BaseModel):
  

  dropped_example_reasons: Optional[list[str]] = Field(
      default=None,
      description=,
  )
  total_billable_character_count: Optional[int] = Field(
      default=None,
      description=,
  )
  total_billable_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  total_truncated_example_count: Optional[int] = Field(
      default=None,
      description=,
  )
  total_tuning_character_count: Optional[int] = Field(
      default=None,
      description=,
  )
  truncated_example_indices: Optional[list[int]] = Field(
      default=None,
      description=,
  )
  tuning_dataset_example_count: Optional[int] = Field(
      default=None,
      description=,
  )
  tuning_step_count: Optional[int] = Field(
      default=None,
      description=,
  )
  user_dataset_examples: Optional[list[Content]] = Field(
      default=None,
      description=,
  )
  user_input_token_distribution: Optional[
      SupervisedTuningDatasetDistribution
  ] = Field(
      default=None,
      description=,
  )
  user_message_per_example_distribution: Optional[
      SupervisedTuningDatasetDistribution
  ] = Field(
      default=None,
      description=,
  )
  user_output_token_distribution: Optional[
      SupervisedTuningDatasetDistribution
  ] = Field(
      default=None,
      description=,
  )


class SupervisedTuningDataStatsDict(TypedDict, total=False):
  

  dropped_example_reasons: Optional[list[str]]
  

  total_billable_character_count: Optional[int]
  

  total_billable_token_count: Optional[int]
  

  total_truncated_example_count: Optional[int]
  

  total_tuning_character_count: Optional[int]
  

  truncated_example_indices: Optional[list[int]]
  

  tuning_dataset_example_count: Optional[int]
  

  tuning_step_count: Optional[int]
  

  user_dataset_examples: Optional[list[ContentDict]]
  

  user_input_token_distribution: Optional[
      SupervisedTuningDatasetDistributionDict
  ]
  

  user_message_per_example_distribution: Optional[
      SupervisedTuningDatasetDistributionDict
  ]
  

  user_output_token_distribution: Optional[
      SupervisedTuningDatasetDistributionDict
  ]
  


SupervisedTuningDataStatsOrDict = Union[
    SupervisedTuningDataStats, SupervisedTuningDataStatsDict
]


class TuningDataStats(_common.BaseModel):
  

  distillation_data_stats: Optional[DistillationDataStats] = Field(
      default=None, description=
  )
  supervised_tuning_data_stats: Optional[SupervisedTuningDataStats] = Field(
      default=None, description=
  )


class TuningDataStatsDict(TypedDict, total=False):
  

  distillation_data_stats: Optional[DistillationDataStatsDict]
  

  supervised_tuning_data_stats: Optional[SupervisedTuningDataStatsDict]
  


TuningDataStatsOrDict = Union[TuningDataStats, TuningDataStatsDict]


class EncryptionSpec(_common.BaseModel):
  

  kms_key_name: Optional[str] = Field(
      default=None,
      description=,
  )


class EncryptionSpecDict(TypedDict, total=False):
  

  kms_key_name: Optional[str]
  


EncryptionSpecOrDict = Union[EncryptionSpec, EncryptionSpecDict]


class PartnerModelTuningSpec(_common.BaseModel):
  

  hyper_parameters: Optional[dict[str, Any]] = Field(
      default=None,
      description=,
  )
  training_dataset_uri: Optional[str] = Field(
      default=None,
      description=,
  )
  validation_dataset_uri: Optional[str] = Field(
      default=None,
      description=,
  )


class PartnerModelTuningSpecDict(TypedDict, total=False):
  

  hyper_parameters: Optional[dict[str, Any]]
  

  training_dataset_uri: Optional[str]
  

  validation_dataset_uri: Optional[str]
  


PartnerModelTuningSpecOrDict = Union[
    PartnerModelTuningSpec, PartnerModelTuningSpecDict
]


class DistillationHyperParameters(_common.BaseModel):
  

  adapter_size: Optional[AdapterSize] = Field(
      default=None, description=
  )
  epoch_count: Optional[int] = Field(
      default=None,
      description=,
  )
  learning_rate_multiplier: Optional[float] = Field(
      default=None,
      description=,
  )


class DistillationHyperParametersDict(TypedDict, total=False):
  

  adapter_size: Optional[AdapterSize]
  

  epoch_count: Optional[int]
  

  learning_rate_multiplier: Optional[float]
  


DistillationHyperParametersOrDict = Union[
    DistillationHyperParameters, DistillationHyperParametersDict
]


class DistillationSpec(_common.BaseModel):
  

  base_teacher_model: Optional[str] = Field(
      default=None,
      description=Optional. Hyperparameters for Distillation.Deprecated. A path in a Cloud Storage bucket, which will be treated as the root output directory of the distillation pipeline. It is used by the system to generate the paths of output artifacts.The student model that is being tuned, e.g., "google/gemma-2b-1.1-it". Deprecated. Use base_model instead.Deprecated. Cloud Storage path to file containing training dataset for tuning. The dataset must be formatted as a JSONL file.The resource name of the Tuned teacher model. Format: `projects/{project}/locations/{location}/models/{model}`.Optional. Cloud Storage path to file containing validation dataset for tuning. The dataset must be formatted as a JSONL file.Tuning Spec for Distillation.The base teacher model that is being distilled. See [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/tuning

  hyper_parameters: Optional[DistillationHyperParametersDict]
  

  pipeline_root_directory: Optional[str]
  

  student_model: Optional[str]
  

  training_dataset_uri: Optional[str]
  

  tuned_teacher_model_source: Optional[str]
  

  validation_dataset_uri: Optional[str]
  


DistillationSpecOrDict = Union[DistillationSpec, DistillationSpecDict]


class TuningJob(_common.BaseModel):
  

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  name: Optional[str] = Field(
      default=None,
      description=,
  )
  state: Optional[JobState] = Field(
      default=None,
      description=,
  )
  create_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  start_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  end_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  update_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  error: Optional[GoogleRpcStatus] = Field(
      default=None,
      description=,
  )
  description: Optional[str] = Field(
      default=None,
      description=,
  )
  base_model: Optional[str] = Field(
      default=None,
      description=Output only. The tuned model resources associated with this TuningJob.Tuning Spec for Supervised Fine Tuning.Output only. The tuning data statistics associated with this TuningJob.Customer-managed encryption key options for a TuningJob. If this is set, then all resources created by the TuningJob will be encrypted with the provided encryption key.Tuning Spec for open sourced and third party Partner models.Tuning Spec for Distillation.Output only. The Experiment associated with this TuningJob.Optional. The labels with user-defined metadata to organize TuningJob and generated resources such as Model and Endpoint. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.Output only. The resource name of the PipelineJob associated with the TuningJob. Format: `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`.Output only. Reserved for future use.Output only. Reserved for future use.The service account that the tuningJob workload runs as. If not specified, the Vertex AI Secure Fine-Tuned Service Agent in the project will be used. See https://cloud.google.com/iam/docs/service-agents
  )
  tuned_model_display_name: Optional[str] = Field(
      default=None,
      description=,
  )

  @property
  def has_ended(self) -> bool:
    
    return self.state in JOB_STATES_ENDED

  @property
  def has_succeeded(self) -> bool:
    
    return self.state in JOB_STATES_SUCCEEDED


class TuningJobDict(TypedDict, total=False):
  

  sdk_http_response: Optional[HttpResponseDict]
  

  name: Optional[str]
  

  state: Optional[JobState]
  

  create_time: Optional[datetime.datetime]
  

  start_time: Optional[datetime.datetime]
  

  end_time: Optional[datetime.datetime]
  

  update_time: Optional[datetime.datetime]
  

  error: Optional[GoogleRpcStatusDict]
  

  description: Optional[str]
  

  base_model: Optional[str]
  Output only. The tuned model resources associated with this TuningJob.Tuning Spec for Supervised Fine Tuning.Output only. The tuning data statistics associated with this TuningJob.Customer-managed encryption key options for a TuningJob. If this is set, then all resources created by the TuningJob will be encrypted with the provided encryption key.Tuning Spec for open sourced and third party Partner models.Tuning Spec for Distillation.Output only. The Experiment associated with this TuningJob.Optional. The labels with user-defined metadata to organize TuningJob and generated resources such as Model and Endpoint. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.Output only. The resource name of the PipelineJob associated with the TuningJob. Format: `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`.Output only. Reserved for future use.Output only. Reserved for future use.The service account that the tuningJob workload runs as. If not specified, the Vertex AI Secure Fine-Tuned Service Agent in the project will be used. See https://cloud.google.com/iam/docs/service-agents

  tuned_model_display_name: Optional[str]
  


TuningJobOrDict = Union[TuningJob, TuningJobDict]


class ListTuningJobsConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  page_size: Optional[int] = Field(default=None, description=)
  page_token: Optional[str] = Field(default=None, description=)
  filter: Optional[str] = Field(default=None, description=)


class ListTuningJobsConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  page_size: Optional[int]
  

  page_token: Optional[str]
  

  filter: Optional[str]
  


ListTuningJobsConfigOrDict = Union[
    ListTuningJobsConfig, ListTuningJobsConfigDict
]


class _ListTuningJobsParameters(_common.BaseModel):
  

  config: Optional[ListTuningJobsConfig] = Field(
      default=None, description=
  )


class _ListTuningJobsParametersDict(TypedDict, total=False):
  

  config: Optional[ListTuningJobsConfigDict]
  


_ListTuningJobsParametersOrDict = Union[
    _ListTuningJobsParameters, _ListTuningJobsParametersDict
]


class ListTuningJobsResponse(_common.BaseModel):
  

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  next_page_token: Optional[str] = Field(
      default=None,
      description=,
  )
  tuning_jobs: Optional[list[TuningJob]] = Field(
      default=None, description=
  )


class ListTuningJobsResponseDict(TypedDict, total=False):
  

  sdk_http_response: Optional[HttpResponseDict]
  

  next_page_token: Optional[str]
  

  tuning_jobs: Optional[list[TuningJobDict]]
  


ListTuningJobsResponseOrDict = Union[
    ListTuningJobsResponse, ListTuningJobsResponseDict
]


class TuningExample(_common.BaseModel):

  text_input: Optional[str] = Field(
      default=None, description=
  )
  output: Optional[str] = Field(
      default=None, description=
  )


class TuningExampleDict(TypedDict, total=False):

  text_input: Optional[str]
  

  output: Optional[str]
  


TuningExampleOrDict = Union[TuningExample, TuningExampleDict]


class TuningDataset(_common.BaseModel):
  

  gcs_uri: Optional[str] = Field(
      default=None,
      description=,
  )
  vertex_dataset_resource: Optional[str] = Field(
      default=None,
      description=,
  )
  examples: Optional[list[TuningExample]] = Field(
      default=None,
      description=,
  )


class TuningDatasetDict(TypedDict, total=False):
  

  gcs_uri: Optional[str]
  

  vertex_dataset_resource: Optional[str]
  

  examples: Optional[list[TuningExampleDict]]
  


TuningDatasetOrDict = Union[TuningDataset, TuningDatasetDict]


class TuningValidationDataset(_common.BaseModel):

  gcs_uri: Optional[str] = Field(
      default=None,
      description=,
  )
  vertex_dataset_resource: Optional[str] = Field(
      default=None,
      description=,
  )


class TuningValidationDatasetDict(TypedDict, total=False):

  gcs_uri: Optional[str]
  

  vertex_dataset_resource: Optional[str]
  


TuningValidationDatasetOrDict = Union[
    TuningValidationDataset, TuningValidationDatasetDict
]


class CreateTuningJobConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  validation_dataset: Optional[TuningValidationDataset] = Field(
      default=None,
      description=,
  )
  tuned_model_display_name: Optional[str] = Field(
      default=None,
      description=,
  )
  description: Optional[str] = Field(
      default=None, description=
  )
  epoch_count: Optional[int] = Field(
      default=None,
      description=,
  )
  learning_rate_multiplier: Optional[float] = Field(
      default=None,
      description=,
  )
  export_last_checkpoint_only: Optional[bool] = Field(
      default=None,
      description=,
  )
  adapter_size: Optional[AdapterSize] = Field(
      default=None, description=
  )
  batch_size: Optional[int] = Field(
      default=None,
      description=,
  )
  learning_rate: Optional[float] = Field(
      default=None,
      description=,
  )


class CreateTuningJobConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  validation_dataset: Optional[TuningValidationDatasetDict]
  

  tuned_model_display_name: Optional[str]
  

  description: Optional[str]
  

  epoch_count: Optional[int]
  

  learning_rate_multiplier: Optional[float]
  

  export_last_checkpoint_only: Optional[bool]
  

  adapter_size: Optional[AdapterSize]
  

  batch_size: Optional[int]
  

  learning_rate: Optional[float]
  


CreateTuningJobConfigOrDict = Union[
    CreateTuningJobConfig, CreateTuningJobConfigDict
]


class _CreateTuningJobParameters(_common.BaseModel):
  

  base_model: Optional[str] = Field(
      default=None,
      description=,
  )
  training_dataset: Optional[TuningDataset] = Field(
      default=None,
      description=,
  )
  config: Optional[CreateTuningJobConfig] = Field(
      default=None, description=
  )


class _CreateTuningJobParametersDict(TypedDict, total=False):
  

  base_model: Optional[str]
  

  training_dataset: Optional[TuningDatasetDict]
  

  config: Optional[CreateTuningJobConfigDict]
  


_CreateTuningJobParametersOrDict = Union[
    _CreateTuningJobParameters, _CreateTuningJobParametersDict
]


class TuningOperation(_common.BaseModel):
  

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  name: Optional[str] = Field(
      default=None,
      description=,
  )
  metadata: Optional[dict[str, Any]] = Field(
      default=None,
      description=,
  )
  done: Optional[bool] = Field(
      default=None,
      description=,
  )
  error: Optional[dict[str, Any]] = Field(
      default=None,
      description=,
  )


class TuningOperationDict(TypedDict, total=False):
  

  sdk_http_response: Optional[HttpResponseDict]
  

  name: Optional[str]
  

  metadata: Optional[dict[str, Any]]
  

  done: Optional[bool]
  

  error: Optional[dict[str, Any]]
  


TuningOperationOrDict = Union[TuningOperation, TuningOperationDict]


class CreateCachedContentConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  ttl: Optional[str] = Field(
      default=None,
      description=,
  )
  expire_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  display_name: Optional[str] = Field(
      default=None,
      description=,
  )
  contents: Optional[ContentListUnion] = Field(
      default=None,
      description=,
  )
  system_instruction: Optional[ContentUnion] = Field(
      default=None,
      description=,
  )
  tools: Optional[list[Tool]] = Field(
      default=None,
      description=,
  )
  tool_config: Optional[ToolConfig] = Field(
      default=None,
      description=,
  )
  kms_key_name: Optional[str] = Field(
      default=None,
      description=,
  )


class CreateCachedContentConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  ttl: Optional[str]
  

  expire_time: Optional[datetime.datetime]
  

  display_name: Optional[str]
  

  contents: Optional[ContentListUnionDict]
  

  system_instruction: Optional[ContentUnionDict]
  

  tools: Optional[list[ToolDict]]
  

  tool_config: Optional[ToolConfigDict]
  

  kms_key_name: Optional[str]
  


CreateCachedContentConfigOrDict = Union[
    CreateCachedContentConfig, CreateCachedContentConfigDict
]


class _CreateCachedContentParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[CreateCachedContentConfig] = Field(
      default=None,
      description=,
  )


class _CreateCachedContentParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  config: Optional[CreateCachedContentConfigDict]
  


_CreateCachedContentParametersOrDict = Union[
    _CreateCachedContentParameters, _CreateCachedContentParametersDict
]


class CachedContentUsageMetadata(_common.BaseModel):
  

  audio_duration_seconds: Optional[int] = Field(
      default=None, description=
  )
  image_count: Optional[int] = Field(
      default=None, description=
  )
  text_count: Optional[int] = Field(
      default=None, description=
  )
  total_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  video_duration_seconds: Optional[int] = Field(
      default=None, description=
  )


class CachedContentUsageMetadataDict(TypedDict, total=False):
  

  audio_duration_seconds: Optional[int]
  

  image_count: Optional[int]
  

  text_count: Optional[int]
  

  total_token_count: Optional[int]
  

  video_duration_seconds: Optional[int]
  


CachedContentUsageMetadataOrDict = Union[
    CachedContentUsageMetadata, CachedContentUsageMetadataDict
]


class CachedContent(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  display_name: Optional[str] = Field(
      default=None,
      description=,
  )
  model: Optional[str] = Field(
      default=None,
      description=,
  )
  create_time: Optional[datetime.datetime] = Field(
      default=None, description=
  )
  update_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  expire_time: Optional[datetime.datetime] = Field(
      default=None, description=
  )
  usage_metadata: Optional[CachedContentUsageMetadata] = Field(
      default=None,
      description=,
  )


class CachedContentDict(TypedDict, total=False):
  

  name: Optional[str]
  

  display_name: Optional[str]
  

  model: Optional[str]
  

  create_time: Optional[datetime.datetime]
  

  update_time: Optional[datetime.datetime]
  

  expire_time: Optional[datetime.datetime]
  

  usage_metadata: Optional[CachedContentUsageMetadataDict]
  


CachedContentOrDict = Union[CachedContent, CachedContentDict]


class GetCachedContentConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class GetCachedContentConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  


GetCachedContentConfigOrDict = Union[
    GetCachedContentConfig, GetCachedContentConfigDict
]


class _GetCachedContentParameters(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[GetCachedContentConfig] = Field(
      default=None,
      description=,
  )


class _GetCachedContentParametersDict(TypedDict, total=False):
  

  name: Optional[str]
  

  config: Optional[GetCachedContentConfigDict]
  


_GetCachedContentParametersOrDict = Union[
    _GetCachedContentParameters, _GetCachedContentParametersDict
]


class DeleteCachedContentConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class DeleteCachedContentConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  


DeleteCachedContentConfigOrDict = Union[
    DeleteCachedContentConfig, DeleteCachedContentConfigDict
]


class _DeleteCachedContentParameters(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[DeleteCachedContentConfig] = Field(
      default=None,
      description=,
  )


class _DeleteCachedContentParametersDict(TypedDict, total=False):
  

  name: Optional[str]
  

  config: Optional[DeleteCachedContentConfigDict]
  


_DeleteCachedContentParametersOrDict = Union[
    _DeleteCachedContentParameters, _DeleteCachedContentParametersDict
]


class DeleteCachedContentResponse(_common.BaseModel):
  

  pass


class DeleteCachedContentResponseDict(TypedDict, total=False):
  

  pass


DeleteCachedContentResponseOrDict = Union[
    DeleteCachedContentResponse, DeleteCachedContentResponseDict
]


class UpdateCachedContentConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  ttl: Optional[str] = Field(
      default=None,
      description=,
  )
  expire_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )


class UpdateCachedContentConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  ttl: Optional[str]
  

  expire_time: Optional[datetime.datetime]
  


UpdateCachedContentConfigOrDict = Union[
    UpdateCachedContentConfig, UpdateCachedContentConfigDict
]


class _UpdateCachedContentParameters(_common.BaseModel):

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[UpdateCachedContentConfig] = Field(
      default=None,
      description=,
  )


class _UpdateCachedContentParametersDict(TypedDict, total=False):

  name: Optional[str]
  

  config: Optional[UpdateCachedContentConfigDict]
  


_UpdateCachedContentParametersOrDict = Union[
    _UpdateCachedContentParameters, _UpdateCachedContentParametersDict
]


class ListCachedContentsConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  page_size: Optional[int] = Field(default=None, description=)
  page_token: Optional[str] = Field(default=None, description=)


class ListCachedContentsConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  page_size: Optional[int]
  

  page_token: Optional[str]
  


ListCachedContentsConfigOrDict = Union[
    ListCachedContentsConfig, ListCachedContentsConfigDict
]


class _ListCachedContentsParameters(_common.BaseModel):
  

  config: Optional[ListCachedContentsConfig] = Field(
      default=None,
      description=,
  )


class _ListCachedContentsParametersDict(TypedDict, total=False):
  

  config: Optional[ListCachedContentsConfigDict]
  


_ListCachedContentsParametersOrDict = Union[
    _ListCachedContentsParameters, _ListCachedContentsParametersDict
]


class ListCachedContentsResponse(_common.BaseModel):

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  next_page_token: Optional[str] = Field(default=None, description=)
  cached_contents: Optional[list[CachedContent]] = Field(
      default=None,
      description=,
  )


class ListCachedContentsResponseDict(TypedDict, total=False):

  sdk_http_response: Optional[HttpResponseDict]
  

  next_page_token: Optional[str]
  

  cached_contents: Optional[list[CachedContentDict]]
  


ListCachedContentsResponseOrDict = Union[
    ListCachedContentsResponse, ListCachedContentsResponseDict
]


class ListFilesConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  page_size: Optional[int] = Field(default=None, description=)
  page_token: Optional[str] = Field(default=None, description=)


class ListFilesConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  page_size: Optional[int]
  

  page_token: Optional[str]
  


ListFilesConfigOrDict = Union[ListFilesConfig, ListFilesConfigDict]


class _ListFilesParameters(_common.BaseModel):
  

  config: Optional[ListFilesConfig] = Field(
      default=None,
      description=,
  )


class _ListFilesParametersDict(TypedDict, total=False):
  

  config: Optional[ListFilesConfigDict]
  


_ListFilesParametersOrDict = Union[
    _ListFilesParameters, _ListFilesParametersDict
]


class ListFilesResponse(_common.BaseModel):
  

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  next_page_token: Optional[str] = Field(
      default=None, description=
  )
  files: Optional[list[File]] = Field(
      default=None, description=
  )


class ListFilesResponseDict(TypedDict, total=False):
  

  sdk_http_response: Optional[HttpResponseDict]
  

  next_page_token: Optional[str]
  

  files: Optional[list[FileDict]]
  


ListFilesResponseOrDict = Union[ListFilesResponse, ListFilesResponseDict]


class CreateFileConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  should_return_http_response: Optional[bool] = Field(
      default=None,
      description=,
  )


class CreateFileConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  should_return_http_response: Optional[bool]
  


CreateFileConfigOrDict = Union[CreateFileConfig, CreateFileConfigDict]


class _CreateFileParameters(_common.BaseModel):
  

  file: Optional[File] = Field(
      default=None,
      description=,
  )
  config: Optional[CreateFileConfig] = Field(
      default=None,
      description=,
  )


class _CreateFileParametersDict(TypedDict, total=False):
  

  file: Optional[FileDict]
  

  config: Optional[CreateFileConfigDict]
  


_CreateFileParametersOrDict = Union[
    _CreateFileParameters, _CreateFileParametersDict
]


class CreateFileResponse(_common.BaseModel):
  

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )


class CreateFileResponseDict(TypedDict, total=False):
  

  sdk_http_response: Optional[HttpResponseDict]
  


CreateFileResponseOrDict = Union[CreateFileResponse, CreateFileResponseDict]


class GetFileConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class GetFileConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  


GetFileConfigOrDict = Union[GetFileConfig, GetFileConfigDict]


class _GetFileParameters(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[GetFileConfig] = Field(
      default=None,
      description=,
  )


class _GetFileParametersDict(TypedDict, total=False):
  

  name: Optional[str]
  

  config: Optional[GetFileConfigDict]
  


_GetFileParametersOrDict = Union[_GetFileParameters, _GetFileParametersDict]


class DeleteFileConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class DeleteFileConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  


DeleteFileConfigOrDict = Union[DeleteFileConfig, DeleteFileConfigDict]


class _DeleteFileParameters(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[DeleteFileConfig] = Field(
      default=None,
      description=,
  )


class _DeleteFileParametersDict(TypedDict, total=False):
  

  name: Optional[str]
  

  config: Optional[DeleteFileConfigDict]
  


_DeleteFileParametersOrDict = Union[
    _DeleteFileParameters, _DeleteFileParametersDict
]


class DeleteFileResponse(_common.BaseModel):
  

  pass


class DeleteFileResponseDict(TypedDict, total=False):
  

  pass


DeleteFileResponseOrDict = Union[DeleteFileResponse, DeleteFileResponseDict]


class InlinedRequest(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  contents: Optional[ContentListUnion] = Field(
      default=None,
      description=,
  )
  config: Optional[GenerateContentConfig] = Field(
      default=None,
      description=,
  )


class InlinedRequestDict(TypedDict, total=False):
  

  model: Optional[str]
  

  contents: Optional[ContentListUnionDict]
  

  config: Optional[GenerateContentConfigDict]
  


InlinedRequestOrDict = Union[InlinedRequest, InlinedRequestDict]


class BatchJobSource(_common.BaseModel):
  

  format: Optional[str] = Field(
      default=None,
      description=,
  )
  gcs_uri: Optional[list[str]] = Field(
      default=None,
      description=,
  )
  bigquery_uri: Optional[str] = Field(
      default=None,
      description=,
  )
  file_name: Optional[str] = Field(
      default=None,
      description=,
  )
  inlined_requests: Optional[list[InlinedRequest]] = Field(
      default=None,
      description=,
  )


class BatchJobSourceDict(TypedDict, total=False):
  

  format: Optional[str]
  

  gcs_uri: Optional[list[str]]
  

  bigquery_uri: Optional[str]
  

  file_name: Optional[str]
  

  inlined_requests: Optional[list[InlinedRequestDict]]
  


BatchJobSourceOrDict = Union[BatchJobSource, BatchJobSourceDict]


class JobError(_common.BaseModel):
  

  details: Optional[list[str]] = Field(
      default=None,
      description=,
  )
  code: Optional[int] = Field(default=None, description=)
  message: Optional[str] = Field(
      default=None,
      description=,
  )


class JobErrorDict(TypedDict, total=False):
  

  details: Optional[list[str]]
  

  code: Optional[int]
  

  message: Optional[str]
  


JobErrorOrDict = Union[JobError, JobErrorDict]


class InlinedResponse(_common.BaseModel):
  

  response: Optional[GenerateContentResponse] = Field(
      default=None,
      description=,
  )
  error: Optional[JobError] = Field(
      default=None,
      description=,
  )


class InlinedResponseDict(TypedDict, total=False):
  

  response: Optional[GenerateContentResponseDict]
  

  error: Optional[JobErrorDict]
  


InlinedResponseOrDict = Union[InlinedResponse, InlinedResponseDict]


class BatchJobDestination(_common.BaseModel):
  

  format: Optional[str] = Field(
      default=None,
      description=,
  )
  gcs_uri: Optional[str] = Field(
      default=None,
      description=,
  )
  bigquery_uri: Optional[str] = Field(
      default=None,
      description=,
  )
  file_name: Optional[str] = Field(
      default=None,
      description=,
  )
  inlined_responses: Optional[list[InlinedResponse]] = Field(
      default=None,
      description=,
  )


class BatchJobDestinationDict(TypedDict, total=False):
  

  format: Optional[str]
  

  gcs_uri: Optional[str]
  

  bigquery_uri: Optional[str]
  

  file_name: Optional[str]
  

  inlined_responses: Optional[list[InlinedResponseDict]]
  


BatchJobDestinationOrDict = Union[BatchJobDestination, BatchJobDestinationDict]


BatchJobDestinationUnion = Union[BatchJobDestination, str]


BatchJobDestinationUnionDict = Union[
    BatchJobDestinationUnion, BatchJobDestinationDict
]


class CreateBatchJobConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  display_name: Optional[str] = Field(
      default=None,
      description=,
  )
  dest: Optional[BatchJobDestinationUnion] = Field(
      default=None,
      description=,
  )


class CreateBatchJobConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  display_name: Optional[str]
  

  dest: Optional[BatchJobDestinationUnionDict]
  


CreateBatchJobConfigOrDict = Union[
    CreateBatchJobConfig, CreateBatchJobConfigDict
]


BatchJobSourceUnion = Union[BatchJobSource, list[InlinedRequest], str]


BatchJobSourceUnionDict = Union[
    BatchJobSourceUnion, BatchJobSourceDict, list[InlinedRequestDict]
]


class _CreateBatchJobParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  src: Optional[BatchJobSourceUnion] = Field(
      default=None,
      description=,
  )
  config: Optional[CreateBatchJobConfig] = Field(
      default=None,
      description=,
  )


class _CreateBatchJobParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  src: Optional[BatchJobSourceUnionDict]
  

  config: Optional[CreateBatchJobConfigDict]
  


_CreateBatchJobParametersOrDict = Union[
    _CreateBatchJobParameters, _CreateBatchJobParametersDict
]


class BatchJob(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  display_name: Optional[str] = Field(
      default=None,
      description=,
  )
  state: Optional[JobState] = Field(
      default=None,
      description=,
  )
  error: Optional[JobError] = Field(
      default=None,
      description=,
  )
  create_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  start_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  end_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  update_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  model: Optional[str] = Field(
      default=None,
      description=,
  )
  src: Optional[BatchJobSource] = Field(
      default=None,
      description=,
  )
  dest: Optional[BatchJobDestination] = Field(
      default=None,
      description=,
  )


class BatchJobDict(TypedDict, total=False):
  

  name: Optional[str]
  

  display_name: Optional[str]
  

  state: Optional[JobState]
  

  error: Optional[JobErrorDict]
  

  create_time: Optional[datetime.datetime]
  

  start_time: Optional[datetime.datetime]
  

  end_time: Optional[datetime.datetime]
  

  update_time: Optional[datetime.datetime]
  

  model: Optional[str]
  

  src: Optional[BatchJobSourceDict]
  

  dest: Optional[BatchJobDestinationDict]
  


BatchJobOrDict = Union[BatchJob, BatchJobDict]


class GetBatchJobConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class GetBatchJobConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  


GetBatchJobConfigOrDict = Union[GetBatchJobConfig, GetBatchJobConfigDict]


class _GetBatchJobParameters(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[GetBatchJobConfig] = Field(
      default=None, description=
  )


class _GetBatchJobParametersDict(TypedDict, total=False):
  

  name: Optional[str]
  

  config: Optional[GetBatchJobConfigDict]
  


_GetBatchJobParametersOrDict = Union[
    _GetBatchJobParameters, _GetBatchJobParametersDict
]


class CancelBatchJobConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class CancelBatchJobConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  


CancelBatchJobConfigOrDict = Union[
    CancelBatchJobConfig, CancelBatchJobConfigDict
]


class _CancelBatchJobParameters(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[CancelBatchJobConfig] = Field(
      default=None, description=
  )


class _CancelBatchJobParametersDict(TypedDict, total=False):
  

  name: Optional[str]
  

  config: Optional[CancelBatchJobConfigDict]
  


_CancelBatchJobParametersOrDict = Union[
    _CancelBatchJobParameters, _CancelBatchJobParametersDict
]


class ListBatchJobsConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  page_size: Optional[int] = Field(default=None, description=)
  page_token: Optional[str] = Field(default=None, description=)
  filter: Optional[str] = Field(default=None, description=)


class ListBatchJobsConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  page_size: Optional[int]
  

  page_token: Optional[str]
  

  filter: Optional[str]
  


ListBatchJobsConfigOrDict = Union[ListBatchJobsConfig, ListBatchJobsConfigDict]


class _ListBatchJobsParameters(_common.BaseModel):
  

  config: Optional[ListBatchJobsConfig] = Field(
      default=None, description=
  )


class _ListBatchJobsParametersDict(TypedDict, total=False):
  

  config: Optional[ListBatchJobsConfigDict]
  


_ListBatchJobsParametersOrDict = Union[
    _ListBatchJobsParameters, _ListBatchJobsParametersDict
]


class ListBatchJobsResponse(_common.BaseModel):
  

  sdk_http_response: Optional[HttpResponse] = Field(
      default=None, description=
  )
  next_page_token: Optional[str] = Field(default=None, description=)
  batch_jobs: Optional[list[BatchJob]] = Field(default=None, description=)


class ListBatchJobsResponseDict(TypedDict, total=False):
  

  sdk_http_response: Optional[HttpResponseDict]
  

  next_page_token: Optional[str]
  

  batch_jobs: Optional[list[BatchJobDict]]
  


ListBatchJobsResponseOrDict = Union[
    ListBatchJobsResponse, ListBatchJobsResponseDict
]


class DeleteBatchJobConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class DeleteBatchJobConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  


DeleteBatchJobConfigOrDict = Union[
    DeleteBatchJobConfig, DeleteBatchJobConfigDict
]


class _DeleteBatchJobParameters(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[DeleteBatchJobConfig] = Field(
      default=None, description=
  )


class _DeleteBatchJobParametersDict(TypedDict, total=False):
  

  name: Optional[str]
  

  config: Optional[DeleteBatchJobConfigDict]
  


_DeleteBatchJobParametersOrDict = Union[
    _DeleteBatchJobParameters, _DeleteBatchJobParametersDict
]


class DeleteResourceJob(_common.BaseModel):
  

  name: Optional[str] = Field(default=None, description=)
  done: Optional[bool] = Field(default=None, description=)
  error: Optional[JobError] = Field(default=None, description=)


class DeleteResourceJobDict(TypedDict, total=False):
  

  name: Optional[str]
  

  done: Optional[bool]
  

  error: Optional[JobErrorDict]
  


DeleteResourceJobOrDict = Union[DeleteResourceJob, DeleteResourceJobDict]


class GetOperationConfig(_common.BaseModel):

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class GetOperationConfigDict(TypedDict, total=False):

  http_options: Optional[HttpOptionsDict]
  


GetOperationConfigOrDict = Union[GetOperationConfig, GetOperationConfigDict]


class _GetOperationParameters(_common.BaseModel):
  

  operation_name: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[GetOperationConfig] = Field(
      default=None,
      description=,
  )


class _GetOperationParametersDict(TypedDict, total=False):
  

  operation_name: Optional[str]
  

  config: Optional[GetOperationConfigDict]
  


_GetOperationParametersOrDict = Union[
    _GetOperationParameters, _GetOperationParametersDict
]


class FetchPredictOperationConfig(_common.BaseModel):

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class FetchPredictOperationConfigDict(TypedDict, total=False):

  http_options: Optional[HttpOptionsDict]
  


FetchPredictOperationConfigOrDict = Union[
    FetchPredictOperationConfig, FetchPredictOperationConfigDict
]


class _FetchPredictOperationParameters(_common.BaseModel):
  

  operation_name: Optional[str] = Field(
      default=None,
      description=,
  )
  resource_name: Optional[str] = Field(default=None, description=)
  config: Optional[FetchPredictOperationConfig] = Field(
      default=None,
      description=,
  )


class _FetchPredictOperationParametersDict(TypedDict, total=False):
  

  operation_name: Optional[str]
  

  resource_name: Optional[str]
  

  config: Optional[FetchPredictOperationConfigDict]
  


_FetchPredictOperationParametersOrDict = Union[
    _FetchPredictOperationParameters, _FetchPredictOperationParametersDict
]


class TestTableItem(_common.BaseModel):

  name: Optional[str] = Field(
      default=None,
      description=,
  )
  parameters: Optional[dict[str, Any]] = Field(
      default=None,
      description=,
  )
  exception_if_mldev: Optional[str] = Field(
      default=None,
      description=,
  )
  exception_if_vertex: Optional[str] = Field(
      default=None,
      description=,
  )
  override_replay_id: Optional[str] = Field(
      default=None,
      description=,
  )
  has_union: Optional[bool] = Field(
      default=None,
      description=,
  )
  skip_in_api_mode: Optional[str] = Field(
      default=None,
      description=,
  )
  ignore_keys: Optional[list[str]] = Field(
      default=None,
      description=,
  )


class TestTableItemDict(TypedDict, total=False):

  name: Optional[str]
  

  parameters: Optional[dict[str, Any]]
  

  exception_if_mldev: Optional[str]
  

  exception_if_vertex: Optional[str]
  

  override_replay_id: Optional[str]
  

  has_union: Optional[bool]
  

  skip_in_api_mode: Optional[str]
  

  ignore_keys: Optional[list[str]]
  


TestTableItemOrDict = Union[TestTableItem, TestTableItemDict]


class TestTableFile(_common.BaseModel):

  comment: Optional[str] = Field(default=None, description=)
  test_method: Optional[str] = Field(default=None, description=)
  parameter_names: Optional[list[str]] = Field(default=None, description=)
  test_table: Optional[list[TestTableItem]] = Field(
      default=None, description=
  )


class TestTableFileDict(TypedDict, total=False):

  comment: Optional[str]
  

  test_method: Optional[str]
  

  parameter_names: Optional[list[str]]
  

  test_table: Optional[list[TestTableItemDict]]
  


TestTableFileOrDict = Union[TestTableFile, TestTableFileDict]


class ReplayRequest(_common.BaseModel):
  

  method: Optional[str] = Field(default=None, description=)
  url: Optional[str] = Field(default=None, description=)
  headers: Optional[dict[str, str]] = Field(default=None, description=)
  body_segments: Optional[list[dict[str, Any]]] = Field(
      default=None, description=
  )


class ReplayRequestDict(TypedDict, total=False):
  

  method: Optional[str]
  

  url: Optional[str]
  

  headers: Optional[dict[str, str]]
  

  body_segments: Optional[list[dict[str, Any]]]
  


ReplayRequestOrDict = Union[ReplayRequest, ReplayRequestDict]


class ReplayResponse(_common.BaseModel):
  

  status_code: Optional[int] = Field(default=None, description=)
  headers: Optional[dict[str, str]] = Field(default=None, description=)
  body_segments: Optional[list[dict[str, Any]]] = Field(
      default=None, description=
  )
  sdk_response_segments: Optional[list[dict[str, Any]]] = Field(
      default=None, description=
  )


class ReplayResponseDict(TypedDict, total=False):
  

  status_code: Optional[int]
  

  headers: Optional[dict[str, str]]
  

  body_segments: Optional[list[dict[str, Any]]]
  

  sdk_response_segments: Optional[list[dict[str, Any]]]
  


ReplayResponseOrDict = Union[ReplayResponse, ReplayResponseDict]


class ReplayInteraction(_common.BaseModel):
  

  request: Optional[ReplayRequest] = Field(default=None, description=)
  response: Optional[ReplayResponse] = Field(default=None, description=)


class ReplayInteractionDict(TypedDict, total=False):
  

  request: Optional[ReplayRequestDict]
  

  response: Optional[ReplayResponseDict]
  


ReplayInteractionOrDict = Union[ReplayInteraction, ReplayInteractionDict]


class ReplayFile(_common.BaseModel):
  

  replay_id: Optional[str] = Field(default=None, description=)
  interactions: Optional[list[ReplayInteraction]] = Field(
      default=None, description=
  )


class ReplayFileDict(TypedDict, total=False):
  

  replay_id: Optional[str]
  

  interactions: Optional[list[ReplayInteractionDict]]
  


ReplayFileOrDict = Union[ReplayFile, ReplayFileDict]


class UploadFileConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  name: Optional[str] = Field(
      default=None,
      description=,
  )
  mime_type: Optional[str] = Field(
      default=None,
      description=,
  )
  display_name: Optional[str] = Field(
      default=None, description=
  )


class UploadFileConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  name: Optional[str]
  

  mime_type: Optional[str]
  

  display_name: Optional[str]
  


UploadFileConfigOrDict = Union[UploadFileConfig, UploadFileConfigDict]


class DownloadFileConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )


class DownloadFileConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  


DownloadFileConfigOrDict = Union[DownloadFileConfig, DownloadFileConfigDict]


class UpscaleImageConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  include_rai_reason: Optional[bool] = Field(
      default=None,
      description=,
  )
  output_mime_type: Optional[str] = Field(
      default=None,
      description=,
  )
  output_compression_quality: Optional[int] = Field(
      default=None,
      description=,
  )
  enhance_input_image: Optional[bool] = Field(
      default=None,
      description=,
  )
  image_preservation_factor: Optional[float] = Field(
      default=None,
      description=,
  )


class UpscaleImageConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  include_rai_reason: Optional[bool]
  

  output_mime_type: Optional[str]
  

  output_compression_quality: Optional[int]
  

  enhance_input_image: Optional[bool]
  

  image_preservation_factor: Optional[float]
  


UpscaleImageConfigOrDict = Union[UpscaleImageConfig, UpscaleImageConfigDict]


class UpscaleImageParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None, description=
  )
  image: Optional[Image] = Field(
      default=None, description=
  )
  upscale_factor: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[UpscaleImageConfig] = Field(
      default=None, description=
  )


class UpscaleImageParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  image: Optional[ImageDict]
  

  upscale_factor: Optional[str]
  

  config: Optional[UpscaleImageConfigDict]
  


UpscaleImageParametersOrDict = Union[
    UpscaleImageParameters, UpscaleImageParametersDict
]


class RawReferenceImage(_common.BaseModel):
  

  reference_image: Optional[Image] = Field(
      default=None,
      description=,
  )
  reference_id: Optional[int] = Field(
      default=None, description=
  )
  reference_type: Optional[str] = Field(
      default=None,
      description=,
  )

  @pydantic.model_validator(mode='before')
  @classmethod
  def _validate_mask_image_config(self, values: Any) -> Any:
    if 'reference_type' in values:
      raise ValueError('Cannot set internal reference_type field directly.')
    values['reference_type'] = 'REFERENCE_TYPE_RAW'
    return values


class RawReferenceImageDict(TypedDict, total=False):
  

  reference_image: Optional[ImageDict]
  

  reference_id: Optional[int]
  

  reference_type: Optional[str]
  


RawReferenceImageOrDict = Union[RawReferenceImage, RawReferenceImageDict]


class MaskReferenceImage(_common.BaseModel):
  

  reference_image: Optional[Image] = Field(
      default=None,
      description=,
  )
  reference_id: Optional[int] = Field(
      default=None, description=
  )
  reference_type: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[MaskReferenceConfig] = Field(
      default=None,
      description=,
  )
  
  mask_image_config: Optional['MaskReferenceConfig'] = Field(
      default=None, description=
  )

  @pydantic.model_validator(mode='before')
  @classmethod
  def _validate_mask_image_config(self, values: Any) -> Any:
    config = values.get('config', None)
    values['mask_image_config'] = config
    if 'reference_type' in values:
      raise ValueError('Cannot set internal reference_type field directly.')
    values['reference_type'] = 'REFERENCE_TYPE_MASK'
    return values


class MaskReferenceImageDict(TypedDict, total=False):
  

  reference_image: Optional[ImageDict]
  

  reference_id: Optional[int]
  

  reference_type: Optional[str]
  

  config: Optional[MaskReferenceConfigDict]
  


MaskReferenceImageOrDict = Union[MaskReferenceImage, MaskReferenceImageDict]


class ControlReferenceImage(_common.BaseModel):
  

  reference_image: Optional[Image] = Field(
      default=None,
      description=,
  )
  reference_id: Optional[int] = Field(
      default=None, description=
  )
  reference_type: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[ControlReferenceConfig] = Field(
      default=None,
      description=,
  )
  
  control_image_config: Optional['ControlReferenceConfig'] = Field(
      default=None, description=
  )

  @pydantic.model_validator(mode='before')
  @classmethod
  def _validate_mask_image_config(self, values: Any) -> Any:
    config = values.get('config', None)
    values['control_image_config'] = config
    if 'reference_type' in values:
      raise ValueError('Cannot set internal reference_type field directly.')
    values['reference_type'] = 'REFERENCE_TYPE_CONTROL'
    return values


class ControlReferenceImageDict(TypedDict, total=False):
  

  reference_image: Optional[ImageDict]
  

  reference_id: Optional[int]
  

  reference_type: Optional[str]
  

  config: Optional[ControlReferenceConfigDict]
  


ControlReferenceImageOrDict = Union[
    ControlReferenceImage, ControlReferenceImageDict
]


class StyleReferenceImage(_common.BaseModel):
  

  reference_image: Optional[Image] = Field(
      default=None,
      description=,
  )
  reference_id: Optional[int] = Field(
      default=None, description=
  )
  reference_type: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[StyleReferenceConfig] = Field(
      default=None,
      description=,
  )
  
  style_image_config: Optional['StyleReferenceConfig'] = Field(
      default=None, description=
  )

  @pydantic.model_validator(mode='before')
  @classmethod
  def _validate_mask_image_config(self, values: Any) -> Any:
    config = values.get('config', None)
    values['style_image_config'] = config
    if 'reference_type' in values:
      raise ValueError('Cannot set internal reference_type field directly.')
    values['reference_type'] = 'REFERENCE_TYPE_STYLE'
    return values


class StyleReferenceImageDict(TypedDict, total=False):
  

  reference_image: Optional[ImageDict]
  

  reference_id: Optional[int]
  

  reference_type: Optional[str]
  

  config: Optional[StyleReferenceConfigDict]
  


StyleReferenceImageOrDict = Union[StyleReferenceImage, StyleReferenceImageDict]


class SubjectReferenceImage(_common.BaseModel):
  

  reference_image: Optional[Image] = Field(
      default=None,
      description=,
  )
  reference_id: Optional[int] = Field(
      default=None, description=
  )
  reference_type: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[SubjectReferenceConfig] = Field(
      default=None,
      description=,
  )
  
  subject_image_config: Optional['SubjectReferenceConfig'] = Field(
      default=None, description=
  )

  @pydantic.model_validator(mode='before')
  @classmethod
  def _validate_mask_image_config(self, values: Any) -> Any:
    config = values.get('config', None)
    values['subject_image_config'] = config
    if 'reference_type' in values:
      raise ValueError('Cannot set internal reference_type field directly.')
    values['reference_type'] = 'REFERENCE_TYPE_SUBJECT'
    return values


class SubjectReferenceImageDict(TypedDict, total=False):
  

  reference_image: Optional[ImageDict]
  

  reference_id: Optional[int]
  

  reference_type: Optional[str]
  

  config: Optional[SubjectReferenceConfigDict]
  


SubjectReferenceImageOrDict = Union[
    SubjectReferenceImage, SubjectReferenceImageDict
]


class LiveServerSetupComplete(_common.BaseModel):
  

  session_id: Optional[str] = Field(
      default=None, description=
  )


class LiveServerSetupCompleteDict(TypedDict, total=False):
  

  session_id: Optional[str]
  


LiveServerSetupCompleteOrDict = Union[
    LiveServerSetupComplete, LiveServerSetupCompleteDict
]


class Transcription(_common.BaseModel):
  

  text: Optional[str] = Field(
      default=None,
      description=,
  )
  finished: Optional[bool] = Field(
      default=None,
      description=,
  )


class TranscriptionDict(TypedDict, total=False):
  

  text: Optional[str]
  

  finished: Optional[bool]
  


TranscriptionOrDict = Union[Transcription, TranscriptionDict]


class LiveServerContent(_common.BaseModel):
  

  model_turn: Optional[Content] = Field(
      default=None,
      description=,
  )
  turn_complete: Optional[bool] = Field(
      default=None,
      description=,
  )
  interrupted: Optional[bool] = Field(
      default=None,
      description=,
  )
  grounding_metadata: Optional[GroundingMetadata] = Field(
      default=None,
      description=,
  )
  generation_complete: Optional[bool] = Field(
      default=None,
      description=,
  )
  input_transcription: Optional[Transcription] = Field(
      default=None,
      description=,
  )
  output_transcription: Optional[Transcription] = Field(
      default=None,
      description=,
  )
  url_context_metadata: Optional[UrlContextMetadata] = Field(
      default=None,
      description=,
  )


class LiveServerContentDict(TypedDict, total=False):
  

  model_turn: Optional[ContentDict]
  

  turn_complete: Optional[bool]
  

  interrupted: Optional[bool]
  

  grounding_metadata: Optional[GroundingMetadataDict]
  

  generation_complete: Optional[bool]
  

  input_transcription: Optional[TranscriptionDict]
  

  output_transcription: Optional[TranscriptionDict]
  

  url_context_metadata: Optional[UrlContextMetadataDict]
  


LiveServerContentOrDict = Union[LiveServerContent, LiveServerContentDict]


class LiveServerToolCall(_common.BaseModel):
  

  function_calls: Optional[list[FunctionCall]] = Field(
      default=None, description=
  )


class LiveServerToolCallDict(TypedDict, total=False):
  

  function_calls: Optional[list[FunctionCallDict]]
  


LiveServerToolCallOrDict = Union[LiveServerToolCall, LiveServerToolCallDict]


class LiveServerToolCallCancellation(_common.BaseModel):
  

  ids: Optional[list[str]] = Field(
      default=None, description=
  )


class LiveServerToolCallCancellationDict(TypedDict, total=False):
  

  ids: Optional[list[str]]
  


LiveServerToolCallCancellationOrDict = Union[
    LiveServerToolCallCancellation, LiveServerToolCallCancellationDict
]


class UsageMetadata(_common.BaseModel):
  

  prompt_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  cached_content_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  response_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  tool_use_prompt_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  thoughts_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  total_token_count: Optional[int] = Field(
      default=None,
      description=,
  )
  prompt_tokens_details: Optional[list[ModalityTokenCount]] = Field(
      default=None,
      description=,
  )
  cache_tokens_details: Optional[list[ModalityTokenCount]] = Field(
      default=None,
      description=,
  )
  response_tokens_details: Optional[list[ModalityTokenCount]] = Field(
      default=None,
      description=,
  )
  tool_use_prompt_tokens_details: Optional[list[ModalityTokenCount]] = Field(
      default=None,
      description=,
  )
  traffic_type: Optional[TrafficType] = Field(
      default=None,
      description=,
  )


class UsageMetadataDict(TypedDict, total=False):
  

  prompt_token_count: Optional[int]
  

  cached_content_token_count: Optional[int]
  

  response_token_count: Optional[int]
  

  tool_use_prompt_token_count: Optional[int]
  

  thoughts_token_count: Optional[int]
  

  total_token_count: Optional[int]
  

  prompt_tokens_details: Optional[list[ModalityTokenCountDict]]
  

  cache_tokens_details: Optional[list[ModalityTokenCountDict]]
  

  response_tokens_details: Optional[list[ModalityTokenCountDict]]
  

  tool_use_prompt_tokens_details: Optional[list[ModalityTokenCountDict]]
  

  traffic_type: Optional[TrafficType]
  


UsageMetadataOrDict = Union[UsageMetadata, UsageMetadataDict]


class LiveServerGoAway(_common.BaseModel):
  

  time_left: Optional[str] = Field(
      default=None,
      description=,
  )


class LiveServerGoAwayDict(TypedDict, total=False):
  

  time_left: Optional[str]
  


LiveServerGoAwayOrDict = Union[LiveServerGoAway, LiveServerGoAwayDict]


class LiveServerSessionResumptionUpdate(_common.BaseModel):
  

  new_handle: Optional[str] = Field(
      default=None,
      description=,
  )
  resumable: Optional[bool] = Field(
      default=None,
      description=,
  )
  last_consumed_client_message_index: Optional[int] = Field(
      default=None,
      description=,
  )


class LiveServerSessionResumptionUpdateDict(TypedDict, total=False):
  

  new_handle: Optional[str]
  

  resumable: Optional[bool]
  

  last_consumed_client_message_index: Optional[int]
  


LiveServerSessionResumptionUpdateOrDict = Union[
    LiveServerSessionResumptionUpdate, LiveServerSessionResumptionUpdateDict
]


class LiveServerMessage(_common.BaseModel):
  

  setup_complete: Optional[LiveServerSetupComplete] = Field(
      default=None,
      description=,
  )
  server_content: Optional[LiveServerContent] = Field(
      default=None,
      description=,
  )
  tool_call: Optional[LiveServerToolCall] = Field(
      default=None,
      description=,
  )
  tool_call_cancellation: Optional[LiveServerToolCallCancellation] = Field(
      default=None,
      description=,
  )
  usage_metadata: Optional[UsageMetadata] = Field(
      default=None, description=
  )
  go_away: Optional[LiveServerGoAway] = Field(
      default=None, description=
  )
  session_resumption_update: Optional[LiveServerSessionResumptionUpdate] = (
      Field(
          default=None,
          description=,
      )
  )

  @property
  def text(self) -> Optional[str]:
    
    if (
        not self.server_content
        or not self.server_content
        or not self.server_content.model_turn
        or not self.server_content.model_turn.parts
    ):
      return None
    text = ''
    non_text_parts = []
    for part in self.server_content.model_turn.parts:
      for field_name, field_value in part.model_dump(
          exclude={'text', 'thought'}
      ).items():
        if field_value is not None:
          non_text_parts.append(field_name)
      if isinstance(part.text, str):
        if isinstance(part.thought, bool) and part.thought:
          continue
        text += part.text
    if non_text_parts:
      logger.warning(
          'Warning: there are non-text parts in the response:'
          f' {non_text_parts}, returning concatenated text result from text'
          ' parts, check out the non text parts for full response from model.'
      )
    return text if text else None

  @property
  def data(self) -> Optional[bytes]:
    
    if (
        not self.server_content
        or not self.server_content
        or not self.server_content.model_turn
        or not self.server_content.model_turn.parts
    ):
      return None
    concatenated_data = b''
    non_data_parts = []
    for part in self.server_content.model_turn.parts:
      for field_name, field_value in part.model_dump(
          exclude={'inline_data'}
      ).items():
        if field_value is not None:
          non_data_parts.append(field_name)
      if part.inline_data and isinstance(part.inline_data.data, bytes):
        concatenated_data += part.inline_data.data
    if non_data_parts:
      logger.warning(
          'Warning: there are non-data parts in the response:'
          f' {non_data_parts}, returning concatenated data result from data'
          ' parts, check out the non data parts for full response from model.'
      )
    return concatenated_data if len(concatenated_data) > 0 else None


class LiveServerMessageDict(TypedDict, total=False):
  

  setup_complete: Optional[LiveServerSetupCompleteDict]
  

  server_content: Optional[LiveServerContentDict]
  

  tool_call: Optional[LiveServerToolCallDict]
  

  tool_call_cancellation: Optional[LiveServerToolCallCancellationDict]
  

  usage_metadata: Optional[UsageMetadataDict]
  

  go_away: Optional[LiveServerGoAwayDict]
  

  session_resumption_update: Optional[LiveServerSessionResumptionUpdateDict]
  


LiveServerMessageOrDict = Union[LiveServerMessage, LiveServerMessageDict]


class AutomaticActivityDetection(_common.BaseModel):
  

  disabled: Optional[bool] = Field(
      default=None,
      description=,
  )
  start_of_speech_sensitivity: Optional[StartSensitivity] = Field(
      default=None,
      description=,
  )
  end_of_speech_sensitivity: Optional[EndSensitivity] = Field(
      default=None,
      description=,
  )
  prefix_padding_ms: Optional[int] = Field(
      default=None,
      description=,
  )
  silence_duration_ms: Optional[int] = Field(
      default=None,
      description=,
  )


class AutomaticActivityDetectionDict(TypedDict, total=False):
  

  disabled: Optional[bool]
  

  start_of_speech_sensitivity: Optional[StartSensitivity]
  

  end_of_speech_sensitivity: Optional[EndSensitivity]
  

  prefix_padding_ms: Optional[int]
  

  silence_duration_ms: Optional[int]
  


AutomaticActivityDetectionOrDict = Union[
    AutomaticActivityDetection, AutomaticActivityDetectionDict
]


class RealtimeInputConfig(_common.BaseModel):
  

  automatic_activity_detection: Optional[AutomaticActivityDetection] = Field(
      default=None,
      description=,
  )
  activity_handling: Optional[ActivityHandling] = Field(
      default=None, description=
  )
  turn_coverage: Optional[TurnCoverage] = Field(
      default=None,
      description=,
  )


class RealtimeInputConfigDict(TypedDict, total=False):
  

  automatic_activity_detection: Optional[AutomaticActivityDetectionDict]
  

  activity_handling: Optional[ActivityHandling]
  

  turn_coverage: Optional[TurnCoverage]
  


RealtimeInputConfigOrDict = Union[RealtimeInputConfig, RealtimeInputConfigDict]


class SessionResumptionConfig(_common.BaseModel):
  

  handle: Optional[str] = Field(
      default=None,
      description=,
  )
  transparent: Optional[bool] = Field(
      default=None,
      description=,
  )


class SessionResumptionConfigDict(TypedDict, total=False):
  

  handle: Optional[str]
  

  transparent: Optional[bool]
  


SessionResumptionConfigOrDict = Union[
    SessionResumptionConfig, SessionResumptionConfigDict
]


class SlidingWindow(_common.BaseModel):
  

  target_tokens: Optional[int] = Field(
      default=None,
      description=,
  )


class SlidingWindowDict(TypedDict, total=False):
  

  target_tokens: Optional[int]
  


SlidingWindowOrDict = Union[SlidingWindow, SlidingWindowDict]


class ContextWindowCompressionConfig(_common.BaseModel):
  

  trigger_tokens: Optional[int] = Field(
      default=None,
      description=,
  )
  sliding_window: Optional[SlidingWindow] = Field(
      default=None, description=
  )


class ContextWindowCompressionConfigDict(TypedDict, total=False):
  

  trigger_tokens: Optional[int]
  

  sliding_window: Optional[SlidingWindowDict]
  


ContextWindowCompressionConfigOrDict = Union[
    ContextWindowCompressionConfig, ContextWindowCompressionConfigDict
]


class AudioTranscriptionConfig(_common.BaseModel):
  

  pass


class AudioTranscriptionConfigDict(TypedDict, total=False):
  

  pass


AudioTranscriptionConfigOrDict = Union[
    AudioTranscriptionConfig, AudioTranscriptionConfigDict
]


class ProactivityConfig(_common.BaseModel):
  

  proactive_audio: Optional[bool] = Field(
      default=None,
      description=,
  )


class ProactivityConfigDict(TypedDict, total=False):
  

  proactive_audio: Optional[bool]
  


ProactivityConfigOrDict = Union[ProactivityConfig, ProactivityConfigDict]


class LiveClientSetup(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  generation_config: Optional[GenerationConfig] = Field(
      default=None,
      description=,
  )
  system_instruction: Optional[ContentUnion] = Field(
      default=None,
      description=,
  )
  tools: Optional[ToolListUnion] = Field(
      default=None,
      description=,
  )
  session_resumption: Optional[SessionResumptionConfig] = Field(
      default=None,
      description=,
  )
  context_window_compression: Optional[ContextWindowCompressionConfig] = Field(
      default=None,
      description=,
  )
  input_audio_transcription: Optional[AudioTranscriptionConfig] = Field(
      default=None,
      description=,
  )
  output_audio_transcription: Optional[AudioTranscriptionConfig] = Field(
      default=None,
      description=,
  )
  proactivity: Optional[ProactivityConfig] = Field(
      default=None,
      description=,
  )


class LiveClientSetupDict(TypedDict, total=False):
  

  model: Optional[str]
  

  generation_config: Optional[GenerationConfigDict]
  

  system_instruction: Optional[ContentUnionDict]
  

  tools: Optional[ToolListUnionDict]
  

  session_resumption: Optional[SessionResumptionConfigDict]
  

  context_window_compression: Optional[ContextWindowCompressionConfigDict]
  

  input_audio_transcription: Optional[AudioTranscriptionConfigDict]
  

  output_audio_transcription: Optional[AudioTranscriptionConfigDict]
  

  proactivity: Optional[ProactivityConfigDict]
  


LiveClientSetupOrDict = Union[LiveClientSetup, LiveClientSetupDict]


class LiveClientContent(_common.BaseModel):
  

  turns: Optional[list[Content]] = Field(
      default=None,
      description=,
  )
  turn_complete: Optional[bool] = Field(
      default=None,
      description=,
  )


class LiveClientContentDict(TypedDict, total=False):
  

  turns: Optional[list[ContentDict]]
  

  turn_complete: Optional[bool]
  


LiveClientContentOrDict = Union[LiveClientContent, LiveClientContentDict]


class ActivityStart(_common.BaseModel):
  

  pass


class ActivityStartDict(TypedDict, total=False):
  

  pass


ActivityStartOrDict = Union[ActivityStart, ActivityStartDict]


class ActivityEnd(_common.BaseModel):
  

  pass


class ActivityEndDict(TypedDict, total=False):
  

  pass


ActivityEndOrDict = Union[ActivityEnd, ActivityEndDict]


class LiveClientRealtimeInput(_common.BaseModel):
  

  media_chunks: Optional[list[Blob]] = Field(
      default=None, description=
  )
  audio: Optional[Blob] = Field(
      default=None, description=
  )
  audio_stream_end: Optional[bool] = Field(
      default=None,
      description=,
  )
  video: Optional[Blob] = Field(
      default=None, description=
  )
  text: Optional[str] = Field(
      default=None, description=
  )
  activity_start: Optional[ActivityStart] = Field(
      default=None, description=
  )
  activity_end: Optional[ActivityEnd] = Field(
      default=None, description=
  )


class LiveClientRealtimeInputDict(TypedDict, total=False):
  

  media_chunks: Optional[list[BlobDict]]
  

  audio: Optional[BlobDict]
  

  audio_stream_end: Optional[bool]
  

  video: Optional[BlobDict]
  

  text: Optional[str]
  

  activity_start: Optional[ActivityStartDict]
  

  activity_end: Optional[ActivityEndDict]
  


LiveClientRealtimeInputOrDict = Union[
    LiveClientRealtimeInput, LiveClientRealtimeInputDict
]

if _is_pillow_image_imported:
  BlobImageUnion = Union[Blob, PIL_Image]
else:
  BlobImageUnion = Blob  


BlobImageUnionDict = Union[BlobImageUnion, BlobDict]


class LiveSendRealtimeInputParameters(_common.BaseModel):
  

  media: Optional[BlobImageUnion] = Field(
      default=None, description=
  )
  audio: Optional[Blob] = Field(
      default=None, description=
  )
  audio_stream_end: Optional[bool] = Field(
      default=None,
      description=,
  )
  video: Optional[BlobImageUnion] = Field(
      default=None, description=
  )
  text: Optional[str] = Field(
      default=None, description=
  )
  activity_start: Optional[ActivityStart] = Field(
      default=None, description=
  )
  activity_end: Optional[ActivityEnd] = Field(
      default=None, description=
  )


class LiveSendRealtimeInputParametersDict(TypedDict, total=False):
  

  media: Optional[BlobImageUnionDict]
  

  audio: Optional[BlobDict]
  

  audio_stream_end: Optional[bool]
  

  video: Optional[BlobImageUnionDict]
  

  text: Optional[str]
  

  activity_start: Optional[ActivityStartDict]
  

  activity_end: Optional[ActivityEndDict]
  


LiveSendRealtimeInputParametersOrDict = Union[
    LiveSendRealtimeInputParameters, LiveSendRealtimeInputParametersDict
]


class LiveClientToolResponse(_common.BaseModel):
  

  function_responses: Optional[list[FunctionResponse]] = Field(
      default=None, description=
  )


class LiveClientToolResponseDict(TypedDict, total=False):
  

  function_responses: Optional[list[FunctionResponseDict]]
  


LiveClientToolResponseOrDict = Union[
    LiveClientToolResponse, LiveClientToolResponseDict
]


class LiveClientMessage(_common.BaseModel):
  

  setup: Optional[LiveClientSetup] = Field(
      default=None,
      description=,
  )
  client_content: Optional[LiveClientContent] = Field(
      default=None,
      description=,
  )
  realtime_input: Optional[LiveClientRealtimeInput] = Field(
      default=None, description=
  )
  tool_response: Optional[LiveClientToolResponse] = Field(
      default=None,
      description=,
  )


class LiveClientMessageDict(TypedDict, total=False):
  

  setup: Optional[LiveClientSetupDict]
  

  client_content: Optional[LiveClientContentDict]
  

  realtime_input: Optional[LiveClientRealtimeInputDict]
  

  tool_response: Optional[LiveClientToolResponseDict]
  


LiveClientMessageOrDict = Union[LiveClientMessage, LiveClientMessageDict]


class LiveConnectConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  generation_config: Optional[GenerationConfig] = Field(
      default=None,
      description=,
  )
  response_modalities: Optional[list[Modality]] = Field(
      default=None,
      description=,
  )
  temperature: Optional[float] = Field(
      default=None,
      description=,
  )
  top_p: Optional[float] = Field(
      default=None,
      description=,
  )
  top_k: Optional[float] = Field(
      default=None,
      description=,
  )
  max_output_tokens: Optional[int] = Field(
      default=None,
      description=,
  )
  media_resolution: Optional[MediaResolution] = Field(
      default=None,
      description=,
  )
  seed: Optional[int] = Field(
      default=None,
      description=,
  )
  speech_config: Optional[SpeechConfig] = Field(
      default=None,
      description=,
  )
  enable_affective_dialog: Optional[bool] = Field(
      default=None,
      description=,
  )
  system_instruction: Optional[ContentUnion] = Field(
      default=None,
      description=,
  )
  tools: Optional[ToolListUnion] = Field(
      default=None,
      description=,
  )
  session_resumption: Optional[SessionResumptionConfig] = Field(
      default=None,
      description=,
  )
  input_audio_transcription: Optional[AudioTranscriptionConfig] = Field(
      default=None,
      description=,
  )
  output_audio_transcription: Optional[AudioTranscriptionConfig] = Field(
      default=None,
      description=,
  )
  realtime_input_config: Optional[RealtimeInputConfig] = Field(
      default=None,
      description=,
  )
  context_window_compression: Optional[ContextWindowCompressionConfig] = Field(
      default=None,
      description=,
  )
  proactivity: Optional[ProactivityConfig] = Field(
      default=None,
      description=,
  )


class LiveConnectConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  generation_config: Optional[GenerationConfigDict]
  

  response_modalities: Optional[list[Modality]]
  

  temperature: Optional[float]
  

  top_p: Optional[float]
  

  top_k: Optional[float]
  

  max_output_tokens: Optional[int]
  

  media_resolution: Optional[MediaResolution]
  

  seed: Optional[int]
  

  speech_config: Optional[SpeechConfigDict]
  

  enable_affective_dialog: Optional[bool]
  

  system_instruction: Optional[ContentUnionDict]
  

  tools: Optional[ToolListUnionDict]
  

  session_resumption: Optional[SessionResumptionConfigDict]
  

  input_audio_transcription: Optional[AudioTranscriptionConfigDict]
  

  output_audio_transcription: Optional[AudioTranscriptionConfigDict]
  

  realtime_input_config: Optional[RealtimeInputConfigDict]
  

  context_window_compression: Optional[ContextWindowCompressionConfigDict]
  

  proactivity: Optional[ProactivityConfigDict]
  


LiveConnectConfigOrDict = Union[LiveConnectConfig, LiveConnectConfigDict]


class LiveConnectParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[LiveConnectConfig] = Field(
      default=None,
      description=,
  )


class LiveConnectParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  

  config: Optional[LiveConnectConfigDict]
  


LiveConnectParametersOrDict = Union[
    LiveConnectParameters, LiveConnectParametersDict
]


class LiveMusicClientSetup(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )


class LiveMusicClientSetupDict(TypedDict, total=False):
  

  model: Optional[str]
  


LiveMusicClientSetupOrDict = Union[
    LiveMusicClientSetup, LiveMusicClientSetupDict
]


class WeightedPrompt(_common.BaseModel):
  

  text: Optional[str] = Field(default=None, description=)
  weight: Optional[float] = Field(
      default=None,
      description=,
  )


class WeightedPromptDict(TypedDict, total=False):
  

  text: Optional[str]
  

  weight: Optional[float]
  


WeightedPromptOrDict = Union[WeightedPrompt, WeightedPromptDict]


class LiveMusicClientContent(_common.BaseModel):
  

  weighted_prompts: Optional[list[WeightedPrompt]] = Field(
      default=None, description=
  )


class LiveMusicClientContentDict(TypedDict, total=False):
  

  weighted_prompts: Optional[list[WeightedPromptDict]]
  


LiveMusicClientContentOrDict = Union[
    LiveMusicClientContent, LiveMusicClientContentDict
]


class LiveMusicGenerationConfig(_common.BaseModel):
  

  temperature: Optional[float] = Field(
      default=None,
      description=,
  )
  top_k: Optional[int] = Field(
      default=None,
      description=,
  )
  seed: Optional[int] = Field(
      default=None,
      description=,
  )
  guidance: Optional[float] = Field(
      default=None,
      description=,
  )
  bpm: Optional[int] = Field(
      default=None, description=
  )
  density: Optional[float] = Field(
      default=None, description=
  )
  brightness: Optional[float] = Field(
      default=None,
      description=,
  )
  scale: Optional[Scale] = Field(
      default=None, description=
  )
  mute_bass: Optional[bool] = Field(
      default=None,
      description=,
  )
  mute_drums: Optional[bool] = Field(
      default=None,
      description=,
  )
  only_bass_and_drums: Optional[bool] = Field(
      default=None,
      description=,
  )


class LiveMusicGenerationConfigDict(TypedDict, total=False):
  

  temperature: Optional[float]
  

  top_k: Optional[int]
  

  seed: Optional[int]
  

  guidance: Optional[float]
  

  bpm: Optional[int]
  

  density: Optional[float]
  

  brightness: Optional[float]
  

  scale: Optional[Scale]
  

  mute_bass: Optional[bool]
  

  mute_drums: Optional[bool]
  

  only_bass_and_drums: Optional[bool]
  


LiveMusicGenerationConfigOrDict = Union[
    LiveMusicGenerationConfig, LiveMusicGenerationConfigDict
]


class LiveMusicClientMessage(_common.BaseModel):
  

  setup: Optional[LiveMusicClientSetup] = Field(
      default=None,
      description=,
  )
  client_content: Optional[LiveMusicClientContent] = Field(
      default=None, description=
  )
  music_generation_config: Optional[LiveMusicGenerationConfig] = Field(
      default=None, description=
  )
  playback_control: Optional[LiveMusicPlaybackControl] = Field(
      default=None,
      description=,
  )


class LiveMusicClientMessageDict(TypedDict, total=False):
  

  setup: Optional[LiveMusicClientSetupDict]
  

  client_content: Optional[LiveMusicClientContentDict]
  

  music_generation_config: Optional[LiveMusicGenerationConfigDict]
  

  playback_control: Optional[LiveMusicPlaybackControl]
  


LiveMusicClientMessageOrDict = Union[
    LiveMusicClientMessage, LiveMusicClientMessageDict
]


class LiveMusicServerSetupComplete(_common.BaseModel):
  

  pass


class LiveMusicServerSetupCompleteDict(TypedDict, total=False):
  

  pass


LiveMusicServerSetupCompleteOrDict = Union[
    LiveMusicServerSetupComplete, LiveMusicServerSetupCompleteDict
]


class LiveMusicSourceMetadata(_common.BaseModel):
  

  client_content: Optional[LiveMusicClientContent] = Field(
      default=None,
      description=,
  )
  music_generation_config: Optional[LiveMusicGenerationConfig] = Field(
      default=None,
      description=,
  )


class LiveMusicSourceMetadataDict(TypedDict, total=False):
  

  client_content: Optional[LiveMusicClientContentDict]
  

  music_generation_config: Optional[LiveMusicGenerationConfigDict]
  


LiveMusicSourceMetadataOrDict = Union[
    LiveMusicSourceMetadata, LiveMusicSourceMetadataDict
]


class AudioChunk(_common.BaseModel):
  

  data: Optional[bytes] = Field(
      default=None, description=
  )
  mime_type: Optional[str] = Field(
      default=None, description=
  )
  source_metadata: Optional[LiveMusicSourceMetadata] = Field(
      default=None,
      description=,
  )


class AudioChunkDict(TypedDict, total=False):
  

  data: Optional[bytes]
  

  mime_type: Optional[str]
  

  source_metadata: Optional[LiveMusicSourceMetadataDict]
  


AudioChunkOrDict = Union[AudioChunk, AudioChunkDict]


class LiveMusicServerContent(_common.BaseModel):
  

  audio_chunks: Optional[list[AudioChunk]] = Field(
      default=None,
      description=,
  )


class LiveMusicServerContentDict(TypedDict, total=False):
  

  audio_chunks: Optional[list[AudioChunkDict]]
  


LiveMusicServerContentOrDict = Union[
    LiveMusicServerContent, LiveMusicServerContentDict
]


class LiveMusicFilteredPrompt(_common.BaseModel):
  

  text: Optional[str] = Field(
      default=None, description=
  )
  filtered_reason: Optional[str] = Field(
      default=None, description=
  )


class LiveMusicFilteredPromptDict(TypedDict, total=False):
  

  text: Optional[str]
  

  filtered_reason: Optional[str]
  


LiveMusicFilteredPromptOrDict = Union[
    LiveMusicFilteredPrompt, LiveMusicFilteredPromptDict
]


class LiveMusicServerMessage(_common.BaseModel):
  

  setup_complete: Optional[LiveMusicServerSetupComplete] = Field(
      default=None,
      description=,
  )
  server_content: Optional[LiveMusicServerContent] = Field(
      default=None,
      description=,
  )
  filtered_prompt: Optional[LiveMusicFilteredPrompt] = Field(
      default=None,
      description=,
  )


class LiveMusicServerMessageDict(TypedDict, total=False):
  

  setup_complete: Optional[LiveMusicServerSetupCompleteDict]
  

  server_content: Optional[LiveMusicServerContentDict]
  

  filtered_prompt: Optional[LiveMusicFilteredPromptDict]
  


LiveMusicServerMessageOrDict = Union[
    LiveMusicServerMessage, LiveMusicServerMessageDict
]


class LiveMusicConnectParameters(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None, description=
  )


class LiveMusicConnectParametersDict(TypedDict, total=False):
  

  model: Optional[str]
  


LiveMusicConnectParametersOrDict = Union[
    LiveMusicConnectParameters, LiveMusicConnectParametersDict
]


class LiveMusicSetConfigParameters(_common.BaseModel):
  

  music_generation_config: Optional[LiveMusicGenerationConfig] = Field(
      default=None, description=
  )


class LiveMusicSetConfigParametersDict(TypedDict, total=False):
  

  music_generation_config: Optional[LiveMusicGenerationConfigDict]
  


LiveMusicSetConfigParametersOrDict = Union[
    LiveMusicSetConfigParameters, LiveMusicSetConfigParametersDict
]


class LiveMusicSetWeightedPromptsParameters(_common.BaseModel):
  

  weighted_prompts: Optional[list[WeightedPrompt]] = Field(
      default=None,
      description=,
  )


class LiveMusicSetWeightedPromptsParametersDict(TypedDict, total=False):
  

  weighted_prompts: Optional[list[WeightedPromptDict]]
  


LiveMusicSetWeightedPromptsParametersOrDict = Union[
    LiveMusicSetWeightedPromptsParameters,
    LiveMusicSetWeightedPromptsParametersDict,
]


class AuthToken(_common.BaseModel):
  

  name: Optional[str] = Field(
      default=None, description=
  )


class AuthTokenDict(TypedDict, total=False):
  

  name: Optional[str]
  


AuthTokenOrDict = Union[AuthToken, AuthTokenDict]


class LiveConnectConstraints(_common.BaseModel):
  

  model: Optional[str] = Field(
      default=None,
      description=,
  )
  config: Optional[LiveConnectConfig] = Field(
      default=None,
      description=,
  )


class LiveConnectConstraintsDict(TypedDict, total=False):
  

  model: Optional[str]
  

  config: Optional[LiveConnectConfigDict]
  


LiveConnectConstraintsOrDict = Union[
    LiveConnectConstraints, LiveConnectConstraintsDict
]


class CreateAuthTokenConfig(_common.BaseModel):
  

  http_options: Optional[HttpOptions] = Field(
      default=None, description=
  )
  expire_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  new_session_expire_time: Optional[datetime.datetime] = Field(
      default=None,
      description=,
  )
  uses: Optional[int] = Field(
      default=None,
      description=,
  )
  live_connect_constraints: Optional[LiveConnectConstraints] = Field(
      default=None,
      description=,
  )
  lock_additional_fields: Optional[list[str]] = Field(
      default=None,
      description=,
  )


class CreateAuthTokenConfigDict(TypedDict, total=False):
  

  http_options: Optional[HttpOptionsDict]
  

  expire_time: Optional[datetime.datetime]
  

  new_session_expire_time: Optional[datetime.datetime]
  

  uses: Optional[int]
  

  live_connect_constraints: Optional[LiveConnectConstraintsDict]
  

  lock_additional_fields: Optional[list[str]]
  


CreateAuthTokenConfigOrDict = Union[
    CreateAuthTokenConfig, CreateAuthTokenConfigDict
]


class CreateAuthTokenParameters(_common.BaseModel):
  

  config: Optional[CreateAuthTokenConfig] = Field(
      default=None, description=
  )


class CreateAuthTokenParametersDict(TypedDict, total=False):
  

  config: Optional[CreateAuthTokenConfigDict]
  


CreateAuthTokenParametersOrDict = Union[
    CreateAuthTokenParameters, CreateAuthTokenParametersDict
]
