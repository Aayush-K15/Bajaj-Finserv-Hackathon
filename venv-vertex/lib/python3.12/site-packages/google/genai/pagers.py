


















import copy
from typing import Any, AsyncIterator, Awaitable, Callable, Generic, Iterator, Literal, TypeVar, Union
from . import _common
from . import types

T = TypeVar('T')

PagedItem = Literal[
    'batch_jobs', 'models', 'tuning_jobs', 'files', 'cached_contents'
]


class _BasePager(Generic[T]):
  

  def _init_page(
      self,
      name: PagedItem,
      request: Callable[..., Any],
      response: Any,
      config: Any,
  ) -> None:
    self._name = name
    self._request = request

    self._page = getattr(response, self._name) or []
    self._idx = 0

    self._sdk_http_response = getattr(response, 'sdk_http_response', None)

    if not config:
      request_config = {}
    elif isinstance(config, dict):
      request_config = copy.deepcopy(config)
    else:
      request_config = dict(config)
    request_config['page_token'] = getattr(response, 'next_page_token')
    self._config = request_config

    self._page_size: int = request_config.get('page_size', len(self._page))

  def __init__(
      self,
      name: PagedItem,
      request: Callable[..., Any],
      response: Any,
      config: Any,
  ):
    self._init_page(name, request, response, config)

  @property
  def page(self) -> list[T]:
    

    return self._page

  @property
  def name(self) -> PagedItem:
    

    return self._name

  @property
  def page_size(self) -> int:
    

    return self._page_size

  @property
  def sdk_http_response(self) -> Union[types.HttpResponse, None]:
    

    return self._sdk_http_response

  @property
  def config(self) -> _common.StringDict:
    

    return self._config

  def __len__(self) -> int:
    
    return len(self.page)

  def __getitem__(self, index: int) -> T:
    
    return self.page[index]

  def _init_next_page(self, response: Any) -> None:
    
    self._init_page(self.name, self._request, response, self.config)


class Pager(_BasePager[T]):
  

  def __next__(self) -> T:
    
    if self._idx >= len(self):
      try:
        self.next_page()
      except IndexError:
        raise StopIteration

    item = self.page[self._idx]
    self._idx += 1
    return item

  def __iter__(self) -> Iterator[T]:
    
    self._idx = 0
    return self

  def next_page(self) -> list[T]:
    

    if not self.config.get('page_token'):
      raise IndexError('No more pages to fetch.')

    response = self._request(config=self.config)
    self._init_next_page(response)
    return self.page


class AsyncPager(_BasePager[T]):
  

  def __init__(
      self,
      name: PagedItem,
      request: Callable[..., Awaitable[Any]],
      response: Any,
      config: Any,
  ):
    super().__init__(name, request, response, config)

  def __aiter__(self) -> AsyncIterator[T]:
    
    self._idx = 0
    return self

  async def __anext__(self) -> T:
    
    if self._idx >= len(self):
      try:
        await self.next_page()
      except IndexError:
        raise StopAsyncIteration

    item = self.page[self._idx]
    self._idx += 1
    return item

  async def next_page(self) -> list[T]:
    

    if not self.config.get('page_token'):
      raise IndexError('No more pages to fetch.')

    response = await self._request(config=self.config)
    self._init_next_page(response)
    return self.page
