
















import json
import logging
from typing import Any, Dict, List, Optional
from urllib.parse import urlencode
from . import _api_module
from . import _common
from . import _tokens_converters as tokens_converters
from . import types

logger = logging.getLogger('google_genai.tokens')


def _get_field_masks(setup: _common.StringDict) -> str:
  
  fields = []
  for k, v in setup.items():
    
    if isinstance(v, dict) and v:
      field = [f'{k}.{kk}' for kk in v.keys()]
    else:
      field = [k]  
    fields.extend(field)

  return ','.join(fields)


def _convert_bidi_setup_to_token_setup(
    request_dict: _common.StringDict,
    config: Optional[types.CreateAuthTokenConfigOrDict] = None,
) -> _common.StringDict:
  
  bidi_setup = request_dict.get('bidiGenerateContentSetup')
  if bidi_setup and bidi_setup.get('setup'):
    
    
    request_dict['bidiGenerateContentSetup'] = bidi_setup.get('setup')

    
    field_mask = _get_field_masks(request_dict['bidiGenerateContentSetup'])

    if (
        isinstance(config, dict)
        and config.get('lock_additional_fields') is not None
        and not config.get('lock_additional_fields')
    ) or (
        isinstance(config, types.CreateAuthTokenConfig)
        and config.lock_additional_fields is not None
        and not config.lock_additional_fields  
    ):
      
      request_dict['fieldMask'] = field_mask
    elif (
        isinstance(config, dict)
        and config.get('lock_additional_fields') is None
    ) or (
        isinstance(config, types.CreateAuthTokenConfig)
        and config.lock_additional_fields is None
    ):
      
      request_dict.pop('fieldMask', None)
    elif request_dict['fieldMask']:
      
      additional_fields_list: Optional[List[str]] = request_dict.get(
          'fieldMask'
      )
      generation_config_list = types.GenerationConfig().model_dump().keys()
      if additional_fields_list:
        field_mask_list = []
        for field in additional_fields_list:
          if field in generation_config_list:
            field = f'generationConfig.{field}'
          field_mask_list.append(field)
      else:
        field_mask_list = []
      request_dict['fieldMask'] = (
          field_mask + ',' + ','.join(field_mask_list)
          if field_mask_list
          else field_mask
      )
    else:
      
      request_dict.pop('fieldMask', None)
  else:
    field_mask = request_dict.get('fieldMask', [])
    field_mask_str = ','.join(field_mask)
    if field_mask:
      request_dict['fieldMask'] = field_mask_str
    else:
      request_dict.pop('fieldMask', None)
  if not request_dict.get('bidiGenerateContentSetup'):
    request_dict.pop('bidiGenerateContentSetup', None)

  return request_dict


class Tokens(_api_module.BaseModule):
  

  @_common.experimental_warning(
      "The SDK's token creation implementation is experimental, "
      'and may change in future versions.',
  )
  def create(
      self, *, config: Optional[types.CreateAuthTokenConfigOrDict] = None
  ) -> types.AuthToken:
    

    parameter_model = types.CreateAuthTokenParameters(
        config=config,
    )
    request_url_dict: Optional[dict[str, str]]
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    else:
      request_dict = tokens_converters._CreateAuthTokenParameters_to_mldev(
          self._api_client,
          parameter_model
      )
      request_url_dict = request_dict.get('_url')
      if request_url_dict:
        path = 'auth_tokens'.format_map(request_url_dict)
      else:
        path = 'auth_tokens'

    query_params = request_dict.get('_query')
    if query_params:
      path = f'{path}?{urlencode(query_params)}'
    

    request_dict.pop('config', None)

    
    
    if request_dict:
      request_dict = _convert_bidi_setup_to_token_setup(request_dict, config)

    http_options: Optional[types.HttpOptions] = None
    if (
        parameter_model is not None
        and parameter_model.config is not None
        and parameter_model.config.http_options is not None
    ):
      http_options = parameter_model.config.http_options

    request_dict = _common.convert_to_dict(request_dict)
    request_dict = _common.encode_unserializable_types(request_dict)

    response = self._api_client.request(
        'post', path, request_dict, http_options
    )
    response_dict = '' if not response.body else json.loads(response.body)

    if not self._api_client.vertexai:
      response_dict = tokens_converters._AuthToken_from_mldev(
          response_dict
      )

    return_value = types.AuthToken._from_response(
        response=response_dict, kwargs=parameter_model.model_dump()
    )
    self._api_client._verify_response(return_value)
    return return_value


class AsyncTokens(_api_module.BaseModule):
  

  @_common.experimental_warning(
      "The SDK's token creation implementation is experimental, "
      'and may change in future versions.',
  )
  async def create(
      self, *, config: Optional[types.CreateAuthTokenConfigOrDict] = None
  ) -> types.AuthToken:
    

    parameter_model = types.CreateAuthTokenParameters(
        config=config,
    )

    request_url_dict: Optional[dict[str, str]]
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    else:
      request_dict = tokens_converters._CreateAuthTokenParameters_to_mldev(
          self._api_client,
          parameter_model
      )
      request_url_dict = request_dict.get('_url')
      if request_url_dict:
        path = 'auth_tokens'.format_map(request_url_dict)
      else:
        path = 'auth_tokens'

    query_params = request_dict.get('_query')
    if query_params:
      path = f'{path}?{urlencode(query_params)}'
    
    request_dict.pop('config', None)

    
    
    request_dict = _convert_bidi_setup_to_token_setup(request_dict, config)

    http_options: Optional[types.HttpOptions] = None
    if (
        parameter_model is not None
        and parameter_model.config is not None
        and parameter_model.config.http_options is not None
    ):
      http_options = parameter_model.config.http_options

    request_dict = _common.convert_to_dict(request_dict)
    request_dict = _common.encode_unserializable_types(request_dict)

    response = await self._api_client.async_request(
        'post',
        path,
        request_dict,
        http_options=http_options,
    )
    response_dict = '' if not response.body else json.loads(response.body)

    if not self._api_client.vertexai:
      response_dict = tokens_converters._AuthToken_from_mldev(
          response_dict
      )

    return_value = types.AuthToken._from_response(
        response=response_dict, kwargs=parameter_model.model_dump()
    )
    self._api_client._verify_response(return_value)
    return return_value
