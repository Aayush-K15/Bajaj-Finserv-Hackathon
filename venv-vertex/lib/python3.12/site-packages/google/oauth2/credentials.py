















from datetime import datetime
import io
import json
import logging
import warnings

from google.auth import _cloud_sdk
from google.auth import _helpers
from google.auth import credentials
from google.auth import exceptions
from google.auth import metrics
from google.oauth2 import reauth

_LOGGER = logging.getLogger(__name__)



_GOOGLE_OAUTH2_TOKEN_ENDPOINT = "https://oauth2.googleapis.com/token"


_GOOGLE_OAUTH2_TOKEN_INFO_ENDPOINT = "https://oauth2.googleapis.com/tokeninfo"


class Credentials(credentials.ReadOnlyScoped, credentials.CredentialsWithQuotaProject):
    

    def __init__(
        self,
        token,
        refresh_token=None,
        id_token=None,
        token_uri=None,
        client_id=None,
        client_secret=None,
        scopes=None,
        default_scopes=None,
        quota_project_id=None,
        expiry=None,
        rapt_token=None,
        refresh_handler=None,
        enable_reauth_refresh=False,
        granted_scopes=None,
        trust_boundary=None,
        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,
        account=None,
    ):
        
        super(Credentials, self).__init__()
        self.token = token
        self.expiry = expiry
        self._refresh_token = refresh_token
        self._id_token = id_token
        self._scopes = scopes
        self._default_scopes = default_scopes
        self._granted_scopes = granted_scopes
        self._token_uri = token_uri
        self._client_id = client_id
        self._client_secret = client_secret
        self._quota_project_id = quota_project_id
        self._rapt_token = rapt_token
        self.refresh_handler = refresh_handler
        self._enable_reauth_refresh = enable_reauth_refresh
        self._trust_boundary = trust_boundary
        self._universe_domain = universe_domain or credentials.DEFAULT_UNIVERSE_DOMAIN
        self._account = account or ""
        self._cred_file_path = None

    def __getstate__(self):
        
        state_dict = self.__dict__.copy()
        
        
        
        
        if "_refresh_handler" in state_dict:
            del state_dict["_refresh_handler"]

        if "_refresh_worker" in state_dict:
            del state_dict["_refresh_worker"]
        return state_dict

    def __setstate__(self, d):
        
        self.token = d.get("token")
        self.expiry = d.get("expiry")
        self._refresh_token = d.get("_refresh_token")
        self._id_token = d.get("_id_token")
        self._scopes = d.get("_scopes")
        self._default_scopes = d.get("_default_scopes")
        self._granted_scopes = d.get("_granted_scopes")
        self._token_uri = d.get("_token_uri")
        self._client_id = d.get("_client_id")
        self._client_secret = d.get("_client_secret")
        self._quota_project_id = d.get("_quota_project_id")
        self._rapt_token = d.get("_rapt_token")
        self._enable_reauth_refresh = d.get("_enable_reauth_refresh")
        self._trust_boundary = d.get("_trust_boundary")
        self._universe_domain = (
            d.get("_universe_domain") or credentials.DEFAULT_UNIVERSE_DOMAIN
        )
        self._cred_file_path = d.get("_cred_file_path")
        
        self._refresh_handler = None
        self._refresh_worker = None
        self._use_non_blocking_refresh = d.get("_use_non_blocking_refresh", False)
        self._account = d.get("_account", "")

    @property
    def refresh_token(self):
        
        return self._refresh_token

    @property
    def scopes(self):
        
        return self._scopes

    @property
    def granted_scopes(self):
        
        return self._granted_scopes

    @property
    def token_uri(self):
        
        return self._token_uri

    @property
    def id_token(self):
        
        return self._id_token

    @property
    def client_id(self):
        
        return self._client_id

    @property
    def client_secret(self):
        
        return self._client_secret

    @property
    def requires_scopes(self):
        
        return False

    @property
    def rapt_token(self):
        
        return self._rapt_token

    @property
    def refresh_handler(self):
        
        return self._refresh_handler

    @refresh_handler.setter
    def refresh_handler(self, value):
        
        if not callable(value) and value is not None:
            raise TypeError("The provided refresh_handler is not a callable or None.")
        self._refresh_handler = value

    @property
    def account(self):
        
        return self._account

    def _make_copy(self):
        cred = self.__class__(
            self.token,
            refresh_token=self.refresh_token,
            id_token=self.id_token,
            token_uri=self.token_uri,
            client_id=self.client_id,
            client_secret=self.client_secret,
            scopes=self.scopes,
            default_scopes=self.default_scopes,
            granted_scopes=self.granted_scopes,
            quota_project_id=self.quota_project_id,
            rapt_token=self.rapt_token,
            enable_reauth_refresh=self._enable_reauth_refresh,
            trust_boundary=self._trust_boundary,
            universe_domain=self._universe_domain,
            account=self._account,
        )
        cred._cred_file_path = self._cred_file_path
        return cred

    @_helpers.copy_docstring(credentials.Credentials)
    def get_cred_info(self):
        if self._cred_file_path:
            cred_info = {
                "credential_source": self._cred_file_path,
                "credential_type": "user credentials",
            }
            if self.account:
                cred_info["principal"] = self.account
            return cred_info
        return None

    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)
    def with_quota_project(self, quota_project_id):
        cred = self._make_copy()
        cred._quota_project_id = quota_project_id
        return cred

    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)
    def with_token_uri(self, token_uri):
        cred = self._make_copy()
        cred._token_uri = token_uri
        return cred

    def with_account(self, account):
        
        cred = self._make_copy()
        cred._account = account
        return cred

    @_helpers.copy_docstring(credentials.CredentialsWithUniverseDomain)
    def with_universe_domain(self, universe_domain):
        cred = self._make_copy()
        cred._universe_domain = universe_domain
        return cred

    def _metric_header_for_usage(self):
        return metrics.CRED_TYPE_USER

    @_helpers.copy_docstring(credentials.Credentials)
    def refresh(self, request):
        if self._universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN:
            raise exceptions.RefreshError(
                "User credential refresh is only supported in the default "
                "googleapis.com universe domain, but the current universe "
                "domain is {}. If you created the credential with an access "
                "token, it's likely that the provided token is expired now, "
                "please update your code with a valid token.".format(
                    self._universe_domain
                )
            )

        scopes = self._scopes if self._scopes is not None else self._default_scopes
        
        
        
        
        if self._refresh_token is None and self.refresh_handler:
            token, expiry = self.refresh_handler(request, scopes=scopes)
            
            if not isinstance(token, str):
                raise exceptions.RefreshError(
                    "The refresh_handler returned token is not a string."
                )
            if not isinstance(expiry, datetime):
                raise exceptions.RefreshError(
                    "The refresh_handler returned expiry is not a datetime object."
                )
            if _helpers.utcnow() >= expiry - _helpers.REFRESH_THRESHOLD:
                raise exceptions.RefreshError(
                    "The credentials returned by the refresh_handler are "
                    "already expired."
                )
            self.token = token
            self.expiry = expiry
            return

        if (
            self._refresh_token is None
            or self._token_uri is None
            or self._client_id is None
            or self._client_secret is None
        ):
            raise exceptions.RefreshError(
                "The credentials do not contain the necessary fields need to "
                "refresh the access token. You must specify refresh_token, "
                "token_uri, client_id, and client_secret."
            )

        (
            access_token,
            refresh_token,
            expiry,
            grant_response,
            rapt_token,
        ) = reauth.refresh_grant(
            request,
            self._token_uri,
            self._refresh_token,
            self._client_id,
            self._client_secret,
            scopes=scopes,
            rapt_token=self._rapt_token,
            enable_reauth_refresh=self._enable_reauth_refresh,
        )

        self.token = access_token
        self.expiry = expiry
        self._refresh_token = refresh_token
        self._id_token = grant_response.get("id_token")
        self._rapt_token = rapt_token

        if scopes and "scope" in grant_response:
            requested_scopes = frozenset(scopes)
            self._granted_scopes = grant_response["scope"].split()
            granted_scopes = frozenset(self._granted_scopes)
            scopes_requested_but_not_granted = requested_scopes - granted_scopes
            if scopes_requested_but_not_granted:
                
                
                
                
                _LOGGER.warning(
                    "Not all requested scopes were granted by the "
                    "authorization server, missing scopes {}.".format(
                        ", ".join(scopes_requested_but_not_granted)
                    )
                )

    @classmethod
    def from_authorized_user_info(cls, info, scopes=None):
        
        keys_needed = set(("refresh_token", "client_id", "client_secret"))
        missing = keys_needed.difference(info.keys())

        if missing:
            raise ValueError(
                "Authorized user info was not in the expected format, missing "
                "fields {}.".format(", ".join(missing))
            )

        
        expiry = info.get("expiry")
        if expiry:
            expiry = datetime.strptime(
                expiry.rstrip("Z").split(".")[0], "%Y-%m-%dT%H:%M:%S"
            )
        else:
            expiry = _helpers.utcnow() - _helpers.REFRESH_THRESHOLD

        
        if scopes is None and "scopes" in info:
            scopes = info.get("scopes")
            if isinstance(scopes, str):
                scopes = scopes.split(" ")

        return cls(
            token=info.get("token"),
            refresh_token=info.get("refresh_token"),
            token_uri=_GOOGLE_OAUTH2_TOKEN_ENDPOINT,  
            scopes=scopes,
            client_id=info.get("client_id"),
            client_secret=info.get("client_secret"),
            quota_project_id=info.get("quota_project_id"),  
            expiry=expiry,
            rapt_token=info.get("rapt_token"),  
            trust_boundary=info.get("trust_boundary"),  
            universe_domain=info.get("universe_domain"),  
            account=info.get("account", ""),  
        )

    @classmethod
    def from_authorized_user_file(cls, filename, scopes=None):
        
        with io.open(filename, "r", encoding="utf-8") as json_file:
            data = json.load(json_file)
            return cls.from_authorized_user_info(data, scopes)

    def to_json(self, strip=None):
        
        prep = {
            "token": self.token,
            "refresh_token": self.refresh_token,
            "token_uri": self.token_uri,
            "client_id": self.client_id,
            "client_secret": self.client_secret,
            "scopes": self.scopes,
            "rapt_token": self.rapt_token,
            "universe_domain": self._universe_domain,
            "account": self._account,
        }
        if self.expiry:  
            prep["expiry"] = self.expiry.isoformat() + "Z"

        
        prep = {k: v for k, v in prep.items() if v is not None}

        
        if strip is not None:
            prep = {k: v for k, v in prep.items() if k not in strip}

        return json.dumps(prep)


class UserAccessTokenCredentials(credentials.CredentialsWithQuotaProject):
    

    def __init__(self, account=None, quota_project_id=None):
        warnings.warn(
            "UserAccessTokenCredentials is deprecated, please use "
            "google.oauth2.credentials.Credentials instead. To use "
            "that credential type, simply run "
            "`gcloud auth application-default login` and let the "
            "client libraries pick up the application default credentials."
        )
        super(UserAccessTokenCredentials, self).__init__()
        self._account = account
        self._quota_project_id = quota_project_id

    def with_account(self, account):
        
        return self.__class__(account=account, quota_project_id=self._quota_project_id)

    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)
    def with_quota_project(self, quota_project_id):
        return self.__class__(account=self._account, quota_project_id=quota_project_id)

    def refresh(self, request):
        
        self.token = _cloud_sdk.get_auth_access_token(self._account)

    @_helpers.copy_docstring(credentials.Credentials)
    def before_request(self, request, method, url, headers):
        self.refresh(request)
        self.apply(headers)
