from __future__ import annotations


__license__ = "MIT"

import re
import warnings

from bs4.css import CSS
from bs4._deprecation import (
    _deprecated,
    _deprecated_alias,
    _deprecated_function_alias,
)
from bs4.formatter import (
    Formatter,
    HTMLFormatter,
    XMLFormatter,
)
from bs4._warnings import AttributeResemblesVariableWarning

from typing import (
    Any,
    Callable,
    Dict,
    Generic,
    Iterable,
    Iterator,
    List,
    Mapping,
    Optional,
    Pattern,
    Set,
    TYPE_CHECKING,
    Tuple,
    Type,
    TypeVar,
    Union,
    cast,
)
from typing_extensions import (
    Self,
    TypeAlias,
)

if TYPE_CHECKING:
    from bs4 import BeautifulSoup
    from bs4.builder import TreeBuilder
    from bs4.filter import ElementFilter
    from bs4.formatter import (
        _EntitySubstitutionFunction,
        _FormatterOrName,
    )
    from bs4._typing import (
        _AtMostOneElement,
        _AttributeValue,
        _AttributeValues,
        _Encoding,
        _InsertableElement,
        _OneElement,
        _QueryResults,
        _RawOrProcessedAttributeValues,
        _StrainableElement,
        _StrainableAttribute,
        _StrainableAttributes,
        _StrainableString,
    )

_OneOrMoreStringTypes: TypeAlias = Union[
    Type["NavigableString"], Iterable[Type["NavigableString"]]
]

_FindMethodName: TypeAlias = Optional[Union["_StrainableElement", "ElementFilter"]]



_deprecated_names = dict(
    whitespace_re="The {name} attribute was deprecated in version 4.7.0. If you need it, make your own copy."
)

_deprecated_whitespace_re: Pattern[str] = re.compile(r"\s+")


def __getattr__(name: str) -> Any:
    if name in _deprecated_names:
        message = _deprecated_names[name]
        warnings.warn(message.format(name=name), DeprecationWarning, stacklevel=2)

        return globals()[f"_deprecated_{name}"]
    raise AttributeError(f"module {__name__!r} has no attribute {name!r}")




DEFAULT_OUTPUT_ENCODING: str = "utf-8"


nonwhitespace_re: Pattern[str] = re.compile(r"\S+")














PYTHON_SPECIFIC_ENCODINGS: Set[_Encoding] = set(
    [
        "idna",
        "mbcs",
        "oem",
        "palmos",
        "punycode",
        "raw_unicode_escape",
        "undefined",
        "unicode_escape",
        "raw-unicode-escape",
        "unicode-escape",
        "string-escape",
        "string_escape",
    ]
)


class NamespacedAttribute(str):
    

    prefix: Optional[str]
    name: Optional[str]
    namespace: Optional[str]

    def __new__(
        cls,
        prefix: Optional[str],
        name: Optional[str] = None,
        namespace: Optional[str] = None,
    ) -> Self:
        if not name:
            
            
            name = None

        if not name:
            obj = str.__new__(cls, prefix)
        elif not prefix:
            
            obj = str.__new__(cls, name)
        else:
            obj = str.__new__(cls, prefix + ":" + name)
        obj.prefix = prefix
        obj.name = name
        obj.namespace = namespace
        return obj


class AttributeValueWithCharsetSubstitution(str):
    

    
    
    original_value: str

    def substitute_encoding(self, eventual_encoding: str) -> str:
        
        raise NotImplementedError()


class CharsetMetaAttributeValue(AttributeValueWithCharsetSubstitution):
    

    def __new__(cls, original_value: str) -> Self:
        
        
        obj = str.__new__(cls, original_value)
        obj.original_value = original_value
        return obj

    def substitute_encoding(self, eventual_encoding: _Encoding = "utf-8") -> str:
        
        if eventual_encoding in PYTHON_SPECIFIC_ENCODINGS:
            return ""
        return eventual_encoding


class AttributeValueList(List[str]):
    


class AttributeDict(Dict[Any,Any]):
    


class XMLAttributeDict(AttributeDict):
    

    def __setitem__(self, key: str, value: Any) -> None:
        
        if value is None:
            value = ""
        if isinstance(value, bool):
            
            
            
            
            pass
        elif isinstance(value, (int, float)):
            
            
            
            
            
            value = str(value)

        super().__setitem__(key, value)


class HTMLAttributeDict(AttributeDict):
    

    def __setitem__(self, key: str, value: Any) -> None:
        
        if value in (False, None):
            
            
            
            if key in self:
                del self[key]
            return
        if isinstance(value, bool):
            
            
            
            
            
            
            
            
            
            if isinstance(key, NamespacedAttribute):
                value = key.name
            else:
                value = key
        elif isinstance(value, (int, float)):
            
            
            value = str(value)
        super().__setitem__(key, value)


class ContentMetaAttributeValue(AttributeValueWithCharsetSubstitution):
    

    
    
    
    CHARSET_RE: Pattern[str] = re.compile(r"((^|;)\s*charset=)([^;]*)", re.M)

    def __new__(cls, original_value: str) -> Self:
        cls.CHARSET_RE.search(original_value)
        obj = str.__new__(cls, original_value)
        obj.original_value = original_value
        return obj

    def substitute_encoding(self, eventual_encoding: _Encoding = "utf-8") -> str:
        
        if eventual_encoding in PYTHON_SPECIFIC_ENCODINGS:
            return self.CHARSET_RE.sub("", self.original_value)

        def rewrite(match: re.Match[str]) -> str:
            return match.group(1) + eventual_encoding

        return self.CHARSET_RE.sub(rewrite, self.original_value)


class PageElement(object):
    

    
    
    
    
    known_xml: Optional[bool] = None

    
    
    _decomposed: bool

    parent: Optional[Tag]
    next_element: _AtMostOneElement
    previous_element: _AtMostOneElement
    next_sibling: _AtMostOneElement
    previous_sibling: _AtMostOneElement

    
    
    hidden: bool = False

    def setup(
        self,
        parent: Optional[Tag] = None,
        previous_element: _AtMostOneElement = None,
        next_element: _AtMostOneElement = None,
        previous_sibling: _AtMostOneElement = None,
        next_sibling: _AtMostOneElement = None,
    ) -> None:
        
        self.parent = parent

        self.previous_element = previous_element
        if self.previous_element is not None:
            self.previous_element.next_element = self

        self.next_element = next_element
        if self.next_element is not None:
            self.next_element.previous_element = self

        self.next_sibling = next_sibling
        if self.next_sibling is not None:
            self.next_sibling.previous_sibling = self

        if (
            previous_sibling is None
            and self.parent is not None
            and self.parent.contents
        ):
            previous_sibling = self.parent.contents[-1]

        self.previous_sibling = previous_sibling
        if self.previous_sibling is not None:
            self.previous_sibling.next_sibling = self

    def format_string(self, s: str, formatter: Optional[_FormatterOrName]) -> str:
        
        if formatter is None:
            return s
        if not isinstance(formatter, Formatter):
            formatter = self.formatter_for_name(formatter)
        output = formatter.substitute(s)
        return output

    def formatter_for_name(
        self, formatter_name: Union[_FormatterOrName, _EntitySubstitutionFunction]
    ) -> Formatter:
        
        if isinstance(formatter_name, Formatter):
            return formatter_name
        c: type[Formatter]
        registry: Mapping[Optional[str], Formatter]
        if self._is_xml:
            c = XMLFormatter
            registry = XMLFormatter.REGISTRY
        else:
            c = HTMLFormatter
            registry = HTMLFormatter.REGISTRY
        if callable(formatter_name):
            return c(entity_substitution=formatter_name)
        return registry[formatter_name]

    @property
    def _is_xml(self) -> bool:
        
        if self.known_xml is not None:
            
            
            return self.known_xml

        
        
        
        if self.parent is None:
            
            
            
            return getattr(self, "is_xml", False)
        return self.parent._is_xml

    nextSibling = _deprecated_alias("nextSibling", "next_sibling", "4.0.0")
    previousSibling = _deprecated_alias("previousSibling", "previous_sibling", "4.0.0")

    def __deepcopy__(self, memo: Dict[Any, Any], recursive: bool = False) -> Self:
        raise NotImplementedError()

    def __copy__(self) -> Self:
        
        return self.__deepcopy__({})

    default: Iterable[type[NavigableString]] = tuple()  

    def _all_strings(
        self, strip: bool = False, types: Iterable[type[NavigableString]] = default
    ) -> Iterator[str]:
        
        raise NotImplementedError()

    @property
    def stripped_strings(self) -> Iterator[str]:
        
        for string in self._all_strings(True):
            yield string

    def get_text(
        self,
        separator: str = "",
        strip: bool = False,
        types: Iterable[Type[NavigableString]] = default,
    ) -> str:
        
        return separator.join([s for s in self._all_strings(strip, types=types)])

    getText = get_text
    text = property(get_text)

    def replace_with(self, *args: PageElement) -> Self:
        
        if self.parent is None:
            raise ValueError(
                "Cannot replace one element with another when the "
                "element to be replaced is not part of a tree."
            )
        if len(args) == 1 and args[0] is self:
            
            return self
        if any(x is self.parent for x in args):
            raise ValueError("Cannot replace a Tag with its parent.")
        old_parent = self.parent
        my_index = self.parent.index(self)
        self.extract(_self_index=my_index)
        for idx, replace_with in enumerate(args, start=my_index):
            old_parent.insert(idx, replace_with)
        return self

    replaceWith = _deprecated_function_alias("replaceWith", "replace_with", "4.0.0")

    def wrap(self, wrap_inside: Tag) -> Tag:
        
        me = self.replace_with(wrap_inside)
        wrap_inside.append(me)
        return wrap_inside

    def extract(self, _self_index: Optional[int] = None) -> Self:
        
        if self.parent is not None:
            if _self_index is None:
                _self_index = self.parent.index(self)
            del self.parent.contents[_self_index]

        
        
        
        last_child = self._last_descendant()

        
        
        
        
        last_child = cast(PageElement, last_child)
        next_element = last_child.next_element

        if self.previous_element is not None:
            if self.previous_element is not next_element:
                self.previous_element.next_element = next_element
        if next_element is not None and next_element is not self.previous_element:
            next_element.previous_element = self.previous_element
        self.previous_element = None
        last_child.next_element = None

        self.parent = None
        if (
            self.previous_sibling is not None
            and self.previous_sibling is not self.next_sibling
        ):
            self.previous_sibling.next_sibling = self.next_sibling
        if (
            self.next_sibling is not None
            and self.next_sibling is not self.previous_sibling
        ):
            self.next_sibling.previous_sibling = self.previous_sibling
        self.previous_sibling = self.next_sibling = None
        return self

    def decompose(self) -> None:
        
        self.extract()
        e: _AtMostOneElement = self
        next_up: _AtMostOneElement = None
        while e is not None:
            next_up = e.next_element
            e.__dict__.clear()
            if isinstance(e, Tag):
                e.contents = []
            e._decomposed = True
            e = next_up

    def _last_descendant(
        self, is_initialized: bool = True, accept_self: bool = True
    ) -> _AtMostOneElement:
        
        if is_initialized and self.next_sibling is not None:
            last_child = self.next_sibling.previous_element
        else:
            last_child = self
            while isinstance(last_child, Tag) and last_child.contents:
                last_child = last_child.contents[-1]
        if not accept_self and last_child is self:
            last_child = None
        return last_child

    _lastRecursiveChild = _deprecated_alias(
        "_lastRecursiveChild", "_last_descendant", "4.0.0"
    )

    def insert_before(self, *args: _InsertableElement) -> List[PageElement]:
        
        parent = self.parent
        if parent is None:
            raise ValueError("Element has no parent, so 'before' has no meaning.")
        if any(x is self for x in args):
            raise ValueError("Can't insert an element before itself.")
        results: List[PageElement] = []
        for predecessor in args:
            
            
            if isinstance(predecessor, PageElement):
                predecessor.extract()
            index = parent.index(self)
            results.extend(parent.insert(index, predecessor))

        return results

    def insert_after(self, *args: _InsertableElement) -> List[PageElement]:
        
        
        parent = self.parent
        if parent is None:
            raise ValueError("Element has no parent, so 'after' has no meaning.")
        if any(x is self for x in args):
            raise ValueError("Can't insert an element after itself.")

        offset = 0
        results: List[PageElement] = []
        for successor in args:
            
            
            if isinstance(successor, PageElement):
                successor.extract()
            index = parent.index(self)
            results.extend(parent.insert(index + 1 + offset, successor))
            offset += 1

        return results

    def find_next(
        self,
        name: _FindMethodName = None,
        attrs: _StrainableAttributes = {},
        string: Optional[_StrainableString] = None,
        **kwargs: _StrainableAttribute,
    ) -> _AtMostOneElement:
        
        return self._find_one(self.find_all_next, name, attrs, string, **kwargs)

    findNext = _deprecated_function_alias("findNext", "find_next", "4.0.0")

    def find_all_next(
        self,
        name: _FindMethodName = None,
        attrs: _StrainableAttributes = {},
        string: Optional[_StrainableString] = None,
        limit: Optional[int] = None,
        _stacklevel: int = 2,
        **kwargs: _StrainableAttribute,
    ) -> _QueryResults:
        
        return self._find_all(
            name,
            attrs,
            string,
            limit,
            self.next_elements,
            _stacklevel=_stacklevel + 1,
            **kwargs,
        )

    findAllNext = _deprecated_function_alias("findAllNext", "find_all_next", "4.0.0")

    def find_next_sibling(
        self,
        name: _FindMethodName = None,
        attrs: _StrainableAttributes = {},
        string: Optional[_StrainableString] = None,
        **kwargs: _StrainableAttribute,
    ) -> _AtMostOneElement:
        
        return self._find_one(self.find_next_siblings, name, attrs, string, **kwargs)

    findNextSibling = _deprecated_function_alias(
        "findNextSibling", "find_next_sibling", "4.0.0"
    )

    def find_next_siblings(
        self,
        name: _FindMethodName = None,
        attrs: _StrainableAttributes = {},
        string: Optional[_StrainableString] = None,
        limit: Optional[int] = None,
        _stacklevel: int = 2,
        **kwargs: _StrainableAttribute,
    ) -> _QueryResults:
        
        return self._find_all(
            name,
            attrs,
            string,
            limit,
            self.next_siblings,
            _stacklevel=_stacklevel + 1,
            **kwargs,
        )

    findNextSiblings = _deprecated_function_alias(
        "findNextSiblings", "find_next_siblings", "4.0.0"
    )
    fetchNextSiblings = _deprecated_function_alias(
        "fetchNextSiblings", "find_next_siblings", "3.0.0"
    )

    def find_previous(
        self,
        name: _FindMethodName = None,
        attrs: _StrainableAttributes = {},
        string: Optional[_StrainableString] = None,
        **kwargs: _StrainableAttribute,
    ) -> _AtMostOneElement:
        
        return self._find_one(self.find_all_previous, name, attrs, string, **kwargs)

    findPrevious = _deprecated_function_alias("findPrevious", "find_previous", "3.0.0")

    def find_all_previous(
        self,
        name: _FindMethodName = None,
        attrs: _StrainableAttributes = {},
        string: Optional[_StrainableString] = None,
        limit: Optional[int] = None,
        _stacklevel: int = 2,
        **kwargs: _StrainableAttribute,
    ) -> _QueryResults:
        
        return self._find_all(
            name,
            attrs,
            string,
            limit,
            self.previous_elements,
            _stacklevel=_stacklevel + 1,
            **kwargs,
        )

    findAllPrevious = _deprecated_function_alias(
        "findAllPrevious", "find_all_previous", "4.0.0"
    )
    fetchAllPrevious = _deprecated_function_alias(
        "fetchAllPrevious", "find_all_previous", "3.0.0"
    )

    def find_previous_sibling(
        self,
        name: _FindMethodName = None,
        attrs: _StrainableAttributes = {},
        string: Optional[_StrainableString] = None,
        **kwargs: _StrainableAttribute,
    ) -> _AtMostOneElement:
        
        return self._find_one(
            self.find_previous_siblings, name, attrs, string, **kwargs
        )

    findPreviousSibling = _deprecated_function_alias(
        "findPreviousSibling", "find_previous_sibling", "4.0.0"
    )

    def find_previous_siblings(
        self,
        name: _FindMethodName = None,
        attrs: _StrainableAttributes = {},
        string: Optional[_StrainableString] = None,
        limit: Optional[int] = None,
        _stacklevel: int = 2,
        **kwargs: _StrainableAttribute,
    ) -> _QueryResults:
        
        return self._find_all(
            name,
            attrs,
            string,
            limit,
            self.previous_siblings,
            _stacklevel=_stacklevel + 1,
            **kwargs,
        )

    findPreviousSiblings = _deprecated_function_alias(
        "findPreviousSiblings", "find_previous_siblings", "4.0.0"
    )
    fetchPreviousSiblings = _deprecated_function_alias(
        "fetchPreviousSiblings", "find_previous_siblings", "3.0.0"
    )

    def find_parent(
        self,
        name: _FindMethodName = None,
        attrs: _StrainableAttributes = {},
        **kwargs: _StrainableAttribute,
    ) -> _AtMostOneElement:
        
        
        
        r = None
        results = self.find_parents(
            name, attrs, 1, _stacklevel=3, **kwargs
        )
        if results:
            r = results[0]
        return r

    findParent = _deprecated_function_alias("findParent", "find_parent", "4.0.0")

    def find_parents(
        self,
        name: _FindMethodName = None,
        attrs: _StrainableAttributes = {},
        limit: Optional[int] = None,
        _stacklevel: int = 2,
        **kwargs: _StrainableAttribute,
    ) -> _QueryResults:
        
        iterator = self.parents
        return self._find_all(
            name, attrs, None, limit, iterator, _stacklevel=_stacklevel + 1, **kwargs
        )

    findParents = _deprecated_function_alias("findParents", "find_parents", "4.0.0")
    fetchParents = _deprecated_function_alias("fetchParents", "find_parents", "3.0.0")

    @property
    def next(self) -> _AtMostOneElement:
        
        return self.next_element

    @property
    def previous(self) -> _AtMostOneElement:
        
        return self.previous_element

    

    def _find_one(
        self,
        
        
        
        
        method: Callable,
        name: _FindMethodName,
        attrs: _StrainableAttributes,
        string: Optional[_StrainableString],
        **kwargs: _StrainableAttribute,
    ) -> _AtMostOneElement:
        r: _AtMostOneElement = None
        results: _QueryResults = method(name, attrs, string, 1, _stacklevel=4, **kwargs)
        if results:
            r = results[0]
        return r

    def _find_all(
        self,
        name: _FindMethodName,
        attrs: _StrainableAttributes,
        string: Optional[_StrainableString],
        limit: Optional[int],
        generator: Iterator[PageElement],
        _stacklevel: int = 3,
        **kwargs: _StrainableAttribute,
    ) -> _QueryResults:
        

        if string is None and "text" in kwargs:
            string = kwargs.pop("text")
            warnings.warn(
                "The 'text' argument to find()-type methods is deprecated. Use 'string' instead.",
                DeprecationWarning,
                stacklevel=_stacklevel,
            )

        if "_class" in kwargs:
            warnings.warn(
                AttributeResemblesVariableWarning.MESSAGE
                % dict(
                    original="_class",
                    autocorrect="class_",
                ),
                AttributeResemblesVariableWarning,
                stacklevel=_stacklevel,
            )

        from bs4.filter import ElementFilter

        if isinstance(name, ElementFilter):
            matcher = name
        else:
            matcher = SoupStrainer(name, attrs, string, **kwargs)

        result: Iterable[_OneElement]
        if string is None and not limit and not attrs and not kwargs:
            if name is True or name is None:
                
                result = (element for element in generator if isinstance(element, Tag))
                return ResultSet(matcher, result)
            elif isinstance(name, str):
                
                if name.count(":") == 1:
                    
                    
                    
                    prefix, local_name = name.split(":", 1)
                else:
                    prefix = None
                    local_name = name
                result = []
                for element in generator:
                    if not isinstance(element, Tag):
                        continue
                    if element.name == name or (
                        element.name == local_name
                        and (prefix is None or element.prefix == prefix)
                    ):
                        result.append(element)
                return ResultSet(matcher, result)
        return matcher.find_all(generator, limit)

    
    
    @property
    def next_elements(self) -> Iterator[PageElement]:
        
        i = self.next_element
        while i is not None:
            successor = i.next_element
            yield i
            i = successor

    @property
    def self_and_next_elements(self) -> Iterator[PageElement]:
        
        return self._self_and(self.next_elements)

    @property
    def next_siblings(self) -> Iterator[PageElement]:
        
        i = self.next_sibling
        while i is not None:
            successor = i.next_sibling
            yield i
            i = successor

    @property
    def self_and_next_siblings(self) -> Iterator[PageElement]:
        
        return self._self_and(self.next_siblings)

    @property
    def previous_elements(self) -> Iterator[PageElement]:
        
        i = self.previous_element
        while i is not None:
            successor = i.previous_element
            yield i
            i = successor

    @property
    def self_and_previous_elements(self) -> Iterator[PageElement]:
        
        return self._self_and(self.previous_elements)

    @property
    def previous_siblings(self) -> Iterator[PageElement]:
        
        i = self.previous_sibling
        while i is not None:
            successor = i.previous_sibling
            yield i
            i = successor

    @property
    def self_and_previous_siblings(self) -> Iterator[PageElement]:
        
        return self._self_and(self.previous_siblings)

    @property
    def parents(self) -> Iterator[Tag]:
        
        i = self.parent
        while i is not None:
            successor = i.parent
            yield i
            i = successor

    @property
    def self_and_parents(self) -> Iterator[PageElement]:
        
        return self._self_and(self.parents)

    def _self_and(self, other_generator:Iterator[PageElement]) -> Iterator[PageElement]:
        
        if not self.hidden:
            yield self
        for i in other_generator:
            yield i

    @property
    def decomposed(self) -> bool:
        
        return getattr(self, "_decomposed", False) or False

    @_deprecated("next_elements", "4.0.0")
    def nextGenerator(self) -> Iterator[PageElement]:
        ":meta private:"
        return self.next_elements

    @_deprecated("next_siblings", "4.0.0")
    def nextSiblingGenerator(self) -> Iterator[PageElement]:
        ":meta private:"
        return self.next_siblings

    @_deprecated("previous_elements", "4.0.0")
    def previousGenerator(self) -> Iterator[PageElement]:
        ":meta private:"
        return self.previous_elements

    @_deprecated("previous_siblings", "4.0.0")
    def previousSiblingGenerator(self) -> Iterator[PageElement]:
        ":meta private:"
        return self.previous_siblings

    @_deprecated("parents", "4.0.0")
    def parentGenerator(self) -> Iterator[PageElement]:
        ":meta private:"
        return self.parents


class NavigableString(str, PageElement):
    

    
    
    
    PREFIX: str = ""

    
    
    
    SUFFIX: str = ""

    def __new__(cls, value: Union[str, bytes]) -> Self:
        
        if isinstance(value, str):
            u = str.__new__(cls, value)
        else:
            u = str.__new__(cls, value, DEFAULT_OUTPUT_ENCODING)
        u.hidden = False
        u.setup()
        return u

    def __deepcopy__(self, memo: Dict[Any, Any], recursive: bool = False) -> Self:
        
        return type(self)(self)

    def __getnewargs__(self) -> Tuple[str]:
        return (str(self),)

    
    
    def __getitem__(self, key: Union[int|slice]) -> str:
        
        if isinstance(key, str):
            raise TypeError("string indices must be integers, not '{0}'. Are you treating a NavigableString like a Tag?".format(key.__class__.__name__))
        return super(NavigableString, self).__getitem__(key)

    @property
    def string(self) -> str:
        
        return self

    def output_ready(self, formatter: _FormatterOrName = "minimal") -> str:
        
        output = self.format_string(self, formatter)
        return self.PREFIX + output + self.SUFFIX

    @property
    def name(self) -> None:
        
        return None

    @name.setter
    def name(self, name: str) -> None:
        
        raise AttributeError("A NavigableString cannot be given a name.")

    def _all_strings(
        self, strip: bool = False, types: _OneOrMoreStringTypes = PageElement.default
    ) -> Iterator[str]:
        
        if types is self.default:
            
            
            types = Tag.MAIN_CONTENT_STRING_TYPES

        
        
        
        
        
        
        
        my_type = type(self)
        if types is not None:
            if isinstance(types, type):
                
                if my_type is not types:
                    return
            elif my_type not in types:
                
                return

        value = self
        if strip:
            final_value = value.strip()
        else:
            final_value = self
        if len(final_value) > 0:
            yield final_value

    @property
    def strings(self) -> Iterator[str]:
        
        return self._all_strings()


class PreformattedString(NavigableString):
    

    PREFIX: str = ""
    SUFFIX: str = ""

    def output_ready(self, formatter: Optional[_FormatterOrName] = None) -> str:
        
        if formatter is not None:
            self.format_string(self, formatter)
        return self.PREFIX + self + self.SUFFIX


class CData(PreformattedString):
    A SGML processing instruction.An `XML processing instruction <https://www.w3.org/TR/REC-xml/

    PREFIX: str = "<?"
    SUFFIX: str = "?>"


class Comment(PreformattedString):
    An `XML declaration <https://www.w3.org/TR/REC-xml/

    PREFIX: str = "<?"
    SUFFIX: str = "?>"


class Doctype(PreformattedString):
    Generate an appropriate document type declaration for a given
        public ID and system ID.

        :param name: The name of the document's root element, e.g. 'html'.
        :param pub_id: The Formal Public Identifier for this document type,
            e.g. '-//W3C//DTD XHTML 1.1//EN'
        :param system_id: The system identifier for this document type,
            e.g. 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'
        Generate a string to be used as the basis of a Doctype object.

        This is a separate method from for_name_and_ids() because the lxml
        TreeBuilder needs to call it.
        A `NavigableString` representing the contents of a `<style> HTML
    tag <https://dev.w3.org/html5/spec-LC/Overview.html
    (probably CSS).

    Used to distinguish embedded stylesheets from textual content.
    A `NavigableString` representing the contents of a `<script>
    HTML tag
    <https://dev.w3.org/html5/spec-LC/Overview.html
    (probably Javascript).

    Used to distinguish executable code from textual content.
    A `NavigableString` representing a string found inside an `HTML
    <template> tag <https://html.spec.whatwg.org/multipage/scripting.html
    embedded in a larger document.

    Used to distinguish such strings from the main body of the document.
    A NavigableString representing the contents of an `<rt> HTML
    tag <https://dev.w3.org/html5/spec-LC/text-level-semantics.html

    Can be used to distinguish such strings from the strings they're
    annotating.
    A NavigableString representing the contents of an `<rp> HTML
    tag <https://dev.w3.org/html5/spec-LC/text-level-semantics.html
    An HTML or XML tag that is part of a parse tree, along with its
    attributes, contents, and relationships to other parts of the tree.

    When Beautiful Soup parses the markup ``<b>penguin</b>``, it will
    create a `Tag` object representing the ``<b>`` tag. You can
    instantiate `Tag` objects directly, but it's not necessary unless
    you're adding entirely new markup to a parsed document. Most of
    the constructor arguments are intended for use by the `TreeBuilder`
    that's parsing a document.

    :param parser: A `BeautifulSoup` object representing the parse tree this
        `Tag` will be part of.
    :param builder: The `TreeBuilder` being used to build the tree.
    :param name: The name of the tag.
    :param namespace: The URI of this tag's XML namespace, if any.
    :param prefix: The prefix for this tag's XML namespace, if any.
    :param attrs: A dictionary of attribute values.
    :param parent: The `Tag` to use as the parent of this `Tag`. May be
       the `BeautifulSoup` object itself.
    :param previous: The `PageElement` that was parsed immediately before
        parsing this tag.
    :param is_xml: If True, this is an XML tag. Otherwise, this is an
        HTML tag.
    :param sourceline: The line number where this tag was found in its
        source document.
    :param sourcepos: The character position within ``sourceline`` where this
        tag was found.
    :param can_be_empty_element: If True, this tag should be
        represented as <tag/>. If False, this tag should be represented
        as <tag></tag>.
    :param cdata_list_attributes: A dictionary of attributes whose values should
        be parsed as lists of strings if they ever show up on this tag.
    :param preserve_whitespace_tags: Names of tags whose contents
        should have their whitespace preserved if they are encountered inside
        this tag.
    :param interesting_string_types: When iterating over this tag's
        string contents in methods like `Tag.strings` or
        `PageElement.get_text`, these are the types of strings that are
        interesting enough to be considered. By default,
        `NavigableString` (normal strings) and `CData` (CDATA
        sections) are the only interesting string subtypes.
    :param namespaces: A dictionary mapping currently active
        namespace prefixes to URIs, as of the point in the parsing process when
        this tag was encountered. This can be used later to
        construct CSS selectors.

    A deepcopy of a Tag is a new Tag, unconnected to the parse tree.
        Its contents are a copy of the old Tag's contents.
        Create a new Tag just like this one, but with no
        contents and unattached to any parse tree.

        This is the first step in the deepcopy process, but you can
        call it on its own to create a copy of a Tag without copying its
        contents.
        Is this tag an empty-element tag? (aka a self-closing tag)

        A tag that has contents is never an empty-element tag.

        A tag that has no contents may or may not be an empty-element
        tag. It depends on the `TreeBuilder` used to create the
        tag. If the builder has a designated list of empty-element
        tags, then only a tag whose name shows up in that list is
        considered an empty-element tag. This is usually the case
        for HTML documents.

        If the builder has no designated list of empty-element, then
        any tag with no contents is an empty-element tag. This is usually
        the case for XML documents.
        Convenience property to get the single string within this
        `Tag`, assuming there is just one.

        :return: If this `Tag` has a single child that's a
         `NavigableString`, the return value is that string. If this
         element has one child `Tag`, the return value is that child's
         `Tag.string`, recursively. If this `Tag` has no children,
         or has more than one child, the return value is ``None``.

         If this property is unexpectedly returning ``None`` for you,
         it's probably because your `Tag` has more than one thing
         inside it.
        Replace the `Tag.contents` of this `Tag` with a single string.Yield all strings of certain classes, possibly stripping them.

        :param strip: If True, all strings will be stripped before being
            yielded.

        :param types: A tuple of NavigableString subclasses. Any strings of
            a subclass not found in this list will be ignored. By
            default, the subclasses considered are the ones found in
            self.interesting_string_types. If that's not specified,
            only NavigableString and CData objects will be
            considered. That means no comments, processing
            instructions, etc.
        Insert one or more new PageElements as a child of this `Tag`.

        This works similarly to :py:meth:`list.insert`, except you can insert
        multiple elements at once.

        :param position: The numeric position that should be occupied
           in this Tag's `Tag.children` by the first new `PageElement`.

        :param new_children: The PageElements to insert.

        :return The newly inserted PageElements.
        Replace this `PageElement` with its contents.

        :return: This object, no longer part of the tree.
        
        Appends the given `PageElement` to the contents of this `Tag`.

        :param tag: A PageElement.

        :return The newly appended PageElement.
        Appends one or more objects to the contents of this
        `Tag`.

        :param tags: If a list of `PageElement` objects is provided,
            they will be appended to this tag's contents, one at a time.
            If a single `Tag` is provided, its `Tag.contents` will be
            used to extend this object's `Tag.contents`.

        :return The list of PageElements that were appended.
        Destroy all children of this `Tag` by calling
           `PageElement.extract` on them.

        :param decompose: If this is True, `PageElement.decompose` (a
            more destructive method) will be called instead of
            `PageElement.extract`.
        Smooth out the children of this `Tag` by consolidating consecutive
        strings.

        If you perform a lot of operations that modify the tree,
        calling this method afterwards can make pretty-printed output
        look more natural.
        Find the index of a child of this `Tag` (by identity, not value).

        Doing this by identity avoids issues when a `Tag` contains two
        children that have string equality.

        :param element: Look for this `PageElement` in this object's contents.
        Returns the value of the 'key' attribute for the tag, or
        the value given for 'default' if it doesn't have that
        attribute.

        :param key: The attribute to look for.
        :param default: Use this value if the attribute is not present
            on this `Tag`.
        The same as get(), but always returns a (possibly empty) list.

        :param key: The attribute to look for.
        :param default: Use this value if the attribute is not present
            on this `Tag`.
        :return: A list of strings, usually empty or containing only a single
            value.
        Does this `Tag` have an attribute with the given name?tag[key] returns the value of the 'key' attribute for the Tag,
        and throws an exception if it's not there.Setting tag[key] sets the value of the 'key' attribute for the
        tag.Calling a Tag like a function is the same as calling its
        find_all() method. Eg. tag('a') returns a list of all the A tags
        found within this tag.Calling tag.subtag is the same as calling tag.find(name="subtag")Returns true iff this Tag has the same name, the same attributes,
        and the same contents (recursively) as `other`.Returns true iff this Tag is not identical to `other`,
        as defined in __eq__.Renders this `Tag` as a string.Render this `Tag` and its contents as a bytestring.

        :param encoding: The encoding to use when converting to
           a bytestring. This may also affect the text of the document,
           specifically any encoding declarations within the document.
        :param indent_level: Each line of the rendering will be
           indented this many levels. (The ``formatter`` decides what a
           'level' means, in terms of spaces or other characters
           output.) This is used internally in recursive calls while
           pretty-printing.
        :param formatter: Either a `Formatter` object, or a string naming one of
            the standard formatters.
        :param errors: An error handling strategy such as
            'xmlcharrefreplace'. This value is passed along into
            :py:meth:`str.encode` and its value should be one of the `error
            handling constants defined by Python's codecs module
            <https://docs.python.org/3/library/codecs.html
        Render this `Tag` and its contents as a Unicode string.

        :param indent_level: Each line of the rendering will be
           indented this many levels. (The ``formatter`` decides what a
           'level' means, in terms of spaces or other characters
           output.) This is used internally in recursive calls while
           pretty-printing.
        :param encoding: The encoding you intend to use when
           converting the string to a bytestring. decode() is *not*
           responsible for performing that encoding. This information
           is needed so that a real encoding can be substituted in if
           the document contains an encoding declaration (e.g. in a
           <meta> tag).
        :param formatter: Either a `Formatter` object, or a string
            naming one of the standard formatters.
        :param iterator: The iterator to use when navigating over the
            parse tree. This is only used by `Tag.decode_contents` and
            you probably won't need to use it.
        An internal class representing an event in the process
        of traversing a parse tree.

        :meta private:
        Yield a sequence of events that can be used to reconstruct the DOM
        for this element.

        This lets us recreate the nested structure of this element
        (e.g. when formatting it as a string) without using recursive
        method calls.

        This is similar in concept to the SAX API, but it's a simpler
        interface designed for internal use. The events are different
        from SAX and the arguments associated with the events are Tags
        and other Beautiful Soup objects.

        :param iterator: An alternate iterator to use when traversing
         the tree.
        Add indentation whitespace before and/or after a string.

        :param s: The string to amend with whitespace.
        :param indent_level: The indentation level; affects how much
           whitespace goes before the string.
        :param indent_before: Whether or not to add whitespace
           before the string.
        :param indent_after: Whether or not to add whitespace
           (a newline) after the string.
        Should this tag be pretty-printed?

        Most of them should, but some (such as <pre> in HTML
        documents) should not.
        Pretty-print this `Tag` as a string or bytestring.

        :param encoding: The encoding of the bytestring, or None if you want Unicode.
        :param formatter: A Formatter object, or a string naming one of
            the standard formatters.
        :return: A string (if no ``encoding`` is provided) or a bytestring
            (otherwise).
        Renders the contents of this tag as a Unicode string.

        :param indent_level: Each line of the rendering will be
           indented this many levels. (The formatter decides what a
           'level' means in terms of spaces or other characters
           output.) Used internally in recursive calls while
           pretty-printing.

        :param eventual_encoding: The tag is destined to be
           encoded into this encoding. decode_contents() is *not*
           responsible for performing that encoding. This information
           is needed so that a real encoding can be substituted in if
           the document contains an encoding declaration (e.g. in a
           <meta> tag).

        :param formatter: A `Formatter` object, or a string naming one of
            the standard Formatters.
        Renders the contents of this PageElement as a bytestring.

        :param indent_level: Each line of the rendering will be
           indented this many levels. (The ``formatter`` decides what a
           'level' means, in terms of spaces or other characters
           output.) This is used internally in recursive calls while
           pretty-printing.
        :param formatter: Either a `Formatter` object, or a string naming one of
            the standard formatters.
        :param encoding: The bytestring will be in this encoding.
        Deprecated method for BS3 compatibility.

        :meta private:
        Look in the children of this PageElement and find the first
        PageElement that matches the given criteria.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param recursive: If this is True, find() will perform a
            recursive search of this Tag's children. Otherwise,
            only the direct children will be considered.
        :param string: A filter on the `Tag.string` attribute.
        :param limit: Stop looking after finding this many results.
        :kwargs: Additional filters on attribute values.
        Look in the children of this `PageElement` and find all
        `PageElement` objects that match the given criteria.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param recursive: If this is True, find_all() will perform a
            recursive search of this PageElement's children. Otherwise,
            only the direct children will be considered.
        :param limit: Stop looking after finding this many results.
        :param _stacklevel: Used internally to improve warning messages.
        :kwargs: Additional filters on attribute values.
        Iterate over all direct children of this `PageElement`.Iterate over this `Tag` and its children in a
        breadth-first sequence.
        Iterate over all children of this `Tag` in a
        breadth-first sequence.
        Perform a CSS selection operation on the current element.

        :param selector: A CSS selector.

        :param namespaces: A dictionary mapping namespace prefixes
           used in the CSS selector to namespace URIs. By default,
           Beautiful Soup will use the prefixes it encountered while
           parsing the document.

        :param kwargs: Keyword arguments to be passed into Soup Sieve's
           soupsieve.select() method.
        Perform a CSS selection operation on the current element.

        This uses the SoupSieve library.

        :param selector: A string containing a CSS selector.

        :param namespaces: A dictionary mapping namespace prefixes
           used in the CSS selector to namespace URIs. By default,
           Beautiful Soup will use the prefixes it encountered while
           parsing the document.

        :param limit: After finding this number of results, stop looking.

        :param kwargs: Keyword arguments to be passed into SoupSieve's
           soupsieve.select() method.
        Return an interface to the CSS selector API.Deprecated generator.

        :meta private:
        Deprecated generator.

        :meta private:
        Deprecated method. This was kind of misleading because has_key()
        (attributes) was different from __in__ (contents).

        has_key() is gone in Python 3, anyway.

        :meta private:
        A ResultSet is a list of `PageElement` objects, gathered as the result
    of matching an :py:class:`ElementFilter` against a parse tree. Basically, a list of
    search results.
    Raise a helpful exception to explain a common code fix.ResultSet object has no attribute "{key}". You're probably treating a list of elements like a single element. Did you call find_all() when you meant to call find()?"""
        )






from bs4.filter import SoupStrainer 
