import asyncio
import logging
import socket
from abc import ABC, abstractmethod
from collections.abc import Sized
from http.cookies import BaseCookie, Morsel
from typing import (
    TYPE_CHECKING,
    Any,
    Awaitable,
    Callable,
    Dict,
    Generator,
    Iterable,
    List,
    Optional,
    Sequence,
    Tuple,
    TypedDict,
    Union,
)

from multidict import CIMultiDict
from yarl import URL

from ._cookie_helpers import parse_set_cookie_headers
from .typedefs import LooseCookies

if TYPE_CHECKING:
    from .web_app import Application
    from .web_exceptions import HTTPException
    from .web_request import BaseRequest, Request
    from .web_response import StreamResponse
else:
    BaseRequest = Request = Application = StreamResponse = None
    HTTPException = None


class AbstractRouter(ABC):
    def __init__(self) -> None:
        self._frozen = False

    def post_init(self, app: Application) -> None:
        

    @property
    def frozen(self) -> bool:
        return self._frozen

    def freeze(self) -> None:
        
        self._frozen = True

    @abstractmethod
    async def resolve(self, request: Request) -> "AbstractMatchInfo":
        


class AbstractMatchInfo(ABC):

    __slots__ = ()

    @property  
    @abstractmethod
    def handler(self) -> Callable[[Request], Awaitable[StreamResponse]]:
        

    @property
    @abstractmethod
    def expect_handler(
        self,
    ) -> Callable[[Request], Awaitable[Optional[StreamResponse]]]:
        

    @property  
    @abstractmethod
    def http_exception(self) -> Optional[HTTPException]:
        

    @abstractmethod  
    def get_info(self) -> Dict[str, Any]:
        

    @property  
    @abstractmethod
    def apps(self) -> Tuple[Application, ...]:
        

    @abstractmethod
    def add_app(self, app: Application) -> None:
        

    @abstractmethod
    def freeze(self) -> None:
        


class AbstractView(ABC):
    

    def __init__(self, request: Request) -> None:
        self._request = request

    @property
    def request(self) -> Request:
        
        return self._request

    @abstractmethod
    def __await__(self) -> Generator[Any, None, StreamResponse]:
        


class ResolveResult(TypedDict):
    

    hostname: str
    host: str
    port: int
    family: int
    proto: int
    flags: int


class AbstractResolver(ABC):
    

    @abstractmethod
    async def resolve(
        self, host: str, port: int = 0, family: socket.AddressFamily = socket.AF_INET
    ) -> List[ResolveResult]:
        

    @abstractmethod
    async def close(self) -> None:
        


if TYPE_CHECKING:
    IterableBase = Iterable[Morsel[str]]
else:
    IterableBase = Iterable


ClearCookiePredicate = Callable[["Morsel[str]"], bool]


class AbstractCookieJar(Sized, IterableBase):
    

    def __init__(self, *, loop: Optional[asyncio.AbstractEventLoop] = None) -> None:
        self._loop = loop or asyncio.get_running_loop()

    @property
    @abstractmethod
    def quote_cookie(self) -> bool:
        

    @abstractmethod
    def clear(self, predicate: Optional[ClearCookiePredicate] = None) -> None:
        

    @abstractmethod
    def clear_domain(self, domain: str) -> None:
        

    @abstractmethod
    def update_cookies(self, cookies: LooseCookies, response_url: URL = URL()) -> None:
        

    def update_cookies_from_headers(
        self, headers: Sequence[str], response_url: URL
    ) -> None:
        
        if headers and (cookies_to_update := parse_set_cookie_headers(headers)):
            self.update_cookies(cookies_to_update, response_url)

    @abstractmethod
    def filter_cookies(self, request_url: URL) -> "BaseCookie[str]":
        


class AbstractStreamWriter(ABC):
    

    buffer_size: int = 0
    output_size: int = 0
    length: Optional[int] = 0

    @abstractmethod
    async def write(self, chunk: Union[bytes, bytearray, memoryview]) -> None:
        

    @abstractmethod
    async def write_eof(self, chunk: bytes = b"") -> None:
        

    @abstractmethod
    async def drain(self) -> None:
        

    @abstractmethod
    def enable_compression(
        self, encoding: str = "deflate", strategy: Optional[int] = None
    ) -> None:
        

    @abstractmethod
    def enable_chunking(self) -> None:
        

    @abstractmethod
    async def write_headers(
        self, status_line: str, headers: "CIMultiDict[str]"
    ) -> None:
        

    def send_headers(self) -> None:
        


class AbstractAccessLogger(ABC):
    

    __slots__ = ("logger", "log_format")

    def __init__(self, logger: logging.Logger, log_format: str) -> None:
        self.logger = logger
        self.log_format = log_format

    @abstractmethod
    def log(self, request: BaseRequest, response: StreamResponse, time: float) -> None:
        

    @property
    def enabled(self) -> bool:
        
        return True
