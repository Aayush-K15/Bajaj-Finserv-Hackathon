
import copy
import os
import sys
import time
from pathlib import Path


from . import (
    __version__,
    capi_maps,
    cfuncs,
    common_rules,
    f90mod_rules,
    func2subr,
    use_rules,
)
from .auxfuncs import (
    applyrules,
    debugcapi,
    dictappend,
    errmess,
    gentitle,
    getargs2,
    hascallstatement,
    hasexternals,
    hasinitvalue,
    hasnote,
    hasresultnote,
    isarray,
    isarrayofstrings,
    isattr_value,
    ischaracter,
    ischaracter_or_characterarray,
    ischaracterarray,
    iscomplex,
    iscomplexarray,
    iscomplexfunction,
    iscomplexfunction_warn,
    isdummyroutine,
    isexternal,
    isfunction,
    isfunction_wrap,
    isint1,
    isint1array,
    isintent_aux,
    isintent_c,
    isintent_callback,
    isintent_copy,
    isintent_hide,
    isintent_inout,
    isintent_nothide,
    isintent_out,
    isintent_overwrite,
    islogical,
    islong_complex,
    islong_double,
    islong_doublefunction,
    islong_long,
    islong_longfunction,
    ismoduleroutine,
    isoptional,
    isrequired,
    isscalar,
    issigned_long_longarray,
    isstring,
    isstringarray,
    isstringfunction,
    issubroutine,
    issubroutine_wrap,
    isthreadsafe,
    isunsigned,
    isunsigned_char,
    isunsigned_chararray,
    isunsigned_long_long,
    isunsigned_long_longarray,
    isunsigned_short,
    isunsigned_shortarray,
    l_and,
    l_not,
    l_or,
    outmess,
    replace,
    requiresf90wrapper,
    stripcomma,
)

f2py_version = __version__.version
numpy_version = __version__.version

options = {}
sepdict = {}

for k in ['decl',
          'frompyobj',
          'cleanupfrompyobj',
          'topyarr', 'method',
          'pyobjfrom', 'closepyobjfrom',
          'freemem',
          'userincludes',
          'includes0', 'includes', 'typedefs', 'typedefs_generated',
          'cppmacros', 'cfuncs', 'callbacks',
          'latexdoc',
          'restdoc',
          'routine_defs', 'externroutines',
          'initf2pywraphooks',
          'commonhooks', 'initcommonhooks',
          'f90modhooks', 'initf90modhooks']:
    sepdict[k] = '\n'



generationtime = int(os.environ.get('SOURCE_DATE_EPOCH', time.time()))
module_rules = {
    'modulebody':  + time.asctime(time.gmtime(generationtime)) +  + gentitle("See f2py2e/cfuncs.py: includes") +  + gentitle("See f2py2e/rules.py: mod_rules['modulebody']") +  + gentitle("See f2py2e/cfuncs.py: typedefs") +  + gentitle("See f2py2e/cfuncs.py: typedefs_generated") +  + gentitle("See f2py2e/cfuncs.py: cppmacros") +  + gentitle("See f2py2e/cfuncs.py: cfuncs") +  + gentitle("See f2py2e/cfuncs.py: userincludes") +  + gentitle("See f2py2e/capi_rules.py: usercode") +  + gentitle("See f2py2e/capi_rules.py: usercode1") +  + gentitle("See f2py2e/cb_rules.py: buildcallback") +  + gentitle("See f2py2e/rules.py: buildapi") +  + gentitle("See f2py2e/f90mod_rules.py: buildhooks") +  + gentitle("See f2py2e/rules.py: module_rules['modulebody']") +  + gentitle("See f2py2e/common_rules.py: buildhooks") +  + gentitle("See f2py2e/rules.py") + " + numpy_version + ,
    'separatorsfor': {'latexdoc': '\n\n',
                      'restdoc': '\n\n'},
    'latexdoc': ['\\section{Module \\texttt{
                 '
                 '
    'restdoc': ['Module 
                '\n
}

defmod_rules = [
    {'body': '/*eof body*/',
     'method': '/*eof method*/',
     'externroutines': '/*eof externroutines*/',
     'routine_defs': '/*eof routine_defs*/',
     'initf90modhooks': '/*eof initf90modhooks*/',
     'initf2pywraphooks': '/*eof initf2pywraphooks*/',
     'initcommonhooks': '/*eof initcommonhooks*/',
     'latexdoc': '',
     'restdoc': '',
     'modnote': {hasnote: '
     }
]

routine_rules = {
    'separatorsfor': sepdict,
    'body': ,
    'routine_defs': '
    'initf2pywraphooks': '
    'externroutines': '
    'doc': '
    'docshort': '
    'docs': '"    
    'need': ['arrayobject.h', 'CFUNCSMESS', 'MINMAX'],
    'cppmacros': {debugcapi: '
    'latexdoc': ['\\subsection{Wrapper function \\texttt{
                 ],
    'restdoc': ['Wrapped function ``

                ]
}



rout_rules = [
    {  
        'separatorsfor': {'callfortranroutine': '\n', 'routdebugenter': '\n', 'decl': '\n',
                          'routdebugleave': '\n', 'routdebugfailure': '\n',
                          'setjmpbuf': ' || ',
                          'docstrreq': '\n', 'docstropt': '\n', 'docstrout': '\n',
                          'docstrcbs': '\n', 'docstrsigns': '\\n"\n"',
                          'latexdocstrsigns': '\n',
                          'latexdocstrreq': '\n', 'latexdocstropt': '\n',
                          'latexdocstrout': '\n', 'latexdocstrcbs': '\n',
                          },
        'kwlist': '', 'kwlistopt': '', 'callfortran': '', 'callfortranappend': '',
        'docsign': '', 'docsignopt': '', 'decl': '/*decl*/',
        'freemem': '/*freemem*/',
        'docsignshort': '', 'docsignoptshort': '',
        'docstrsigns': '', 'latexdocstrsigns': '',
        'docstrreq': '\\nParameters\\n----------',
        'docstropt': '\\nOther Parameters\\n----------------',
        'docstrout': '\\nReturns\\n-------',
        'docstrcbs': '\\nNotes\\n-----\\nCall-back functions::\\n',
        'latexdocstrreq': '\\noindent Required arguments:',
        'latexdocstropt': '\\noindent Optional arguments:',
        'latexdocstrout': '\\noindent Return objects:',
        'latexdocstrcbs': '\\noindent Call-back functions:',
        'args_capi': '', 'keys_capi': '', 'functype': '',
        'frompyobj': '/*frompyobj*/',
        
        'cleanupfrompyobj': ['/*end of cleanupfrompyobj*/'],
        'pyobjfrom': '/*pyobjfrom*/',
        
        'closepyobjfrom': ['/*end of closepyobjfrom*/'],
        'topyarr': '/*topyarr*/', 'routdebugleave': '/*routdebugleave*/',
        'routdebugenter': '/*routdebugenter*/',
        'routdebugfailure': '/*routdebugfailure*/',
        'callfortranroutine': '/*callfortranroutine*/',
        'argformat': '', 'keyformat': '', 'need_cfuncs': '',
        'docreturn': '', 'return': '', 'returnformat': '', 'rformat': '',
        'kwlistxa': '', 'keys_xa': '', 'xaformat': '', 'docsignxa': '', 'docsignxashort': '',
        'initf2pywraphook': '',
        'routnote': {hasnote: '--- 
    }, {
        'apiname': 'f2py_rout_
        'pyname': '
        'decl': '',
        '_check': l_not(ismoduleroutine)
    }, {
        'apiname': 'f2py_rout_
        'pyname': '
        'decl': '',
        '_check': ismoduleroutine
    }, {  
        'functype': 'void',
        'declfortranroutine': {l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'extern void 
                               l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)): 'extern void 
                               ismoduleroutine: '',
                               isdummyroutine: ''
                               },
        'routine_def': {
            l_not(l_or(ismoduleroutine, isintent_c, isdummyroutine)):
            '    {\"
            '  
            '  (f2py_init_func)
            l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)):
            '    {\"
            '  (f2py_init_func)
            l_and(l_not(ismoduleroutine), isdummyroutine):
            '    {\"
            '  (f2py_init_func)
        },
        'need': {l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'F_FUNC'},
        'callfortranroutine': [
            {debugcapi: [
                \
        if (
            f2py_success = 0;
        } else {        }    fprintf(stderr,\"debug-capi:Fortran subroutine `f2pywrap
            {hasexternals: },
            {isthreadsafe: '    Py_BEGIN_ALLOW_THREADS'},
            {l_not(l_or(hascallstatement, isdummyroutine))
                   : '    (*f2py_func)(
            {hascallstatement:
                '    
            {isthreadsafe: '    Py_END_ALLOW_THREADS'},
            {hasexternals: '    }'}
        ],
        '_check': isfunction_wrap,
    }, {  
        'functype': 'void',
        'declfortranroutine': {l_not(l_or(ismoduleroutine, isdummyroutine)): 'extern void 
                               isdummyroutine: '',
                               },

        'routine_def': {
            l_not(l_or(ismoduleroutine, isdummyroutine)):
            '    {\"
            '  
            '  (f2py_init_func)
            isdummyroutine:
            '    {\"
            '  (f2py_init_func)
        },
        'initf2pywraphook': {l_not(l_or(ismoduleroutine, isdummyroutine)): },
        'need': {l_not(l_or(ismoduleroutine, isdummyroutine)): ['F_WRAPPEDFUNC', 'F_FUNC']},
        'callfortranroutine': [
            {debugcapi: [
                \
    if (
        f2py_success = 0;
    } else {\

    fprintf(stderr,\"debug-capi:Fortran function 

    fprintf(stderr,\"debug-capi:Fortran function 

\
    fprintf(stderr,\"debug-capi:Fortran function 
\
    if (
        f2py_success = 0;
    } else {\
        if (
            f2py_success = 0;
        } else {\

        (*f2py_func)(

        (*f2py_func)(

\
if(F2PyCapsule_Check(
  
} else {
  
}
\
if (
  
  if (
    if (
      if (PyObject_HasAttrString(
        PyObject* capi_tmp = PyObject_GetAttrString(
        if (capi_tmp) {
          
          Py_DECREF(capi_tmp);
        }
        else {
          
        }
        if (
          PyErr_SetString(
          return NULL;
        }
      }
    }
  }
  if (
    PyErr_SetString(
    return NULL;
  }
}
\
    if (create_cb_arglist(
\
        fprintf(stderr,\"debug-capi:Assuming %d arguments; at most 
        CFUNCSMESSPY(\"for 
                         {l_not(isintent_callback): \
        CFUNCSMESS(\"Saving callback variables for `
        
        ],
        'cleanupfrompyobj':
        ,
        'need': ['SWAP', 'create_cb_arglist'],
        '_check': isexternal,
        '_depend': ''
    },
    
    {  
        'decl': '    
        'pyobjfrom': {debugcapi: '    fprintf(stderr,"
        'callfortran': {l_or(isintent_c, isattr_value): '
        'return': {isintent_out: ',
        '_check': l_and(isscalar, l_not(iscomplex))
    }, {
        'need': {hasinitvalue: 'math.h'},
        '_check': l_and(isscalar, l_not(iscomplex)),
    }, {  
        'decl': '    PyObject *
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'args_capi': {isrequired: ',&
        'keys_capi': {isoptional: ',&
        'pyobjfrom': {isintent_inout: },
        'closepyobjfrom': {isintent_inout: "    } /*if (f2py_success) of 
        'need': {isintent_inout: 'try_pyarr_from_
        '_check': l_and(isscalar, l_not(iscomplex), l_not(isstring),
                        isintent_nothide)
    }, {
        'frompyobj': [
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            {hasinitvalue: '    if (
             '_depend': ''},
            {l_and(isoptional, l_not(hasinitvalue)): '    if (
             '_depend': ''},
            {l_not(islogical): },
            {islogical: },
        ],
        'cleanupfrompyobj': '    } /*if (f2py_success) of 
        'need': {l_not(islogical): '
        '_check': l_and(isscalar, l_not(iscomplex), isintent_nothide),
        '_depend': ''
    }, {  
        'frompyobj': {hasinitvalue: '    
        'need': typedef_need_dict,
        '_check': l_and(isscalar, l_not(iscomplex), isintent_hide),
        '_depend': ''
    }, {  
        'frompyobj': {debugcapi: '    fprintf(stderr,"
        '_check': l_and(isscalar, l_not(iscomplex)),
        '_depend': ''
    },
    
    {  
        'decl': '    
        'callfortran': {isintent_c: '
        'pyobjfrom': {debugcapi: '    fprintf(stderr,"
        'return': {isintent_out: ',
        '_check': iscomplex
    }, {  
        'decl': '    PyObject *
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'args_capi': {isrequired: ',&
        'keys_capi': {isoptional: ',&
        'need': {isintent_inout: 'try_pyarr_from_
        'pyobjfrom': {isintent_inout: },
        'closepyobjfrom': {isintent_inout: "        } /*if (f2py_success) of 
        '_check': l_and(iscomplex, isintent_nothide)
    }, {
        'frompyobj': [{hasinitvalue: '    if (
                      {l_and(isoptional, l_not(hasinitvalue))
                             : '    if (
                      '        f2py_success = 
                      '\n    if (f2py_success) {'],
        'cleanupfrompyobj': '    }  /*if (f2py_success) of 
        'need': ['
        '_check': l_and(iscomplex, isintent_nothide),
        '_depend': ''
    }, {  
        'decl': {isintent_out: '    PyObject *
        '_check': l_and(iscomplex, isintent_hide)
    }, {
        'frompyobj': {hasinitvalue: '    
        '_check': l_and(iscomplex, isintent_hide),
        '_depend': ''
    }, {  
        'pyobjfrom': {isintent_out: '    
        'need': ['pyobj_from_
        '_check': iscomplex
    }, {
        'frompyobj': {debugcapi: '    fprintf(stderr,"
        '_check': iscomplex,
        '_depend': ''
    },
    
    {  
        'decl': ['    
                 '    int slen(
                 '    PyObject *
        'callfortran': '
        'callfortranappend': 'slen(
        'pyobjfrom': [
            {debugcapi:
             '    fprintf(stderr,'
             '"
            
            {l_and(isintent_out, l_not(isintent_c)):
             "        STRINGPADN(
        ],
        'return': {isintent_out: ',
        'need': ['len..',
                 {l_and(isintent_out, l_not(isintent_c)): 'STRINGPADN'}],
        '_check': isstring
    }, {  
        'frompyobj': [
            
,
            
            {l_not(isintent_c):
             "        STRINGPADN(
        ],
        'cleanupfrompyobj': \
    if (capi_
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = 
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        
\
        int *_i,capi_i=0;
        CFUNCSMESS(\"
        struct ForcombCache cache;
        if (initforcomb(&cache, PyArray_DIMS(capi_
                        PyArray_NDIM(capi_
            while ((_i = nextforcomb(&cache)))
                
        } else {
            PyObject *exc, *val, *tb;
            PyErr_Fetch(&exc, &val, &tb);
            PyErr_SetString(exc ? exc : 
                \"Initialization of 
            npy_PyErr_ChainExceptionsCause(exc, val, tb);
            f2py_success = 0;
        }
    }
    if (f2py_success) {\
    if((PyObject *)capi_
        Py_XDECREF(capi_
            {l_and(isintent_hide, l_not(isintent_out))
                   : 
    Return
    """
    outmess(f"    Building module \"{m['name']}\"...\n")
    ret = {}
    mod_rules = defmod_rules[:]
    vrd = capi_maps.modsign2map(m)
    rd = dictappend({'f2py_version': f2py_version}, vrd)
    funcwrappers = []
    funcwrappers2 = []  
    for n in m['interfaced']:
        nb = None
        for bi in m['body']:
            if bi['block'] not in ['interface', 'abstract interface']:
                errmess('buildmodule: Expected interface block. Skipping.\n')
                continue
            for b in bi['body']:
                if b['name'] == n:
                    nb = b
                    break

        if not nb:
            print(
                f'buildmodule: Could not find the body of interfaced routine "{n}". Skipping.\n', file=sys.stderr)
            continue
        nb_list = [nb]
        if 'entry' in nb:
            for k, a in nb['entry'].items():
                nb1 = copy.deepcopy(nb)
                del nb1['entry']
                nb1['name'] = k
                nb1['args'] = a
                nb_list.append(nb1)
        for nb in nb_list:
            
            
            isf90 = requiresf90wrapper(nb)
            
            if options['emptygen']:
                b_path = options['buildpath']
                m_name = vrd['modulename']
                outmess('    Generating possibly empty wrappers"\n')
                Path(f"{b_path}/{vrd['coutput']}").touch()
                if isf90:
                    
                    outmess(f'    Maybe empty "{m_name}-f2pywrappers2.f90"\n')
                    Path(f'{b_path}/{m_name}-f2pywrappers2.f90').touch()
                    outmess(f'    Maybe empty "{m_name}-f2pywrappers.f"\n')
                    Path(f'{b_path}/{m_name}-f2pywrappers.f').touch()
                else:
                    
                    outmess(f'    Maybe empty "{m_name}-f2pywrappers.f"\n')
                    Path(f'{b_path}/{m_name}-f2pywrappers.f').touch()
            api, wrap = buildapi(nb)
            if wrap:
                if isf90:
                    funcwrappers2.append(wrap)
                else:
                    funcwrappers.append(wrap)
            ar = applyrules(api, vrd)
            rd = dictappend(rd, ar)

    
    cr, wrap = common_rules.buildhooks(m)
    if wrap:
        funcwrappers.append(wrap)
    ar = applyrules(cr, vrd)
    rd = dictappend(rd, ar)

    
    mr, wrap = f90mod_rules.buildhooks(m)
    if wrap:
        funcwrappers2.append(wrap)
    ar = applyrules(mr, vrd)
    rd = dictappend(rd, ar)

    for u in um:
        ar = use_rules.buildusevars(u, m['use'][u['name']])
        rd = dictappend(rd, ar)

    needs = cfuncs.get_needs()
    
    needs['typedefs'] += [cvar for cvar in capi_maps.f2cmap_mapped  
                          if cvar in typedef_need_dict.values()]
    code = {}
    for n in needs.keys():
        code[n] = []
        for k in needs[n]:
            c = ''
            if k in cfuncs.includes0:
                c = cfuncs.includes0[k]
            elif k in cfuncs.includes:
                c = cfuncs.includes[k]
            elif k in cfuncs.userincludes:
                c = cfuncs.userincludes[k]
            elif k in cfuncs.typedefs:
                c = cfuncs.typedefs[k]
            elif k in cfuncs.typedefs_generated:
                c = cfuncs.typedefs_generated[k]
            elif k in cfuncs.cppmacros:
                c = cfuncs.cppmacros[k]
            elif k in cfuncs.cfuncs:
                c = cfuncs.cfuncs[k]
            elif k in cfuncs.callbacks:
                c = cfuncs.callbacks[k]
            elif k in cfuncs.f90modhooks:
                c = cfuncs.f90modhooks[k]
            elif k in cfuncs.commonhooks:
                c = cfuncs.commonhooks[k]
            else:
                errmess(f'buildmodule: unknown need {repr(k)}.\n')
                continue
            code[n].append(c)
    mod_rules.append(code)
    for r in mod_rules:
        if ('_check' in r and r['_check'](m)) or ('_check' not in r):
            ar = applyrules(r, vrd, m)
            rd = dictappend(rd, ar)
    ar = applyrules(module_rules, rd)

    fn = os.path.join(options['buildpath'], vrd['coutput'])
    ret['csrc'] = fn
    with open(fn, 'w') as f:
        f.write(ar['modulebody'].replace('\t', 2 * ' '))
    outmess(f"    Wrote C/API module \"{m['name']}\" to file \"{fn}\"\n")

    if options['dorestdoc']:
        fn = os.path.join(
            options['buildpath'], vrd['modulename'] + 'module.rest')
        with open(fn, 'w') as f:
            f.write('.. -*- rest -*-\n')
            f.write('\n'.join(ar['restdoc']))
        outmess('    ReST Documentation is saved to file "%s/%smodule.rest"\n' %
                (options['buildpath'], vrd['modulename']))
    if options['dolatexdoc']:
        fn = os.path.join(
            options['buildpath'], vrd['modulename'] + 'module.tex')
        ret['ltx'] = fn
        with open(fn, 'w') as f:
            f.write(
                f'% This file is auto-generated with f2py (version:{f2py_version})\n')
            if 'shortlatex' not in options:
                f.write(
                    '\\documentclass{article}\n\\usepackage{a4wide}\n\\begin{document}\n\\tableofcontents\n\n')
                f.write('\n'.join(ar['latexdoc']))
            if 'shortlatex' not in options:
                f.write('\\end{document}')
        outmess('    Documentation is saved to file "%s/%smodule.tex"\n' %
                (options['buildpath'], vrd['modulename']))
    if funcwrappers:
        wn = os.path.join(options['buildpath'], vrd['f2py_wrapper_output'])
        ret['fsrc'] = wn
        with open(wn, 'w') as f:
            f.write('C     -*- fortran -*-\n')
            f.write(
                f'C     This file is autogenerated with f2py (version:{f2py_version})\n')
            f.write(
                'C     It contains Fortran 77 wrappers to fortran functions.\n')
            lines = []
            for l in ('\n\n'.join(funcwrappers) + '\n').split('\n'):
                if 0 <= l.find('!') < 66:
                    
                    lines.append(l + '\n')
                elif l and l[0] == ' ':
                    while len(l) >= 66:
                        lines.append(l[:66] + '\n     &')
                        l = l[66:]
                    lines.append(l + '\n')
                else:
                    lines.append(l + '\n')
            lines = ''.join(lines).replace('\n     &\n', '\n')
            f.write(lines)
        outmess(f'    Fortran 77 wrappers are saved to "{wn}\"\n')
    if funcwrappers2:
        wn = os.path.join(
            options['buildpath'], f"{vrd['modulename']}-f2pywrappers2.f90")
        ret['fsrc'] = wn
        with open(wn, 'w') as f:
            f.write('!     -*- f90 -*-\n')
            f.write(
                f'!     This file is autogenerated with f2py (version:{f2py_version})\n')
            f.write(
                '!     It contains Fortran 90 wrappers to fortran functions.\n')
            lines = []
            for l in ('\n\n'.join(funcwrappers2) + '\n').split('\n'):
                if 0 <= l.find('!') < 72:
                    
                    lines.append(l + '\n')
                elif len(l) > 72 and l[0] == ' ':
                    lines.append(l[:72] + '&\n     &')
                    l = l[72:]
                    while len(l) > 66:
                        lines.append(l[:66] + '&\n     &')
                        l = l[66:]
                    lines.append(l + '\n')
                else:
                    lines.append(l + '\n')
            lines = ''.join(lines).replace('\n     &\n', '\n')
            f.write(lines)
        outmess(f'    Fortran 90 wrappers are saved to "{wn}\"\n')
    return ret




stnd = {1: 'st', 2: 'nd', 3: 'rd', 4: 'th', 5: 'th',
        6: 'th', 7: 'th', 8: 'th', 9: 'th', 0: 'th'}


def buildapi(rout):
    rout, wrap = func2subr.assubr(rout)
    args, depargs = getargs2(rout)
    capi_maps.depargs = depargs
    var = rout['vars']

    if ismoduleroutine(rout):
        outmess('            Constructing wrapper function "%s.%s"...\n' %
                (rout['modulename'], rout['name']))
    else:
        outmess(f"        Constructing wrapper function \"{rout['name']}\"...\n")
    
    vrd = capi_maps.routsign2map(rout)
    rd = dictappend({}, vrd)
    for r in rout_rules:
        if ('_check' in r and r['_check'](rout)) or ('_check' not in r):
            ar = applyrules(r, vrd, rout)
            rd = dictappend(rd, ar)

    
    nth, nthk = 0, 0
    savevrd = {}
    for a in args:
        vrd = capi_maps.sign2map(a, var[a])
        if isintent_aux(var[a]):
            _rules = aux_rules
        else:
            _rules = arg_rules
            if not isintent_hide(var[a]):
                if not isoptional(var[a]):
                    nth = nth + 1
                    vrd['nth'] = repr(nth) + stnd[nth % 10] + ' argument'
                else:
                    nthk = nthk + 1
                    vrd['nth'] = repr(nthk) + stnd[nthk % 10] + ' keyword'
            else:
                vrd['nth'] = 'hidden'
        savevrd[a] = vrd
        for r in _rules:
            if '_depend' in r:
                continue
            if ('_check' in r and r['_check'](var[a])) or ('_check' not in r):
                ar = applyrules(r, vrd, var[a])
                rd = dictappend(rd, ar)
                if '_break' in r:
                    break
    for a in depargs:
        if isintent_aux(var[a]):
            _rules = aux_rules
        else:
            _rules = arg_rules
        vrd = savevrd[a]
        for r in _rules:
            if '_depend' not in r:
                continue
            if ('_check' in r and r['_check'](var[a])) or ('_check' not in r):
                ar = applyrules(r, vrd, var[a])
                rd = dictappend(rd, ar)
                if '_break' in r:
                    break
        if 'check' in var[a]:
            for c in var[a]['check']:
                vrd['check'] = c
                ar = applyrules(check_rules, vrd, var[a])
                rd = dictappend(rd, ar)
    if isinstance(rd['cleanupfrompyobj'], list):
        rd['cleanupfrompyobj'].reverse()
    if isinstance(rd['closepyobjfrom'], list):
        rd['closepyobjfrom'].reverse()
    rd['docsignature'] = stripcomma(replace('
                                            {'docsign': rd['docsign'],
                                             'docsignopt': rd['docsignopt'],
                                             'docsignxa': rd['docsignxa']}))
    optargs = stripcomma(replace('
                                 {'docsignxa': rd['docsignxashort'],
                                  'docsignopt': rd['docsignoptshort']}
                                 ))
    if optargs == '':
        rd['docsignatureshort'] = stripcomma(
            replace('
    else:
        rd['docsignatureshort'] = replace('
                                          {'docsign': rd['docsign'],
                                           'docsignopt': optargs,
                                           })
    rd['latexdocsignatureshort'] = rd['docsignatureshort'].replace('_', '\\_')
    rd['latexdocsignatureshort'] = rd[
        'latexdocsignatureshort'].replace(',', ', ')
    cfs = stripcomma(replace('
                     'callfortran': rd['callfortran'], 'callfortranappend': rd['callfortranappend']}))
    if len(rd['callfortranappend']) > 1:
        rd['callcompaqfortran'] = stripcomma(replace('
                                             'callfortran': rd['callfortran'], 'callfortranappend': rd['callfortranappend']}))
    else:
        rd['callcompaqfortran'] = cfs
    rd['callfortran'] = cfs
    if isinstance(rd['docreturn'], list):
        rd['docreturn'] = stripcomma(
            replace('
    rd['docstrsigns'] = []
    rd['latexdocstrsigns'] = []
    for k in ['docstrreq', 'docstropt', 'docstrout', 'docstrcbs']:
        if k in rd and isinstance(rd[k], list):
            rd['docstrsigns'] = rd['docstrsigns'] + rd[k]
        k = 'latex' + k
        if k in rd and isinstance(rd[k], list):
            rd['latexdocstrsigns'] = rd['latexdocstrsigns'] + rd[k][0:1] +\
                ['\\begin{description}'] + rd[k][1:] +\
                ['\\end{description}']

    ar = applyrules(routine_rules, rd)
    if ismoduleroutine(rout):
        outmess(f"              {ar['docshort']}\n")
    else:
        outmess(f"          {ar['docshort']}\n")
    return ar, wrap



