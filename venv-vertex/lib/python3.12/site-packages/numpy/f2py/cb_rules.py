
from . import __version__, cfuncs
from .auxfuncs import (
    applyrules,
    debugcapi,
    dictappend,
    errmess,
    getargs,
    hasnote,
    isarray,
    iscomplex,
    iscomplexarray,
    iscomplexfunction,
    isfunction,
    isintent_c,
    isintent_hide,
    isintent_in,
    isintent_inout,
    isintent_nothide,
    isintent_out,
    isoptional,
    isrequired,
    isscalar,
    isstring,
    isstringfunction,
    issubroutine,
    l_and,
    l_not,
    l_or,
    outmess,
    replace,
    stripcomma,
    throw_error,
)

f2py_version = __version__.version




cb_routine_rules = {
    'cbtypedefs': 'typedef 
    'body': ,
    'need': ['setjmp.h', 'CFUNCSMESS', 'F2PY_THREAD_LOCAL_DECL'],
    'maxnofargs': '
    'nofoptargs': '
    'docstr': 
{{}\\verb@def 



    'docstrshort': 'def 
}
cb_rout_rules = [
    {  
        'separatorsfor': {'decl': '\n',
                          'args': ',', 'optargs': '', 'pyobjfrom': '\n', 'freemem': '\n',
                          'args_td': ',', 'optargs_td': '',
                          'args_nm': ',', 'optargs_nm': '',
                          'frompyobj': '\n', 'setdims': '\n',
                          'docstrsigns': '\\n"\n"',
                          'latexdocstrsigns': '\n',
                          'latexdocstrreq': '\n', 'latexdocstropt': '\n',
                          'latexdocstrout': '\n', 'latexdocstrcbs': '\n',
                          },
        'decl': '/*decl*/', 'pyobjfrom': '/*pyobjfrom*/', 'frompyobj': '/*frompyobj*/',
        'args': [], 'optargs': '', 'return': '', 'strarglens': '', 'freemem': '/*freemem*/',
        'args_td': [], 'optargs_td': '', 'strarglens_td': '',
        'args_nm': [], 'optargs_nm': '', 'strarglens_nm': '',
        'noargs': '',
        'setdims': '/*setdims*/',
        'docstrsigns': '', 'latexdocstrsigns': '',
        'docstrreq': '    Required arguments:',
        'docstropt': '    Optional arguments:',
        'docstrout': '    Return objects:',
        'docstrcbs': '    Call-back functions:',
        'docreturn': '', 'docsign': '', 'docsignopt': '',
        'latexdocstrreq': '\\noindent Required arguments:',
        'latexdocstropt': '\\noindent Optional arguments:',
        'latexdocstrout': '\\noindent Return objects:',
        'latexdocstrcbs': '\\noindent Call-back functions:',
        'routnote': {hasnote: '--- 
    }, {  
        'decl': '    
        'frompyobj': [
            {debugcapi: '    CFUNCSMESS("cb:Getting return_value->");'},
            ,
            {debugcapi:
             '    fprintf(stderr,"
        ],
        'need': ['
        'return': '    return return_value;',
        '_check': l_and(isfunction, l_not(isstringfunction), l_not(iscomplexfunction))
    },
    {  
        'pyobjfrom': {debugcapi: '    fprintf(stderr,"debug-capi:cb:
        'args': '
        'args_nm': 'return_value,&return_value_len',
        'args_td': '
        'frompyobj': [
            {debugcapi: '    CFUNCSMESS("cb:Getting return_value->\\"");'},
            ,
            {debugcapi:
             '    fprintf(stderr,"
        ],
        'need': ['
                 'string.h', 'GETSTRFROMPYTUPLE'],
        'return': 'return;',
        '_check': isstringfunction
    },
    {  
        'optargs': ,
        'optargs_nm': ,
        'optargs_td': ,
        'decl': ,
        'frompyobj': [
            {debugcapi: '    CFUNCSMESS("cb:Getting return_value->");'},
            ,
            {debugcapi: }
        ],
        'return': ,
        'need': ['
                 'string.h', 'GETSCALARFROMPYTUPLE', '
        '_check': iscomplexfunction
    },
    {'docstrout': '        
     'latexdocstrout': ['\\item[]{{}\\verb@
                        {hasnote: '--- 
     'docreturn': '
     '_check': isfunction},
    {'_check': issubroutine, 'return': 'return;'}
]

cb_arg_rules = [
    {  
        'docstropt': {l_and(isoptional, isintent_nothide): '        
        'docstrreq': {l_and(isrequired, isintent_nothide): '        
        'docstrout': {isintent_out: '        
        'latexdocstropt': {l_and(isoptional, isintent_nothide): ['\\item[]{{}\\verb@
                                                                 {hasnote: '--- 
        'latexdocstrreq': {l_and(isrequired, isintent_nothide): ['\\item[]{{}\\verb@
                                                                 {hasnote: '--- 
        'latexdocstrout': {isintent_out: ['\\item[]{{}\\verb@
                                          {l_and(hasnote, isintent_hide): '--- 
                                           l_and(hasnote, isintent_nothide): '--- See above.'}]},
        'docsign': {l_and(isrequired, isintent_nothide): '
        'docsignopt': {l_and(isoptional, isintent_nothide): '
        'depend': ''
    },
    {
        'args': {
            l_and(isscalar, isintent_c): '
            l_and(isscalar, l_not(isintent_c)): '
            isarray: '
            isstring: '
        },
        'args_nm': {
            l_and(isscalar, isintent_c): '
            l_and(isscalar, l_not(isintent_c)): '
            isarray: '
            isstring: '
        },
        'args_td': {
            l_and(isscalar, isintent_c): '
            l_and(isscalar, l_not(isintent_c)): '
            isarray: '
            isstring: '
        },
        'need': {l_or(isscalar, isarray, isstring): '
        
        'strarglens': {isstring: ',int 
        'strarglens_td': {isstring: ',int'},  
        
        'strarglens_nm': {isstring: ',
    },
    {  
        'decl': {l_not(isintent_c): '    
        'error': {l_and(isintent_c, isintent_out,
                        throw_error('intent(c,out) is forbidden for callback scalar arguments')):
                  ''},
        'frompyobj': [{debugcapi: '    CFUNCSMESS("cb:Getting 
                      {isintent_out:
                       '    if (capi_j>capi_i)\n        GETSCALARFROMPYTUPLE(capi_return,capi_i++,
                      {l_and(debugcapi, l_and(l_not(iscomplex), isintent_c)):
                          '    fprintf(stderr,"
                      {l_and(debugcapi, l_and(l_not(iscomplex), l_not(isintent_c))):
                          '    fprintf(stderr,"
                      {l_and(debugcapi, l_and(iscomplex, isintent_c)):
                          '    fprintf(stderr,"
                      {l_and(debugcapi, l_and(iscomplex, l_not(isintent_c))):
                          '    fprintf(stderr,"
                      ],
        'need': [{isintent_out: ['
                 {debugcapi: 'CFUNCSMESS'}],
        '_check': isscalar
    }, {
        'pyobjfrom': [{isintent_in: },
                      {isintent_inout: }],
        'need': [{isintent_in: 'pyobj_from_
                 {isintent_inout: 'pyarr_from_p_
                 {iscomplex: '
        '_check': l_and(isscalar, isintent_nothide),
        '_optional': ''
    }, {  
        'frompyobj': [{debugcapi: '    CFUNCSMESS("cb:Getting 
                      \
    if (cb->nofargs>capi_i)
        if (CAPI_ARGLIST_SETITEM(capi_i++,pyobj_from_
            goto capi_fail;\
    if (cb->nofargs>capi_i) {
        int 
        if (CAPI_ARGLIST_SETITEM(capi_i++,pyarr_from_p_
            goto capi_fail;
    }\
    if (cb->nofargs>capi_i) {
        /* tmp_arr will be inserted to capi_arglist_list that will be
           destroyed when leaving callback function wrapper together
           with tmp_arr. */
        PyArrayObject *tmp_arr = (PyArrayObject *)PyArray_New(&PyArray_Type,
          
          NPY_ARRAY_CARRAY,NULL);
\
    if (cb->nofargs>capi_i) {
        /* tmp_arr will be inserted to capi_arglist_list that will be
           destroyed when leaving callback function wrapper together
           with tmp_arr. */
        PyArrayObject *tmp_arr = (PyArrayObject *)PyArray_New(&PyArray_Type,
          
          NPY_ARRAY_FARRAY,NULL);

        if (tmp_arr==NULL)
            goto capi_fail;
        if (CAPI_ARGLIST_SETITEM(capi_i++,(PyObject *)tmp_arr))
            goto capi_fail;
}    if (capi_j>capi_i) {
        PyArrayObject *rv_cb_arr = NULL;
        if ((capi_tmp = PyTuple_GetItem(capi_return,capi_i++))==NULL) goto capi_fail;
        rv_cb_arr =  array_from_pyobj(
                      {isintent_c: '|F2PY_INTENT_C'},
                      ,
                      {debugcapi: '    fprintf(stderr,"<-.\\n");'},
                      ],
        'need': ['MEMCOPY', {iscomplexarray: '
        '_check': l_and(isarray, isintent_out)
    }, {
        'docreturn': '
        '_check': isintent_out
    }
]


cb_map = {}


def buildcallbacks(m):
    cb_map[m['name']] = []
    for bi in m['body']:
        if bi['block'] == 'interface':
            for b in bi['body']:
                if b:
                    buildcallback(b, m['name'])
                else:
                    errmess(f"warning: empty body for {m['name']}\n")


def buildcallback(rout, um):
    from . import capi_maps

    outmess(f"    Constructing call-back function \"cb_{rout['name']}_in_{um}\"\n")
    args, depargs = getargs(rout)
    capi_maps.depargs = depargs
    var = rout['vars']
    vrd = capi_maps.cb_routsign2map(rout, um)
    rd = dictappend({}, vrd)
    cb_map[um].append([rout['name'], rd['name']])
    for r in cb_rout_rules:
        if ('_check' in r and r['_check'](rout)) or ('_check' not in r):
            ar = applyrules(r, vrd, rout)
            rd = dictappend(rd, ar)
    savevrd = {}
    for i, a in enumerate(args):
        vrd = capi_maps.cb_sign2map(a, var[a], index=i)
        savevrd[a] = vrd
        for r in cb_arg_rules:
            if '_depend' in r:
                continue
            if '_optional' in r and isoptional(var[a]):
                continue
            if ('_check' in r and r['_check'](var[a])) or ('_check' not in r):
                ar = applyrules(r, vrd, var[a])
                rd = dictappend(rd, ar)
                if '_break' in r:
                    break
    for a in args:
        vrd = savevrd[a]
        for r in cb_arg_rules:
            if '_depend' in r:
                continue
            if ('_optional' not in r) or ('_optional' in r and isrequired(var[a])):
                continue
            if ('_check' in r and r['_check'](var[a])) or ('_check' not in r):
                ar = applyrules(r, vrd, var[a])
                rd = dictappend(rd, ar)
                if '_break' in r:
                    break
    for a in depargs:
        vrd = savevrd[a]
        for r in cb_arg_rules:
            if '_depend' not in r:
                continue
            if '_optional' in r:
                continue
            if ('_check' in r and r['_check'](var[a])) or ('_check' not in r):
                ar = applyrules(r, vrd, var[a])
                rd = dictappend(rd, ar)
                if '_break' in r:
                    break
    if 'args' in rd and 'optargs' in rd:
        if isinstance(rd['optargs'], list):
            rd['optargs'] = rd['optargs'] + []
            rd['optargs_nm'] = rd['optargs_nm'] + []
            rd['optargs_td'] = rd['optargs_td'] + []
    if isinstance(rd['docreturn'], list):
        rd['docreturn'] = stripcomma(
            replace('
    optargs = stripcomma(replace('
                                 {'docsignopt': rd['docsignopt']}
                                 ))
    if optargs == '':
        rd['docsignature'] = stripcomma(
            replace('
    else:
        rd['docsignature'] = replace('
                                     {'docsign': rd['docsign'],
                                      'docsignopt': optargs,
                                      })
    rd['latexdocsignature'] = rd['docsignature'].replace('_', '\\_')
    rd['latexdocsignature'] = rd['latexdocsignature'].replace(',', ', ')
    rd['docstrsigns'] = []
    rd['latexdocstrsigns'] = []
    for k in ['docstrreq', 'docstropt', 'docstrout', 'docstrcbs']:
        if k in rd and isinstance(rd[k], list):
            rd['docstrsigns'] = rd['docstrsigns'] + rd[k]
        k = 'latex' + k
        if k in rd and isinstance(rd[k], list):
            rd['latexdocstrsigns'] = rd['latexdocstrsigns'] + rd[k][0:1] +\
                ['\\begin{description}'] + rd[k][1:] +\
                ['\\end{description}']
    if 'args' not in rd:
        rd['args'] = ''
        rd['args_td'] = ''
        rd['args_nm'] = ''
    if not (rd.get('args') or rd.get('optargs') or rd.get('strarglens')):
        rd['noargs'] = 'void'

    ar = applyrules(cb_routine_rules, rd)
    cfuncs.callbacks[rd['name']] = ar['body']
    if isinstance(ar['need'], str):
        ar['need'] = [ar['need']]

    if 'need' in rd:
        for t in cfuncs.typedefs.keys():
            if t in rd['need']:
                ar['need'].append(t)

    cfuncs.typedefs_generated[rd['name'] + '_typedef'] = ar['cbtypedefs']
    ar['need'].append(rd['name'] + '_typedef')
    cfuncs.needs[rd['name']] = ar['need']

    capi_maps.lcb2_map[rd['name']] = {'maxnofargs': ar['maxnofargs'],
                                      'nofoptargs': ar['nofoptargs'],
                                      'docstr': ar['docstr'],
                                      'latexdocstr': ar['latexdocstr'],
                                      'argname': rd['argname']
                                      }
    outmess(f"      {ar['docstrshort']}\n")

