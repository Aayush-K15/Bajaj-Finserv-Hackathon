

import functools
import sys

import numpy as np
from numpy import (
    add,
    equal,
    greater,
    greater_equal,
    less,
    less_equal,
    not_equal,
)
from numpy import (
    multiply as _multiply_ufunc,
)
from numpy._core.multiarray import _vec_string
from numpy._core.overrides import array_function_dispatch, set_module
from numpy._core.umath import (
    _center,
    _expandtabs,
    _expandtabs_length,
    _ljust,
    _lstrip_chars,
    _lstrip_whitespace,
    _partition,
    _partition_index,
    _replace,
    _rjust,
    _rpartition,
    _rpartition_index,
    _rstrip_chars,
    _rstrip_whitespace,
    _slice,
    _strip_chars,
    _strip_whitespace,
    _zfill,
    isalnum,
    isalpha,
    isdecimal,
    isdigit,
    islower,
    isnumeric,
    isspace,
    istitle,
    isupper,
    str_len,
)
from numpy._core.umath import (
    count as _count_ufunc,
)
from numpy._core.umath import (
    endswith as _endswith_ufunc,
)
from numpy._core.umath import (
    find as _find_ufunc,
)
from numpy._core.umath import (
    index as _index_ufunc,
)
from numpy._core.umath import (
    rfind as _rfind_ufunc,
)
from numpy._core.umath import (
    rindex as _rindex_ufunc,
)
from numpy._core.umath import (
    startswith as _startswith_ufunc,
)


def _override___module__():
    for ufunc in [
        isalnum, isalpha, isdecimal, isdigit, islower, isnumeric, isspace,
        istitle, isupper, str_len,
    ]:
        ufunc.__module__ = "numpy.strings"
        ufunc.__qualname__ = ufunc.__name__


_override___module__()


__all__ = [
    
    "equal", "not_equal", "less", "less_equal", "greater", "greater_equal",
    "add", "multiply", "isalpha", "isdigit", "isspace", "isalnum", "islower",
    "isupper", "istitle", "isdecimal", "isnumeric", "str_len", "find",
    "rfind", "index", "rindex", "count", "startswith", "endswith", "lstrip",
    "rstrip", "strip", "replace", "expandtabs", "center", "ljust", "rjust",
    "zfill", "partition", "rpartition", "slice",

    
    "upper", "lower", "swapcase", "capitalize", "title",

    
    "mod", "decode", "encode", "translate",

    
    
]


MAX = np.iinfo(np.int64).max

array_function_dispatch = functools.partial(
    array_function_dispatch, module='numpy.strings')


def _get_num_chars(a):
    
    if issubclass(a.dtype.type, np.str_):
        return a.itemsize // 4
    return a.itemsize


def _to_bytes_or_str_array(result, output_dtype_like):
    
    output_dtype_like = np.asarray(output_dtype_like)
    if result.size == 0:
        
        
        return result.astype(output_dtype_like.dtype)
    ret = np.asarray(result.tolist())
    if isinstance(output_dtype_like.dtype, np.dtypes.StringDType):
        return ret.astype(type(output_dtype_like.dtype))
    return ret.astype(type(output_dtype_like.dtype)(_get_num_chars(ret)))


def _clean_args(*args):
    
    newargs = []
    for chk in args:
        if chk is None:
            break
        newargs.append(chk)
    return newargs


def _multiply_dispatcher(a, i):
    return (a,)


@set_module("numpy.strings")
@array_function_dispatch(_multiply_dispatcher)
def multiply(a, i):
    
    a = np.asanyarray(a)

    i = np.asanyarray(i)
    if not np.issubdtype(i.dtype, np.integer):
        raise TypeError(f"unsupported type {i.dtype} for operand 'i'")
    i = np.maximum(i, 0)

    
    if a.dtype.char == "T":
        return a * i

    a_len = str_len(a)

    
    if np.any(a_len > sys.maxsize / np.maximum(i, 1)):
        raise OverflowError("Overflow encountered in string multiply")

    buffersizes = a_len * i
    out_dtype = f"{a.dtype.char}{buffersizes.max()}"
    out = np.empty_like(a, shape=buffersizes.shape, dtype=out_dtype)
    return _multiply_ufunc(a, i, out=out)


def _mod_dispatcher(a, values):
    return (a, values)


@set_module("numpy.strings")
@array_function_dispatch(_mod_dispatcher)
def mod(a, values):
    
    return _to_bytes_or_str_array(
        _vec_string(a, np.object_, '__mod__', (values,)), a)


@set_module("numpy.strings")
def find(a, sub, start=0, end=None):
    
    end = end if end is not None else MAX
    return _find_ufunc(a, sub, start, end)


@set_module("numpy.strings")
def rfind(a, sub, start=0, end=None):
    
    end = end if end is not None else MAX
    return _rfind_ufunc(a, sub, start, end)


@set_module("numpy.strings")
def index(a, sub, start=0, end=None):
    
    end = end if end is not None else MAX
    return _index_ufunc(a, sub, start, end)


@set_module("numpy.strings")
def rindex(a, sub, start=0, end=None):
    
    end = end if end is not None else MAX
    return _rindex_ufunc(a, sub, start, end)


@set_module("numpy.strings")
def count(a, sub, start=0, end=None):
    
    end = end if end is not None else MAX
    return _count_ufunc(a, sub, start, end)


@set_module("numpy.strings")
def startswith(a, prefix, start=0, end=None):
    
    end = end if end is not None else MAX
    return _startswith_ufunc(a, prefix, start, end)


@set_module("numpy.strings")
def endswith(a, suffix, start=0, end=None):
    
    end = end if end is not None else MAX
    return _endswith_ufunc(a, suffix, start, end)


def _code_dispatcher(a, encoding=None, errors=None):
    return (a,)


@set_module("numpy.strings")
@array_function_dispatch(_code_dispatcher)
def decode(a, encoding=None, errors=None):
    r
    return _to_bytes_or_str_array(
        _vec_string(a, np.object_, 'decode', _clean_args(encoding, errors)),
        np.str_(''))


@set_module("numpy.strings")
@array_function_dispatch(_code_dispatcher)
def encode(a, encoding=None, errors=None):
    
    return _to_bytes_or_str_array(
        _vec_string(a, np.object_, 'encode', _clean_args(encoding, errors)),
        np.bytes_(b''))


def _expandtabs_dispatcher(a, tabsize=None):
    return (a,)


@set_module("numpy.strings")
@array_function_dispatch(_expandtabs_dispatcher)
def expandtabs(a, tabsize=8):
    
    a = np.asanyarray(a)
    tabsize = np.asanyarray(tabsize)

    if a.dtype.char == "T":
        return _expandtabs(a, tabsize)

    buffersizes = _expandtabs_length(a, tabsize)
    out_dtype = f"{a.dtype.char}{buffersizes.max()}"
    out = np.empty_like(a, shape=buffersizes.shape, dtype=out_dtype)
    return _expandtabs(a, tabsize, out=out)


def _just_dispatcher(a, width, fillchar=None):
    return (a,)


@set_module("numpy.strings")
@array_function_dispatch(_just_dispatcher)
def center(a, width, fillchar=' '):
    
    width = np.asanyarray(width)

    if not np.issubdtype(width.dtype, np.integer):
        raise TypeError(f"unsupported type {width.dtype} for operand 'width'")

    a = np.asanyarray(a)
    fillchar = np.asanyarray(fillchar)

    if np.any(str_len(fillchar) != 1):
        raise TypeError(
            "The fill character must be exactly one character long")

    if np.result_type(a, fillchar).char == "T":
        return _center(a, width, fillchar)

    fillchar = fillchar.astype(a.dtype, copy=False)
    width = np.maximum(str_len(a), width)
    out_dtype = f"{a.dtype.char}{width.max()}"
    shape = np.broadcast_shapes(a.shape, width.shape, fillchar.shape)
    out = np.empty_like(a, shape=shape, dtype=out_dtype)

    return _center(a, width, fillchar, out=out)


@set_module("numpy.strings")
@array_function_dispatch(_just_dispatcher)
def ljust(a, width, fillchar=' '):
    
    width = np.asanyarray(width)
    if not np.issubdtype(width.dtype, np.integer):
        raise TypeError(f"unsupported type {width.dtype} for operand 'width'")

    a = np.asanyarray(a)
    fillchar = np.asanyarray(fillchar)

    if np.any(str_len(fillchar) != 1):
        raise TypeError(
            "The fill character must be exactly one character long")

    if np.result_type(a, fillchar).char == "T":
        return _ljust(a, width, fillchar)

    fillchar = fillchar.astype(a.dtype, copy=False)
    width = np.maximum(str_len(a), width)
    shape = np.broadcast_shapes(a.shape, width.shape, fillchar.shape)
    out_dtype = f"{a.dtype.char}{width.max()}"
    out = np.empty_like(a, shape=shape, dtype=out_dtype)

    return _ljust(a, width, fillchar, out=out)


@set_module("numpy.strings")
@array_function_dispatch(_just_dispatcher)
def rjust(a, width, fillchar=' '):
    
    width = np.asanyarray(width)
    if not np.issubdtype(width.dtype, np.integer):
        raise TypeError(f"unsupported type {width.dtype} for operand 'width'")

    a = np.asanyarray(a)
    fillchar = np.asanyarray(fillchar)

    if np.any(str_len(fillchar) != 1):
        raise TypeError(
            "The fill character must be exactly one character long")

    if np.result_type(a, fillchar).char == "T":
        return _rjust(a, width, fillchar)

    fillchar = fillchar.astype(a.dtype, copy=False)
    width = np.maximum(str_len(a), width)
    shape = np.broadcast_shapes(a.shape, width.shape, fillchar.shape)
    out_dtype = f"{a.dtype.char}{width.max()}"
    out = np.empty_like(a, shape=shape, dtype=out_dtype)

    return _rjust(a, width, fillchar, out=out)


def _zfill_dispatcher(a, width):
    return (a,)


@set_module("numpy.strings")
@array_function_dispatch(_zfill_dispatcher)
def zfill(a, width):
    
    width = np.asanyarray(width)
    if not np.issubdtype(width.dtype, np.integer):
        raise TypeError(f"unsupported type {width.dtype} for operand 'width'")

    a = np.asanyarray(a)

    if a.dtype.char == "T":
        return _zfill(a, width)

    width = np.maximum(str_len(a), width)
    shape = np.broadcast_shapes(a.shape, width.shape)
    out_dtype = f"{a.dtype.char}{width.max()}"
    out = np.empty_like(a, shape=shape, dtype=out_dtype)
    return _zfill(a, width, out=out)


@set_module("numpy.strings")
def lstrip(a, chars=None):
    
    if chars is None:
        return _lstrip_whitespace(a)
    return _lstrip_chars(a, chars)


@set_module("numpy.strings")
def rstrip(a, chars=None):
    
    if chars is None:
        return _rstrip_whitespace(a)
    return _rstrip_chars(a, chars)


@set_module("numpy.strings")
def strip(a, chars=None):
    
    if chars is None:
        return _strip_whitespace(a)
    return _strip_chars(a, chars)


def _unary_op_dispatcher(a):
    return (a,)


@set_module("numpy.strings")
@array_function_dispatch(_unary_op_dispatcher)
def upper(a):
    
    a_arr = np.asarray(a)
    return _vec_string(a_arr, a_arr.dtype, 'upper')


@set_module("numpy.strings")
@array_function_dispatch(_unary_op_dispatcher)
def lower(a):
    
    a_arr = np.asarray(a)
    return _vec_string(a_arr, a_arr.dtype, 'lower')


@set_module("numpy.strings")
@array_function_dispatch(_unary_op_dispatcher)
def swapcase(a):
    
    a_arr = np.asarray(a)
    return _vec_string(a_arr, a_arr.dtype, 'swapcase')


@set_module("numpy.strings")
@array_function_dispatch(_unary_op_dispatcher)
def capitalize(a):
    
    a_arr = np.asarray(a)
    return _vec_string(a_arr, a_arr.dtype, 'capitalize')


@set_module("numpy.strings")
@array_function_dispatch(_unary_op_dispatcher)
def title(a):
    
    a_arr = np.asarray(a)
    return _vec_string(a_arr, a_arr.dtype, 'title')


def _replace_dispatcher(a, old, new, count=None):
    return (a,)


@set_module("numpy.strings")
@array_function_dispatch(_replace_dispatcher)
def replace(a, old, new, count=-1):
    
    count = np.asanyarray(count)
    if not np.issubdtype(count.dtype, np.integer):
        raise TypeError(f"unsupported type {count.dtype} for operand 'count'")

    arr = np.asanyarray(a)
    old_dtype = getattr(old, 'dtype', None)
    old = np.asanyarray(old)
    new_dtype = getattr(new, 'dtype', None)
    new = np.asanyarray(new)

    if np.result_type(arr, old, new).char == "T":
        return _replace(arr, old, new, count)

    a_dt = arr.dtype
    old = old.astype(old_dtype or a_dt, copy=False)
    new = new.astype(new_dtype or a_dt, copy=False)
    max_int64 = np.iinfo(np.int64).max
    counts = _count_ufunc(arr, old, 0, max_int64)
    counts = np.where(count < 0, counts, np.minimum(counts, count))
    buffersizes = str_len(arr) + counts * (str_len(new) - str_len(old))
    out_dtype = f"{arr.dtype.char}{buffersizes.max()}"
    out = np.empty_like(arr, shape=buffersizes.shape, dtype=out_dtype)

    return _replace(arr, old, new, counts, out=out)


def _join_dispatcher(sep, seq):
    return (sep, seq)


@array_function_dispatch(_join_dispatcher)
def _join(sep, seq):
    
    return _to_bytes_or_str_array(
        _vec_string(sep, np.object_, 'join', (seq,)), seq)


def _split_dispatcher(a, sep=None, maxsplit=None):
    return (a,)


@array_function_dispatch(_split_dispatcher)
def _split(a, sep=None, maxsplit=None):
    
    
    
    return _vec_string(
        a, np.object_, 'split', [sep] + _clean_args(maxsplit))


@array_function_dispatch(_split_dispatcher)
def _rsplit(a, sep=None, maxsplit=None):
    
    
    
    return _vec_string(
        a, np.object_, 'rsplit', [sep] + _clean_args(maxsplit))


def _splitlines_dispatcher(a, keepends=None):
    return (a,)


@array_function_dispatch(_splitlines_dispatcher)
def _splitlines(a, keepends=None):
    
    return _vec_string(
        a, np.object_, 'splitlines', _clean_args(keepends))


def _partition_dispatcher(a, sep):
    return (a,)


@set_module("numpy.strings")
@array_function_dispatch(_partition_dispatcher)
def partition(a, sep):
    
    a = np.asanyarray(a)
    sep = np.asanyarray(sep)

    if np.result_type(a, sep).char == "T":
        return _partition(a, sep)

    sep = sep.astype(a.dtype, copy=False)
    pos = _find_ufunc(a, sep, 0, MAX)
    a_len = str_len(a)
    sep_len = str_len(sep)

    not_found = pos < 0
    buffersizes1 = np.where(not_found, a_len, pos)
    buffersizes3 = np.where(not_found, 0, a_len - pos - sep_len)

    out_dtype = ",".join([f"{a.dtype.char}{n}" for n in (
        buffersizes1.max(),
        1 if np.all(not_found) else sep_len.max(),
        buffersizes3.max(),
    )])
    shape = np.broadcast_shapes(a.shape, sep.shape)
    out = np.empty_like(a, shape=shape, dtype=out_dtype)
    return _partition_index(a, sep, pos, out=(out["f0"], out["f1"], out["f2"]))


@set_module("numpy.strings")
@array_function_dispatch(_partition_dispatcher)
def rpartition(a, sep):
    
    a = np.asanyarray(a)
    sep = np.asanyarray(sep)

    if np.result_type(a, sep).char == "T":
        return _rpartition(a, sep)

    sep = sep.astype(a.dtype, copy=False)
    pos = _rfind_ufunc(a, sep, 0, MAX)
    a_len = str_len(a)
    sep_len = str_len(sep)

    not_found = pos < 0
    buffersizes1 = np.where(not_found, 0, pos)
    buffersizes3 = np.where(not_found, a_len, a_len - pos - sep_len)

    out_dtype = ",".join([f"{a.dtype.char}{n}" for n in (
        buffersizes1.max(),
        1 if np.all(not_found) else sep_len.max(),
        buffersizes3.max(),
    )])
    shape = np.broadcast_shapes(a.shape, sep.shape)
    out = np.empty_like(a, shape=shape, dtype=out_dtype)
    return _rpartition_index(
        a, sep, pos, out=(out["f0"], out["f1"], out["f2"]))


def _translate_dispatcher(a, table, deletechars=None):
    return (a,)


@set_module("numpy.strings")
@array_function_dispatch(_translate_dispatcher)
def translate(a, table, deletechars=None):
    
    a_arr = np.asarray(a)
    if issubclass(a_arr.dtype.type, np.str_):
        return _vec_string(
            a_arr, a_arr.dtype, 'translate', (table,))
    else:
        return _vec_string(
            a_arr,
            a_arr.dtype,
            'translate',
            [table] + _clean_args(deletechars)
        )

@set_module("numpy.strings")
def slice(a, start=None, stop=None, step=None, /):
    
    
    
    if stop is None:
        stop = start
        start = None

    
    if step is None:
        step = 1
    step = np.asanyarray(step)
    if not np.issubdtype(step.dtype, np.integer):
        raise TypeError(f"unsupported type {step.dtype} for operand 'step'")
    if np.any(step == 0):
        raise ValueError("slice step cannot be zero")

    if start is None:
        start = np.where(step < 0, np.iinfo(np.intp).max, 0)

    if stop is None:
        stop = np.where(step < 0, np.iinfo(np.intp).min, np.iinfo(np.intp).max)

    return _slice(a, start, stop, step)
