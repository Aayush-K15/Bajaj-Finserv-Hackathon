

from collections.abc import Callable, Iterable
from typing import TYPE_CHECKING, Final, TypeAlias, cast

import numpy as np

__all__: list[str] = []


def _get_precision_dict() -> dict[str, str]:
    names = [
        ("_NBitByte", np.byte),
        ("_NBitShort", np.short),
        ("_NBitIntC", np.intc),
        ("_NBitIntP", np.intp),
        ("_NBitInt", np.int_),
        ("_NBitLong", np.long),
        ("_NBitLongLong", np.longlong),

        ("_NBitHalf", np.half),
        ("_NBitSingle", np.single),
        ("_NBitDouble", np.double),
        ("_NBitLongDouble", np.longdouble),
    ]
    ret: dict[str, str] = {}
    for name, typ in names:
        n = 8 * np.dtype(typ).itemsize
        ret[f"{_MODULE}._nbit.{name}"] = f"{_MODULE}._nbit_base._{n}Bit"
    return ret


def _get_extended_precision_list() -> list[str]:
    extended_names = [
        "float96",
        "float128",
        "complex192",
        "complex256",
    ]
    return [i for i in extended_names if hasattr(np, i)]

def _get_c_intp_name() -> str:
    
    return {
        "i": "c_int",
        "l": "c_long",
        "q": "c_longlong",
    }.get(np.dtype("n").char, "c_long")


_MODULE: Final = "numpy._typing"



_PRECISION_DICT: Final = _get_precision_dict()


_EXTENDED_PRECISION_LIST: Final = _get_extended_precision_list()


_C_INTP: Final = _get_c_intp_name()


try:
    if TYPE_CHECKING:
        from mypy.typeanal import TypeAnalyser

    import mypy.types
    from mypy.build import PRI_MED
    from mypy.nodes import ImportFrom, MypyFile, Statement
    from mypy.plugin import AnalyzeTypeContext, Plugin

except ModuleNotFoundError as e:

    def plugin(version: str) -> type:
        raise e

else:

    _HookFunc: TypeAlias = Callable[[AnalyzeTypeContext], mypy.types.Type]

    def _hook(ctx: AnalyzeTypeContext) -> mypy.types.Type:
        
        typ, _, api = ctx
        name = typ.name.split(".")[-1]
        name_new = _PRECISION_DICT[f"{_MODULE}._nbit.{name}"]
        return cast("TypeAnalyser", api).named_type(name_new)

    def _index(iterable: Iterable[Statement], id: str) -> int:
        
        for i, value in enumerate(iterable):
            if getattr(value, "id", None) == id:
                return i
        raise ValueError("Failed to identify a `ImportFrom` instance "
                         f"with the following id: {id!r}")

    def _override_imports(
        file: MypyFile,
        module: str,
        imports: list[tuple[str, str | None]],
    ) -> None:
        
        
        import_obj = ImportFrom(module, 0, names=imports)
        import_obj.is_top_level = True

        
        for lst in [file.defs, cast("list[Statement]", file.imports)]:
            i = _index(lst, module)
            lst[i] = import_obj

    class _NumpyPlugin(Plugin):
        

        def get_type_analyze_hook(self, fullname: str) -> _HookFunc | None:
            
            if fullname in _PRECISION_DICT:
                return _hook
            return None

        def get_additional_deps(
            self, file: MypyFile
        ) -> list[tuple[int, str, int]]:
            
            fullname = file.fullname
            if fullname == "numpy":
                _override_imports(
                    file,
                    f"{_MODULE}._extended_precision",
                    imports=[(v, v) for v in _EXTENDED_PRECISION_LIST],
                )
            elif fullname == "numpy.ctypeslib":
                _override_imports(
                    file,
                    "ctypes",
                    imports=[(_C_INTP, "_c_intp")],
                )
            return [(PRI_MED, fullname, -1)]

    def plugin(version: str) -> type:
        import warnings

        plugin = "numpy.typing.mypy_plugin"
        
        warn_msg = (
            f"`{plugin}` is deprecated, and will be removed in a future "
            f"release. Please remove `plugins = {plugin}` in your mypy config."
            f"(deprecated in NumPy 2.3)"
        )
        warnings.warn(warn_msg, DeprecationWarning, stacklevel=3)

        return _NumpyPlugin
