



import binascii
import os
import mmap
import sys
import time
import errno

from io import BytesIO

from smmap import (
    StaticWindowMapManager,
    SlidingWindowMapManager,
    SlidingWindowMapBuffer
)



mman = SlidingWindowMapManager()


import hashlib

try:
    from struct import unpack_from
except ImportError:
    from struct import unpack, calcsize
    __calcsize_cache = dict()

    def unpack_from(fmt, data, offset=0):
        try:
            size = __calcsize_cache[fmt]
        except KeyError:
            size = calcsize(fmt)
            __calcsize_cache[fmt] = size
        
        return unpack(fmt, data[offset: offset + size])
    




hex_to_bin = binascii.a2b_hex
bin_to_hex = binascii.b2a_hex


ENOENT = errno.ENOENT


exists = os.path.exists
mkdir = os.mkdir
chmod = os.chmod
isdir = os.path.isdir
isfile = os.path.isfile
rename = os.rename
dirname = os.path.dirname
basename = os.path.basename
join = os.path.join
read = os.read
write = os.write
close = os.close
fsync = os.fsync


def _retry(func, *args, **kwargs):
    
    
    if sys.platform == "win32":
        for _ in range(10):
            try:
                return func(*args, **kwargs)
            except Exception:
                time.sleep(0.1)
        return func(*args, **kwargs)
    else:
        return func(*args, **kwargs)


def remove(*args, **kwargs):
    return _retry(os.remove, *args, **kwargs)



from gitdb.const import (
    NULL_BIN_SHA,
    NULL_HEX_SHA
)






class _RandomAccessBytesIO:

    
    __slots__ = '_sio'

    def __init__(self, buf=''):
        self._sio = BytesIO(buf)

    def __getattr__(self, attr):
        return getattr(self._sio, attr)

    def __len__(self):
        return len(self.getvalue())

    def __getitem__(self, i):
        return self.getvalue()[i]

    def __getslice__(self, start, end):
        return self.getvalue()[start:end]


def byte_ord(b):
    
    try:
        return ord(b)
    except TypeError:
        return b






def make_sha(source=b''):
    
    try:
        return hashlib.sha1(source)
    except NameError:
        import sha
        sha1 = sha.sha(source)
        return sha1


def allocate_memory(size):
    
    if size == 0:
        return _RandomAccessBytesIO(b'')
    

    try:
        return mmap.mmap(-1, size)  
    except OSError:
        
        
        
        
        return _RandomAccessBytesIO(b"\0" * size)
    


def file_contents_ro(fd, stream=False, allow_mmap=True):
    
    try:
        if allow_mmap:
            
            try:
                return mmap.mmap(fd, 0, access=mmap.ACCESS_READ)
            except OSError:
                
                return mmap.mmap(fd, os.fstat(fd).st_size, access=mmap.ACCESS_READ)
            
    except OSError:
        pass
    

    
    contents = os.read(fd, os.fstat(fd).st_size)
    if stream:
        return _RandomAccessBytesIO(contents)
    return contents


def file_contents_ro_filepath(filepath, stream=False, allow_mmap=True, flags=0):
    
    fd = os.open(filepath, os.O_RDONLY | getattr(os, 'O_BINARY', 0) | flags)
    try:
        return file_contents_ro(fd, stream, allow_mmap)
    finally:
        close(fd)
    


def sliding_ro_buffer(filepath, flags=0):
    
    return SlidingWindowMapBuffer(mman.make_cursor(filepath), flags=flags)


def to_hex_sha(sha):
    
    if len(sha) == 40:
        return sha
    return bin_to_hex(sha)


def to_bin_sha(sha):
    if len(sha) == 20:
        return sha
    return hex_to_bin(sha)







class LazyMixin:

    

    __slots__ = tuple()

    def __getattr__(self, attr):
        
        self._set_cache_(attr)
        
        return object.__getattribute__(self, attr)

    def _set_cache_(self, attr):
        
        pass


class LockedFD:

    
    __slots__ = ("_filepath", '_fd', '_write')

    def __init__(self, filepath):
        
        self._filepath = filepath
        self._fd = None
        self._write = None          

    def __del__(self):
        
        if self._fd is not None:
            self.rollback()

    def _lockfilepath(self):
        return "%s.lock" % self._filepath

    def open(self, write=False, stream=False):
        
        if self._write is not None:
            raise AssertionError("Called %s multiple times" % self.open)

        self._write = write

        
        binary = getattr(os, 'O_BINARY', 0)
        lockmode = os.O_WRONLY | os.O_CREAT | os.O_EXCL | binary
        try:
            fd = os.open(self._lockfilepath(), lockmode, int("600", 8))
            if not write:
                os.close(fd)
            else:
                self._fd = fd
            
        except OSError as e:
            raise OSError("Lock at %r could not be obtained" % self._lockfilepath()) from e
        

        
        if self._fd is None:
            
            try:
                self._fd = os.open(self._filepath, os.O_RDONLY | binary)
            except:
                
                remove(self._lockfilepath())
                raise
            
        

        if stream:
            
            from gitdb.stream import FDStream
            return FDStream(self._fd)
        else:
            return self._fd
        

    def commit(self):
        
        self._end_writing(successful=True)

    def rollback(self):
        
        self._end_writing(successful=False)

    def _end_writing(self, successful=True):
        
        if self._write is None:
            raise AssertionError("Cannot end operation if it wasn't started yet")

        if self._fd is None:
            return

        os.close(self._fd)
        self._fd = None

        lockfile = self._lockfilepath()
        if self._write and successful:
            
            if sys.platform == "win32":
                if isfile(self._filepath):
                    remove(self._filepath)
                
            
            os.rename(lockfile, self._filepath)

            
            
            
            chmod(self._filepath, int("644", 8))
        else:
            
            remove(lockfile)
        


