




from gitdb.util import (
    join,
    LazyMixin,
    hex_to_bin
)

from gitdb.utils.encoding import force_text
from gitdb.exc import (
    BadObject,
    AmbiguousObjectName
)

from itertools import chain
from functools import reduce


__all__ = ('ObjectDBR', 'ObjectDBW', 'FileDBBase', 'CompoundDB', 'CachingDB')


class ObjectDBR:

    

    def __contains__(self, sha):
        return self.has_obj

    
    def has_object(self, sha):
        
        raise NotImplementedError("To be implemented in subclass")

    def info(self, sha):
        
        raise NotImplementedError("To be implemented in subclass")

    def stream(self, sha):
        
        raise NotImplementedError("To be implemented in subclass")

    def size(self):
        
        raise NotImplementedError()

    def sha_iter(self):
        
        raise NotImplementedError()

    


class ObjectDBW:

    

    def __init__(self, *args, **kwargs):
        self._ostream = None

    
    def set_ostream(self, stream):
        
        cstream = self._ostream
        self._ostream = stream
        return cstream

    def ostream(self):
        
        return self._ostream

    def store(self, istream):
        
        raise NotImplementedError("To be implemented in subclass")

    


class FileDBBase:

    

    def __init__(self, root_path):
        
        super().__init__()
        self._root_path = root_path

    
    def root_path(self):
        
        return self._root_path

    def db_path(self, rela_path):
        
        return join(self._root_path, force_text(rela_path))
    


class CachingDB:

    

    
    def update_cache(self, force=False):
        

    


def _databases_recursive(database, output):
    
    if isinstance(database, CompoundDB):
        dbs = database.databases()
        output.extend(db for db in dbs if not isinstance(db, CompoundDB))
        for cdb in (db for db in dbs if isinstance(db, CompoundDB)):
            _databases_recursive(cdb, output)
    else:
        output.append(database)
    


class CompoundDB(ObjectDBR, LazyMixin, CachingDB):

    

    def _set_cache_(self, attr):
        if attr == '_dbs':
            self._dbs = list()
        elif attr == '_db_cache':
            self._db_cache = dict()
        else:
            super()._set_cache_(attr)

    def _db_query(self, sha):
        
        
        
        try:
            return self._db_cache[sha]
        except KeyError:
            pass
        

        for db in self._dbs:
            if db.has_object(sha):
                self._db_cache[sha] = db
                return db
        
        raise BadObject(sha)

    

    def has_object(self, sha):
        try:
            self._db_query(sha)
            return True
        except BadObject:
            return False
        

    def info(self, sha):
        return self._db_query(sha).info(sha)

    def stream(self, sha):
        return self._db_query(sha).stream(sha)

    def size(self):
        
        return reduce(lambda x, y: x + y, (db.size() for db in self._dbs), 0)

    def sha_iter(self):
        return chain(*(db.sha_iter() for db in self._dbs))

    

    

    def databases(self):
        
        return tuple(self._dbs)

    def update_cache(self, force=False):
        
        self._db_cache.clear()
        stat = False
        for db in self._dbs:
            if isinstance(db, CachingDB):
                stat |= db.update_cache(force)
            
        
        return stat

    def partial_to_complete_sha_hex(self, partial_hexsha):
        
        databases = list()
        _databases_recursive(self, databases)
        partial_hexsha = force_text(partial_hexsha)
        len_partial_hexsha = len(partial_hexsha)
        if len_partial_hexsha % 2 != 0:
            partial_binsha = hex_to_bin(partial_hexsha + "0")
        else:
            partial_binsha = hex_to_bin(partial_hexsha)
        

        candidate = None
        for db in databases:
            full_bin_sha = None
            try:
                if hasattr(db, 'partial_to_complete_sha_hex'):
                    full_bin_sha = db.partial_to_complete_sha_hex(partial_hexsha)
                else:
                    full_bin_sha = db.partial_to_complete_sha(partial_binsha, len_partial_hexsha)
                
            except BadObject:
                continue
            
            if full_bin_sha:
                if candidate and candidate != full_bin_sha:
                    raise AmbiguousObjectName(partial_hexsha)
                candidate = full_bin_sha
            
        
        if not candidate:
            raise BadObject(partial_binsha)
        return candidate

    
