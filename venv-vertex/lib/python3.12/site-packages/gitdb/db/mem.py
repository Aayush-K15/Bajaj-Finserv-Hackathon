




from gitdb.db.loose import LooseObjectDB
from gitdb.db.base import (
    ObjectDBR,
    ObjectDBW
)

from gitdb.base import (
    OStream,
    IStream,
)

from gitdb.exc import (
    BadObject,
    UnsupportedOperation
)

from gitdb.stream import (
    ZippedStoreShaWriter,
    DecompressMemMapReader,
)

from io import BytesIO

__all__ = ("MemoryDB", )


class MemoryDB(ObjectDBR, ObjectDBW):

    

    def __init__(self):
        super().__init__()
        self._db = LooseObjectDB("path/doesnt/matter")

        
        self._cache = dict()

    def set_ostream(self, stream):
        raise UnsupportedOperation("MemoryDB's always stream into memory")

    def store(self, istream):
        zstream = ZippedStoreShaWriter()
        self._db.set_ostream(zstream)

        istream = self._db.store(istream)
        zstream.close()     
        zstream.seek(0)

        
        
        decomp_stream = DecompressMemMapReader(zstream.getvalue(), close_on_deletion=False)
        self._cache[istream.binsha] = OStream(istream.binsha, istream.type, istream.size, decomp_stream)

        return istream

    def has_object(self, sha):
        return sha in self._cache

    def info(self, sha):
        
        return self.stream(sha)

    def stream(self, sha):
        try:
            ostream = self._cache[sha]
            
            ostream.stream.seek(0)
            return ostream
        except KeyError as e:
            raise BadObject(sha) from e
        

    def size(self):
        return len(self._cache)

    def sha_iter(self):
        return self._cache.keys()

    
    def stream_copy(self, sha_iter, odb):
        
        count = 0
        for sha in sha_iter:
            if odb.has_object(sha):
                continue
            

            ostream = self.stream(sha)
            
            sio = BytesIO(ostream.stream.data())
            istream = IStream(ostream.type, ostream.size, sio, sha)

            odb.store(istream)
            count += 1
        
        return count
    
