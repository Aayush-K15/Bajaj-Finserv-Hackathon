from __future__ import annotations

import asyncio
import collections
import contextlib
import logging
import random
import struct
import sys
import traceback
import uuid
from collections.abc import AsyncIterable, AsyncIterator, Awaitable, Iterable, Mapping
from types import TracebackType
from typing import Any, Literal, cast, overload

from ..exceptions import (
    ConcurrencyError,
    ConnectionClosed,
    ConnectionClosedOK,
    ProtocolError,
)
from ..frames import DATA_OPCODES, BytesLike, CloseCode, Frame, Opcode
from ..http11 import Request, Response
from ..protocol import CLOSED, OPEN, Event, Protocol, State
from ..typing import Data, LoggerLike, Subprotocol
from .compatibility import (
    TimeoutError,
    aiter,
    anext,
    asyncio_timeout,
    asyncio_timeout_at,
)
from .messages import Assembler


__all__ = ["Connection"]


class Connection(asyncio.Protocol):
    

    def __init__(
        self,
        protocol: Protocol,
        *,
        ping_interval: float | None = 20,
        ping_timeout: float | None = 20,
        close_timeout: float | None = 10,
        max_queue: int | None | tuple[int | None, int | None] = 16,
        write_limit: int | tuple[int, int | None] = 2**15,
    ) -> None:
        self.protocol = protocol
        self.ping_interval = ping_interval
        self.ping_timeout = ping_timeout
        self.close_timeout = close_timeout
        if isinstance(max_queue, int) or max_queue is None:
            max_queue = (max_queue, None)
        self.max_queue = max_queue
        if isinstance(write_limit, int):
            write_limit = (write_limit, None)
        self.write_limit = write_limit

        
        self.protocol.logger = logging.LoggerAdapter(
            self.protocol.logger,
            {"websocket": self},
        )

        
        self.id: uuid.UUID = self.protocol.id
        
        self.logger: LoggerLike = self.protocol.logger
        
        self.debug = self.protocol.debug

        
        self.request: Request | None = None
        
        self.response: Response | None = None
        

        
        self.loop = asyncio.get_running_loop()

        
        self.recv_messages: Assembler  

        
        self.close_deadline: float | None = None

        
        self.fragmented_send_waiter: asyncio.Future[None] | None = None

        
        self.pong_waiters: dict[bytes, tuple[asyncio.Future[float], float]] = {}

        self.latency: float = 0
        

        
        self.keepalive_task: asyncio.Task[None] | None = None

        
        
        self.recv_exc: BaseException | None = None

        
        
        self.connection_lost_waiter: asyncio.Future[None] = self.loop.create_future()

        
        self.paused: bool = False
        self.drain_waiters: collections.deque[asyncio.Future[None]] = (
            collections.deque()
        )

    

    @property
    def local_address(self) -> Any:
        
        return self.transport.get_extra_info("sockname")

    @property
    def remote_address(self) -> Any:
        
        return self.transport.get_extra_info("peername")

    @property
    def state(self) -> State:
        
        return self.protocol.state

    @property
    def subprotocol(self) -> Subprotocol | None:
        
        return self.protocol.subprotocol

    @property
    def close_code(self) -> int | None:
        
        return self.protocol.close_code

    @property
    def close_reason(self) -> str | None:
        
        return self.protocol.close_reason

    

    async def __aenter__(self) -> Connection:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        if exc_type is None:
            await self.close()
        else:
            await self.close(CloseCode.INTERNAL_ERROR)

    async def __aiter__(self) -> AsyncIterator[Data]:
        
        try:
            while True:
                yield await self.recv()
        except ConnectionClosedOK:
            return

    @overload
    async def recv(self, decode: Literal[True]) -> str: ...

    @overload
    async def recv(self, decode: Literal[False]) -> bytes: ...

    @overload
    async def recv(self, decode: bool | None = None) -> Data: ...

    async def recv(self, decode: bool | None = None) -> Data:
        
        try:
            return await self.recv_messages.get(decode)
        except EOFError:
            pass
            
        except ConcurrencyError:
            raise ConcurrencyError(
                "cannot call recv while another coroutine "
                "is already running recv or recv_streaming"
            ) from None
        except UnicodeDecodeError as exc:
            async with self.send_context():
                self.protocol.fail(
                    CloseCode.INVALID_DATA,
                    f"{exc.reason} at position {exc.start}",
                )
            

        
        await asyncio.shield(self.connection_lost_waiter)
        raise self.protocol.close_exc from self.recv_exc

    @overload
    def recv_streaming(self, decode: Literal[True]) -> AsyncIterator[str]: ...

    @overload
    def recv_streaming(self, decode: Literal[False]) -> AsyncIterator[bytes]: ...

    @overload
    def recv_streaming(self, decode: bool | None = None) -> AsyncIterator[Data]: ...

    async def recv_streaming(self, decode: bool | None = None) -> AsyncIterator[Data]:
        
        try:
            async for frame in self.recv_messages.get_iter(decode):
                yield frame
            return
        except EOFError:
            pass
            
        except ConcurrencyError:
            raise ConcurrencyError(
                "cannot call recv_streaming while another coroutine "
                "is already running recv or recv_streaming"
            ) from None
        except UnicodeDecodeError as exc:
            async with self.send_context():
                self.protocol.fail(
                    CloseCode.INVALID_DATA,
                    f"{exc.reason} at position {exc.start}",
                )
            

        
        await asyncio.shield(self.connection_lost_waiter)
        raise self.protocol.close_exc from self.recv_exc

    async def send(
        self,
        message: Data | Iterable[Data] | AsyncIterable[Data],
        text: bool | None = None,
    ) -> None:
        
        
        
        while self.fragmented_send_waiter is not None:
            await asyncio.shield(self.fragmented_send_waiter)

        
        

        if isinstance(message, str):
            async with self.send_context():
                if text is False:
                    self.protocol.send_binary(message.encode())
                else:
                    self.protocol.send_text(message.encode())

        elif isinstance(message, BytesLike):
            async with self.send_context():
                if text is True:
                    self.protocol.send_text(message)
                else:
                    self.protocol.send_binary(message)

        

        elif isinstance(message, Mapping):
            raise TypeError("data is a dict-like object")

        

        elif isinstance(message, Iterable):
            chunks = iter(message)
            try:
                chunk = next(chunks)
            except StopIteration:
                return

            assert self.fragmented_send_waiter is None
            self.fragmented_send_waiter = self.loop.create_future()
            try:
                
                if isinstance(chunk, str):
                    async with self.send_context():
                        if text is False:
                            self.protocol.send_binary(chunk.encode(), fin=False)
                        else:
                            self.protocol.send_text(chunk.encode(), fin=False)
                    encode = True
                elif isinstance(chunk, BytesLike):
                    async with self.send_context():
                        if text is True:
                            self.protocol.send_text(chunk, fin=False)
                        else:
                            self.protocol.send_binary(chunk, fin=False)
                    encode = False
                else:
                    raise TypeError("iterable must contain bytes or str")

                
                for chunk in chunks:
                    if isinstance(chunk, str) and encode:
                        async with self.send_context():
                            self.protocol.send_continuation(chunk.encode(), fin=False)
                    elif isinstance(chunk, BytesLike) and not encode:
                        async with self.send_context():
                            self.protocol.send_continuation(chunk, fin=False)
                    else:
                        raise TypeError("iterable must contain uniform types")

                
                async with self.send_context():
                    self.protocol.send_continuation(b"", fin=True)

            except Exception:
                
                
                async with self.send_context():
                    self.protocol.fail(
                        CloseCode.INTERNAL_ERROR,
                        "error in fragmented message",
                    )
                raise

            finally:
                self.fragmented_send_waiter.set_result(None)
                self.fragmented_send_waiter = None

        

        elif isinstance(message, AsyncIterable):
            achunks = aiter(message)
            try:
                chunk = await anext(achunks)
            except StopAsyncIteration:
                return

            assert self.fragmented_send_waiter is None
            self.fragmented_send_waiter = self.loop.create_future()
            try:
                
                if isinstance(chunk, str):
                    if text is False:
                        async with self.send_context():
                            self.protocol.send_binary(chunk.encode(), fin=False)
                    else:
                        async with self.send_context():
                            self.protocol.send_text(chunk.encode(), fin=False)
                    encode = True
                elif isinstance(chunk, BytesLike):
                    if text is True:
                        async with self.send_context():
                            self.protocol.send_text(chunk, fin=False)
                    else:
                        async with self.send_context():
                            self.protocol.send_binary(chunk, fin=False)
                    encode = False
                else:
                    raise TypeError("async iterable must contain bytes or str")

                
                async for chunk in achunks:
                    if isinstance(chunk, str) and encode:
                        async with self.send_context():
                            self.protocol.send_continuation(chunk.encode(), fin=False)
                    elif isinstance(chunk, BytesLike) and not encode:
                        async with self.send_context():
                            self.protocol.send_continuation(chunk, fin=False)
                    else:
                        raise TypeError("async iterable must contain uniform types")

                
                async with self.send_context():
                    self.protocol.send_continuation(b"", fin=True)

            except Exception:
                
                
                async with self.send_context():
                    self.protocol.fail(
                        CloseCode.INTERNAL_ERROR,
                        "error in fragmented message",
                    )
                raise

            finally:
                self.fragmented_send_waiter.set_result(None)
                self.fragmented_send_waiter = None

        else:
            raise TypeError("data must be str, bytes, iterable, or async iterable")

    async def close(self, code: int = 1000, reason: str = "") -> None:
        
        try:
            
            
            async with self.send_context():
                if self.fragmented_send_waiter is not None:
                    self.protocol.fail(
                        CloseCode.INTERNAL_ERROR,
                        "close during fragmented message",
                    )
                else:
                    self.protocol.send_close(code, reason)
        except ConnectionClosed:
            
            
            pass

    async def wait_closed(self) -> None:
        
        await asyncio.shield(self.connection_lost_waiter)

    async def ping(self, data: Data | None = None) -> Awaitable[float]:
        
        if isinstance(data, BytesLike):
            data = bytes(data)
        elif isinstance(data, str):
            data = data.encode()
        elif data is not None:
            raise TypeError("data must be str or bytes-like")

        async with self.send_context():
            
            if data in self.pong_waiters:
                raise ConcurrencyError("already waiting for a pong with the same data")

            
            while data is None or data in self.pong_waiters:
                data = struct.pack("!I", random.getrandbits(32))

            pong_waiter = self.loop.create_future()
            
            
            self.pong_waiters[data] = (pong_waiter, self.loop.time())
            self.protocol.send_ping(data)
            return pong_waiter

    async def pong(self, data: Data = b"") -> None:
        
        if isinstance(data, BytesLike):
            data = bytes(data)
        elif isinstance(data, str):
            data = data.encode()
        else:
            raise TypeError("data must be str or bytes-like")

        async with self.send_context():
            self.protocol.send_pong(data)

    

    def process_event(self, event: Event) -> None:
        
        assert isinstance(event, Frame)
        if event.opcode in DATA_OPCODES:
            self.recv_messages.put(event)

        if event.opcode is Opcode.PONG:
            self.acknowledge_pings(bytes(event.data))

    def acknowledge_pings(self, data: bytes) -> None:
        
        
        if data not in self.pong_waiters:
            return

        pong_timestamp = self.loop.time()

        
        
        ping_id = None
        ping_ids = []
        for ping_id, (pong_waiter, ping_timestamp) in self.pong_waiters.items():
            ping_ids.append(ping_id)
            latency = pong_timestamp - ping_timestamp
            if not pong_waiter.done():
                pong_waiter.set_result(latency)
            if ping_id == data:
                self.latency = latency
                break
        else:
            raise AssertionError("solicited pong not found in pings")

        
        for ping_id in ping_ids:
            del self.pong_waiters[ping_id]

    def abort_pings(self) -> None:
        
        assert self.protocol.state is CLOSED
        exc = self.protocol.close_exc

        for pong_waiter, _ping_timestamp in self.pong_waiters.values():
            if not pong_waiter.done():
                pong_waiter.set_exception(exc)
            
            
            
            
            pong_waiter.cancel()

        self.pong_waiters.clear()

    async def keepalive(self) -> None:
        
        assert self.ping_interval is not None
        latency = 0.0
        try:
            while True:
                
                
                
                await asyncio.sleep(self.ping_interval - latency)

                
                
                
                
                
                pong_waiter = await self.ping()
                if self.debug:
                    self.logger.debug("% sent keepalive ping")

                if self.ping_timeout is not None:
                    try:
                        async with asyncio_timeout(self.ping_timeout):
                            
                            
                            
                            
                            latency = await pong_waiter
                        self.logger.debug("% received keepalive pong")
                    except asyncio.TimeoutError:
                        if self.debug:
                            self.logger.debug("- timed out waiting for keepalive pong")
                        async with self.send_context():
                            self.protocol.fail(
                                CloseCode.INTERNAL_ERROR,
                                "keepalive ping timeout",
                            )
                        raise AssertionError(
                            "send_context() should wait for connection_lost(), "
                            "which cancels keepalive()"
                        )
        except Exception:
            self.logger.error("keepalive ping failed", exc_info=True)

    def start_keepalive(self) -> None:
        
        if self.ping_interval is not None:
            self.keepalive_task = self.loop.create_task(self.keepalive())

    @contextlib.asynccontextmanager
    async def send_context(
        self,
        *,
        expected_state: State = OPEN,  
    ) -> AsyncIterator[None]:
        
        
        wait_for_close = False
        
        raise_close_exc = False
        
        original_exc: BaseException | None = None

        if self.protocol.state is expected_state:
            
            try:
                yield
            except (ProtocolError, ConcurrencyError):
                
                raise
            except Exception as exc:
                self.logger.error("unexpected internal error", exc_info=True)
                
                
                
                wait_for_close = False
                raise_close_exc = True
                original_exc = exc
            else:
                
                if self.protocol.close_expected():
                    wait_for_close = True
                    
                    
                    
                    
                    if self.close_timeout is not None:
                        assert self.close_deadline is None
                        self.close_deadline = self.loop.time() + self.close_timeout
                
                try:
                    self.send_data()
                    await self.drain()
                except Exception as exc:
                    if self.debug:
                        self.logger.debug("! error while sending data", exc_info=True)
                    
                    
                    wait_for_close = False
                    raise_close_exc = True
                    original_exc = exc

        else:  
            
            
            wait_for_close = True
            
            if self.close_timeout is not None:
                if self.close_deadline is None:
                    self.close_deadline = self.loop.time() + self.close_timeout
            raise_close_exc = True

        
        
        if wait_for_close:
            try:
                async with asyncio_timeout_at(self.close_deadline):
                    await asyncio.shield(self.connection_lost_waiter)
            except TimeoutError:
                
                
                assert original_exc is None
                original_exc = TimeoutError("timed out while closing connection")
                
                
                raise_close_exc = True
                self.set_recv_exc(original_exc)

        
        
        if raise_close_exc:
            self.transport.abort()
            
            await asyncio.shield(self.connection_lost_waiter)
            raise self.protocol.close_exc from original_exc

    def send_data(self) -> None:
        
        for data in self.protocol.data_to_send():
            if data:
                self.transport.write(data)
            else:
                
                if self.transport.can_write_eof():
                    if self.debug:
                        self.logger.debug("x half-closing TCP connection")
                    
                    
                    try:
                        self.transport.write_eof()
                    except (OSError, RuntimeError):  
                        pass
                
                else:  
                    if self.debug:
                        self.logger.debug("x closing TCP connection")
                    self.transport.close()

    def set_recv_exc(self, exc: BaseException | None) -> None:
        
        if self.recv_exc is None:
            self.recv_exc = exc

    

    

    def connection_made(self, transport: asyncio.BaseTransport) -> None:
        transport = cast(asyncio.Transport, transport)
        self.recv_messages = Assembler(
            *self.max_queue,
            pause=transport.pause_reading,
            resume=transport.resume_reading,
        )
        transport.set_write_buffer_limits(*self.write_limit)
        self.transport = transport

    def connection_lost(self, exc: Exception | None) -> None:
        
        
        self.protocol.receive_eof()
        assert self.protocol.state is CLOSED

        self.set_recv_exc(exc)

        
        self.recv_messages.close()
        self.abort_pings()

        if self.keepalive_task is not None:
            self.keepalive_task.cancel()

        
        
        
        self.connection_lost_waiter.set_result(None)

        
        if self.paused:  
            self.paused = False
            for waiter in self.drain_waiters:
                if not waiter.done():
                    if exc is None:
                        waiter.set_result(None)
                    else:
                        waiter.set_exception(exc)

    

    def pause_writing(self) -> None:  
        
        assert not self.paused
        self.paused = True

    def resume_writing(self) -> None:  
        
        assert self.paused
        self.paused = False
        for waiter in self.drain_waiters:
            if not waiter.done():
                waiter.set_result(None)

    async def drain(self) -> None:  
        
        

        
        
        if self.transport.is_closing():
            await asyncio.sleep(0)

        
        if self.paused:
            waiter = self.loop.create_future()
            self.drain_waiters.append(waiter)
            try:
                await waiter
            finally:
                self.drain_waiters.remove(waiter)

    

    def data_received(self, data: bytes) -> None:
        
        self.protocol.receive_data(data)

        
        events = self.protocol.events_received()

        
        try:
            self.send_data()
        except Exception as exc:
            if self.debug:
                self.logger.debug("! error while sending data", exc_info=True)
            self.set_recv_exc(exc)

        if self.protocol.close_expected():
            
            
            if self.close_timeout is not None:
                if self.close_deadline is None:
                    self.close_deadline = self.loop.time() + self.close_timeout

        for event in events:
            
            self.process_event(event)

    def eof_received(self) -> None:
        
        self.protocol.receive_eof()

        
        events = self.protocol.events_received()

        
        
        self.send_data()

        
        
        
        
        
        for event in events:  
            
            self.process_event(event)

        
        
        
        
        








def broadcast(
    connections: Iterable[Connection],
    message: Data,
    raise_exceptions: bool = False,
) -> None:
    
    if isinstance(message, str):
        send_method = "send_text"
        message = message.encode()
    elif isinstance(message, BytesLike):
        send_method = "send_binary"
    else:
        raise TypeError("data must be str or bytes")

    if raise_exceptions:
        if sys.version_info[:2] < (3, 11):  
            raise ValueError("raise_exceptions requires at least Python 3.11")
        exceptions: list[Exception] = []

    for connection in connections:
        exception: Exception

        if connection.protocol.state is not OPEN:
            continue

        if connection.fragmented_send_waiter is not None:
            if raise_exceptions:
                exception = ConcurrencyError("sending a fragmented message")
                exceptions.append(exception)
            else:
                connection.logger.warning(
                    "skipped broadcast: sending a fragmented message",
                )
            continue

        try:
            
            
            getattr(connection.protocol, send_method)(message)
            connection.send_data()
        except Exception as write_exception:
            if raise_exceptions:
                exception = RuntimeError("failed to write message")
                exception.__cause__ = write_exception
                exceptions.append(exception)
            else:
                connection.logger.warning(
                    "skipped broadcast: failed to write message: %s",
                    traceback.format_exception_only(
                        
                        type(write_exception),
                        write_exception,
                    )[0].strip(),
                )

    if raise_exceptions and exceptions:
        raise ExceptionGroup("skipped broadcast", exceptions)



broadcast.__module__ = "websockets.asyncio.server"
