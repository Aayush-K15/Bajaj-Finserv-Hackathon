from __future__ import annotations

import asyncio
import codecs
import collections
from collections.abc import AsyncIterator, Iterable
from typing import Any, Callable, Generic, Literal, TypeVar, overload

from ..exceptions import ConcurrencyError
from ..frames import OP_BINARY, OP_CONT, OP_TEXT, Frame
from ..typing import Data


__all__ = ["Assembler"]

UTF8Decoder = codecs.getincrementaldecoder("utf-8")

T = TypeVar("T")


class SimpleQueue(Generic[T]):
    

    def __init__(self) -> None:
        self.loop = asyncio.get_running_loop()
        self.get_waiter: asyncio.Future[None] | None = None
        self.queue: collections.deque[T] = collections.deque()

    def __len__(self) -> int:
        return len(self.queue)

    def put(self, item: T) -> None:
        
        self.queue.append(item)
        if self.get_waiter is not None and not self.get_waiter.done():
            self.get_waiter.set_result(None)

    async def get(self, block: bool = True) -> T:
        
        if not self.queue:
            if not block:
                raise EOFError("stream of frames ended")
            assert self.get_waiter is None, "cannot call get() concurrently"
            self.get_waiter = self.loop.create_future()
            try:
                await self.get_waiter
            finally:
                self.get_waiter.cancel()
                self.get_waiter = None
        return self.queue.popleft()

    def reset(self, items: Iterable[T]) -> None:
        
        assert self.get_waiter is None, "cannot reset() while get() is running"
        assert not self.queue, "cannot reset() while queue isn't empty"
        self.queue.extend(items)

    def abort(self) -> None:
        
        if self.get_waiter is not None and not self.get_waiter.done():
            self.get_waiter.set_exception(EOFError("stream of frames ended"))


class Assembler:
    

    
    def __init__(  
        self,
        high: int | None = None,
        low: int | None = None,
        pause: Callable[[], Any] = lambda: None,
        resume: Callable[[], Any] = lambda: None,
    ) -> None:
        
        self.frames: SimpleQueue[Frame] = SimpleQueue()

        
        
        
        
        if high is not None and low is None:
            low = high // 4
        if high is None and low is not None:
            high = low * 4
        if high is not None and low is not None:
            if low < 0:
                raise ValueError("low must be positive or equal to zero")
            if high < low:
                raise ValueError("high must be greater than or equal to low")
        self.high, self.low = high, low
        self.pause = pause
        self.resume = resume
        self.paused = False

        
        self.get_in_progress = False

        
        self.closed = False

    @overload
    async def get(self, decode: Literal[True]) -> str: ...

    @overload
    async def get(self, decode: Literal[False]) -> bytes: ...

    @overload
    async def get(self, decode: bool | None = None) -> Data: ...

    async def get(self, decode: bool | None = None) -> Data:
        
        if self.get_in_progress:
            raise ConcurrencyError("get() or get_iter() is already running")
        self.get_in_progress = True

        
        

        try:
            
            frame = await self.frames.get(not self.closed)
            self.maybe_resume()
            assert frame.opcode is OP_TEXT or frame.opcode is OP_BINARY
            if decode is None:
                decode = frame.opcode is OP_TEXT
            frames = [frame]

            
            while not frame.fin:
                try:
                    frame = await self.frames.get(not self.closed)
                except asyncio.CancelledError:
                    
                    
                    self.frames.reset(frames)
                    raise
                self.maybe_resume()
                assert frame.opcode is OP_CONT
                frames.append(frame)

        finally:
            self.get_in_progress = False

        data = b"".join(frame.data for frame in frames)
        if decode:
            return data.decode()
        else:
            return data

    @overload
    def get_iter(self, decode: Literal[True]) -> AsyncIterator[str]: ...

    @overload
    def get_iter(self, decode: Literal[False]) -> AsyncIterator[bytes]: ...

    @overload
    def get_iter(self, decode: bool | None = None) -> AsyncIterator[Data]: ...

    async def get_iter(self, decode: bool | None = None) -> AsyncIterator[Data]:
        
        if self.get_in_progress:
            raise ConcurrencyError("get() or get_iter() is already running")
        self.get_in_progress = True

        
        

        
        

        
        try:
            frame = await self.frames.get(not self.closed)
        except asyncio.CancelledError:
            self.get_in_progress = False
            raise
        self.maybe_resume()
        assert frame.opcode is OP_TEXT or frame.opcode is OP_BINARY
        if decode is None:
            decode = frame.opcode is OP_TEXT
        if decode:
            decoder = UTF8Decoder()
            yield decoder.decode(frame.data, frame.fin)
        else:
            yield frame.data

        
        while not frame.fin:
            
            
            
            
            frame = await self.frames.get(not self.closed)
            self.maybe_resume()
            assert frame.opcode is OP_CONT
            if decode:
                yield decoder.decode(frame.data, frame.fin)
            else:
                yield frame.data

        self.get_in_progress = False

    def put(self, frame: Frame) -> None:
        
        if self.closed:
            raise EOFError("stream of frames ended")

        self.frames.put(frame)
        self.maybe_pause()

    def maybe_pause(self) -> None:
        
        
        if self.high is None:
            return

        
        if len(self.frames) > self.high and not self.paused:
            self.paused = True
            self.pause()

    def maybe_resume(self) -> None:
        
        
        if self.low is None:
            return

        
        if len(self.frames) <= self.low and self.paused:
            self.paused = False
            self.resume()

    def close(self) -> None:
        
        if self.closed:
            return

        self.closed = True

        
        self.frames.abort()
