from __future__ import annotations

import enum
import logging
import uuid
from collections.abc import Generator
from typing import Union

from .exceptions import (
    ConnectionClosed,
    ConnectionClosedError,
    ConnectionClosedOK,
    InvalidState,
    PayloadTooBig,
    ProtocolError,
)
from .extensions import Extension
from .frames import (
    OK_CLOSE_CODES,
    OP_BINARY,
    OP_CLOSE,
    OP_CONT,
    OP_PING,
    OP_PONG,
    OP_TEXT,
    Close,
    CloseCode,
    Frame,
)
from .http11 import Request, Response
from .streams import StreamReader
from .typing import LoggerLike, Origin, Subprotocol


__all__ = [
    "Protocol",
    "Side",
    "State",
    "SEND_EOF",
]


Event = Union[Request, Response, Frame]



class Side(enum.IntEnum):
    

    SERVER, CLIENT = range(2)


SERVER = Side.SERVER
CLIENT = Side.CLIENT


class State(enum.IntEnum):
    

    CONNECTING, OPEN, CLOSING, CLOSED = range(4)


CONNECTING = State.CONNECTING
OPEN = State.OPEN
CLOSING = State.CLOSING
CLOSED = State.CLOSED


SEND_EOF = b""



class Protocol:
    

    def __init__(
        self,
        side: Side,
        *,
        state: State = OPEN,
        max_size: int | None = 2**20,
        logger: LoggerLike | None = None,
    ) -> None:
        
        self.id: uuid.UUID = uuid.uuid4()
        

        
        if logger is None:
            logger = logging.getLogger(f"websockets.{side.name.lower()}")
        self.logger: LoggerLike = logger
        

        
        self.debug = logger.isEnabledFor(logging.DEBUG)

        
        self.side = side

        
        self.state = state

        
        self.max_size = max_size

        
        
        self.cur_size: int | None = None

        
        
        self.expect_continuation_frame = False

        
        self.origin: Origin | None = None
        self.extensions: list[Extension] = []
        self.subprotocol: Subprotocol | None = None

        
        self.close_rcvd: Close | None = None
        self.close_sent: Close | None = None
        self.close_rcvd_then_sent: bool | None = None

        
        self.handshake_exc: Exception | None = None
        

        
        self.eof_sent = False

        
        self.reader = StreamReader()
        self.events: list[Event] = []
        self.writes: list[bytes] = []
        self.parser = self.parse()
        next(self.parser)  
        self.parser_exc: Exception | None = None

    @property
    def state(self) -> State:
        
        return self._state

    @state.setter
    def state(self, state: State) -> None:
        if self.debug:
            self.logger.debug("= connection is %s", state.name)
        self._state = state

    @property
    def close_code(self) -> int | None:
        
        if self.state is not CLOSED:
            return None
        elif self.close_rcvd is None:
            return CloseCode.ABNORMAL_CLOSURE
        else:
            return self.close_rcvd.code

    @property
    def close_reason(self) -> str | None:
        
        if self.state is not CLOSED:
            return None
        elif self.close_rcvd is None:
            return ""
        else:
            return self.close_rcvd.reason

    @property
    def close_exc(self) -> ConnectionClosed:
        
        assert self.state is CLOSED, "connection isn't closed yet"
        exc_type: type[ConnectionClosed]
        if (
            self.close_rcvd is not None
            and self.close_sent is not None
            and self.close_rcvd.code in OK_CLOSE_CODES
            and self.close_sent.code in OK_CLOSE_CODES
        ):
            exc_type = ConnectionClosedOK
        else:
            exc_type = ConnectionClosedError
        exc: ConnectionClosed = exc_type(
            self.close_rcvd,
            self.close_sent,
            self.close_rcvd_then_sent,
        )
        
        exc.__cause__ = self.parser_exc
        return exc

    

    def receive_data(self, data: bytes) -> None:
        
        self.reader.feed_data(data)
        next(self.parser)

    def receive_eof(self) -> None:
        
        if self.reader.eof:
            return
        self.reader.feed_eof()
        next(self.parser)

    

    def send_continuation(self, data: bytes, fin: bool) -> None:
        
        if not self.expect_continuation_frame:
            raise ProtocolError("unexpected continuation frame")
        if self._state is not OPEN:
            raise InvalidState(f"connection is {self.state.name.lower()}")
        self.expect_continuation_frame = not fin
        self.send_frame(Frame(OP_CONT, data, fin))

    def send_text(self, data: bytes, fin: bool = True) -> None:
        
        if self.expect_continuation_frame:
            raise ProtocolError("expected a continuation frame")
        if self._state is not OPEN:
            raise InvalidState(f"connection is {self.state.name.lower()}")
        self.expect_continuation_frame = not fin
        self.send_frame(Frame(OP_TEXT, data, fin))

    def send_binary(self, data: bytes, fin: bool = True) -> None:
        
        if self.expect_continuation_frame:
            raise ProtocolError("expected a continuation frame")
        if self._state is not OPEN:
            raise InvalidState(f"connection is {self.state.name.lower()}")
        self.expect_continuation_frame = not fin
        self.send_frame(Frame(OP_BINARY, data, fin))

    def send_close(self, code: int | None = None, reason: str = "") -> None:
        
        
        
        if self._state is not OPEN:
            raise InvalidState(f"connection is {self.state.name.lower()}")
        if code is None:
            if reason != "":
                raise ProtocolError("cannot send a reason without a code")
            close = Close(CloseCode.NO_STATUS_RCVD, "")
            data = b""
        else:
            close = Close(code, reason)
            data = close.serialize()
        
        self.send_frame(Frame(OP_CLOSE, data))
        
        
        assert self.close_rcvd is None
        self.close_sent = close
        self.state = CLOSING

    def send_ping(self, data: bytes) -> None:
        
        
        if self._state is not OPEN and self._state is not CLOSING:
            raise InvalidState(f"connection is {self.state.name.lower()}")
        self.send_frame(Frame(OP_PING, data))

    def send_pong(self, data: bytes) -> None:
        
        
        if self._state is not OPEN and self._state is not CLOSING:
            raise InvalidState(f"connection is {self.state.name.lower()}")
        self.send_frame(Frame(OP_PONG, data))

    def fail(self, code: int, reason: str = "") -> None:
        
        

        
        
        
        if self.state is OPEN:
            if code != CloseCode.ABNORMAL_CLOSURE:
                close = Close(code, reason)
                data = close.serialize()
                self.send_frame(Frame(OP_CLOSE, data))
                self.close_sent = close
                
                
                
                
                if self.close_rcvd is not None:
                    self.close_rcvd_then_sent = True
                self.state = CLOSING

        
        
        
        
        if self.side is SERVER and not self.eof_sent:
            self.send_eof()

        
        
        
        
        self.parser = self.discard()
        next(self.parser)  

    

    def events_received(self) -> list[Event]:
        
        events, self.events = self.events, []
        return events

    

    def data_to_send(self) -> list[bytes]:
        
        writes, self.writes = self.writes, []
        return writes

    def close_expected(self) -> bool:
        
        
        
        

        
        
        

        
        
        

        
        
        

        
        

        
        if self.state is OPEN:
            return False
        if self.state is CLOSING:
            return True
        if self.state is CLOSED:
            return False
        assert self.state is CONNECTING
        return self.eof_sent

    

    def parse(self) -> Generator[None]:
        
        try:
            while True:
                if (yield from self.reader.at_eof()):
                    if self.debug:
                        self.logger.debug("< EOF")
                    
                    
                    
                    
                    raise EOFError("unexpected end of stream")

                if self.max_size is None:
                    max_size = None
                elif self.cur_size is None:
                    max_size = self.max_size
                else:
                    max_size = self.max_size - self.cur_size

                
                
                
                frame = yield from Frame.parse(
                    self.reader.read_exact,
                    mask=self.side is SERVER,
                    max_size=max_size,
                    extensions=self.extensions,
                )

                if self.debug:
                    self.logger.debug("< %s", frame)

                self.recv_frame(frame)

        except ProtocolError as exc:
            self.fail(CloseCode.PROTOCOL_ERROR, str(exc))
            self.parser_exc = exc

        except EOFError as exc:
            self.fail(CloseCode.ABNORMAL_CLOSURE, str(exc))
            self.parser_exc = exc

        except UnicodeDecodeError as exc:
            self.fail(CloseCode.INVALID_DATA, f"{exc.reason} at position {exc.start}")
            self.parser_exc = exc

        except PayloadTooBig as exc:
            exc.set_current_size(self.cur_size)
            self.fail(CloseCode.MESSAGE_TOO_BIG, str(exc))
            self.parser_exc = exc

        except Exception as exc:
            self.logger.error("parser failed", exc_info=True)
            
            self.fail(CloseCode.INTERNAL_ERROR)
            self.parser_exc = exc

        
        
        yield
        raise AssertionError("parse() shouldn't step after error")

    def discard(self) -> Generator[None]:
        
        
        
        
        
        assert (self.side is SERVER or self.state is CONNECTING) == (self.eof_sent)
        while not (yield from self.reader.at_eof()):
            self.reader.discard()
        if self.debug:
            self.logger.debug("< EOF")
        
        
        if self.side is CLIENT and self.state is not CONNECTING:
            self.send_eof()
        self.state = CLOSED
        
        yield
        
        
        raise AssertionError("discard() shouldn't step after EOF")

    def recv_frame(self, frame: Frame) -> None:
        
        if frame.opcode is OP_TEXT or frame.opcode is OP_BINARY:
            if self.cur_size is not None:
                raise ProtocolError("expected a continuation frame")
            if not frame.fin:
                self.cur_size = len(frame.data)

        elif frame.opcode is OP_CONT:
            if self.cur_size is None:
                raise ProtocolError("unexpected continuation frame")
            if frame.fin:
                self.cur_size = None
            else:
                self.cur_size += len(frame.data)

        elif frame.opcode is OP_PING:
            
            
            pong_frame = Frame(OP_PONG, frame.data)
            self.send_frame(pong_frame)

        elif frame.opcode is OP_PONG:
            
            
            pass

        elif frame.opcode is OP_CLOSE:
            
            
            self.close_rcvd = Close.parse(frame.data)
            if self.state is CLOSING:
                assert self.close_sent is not None
                self.close_rcvd_then_sent = False

            if self.cur_size is not None:
                raise ProtocolError("incomplete fragmented message")

            
            
            
            
            

            if self.state is OPEN:
                
                
                
                
                self.send_frame(Frame(OP_CLOSE, frame.data))
                self.close_sent = self.close_rcvd
                self.close_rcvd_then_sent = True
                self.state = CLOSING

            
            
            

            
            
            if self.side is SERVER:
                self.send_eof()

            
            
            
            
            
            self.parser = self.discard()
            next(self.parser)  

        else:
            
            raise AssertionError(f"unexpected opcode: {frame.opcode:02x}")

        self.events.append(frame)

    

    def send_frame(self, frame: Frame) -> None:
        if self.debug:
            self.logger.debug("> %s", frame)
        self.writes.append(
            frame.serialize(
                mask=self.side is CLIENT,
                extensions=self.extensions,
            )
        )

    def send_eof(self) -> None:
        assert not self.eof_sent
        self.eof_sent = True
        if self.debug:
            self.logger.debug("> EOF")
        self.writes.append(SEND_EOF)
