

from __future__ import annotations

import warnings

from .imports import lazy_import


__all__ = [
    "WebSocketException",
    "ConnectionClosed",
    "ConnectionClosedOK",
    "ConnectionClosedError",
    "InvalidURI",
    "InvalidProxy",
    "InvalidHandshake",
    "SecurityError",
    "ProxyError",
    "InvalidProxyMessage",
    "InvalidProxyStatus",
    "InvalidMessage",
    "InvalidStatus",
    "InvalidHeader",
    "InvalidHeaderFormat",
    "InvalidHeaderValue",
    "InvalidOrigin",
    "InvalidUpgrade",
    "NegotiationError",
    "DuplicateParameter",
    "InvalidParameterName",
    "InvalidParameterValue",
    "ProtocolError",
    "PayloadTooBig",
    "InvalidState",
    "ConcurrencyError",
]


class WebSocketException(Exception):
    


class ConnectionClosed(WebSocketException):
    

    def __init__(
        self,
        rcvd: frames.Close | None,
        sent: frames.Close | None,
        rcvd_then_sent: bool | None = None,
    ) -> None:
        self.rcvd = rcvd
        self.sent = sent
        self.rcvd_then_sent = rcvd_then_sent
        assert (self.rcvd_then_sent is None) == (self.rcvd is None or self.sent is None)

    def __str__(self) -> str:
        if self.rcvd is None:
            if self.sent is None:
                return "no close frame received or sent"
            else:
                return f"sent {self.sent}; no close frame received"
        else:
            if self.sent is None:
                return f"received {self.rcvd}; no close frame sent"
            else:
                if self.rcvd_then_sent:
                    return f"received {self.rcvd}; then sent {self.sent}"
                else:
                    return f"sent {self.sent}; then received {self.rcvd}"

    

    @property
    def code(self) -> int:
        warnings.warn(  
            "ConnectionClosed.code is deprecated; "
            "use Protocol.close_code or ConnectionClosed.rcvd.code",
            DeprecationWarning,
        )
        if self.rcvd is None:
            return frames.CloseCode.ABNORMAL_CLOSURE
        return self.rcvd.code

    @property
    def reason(self) -> str:
        warnings.warn(  
            "ConnectionClosed.reason is deprecated; "
            "use Protocol.close_reason or ConnectionClosed.rcvd.reason",
            DeprecationWarning,
        )
        if self.rcvd is None:
            return ""
        return self.rcvd.reason


class ConnectionClosedOK(ConnectionClosed):
    


class ConnectionClosedError(ConnectionClosed):
    


class InvalidURI(WebSocketException):
    

    def __init__(self, uri: str, msg: str) -> None:
        self.uri = uri
        self.msg = msg

    def __str__(self) -> str:
        return f"{self.uri} isn't a valid URI: {self.msg}"


class InvalidProxy(WebSocketException):
    

    def __init__(self, proxy: str, msg: str) -> None:
        self.proxy = proxy
        self.msg = msg

    def __str__(self) -> str:
        return f"{self.proxy} isn't a valid proxy: {self.msg}"


class InvalidHandshake(WebSocketException):
    


class SecurityError(InvalidHandshake):
    


class ProxyError(InvalidHandshake):
    


class InvalidProxyMessage(ProxyError):
    


class InvalidProxyStatus(ProxyError):
    

    def __init__(self, response: http11.Response) -> None:
        self.response = response

    def __str__(self) -> str:
        return f"proxy rejected connection: HTTP {self.response.status_code:d}"


class InvalidMessage(InvalidHandshake):
    


class InvalidStatus(InvalidHandshake):
    

    def __init__(self, response: http11.Response) -> None:
        self.response = response

    def __str__(self) -> str:
        return (
            f"server rejected WebSocket connection: HTTP {self.response.status_code:d}"
        )


class InvalidHeader(InvalidHandshake):
    

    def __init__(self, name: str, value: str | None = None) -> None:
        self.name = name
        self.value = value

    def __str__(self) -> str:
        if self.value is None:
            return f"missing {self.name} header"
        elif self.value == "":
            return f"empty {self.name} header"
        else:
            return f"invalid {self.name} header: {self.value}"


class InvalidHeaderFormat(InvalidHeader):
    

    def __init__(self, name: str, error: str, header: str, pos: int) -> None:
        super().__init__(name, f"{error} at {pos} in {header}")


class InvalidHeaderValue(InvalidHeader):
    


class InvalidOrigin(InvalidHeader):
    

    def __init__(self, origin: str | None) -> None:
        super().__init__("Origin", origin)


class InvalidUpgrade(InvalidHeader):
    


class NegotiationError(InvalidHandshake):
    


class DuplicateParameter(NegotiationError):
    

    def __init__(self, name: str) -> None:
        self.name = name

    def __str__(self) -> str:
        return f"duplicate parameter: {self.name}"


class InvalidParameterName(NegotiationError):
    

    def __init__(self, name: str) -> None:
        self.name = name

    def __str__(self) -> str:
        return f"invalid parameter name: {self.name}"


class InvalidParameterValue(NegotiationError):
    

    def __init__(self, name: str, value: str | None) -> None:
        self.name = name
        self.value = value

    def __str__(self) -> str:
        if self.value is None:
            return f"missing value for parameter {self.name}"
        elif self.value == "":
            return f"empty value for parameter {self.name}"
        else:
            return f"invalid value for parameter {self.name}: {self.value}"


class ProtocolError(WebSocketException):
    


class PayloadTooBig(WebSocketException):
    

    def __init__(
        self,
        size_or_message: int | None | str,
        max_size: int | None = None,
        cur_size: int | None = None,
    ) -> None:
        if isinstance(size_or_message, str):
            assert max_size is None
            assert cur_size is None
            warnings.warn(  
                "PayloadTooBig(message) is deprecated; "
                "change to PayloadTooBig(size, max_size)",
                DeprecationWarning,
            )
            self.message: str | None = size_or_message
        else:
            self.message = None
            self.size: int | None = size_or_message
            assert max_size is not None
            self.max_size: int = max_size
            self.cur_size: int | None = None
            self.set_current_size(cur_size)

    def __str__(self) -> str:
        if self.message is not None:
            return self.message
        else:
            message = "frame "
            if self.size is not None:
                message += f"with {self.size} bytes "
            if self.cur_size is not None:
                message += f"after reading {self.cur_size} bytes "
            message += f"exceeds limit of {self.max_size} bytes"
            return message

    def set_current_size(self, cur_size: int | None) -> None:
        assert self.cur_size is None
        if cur_size is not None:
            self.max_size += cur_size
            self.cur_size = cur_size


class InvalidState(WebSocketException, AssertionError):
    


class ConcurrencyError(WebSocketException, RuntimeError):
    



from . import frames, http11  


lazy_import(
    globals(),
    deprecated_aliases={
        
        "AbortHandshake": ".legacy.exceptions",
        "InvalidStatusCode": ".legacy.exceptions",
        "RedirectHandshake": ".legacy.exceptions",
        "WebSocketProtocolError": ".legacy.exceptions",
    },
)
