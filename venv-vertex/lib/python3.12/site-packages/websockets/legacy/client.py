from __future__ import annotations

import asyncio
import functools
import logging
import os
import random
import traceback
import urllib.parse
import warnings
from collections.abc import AsyncIterator, Generator, Sequence
from types import TracebackType
from typing import Any, Callable, cast

from ..asyncio.compatibility import asyncio_timeout
from ..datastructures import Headers, HeadersLike
from ..exceptions import (
    InvalidHeader,
    InvalidHeaderValue,
    InvalidMessage,
    NegotiationError,
    SecurityError,
)
from ..extensions import ClientExtensionFactory, Extension
from ..extensions.permessage_deflate import enable_client_permessage_deflate
from ..headers import (
    build_authorization_basic,
    build_extension,
    build_host,
    build_subprotocol,
    parse_extension,
    parse_subprotocol,
    validate_subprotocols,
)
from ..http11 import USER_AGENT
from ..typing import ExtensionHeader, LoggerLike, Origin, Subprotocol
from ..uri import WebSocketURI, parse_uri
from .exceptions import InvalidStatusCode, RedirectHandshake
from .handshake import build_request, check_response
from .http import read_response
from .protocol import WebSocketCommonProtocol


__all__ = ["connect", "unix_connect", "WebSocketClientProtocol"]


class WebSocketClientProtocol(WebSocketCommonProtocol):
    

    is_client = True
    side = "client"

    def __init__(
        self,
        *,
        logger: LoggerLike | None = None,
        origin: Origin | None = None,
        extensions: Sequence[ClientExtensionFactory] | None = None,
        subprotocols: Sequence[Subprotocol] | None = None,
        extra_headers: HeadersLike | None = None,
        user_agent_header: str | None = USER_AGENT,
        **kwargs: Any,
    ) -> None:
        if logger is None:
            logger = logging.getLogger("websockets.client")
        super().__init__(logger=logger, **kwargs)
        self.origin = origin
        self.available_extensions = extensions
        self.available_subprotocols = subprotocols
        self.extra_headers = extra_headers
        self.user_agent_header = user_agent_header

    def write_http_request(self, path: str, headers: Headers) -> None:
        
        self.path = path
        self.request_headers = headers

        if self.debug:
            self.logger.debug("> GET %s HTTP/1.1", path)
            for key, value in headers.raw_items():
                self.logger.debug("> %s: %s", key, value)

        
        
        request = f"GET {path} HTTP/1.1\r\n"
        request += str(headers)

        self.transport.write(request.encode())

    async def read_http_response(self) -> tuple[int, Headers]:
        
        try:
            status_code, reason, headers = await read_response(self.reader)
        except Exception as exc:
            raise InvalidMessage("did not receive a valid HTTP response") from exc

        if self.debug:
            self.logger.debug("< HTTP/1.1 %d %s", status_code, reason)
            for key, value in headers.raw_items():
                self.logger.debug("< %s: %s", key, value)

        self.response_headers = headers

        return status_code, self.response_headers

    @staticmethod
    def process_extensions(
        headers: Headers,
        available_extensions: Sequence[ClientExtensionFactory] | None,
    ) -> list[Extension]:
        
        accepted_extensions: list[Extension] = []

        header_values = headers.get_all("Sec-WebSocket-Extensions")

        if header_values:
            if available_extensions is None:
                raise NegotiationError("no extensions supported")

            parsed_header_values: list[ExtensionHeader] = sum(
                [parse_extension(header_value) for header_value in header_values], []
            )

            for name, response_params in parsed_header_values:
                for extension_factory in available_extensions:
                    
                    if extension_factory.name != name:
                        continue

                    
                    try:
                        extension = extension_factory.process_response_params(
                            response_params, accepted_extensions
                        )
                    except NegotiationError:
                        continue

                    
                    accepted_extensions.append(extension)

                    
                    break

                
                
                else:
                    raise NegotiationError(
                        f"Unsupported extension: "
                        f"name = {name}, params = {response_params}"
                    )

        return accepted_extensions

    @staticmethod
    def process_subprotocol(
        headers: Headers, available_subprotocols: Sequence[Subprotocol] | None
    ) -> Subprotocol | None:
        
        subprotocol: Subprotocol | None = None

        header_values = headers.get_all("Sec-WebSocket-Protocol")

        if header_values:
            if available_subprotocols is None:
                raise NegotiationError("no subprotocols supported")

            parsed_header_values: Sequence[Subprotocol] = sum(
                [parse_subprotocol(header_value) for header_value in header_values], []
            )

            if len(parsed_header_values) > 1:
                raise InvalidHeaderValue(
                    "Sec-WebSocket-Protocol",
                    f"multiple values: {', '.join(parsed_header_values)}",
                )

            subprotocol = parsed_header_values[0]

            if subprotocol not in available_subprotocols:
                raise NegotiationError(f"unsupported subprotocol: {subprotocol}")

        return subprotocol

    async def handshake(
        self,
        wsuri: WebSocketURI,
        origin: Origin | None = None,
        available_extensions: Sequence[ClientExtensionFactory] | None = None,
        available_subprotocols: Sequence[Subprotocol] | None = None,
        extra_headers: HeadersLike | None = None,
    ) -> None:
        
        request_headers = Headers()

        request_headers["Host"] = build_host(wsuri.host, wsuri.port, wsuri.secure)

        if wsuri.user_info:
            request_headers["Authorization"] = build_authorization_basic(
                *wsuri.user_info
            )

        if origin is not None:
            request_headers["Origin"] = origin

        key = build_request(request_headers)

        if available_extensions is not None:
            extensions_header = build_extension(
                [
                    (extension_factory.name, extension_factory.get_request_params())
                    for extension_factory in available_extensions
                ]
            )
            request_headers["Sec-WebSocket-Extensions"] = extensions_header

        if available_subprotocols is not None:
            protocol_header = build_subprotocol(available_subprotocols)
            request_headers["Sec-WebSocket-Protocol"] = protocol_header

        if self.extra_headers is not None:
            request_headers.update(self.extra_headers)

        if self.user_agent_header:
            request_headers.setdefault("User-Agent", self.user_agent_header)

        self.write_http_request(wsuri.resource_name, request_headers)

        status_code, response_headers = await self.read_http_response()
        if status_code in (301, 302, 303, 307, 308):
            if "Location" not in response_headers:
                raise InvalidHeader("Location")
            raise RedirectHandshake(response_headers["Location"])
        elif status_code != 101:
            raise InvalidStatusCode(status_code, response_headers)

        check_response(response_headers, key)

        self.extensions = self.process_extensions(
            response_headers, available_extensions
        )

        self.subprotocol = self.process_subprotocol(
            response_headers, available_subprotocols
        )

        self.connection_open()


class Connect:
    

    MAX_REDIRECTS_ALLOWED = int(os.environ.get("WEBSOCKETS_MAX_REDIRECTS", "10"))

    def __init__(
        self,
        uri: str,
        *,
        create_protocol: Callable[..., WebSocketClientProtocol] | None = None,
        logger: LoggerLike | None = None,
        compression: str | None = "deflate",
        origin: Origin | None = None,
        extensions: Sequence[ClientExtensionFactory] | None = None,
        subprotocols: Sequence[Subprotocol] | None = None,
        extra_headers: HeadersLike | None = None,
        user_agent_header: str | None = USER_AGENT,
        open_timeout: float | None = 10,
        ping_interval: float | None = 20,
        ping_timeout: float | None = 20,
        close_timeout: float | None = None,
        max_size: int | None = 2**20,
        max_queue: int | None = 2**5,
        read_limit: int = 2**16,
        write_limit: int = 2**16,
        **kwargs: Any,
    ) -> None:
        
        timeout: float | None = kwargs.pop("timeout", None)
        if timeout is None:
            timeout = 10
        else:
            warnings.warn("rename timeout to close_timeout", DeprecationWarning)
        
        if close_timeout is None:
            close_timeout = timeout

        
        klass: type[WebSocketClientProtocol] | None = kwargs.pop("klass", None)
        if klass is None:
            klass = WebSocketClientProtocol
        else:
            warnings.warn("rename klass to create_protocol", DeprecationWarning)
        
        if create_protocol is None:
            create_protocol = klass

        
        legacy_recv: bool = kwargs.pop("legacy_recv", False)

        
        _loop: asyncio.AbstractEventLoop | None = kwargs.pop("loop", None)
        if _loop is None:
            loop = asyncio.get_event_loop()
        else:
            loop = _loop
            warnings.warn("remove loop argument", DeprecationWarning)

        wsuri = parse_uri(uri)
        if wsuri.secure:
            kwargs.setdefault("ssl", True)
        elif kwargs.get("ssl") is not None:
            raise ValueError(
                "connect() received a ssl argument for a ws:// URI, "
                "use a wss:// URI to enable TLS"
            )

        if compression == "deflate":
            extensions = enable_client_permessage_deflate(extensions)
        elif compression is not None:
            raise ValueError(f"unsupported compression: {compression}")

        if subprotocols is not None:
            validate_subprotocols(subprotocols)

        
        
        create_protocol = cast(Callable[..., WebSocketClientProtocol], create_protocol)
        factory = functools.partial(
            create_protocol,
            logger=logger,
            origin=origin,
            extensions=extensions,
            subprotocols=subprotocols,
            extra_headers=extra_headers,
            user_agent_header=user_agent_header,
            ping_interval=ping_interval,
            ping_timeout=ping_timeout,
            close_timeout=close_timeout,
            max_size=max_size,
            max_queue=max_queue,
            read_limit=read_limit,
            write_limit=write_limit,
            host=wsuri.host,
            port=wsuri.port,
            secure=wsuri.secure,
            legacy_recv=legacy_recv,
            loop=_loop,
        )

        if kwargs.pop("unix", False):
            path: str | None = kwargs.pop("path", None)
            create_connection = functools.partial(
                loop.create_unix_connection, factory, path, **kwargs
            )
        else:
            host: str | None
            port: int | None
            if kwargs.get("sock") is None:
                host, port = wsuri.host, wsuri.port
            else:
                
                host, port = None, None
                if kwargs.get("ssl"):
                    kwargs.setdefault("server_hostname", wsuri.host)
            
            host = kwargs.pop("host", host)
            port = kwargs.pop("port", port)
            create_connection = functools.partial(
                loop.create_connection, factory, host, port, **kwargs
            )

        self.open_timeout = open_timeout
        if logger is None:
            logger = logging.getLogger("websockets.client")
        self.logger = logger

        
        self._create_connection = create_connection
        self._uri = uri
        self._wsuri = wsuri

    def handle_redirect(self, uri: str) -> None:
        
        old_uri = self._uri
        old_wsuri = self._wsuri
        new_uri = urllib.parse.urljoin(old_uri, uri)
        new_wsuri = parse_uri(new_uri)

        
        if old_wsuri.secure and not new_wsuri.secure:
            raise SecurityError("redirect from WSS to WS")

        same_origin = (
            old_wsuri.secure == new_wsuri.secure
            and old_wsuri.host == new_wsuri.host
            and old_wsuri.port == new_wsuri.port
        )

        
        
        
        if not same_origin:
            factory = self._create_connection.args[0]
            
            if not old_wsuri.secure and new_wsuri.secure:
                factory.keywords["secure"] = True
                self._create_connection.keywords.setdefault("ssl", True)
            
            factory = functools.partial(
                factory.func,
                *factory.args,
                **dict(factory.keywords, host=new_wsuri.host, port=new_wsuri.port),
            )
            
            self._create_connection = functools.partial(
                self._create_connection.func,
                *(factory, new_wsuri.host, new_wsuri.port),
                **self._create_connection.keywords,
            )

        
        self._uri = new_uri
        self._wsuri = new_wsuri

    

    BACKOFF_INITIAL = float(os.environ.get("WEBSOCKETS_BACKOFF_INITIAL_DELAY", "5"))
    BACKOFF_MIN = float(os.environ.get("WEBSOCKETS_BACKOFF_MIN_DELAY", "3.1"))
    BACKOFF_MAX = float(os.environ.get("WEBSOCKETS_BACKOFF_MAX_DELAY", "90.0"))
    BACKOFF_FACTOR = float(os.environ.get("WEBSOCKETS_BACKOFF_FACTOR", "1.618"))

    async def __aiter__(self) -> AsyncIterator[WebSocketClientProtocol]:
        backoff_delay = self.BACKOFF_MIN / self.BACKOFF_FACTOR
        while True:
            try:
                async with self as protocol:
                    yield protocol
            except Exception as exc:
                
                
                if backoff_delay == self.BACKOFF_MIN:
                    initial_delay = random.random() * self.BACKOFF_INITIAL
                    self.logger.info(
                        "connect failed; reconnecting in %.1f seconds: %s",
                        initial_delay,
                        
                        traceback.format_exception_only(type(exc), exc)[0].strip(),
                    )
                    await asyncio.sleep(initial_delay)
                else:
                    self.logger.info(
                        "connect failed again; retrying in %d seconds: %s",
                        int(backoff_delay),
                        
                        traceback.format_exception_only(type(exc), exc)[0].strip(),
                    )
                    await asyncio.sleep(int(backoff_delay))
                
                backoff_delay = backoff_delay * self.BACKOFF_FACTOR
                backoff_delay = min(backoff_delay, self.BACKOFF_MAX)
                continue
            else:
                
                backoff_delay = self.BACKOFF_MIN

    

    async def __aenter__(self) -> WebSocketClientProtocol:
        return await self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        await self.protocol.close()

    

    def __await__(self) -> Generator[Any, None, WebSocketClientProtocol]:
        
        return self.__await_impl__().__await__()

    async def __await_impl__(self) -> WebSocketClientProtocol:
        async with asyncio_timeout(self.open_timeout):
            for _redirects in range(self.MAX_REDIRECTS_ALLOWED):
                _transport, protocol = await self._create_connection()
                try:
                    await protocol.handshake(
                        self._wsuri,
                        origin=protocol.origin,
                        available_extensions=protocol.available_extensions,
                        available_subprotocols=protocol.available_subprotocols,
                        extra_headers=protocol.extra_headers,
                    )
                except RedirectHandshake as exc:
                    protocol.fail_connection()
                    await protocol.wait_closed()
                    self.handle_redirect(exc.uri)
                
                except (Exception, asyncio.CancelledError):
                    protocol.fail_connection()
                    await protocol.wait_closed()
                    raise
                else:
                    self.protocol = protocol
                    return protocol
            else:
                raise SecurityError("too many redirects")

    

    __iter__ = __await__


connect = Connect


def unix_connect(
    path: str | None = None,
    uri: str = "ws://localhost/",
    **kwargs: Any,
) -> Connect:
    
    return connect(uri=uri, path=path, unix=True, **kwargs)
