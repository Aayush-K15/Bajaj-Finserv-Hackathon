from __future__ import annotations

import asyncio
import codecs
import collections
import logging
import random
import ssl
import struct
import sys
import time
import traceback
import uuid
import warnings
from collections.abc import AsyncIterable, AsyncIterator, Awaitable, Iterable, Mapping
from typing import Any, Callable, Deque, cast

from ..asyncio.compatibility import asyncio_timeout
from ..datastructures import Headers
from ..exceptions import (
    ConnectionClosed,
    ConnectionClosedError,
    ConnectionClosedOK,
    InvalidState,
    PayloadTooBig,
    ProtocolError,
)
from ..extensions import Extension
from ..frames import (
    OK_CLOSE_CODES,
    OP_BINARY,
    OP_CLOSE,
    OP_CONT,
    OP_PING,
    OP_PONG,
    OP_TEXT,
    Close,
    CloseCode,
    Opcode,
)
from ..protocol import State
from ..typing import Data, LoggerLike, Subprotocol
from .framing import Frame, prepare_ctrl, prepare_data


__all__ = ["WebSocketCommonProtocol"]







class WebSocketCommonProtocol(asyncio.Protocol):
    

    
    
    
    is_client: bool
    side: str = "undefined"

    def __init__(
        self,
        *,
        logger: LoggerLike | None = None,
        ping_interval: float | None = 20,
        ping_timeout: float | None = 20,
        close_timeout: float | None = None,
        max_size: int | None = 2**20,
        max_queue: int | None = 2**5,
        read_limit: int = 2**16,
        write_limit: int = 2**16,
        
        host: str | None = None,
        port: int | None = None,
        secure: bool | None = None,
        legacy_recv: bool = False,
        loop: asyncio.AbstractEventLoop | None = None,
        timeout: float | None = None,
    ) -> None:
        if legacy_recv:  
            warnings.warn("legacy_recv is deprecated", DeprecationWarning)

        
        if timeout is None:
            timeout = 10
        else:
            warnings.warn("rename timeout to close_timeout", DeprecationWarning)
        
        if close_timeout is None:
            close_timeout = timeout

        
        if loop is None:
            loop = asyncio.get_event_loop()
        else:
            warnings.warn("remove loop argument", DeprecationWarning)

        self.ping_interval = ping_interval
        self.ping_timeout = ping_timeout
        self.close_timeout = close_timeout
        self.max_size = max_size
        self.max_queue = max_queue
        self.read_limit = read_limit
        self.write_limit = write_limit

        
        self.id: uuid.UUID = uuid.uuid4()
        

        
        if logger is None:
            logger = logging.getLogger("websockets.protocol")
        self.logger: LoggerLike = logging.LoggerAdapter(logger, {"websocket": self})
        

        
        self.debug = logger.isEnabledFor(logging.DEBUG)

        self.loop = loop

        self._host = host
        self._port = port
        self._secure = secure
        self.legacy_recv = legacy_recv

        
        
        
        
        self.reader = asyncio.StreamReader(limit=read_limit // 2, loop=loop)

        
        self._paused = False
        self._drain_waiter: asyncio.Future[None] | None = None

        self._drain_lock = asyncio.Lock()

        
        
        
        
        self.state = State.CONNECTING
        if self.debug:
            self.logger.debug("= connection is CONNECTING")

        
        self.path: str
        
        self.request_headers: Headers
        
        self.response_headers: Headers
        

        
        self.extensions: list[Extension] = []
        self.subprotocol: Subprotocol | None = None
        

        
        self.close_rcvd: Close | None = None
        self.close_sent: Close | None = None
        self.close_rcvd_then_sent: bool | None = None

        
        
        
        
        self.connection_lost_waiter: asyncio.Future[None] = loop.create_future()

        
        self.messages: Deque[Data] = collections.deque()
        self._pop_message_waiter: asyncio.Future[None] | None = None
        self._put_message_waiter: asyncio.Future[None] | None = None

        
        self._fragmented_message_waiter: asyncio.Future[None] | None = None

        
        self.pings: dict[bytes, tuple[asyncio.Future[float], float]] = {}

        self.latency: float = 0
        

        
        self.transfer_data_task: asyncio.Task[None]

        
        self.transfer_data_exc: BaseException | None = None

        
        self.keepalive_ping_task: asyncio.Task[None]

        
        self.close_connection_task: asyncio.Task[None]

    
    async def _drain_helper(self) -> None:  
        if self.connection_lost_waiter.done():
            raise ConnectionResetError("Connection lost")
        if not self._paused:
            return
        waiter = self._drain_waiter
        assert waiter is None or waiter.cancelled()
        waiter = self.loop.create_future()
        self._drain_waiter = waiter
        await waiter

    
    async def _drain(self) -> None:  
        if self.reader is not None:
            exc = self.reader.exception()
            if exc is not None:
                raise exc
        if self.transport is not None:
            if self.transport.is_closing():
                
                
                
                
                
                
                await asyncio.sleep(0)
        await self._drain_helper()

    def connection_open(self) -> None:
        
        
        assert self.state is State.CONNECTING
        self.state = State.OPEN
        if self.debug:
            self.logger.debug("= connection is OPEN")
        
        self.transfer_data_task = self.loop.create_task(self.transfer_data())
        
        self.keepalive_ping_task = self.loop.create_task(self.keepalive_ping())
        
        self.close_connection_task = self.loop.create_task(self.close_connection())

    @property
    def host(self) -> str | None:
        alternative = "remote_address" if self.is_client else "local_address"
        warnings.warn(f"use {alternative}[0] instead of host", DeprecationWarning)
        return self._host

    @property
    def port(self) -> int | None:
        alternative = "remote_address" if self.is_client else "local_address"
        warnings.warn(f"use {alternative}[1] instead of port", DeprecationWarning)
        return self._port

    @property
    def secure(self) -> bool | None:
        warnings.warn("don't use secure", DeprecationWarning)
        return self._secure

    

    @property
    def local_address(self) -> Any:
        
        try:
            transport = self.transport
        except AttributeError:
            return None
        else:
            return transport.get_extra_info("sockname")

    @property
    def remote_address(self) -> Any:
        
        try:
            transport = self.transport
        except AttributeError:
            return None
        else:
            return transport.get_extra_info("peername")

    @property
    def open(self) -> bool:
        
        return self.state is State.OPEN and not self.transfer_data_task.done()

    @property
    def closed(self) -> bool:
        
        return self.state is State.CLOSED

    @property
    def close_code(self) -> int | None:
        
        if self.state is not State.CLOSED:
            return None
        elif self.close_rcvd is None:
            return CloseCode.ABNORMAL_CLOSURE
        else:
            return self.close_rcvd.code

    @property
    def close_reason(self) -> str | None:
        
        if self.state is not State.CLOSED:
            return None
        elif self.close_rcvd is None:
            return ""
        else:
            return self.close_rcvd.reason

    async def __aiter__(self) -> AsyncIterator[Data]:
        
        try:
            while True:
                yield await self.recv()
        except ConnectionClosedOK:
            return

    async def recv(self) -> Data:
        
        if self._pop_message_waiter is not None:
            raise RuntimeError(
                "cannot call recv while another coroutine "
                "is already waiting for the next message"
            )

        
        
        
        
        

        
        
        while len(self.messages) <= 0:
            pop_message_waiter: asyncio.Future[None] = self.loop.create_future()
            self._pop_message_waiter = pop_message_waiter
            try:
                
                
                await asyncio.wait(
                    [pop_message_waiter, self.transfer_data_task],
                    return_when=asyncio.FIRST_COMPLETED,
                )
            finally:
                self._pop_message_waiter = None

            
            
            
            if not pop_message_waiter.done():
                if self.legacy_recv:
                    return None  
                else:
                    
                    
                    await self.ensure_open()

        
        message = self.messages.popleft()

        
        if self._put_message_waiter is not None:
            self._put_message_waiter.set_result(None)
            self._put_message_waiter = None

        return message

    async def send(
        self,
        message: Data | Iterable[Data] | AsyncIterable[Data],
    ) -> None:
        
        await self.ensure_open()

        
        
        while self._fragmented_message_waiter is not None:
            await asyncio.shield(self._fragmented_message_waiter)

        
        

        if isinstance(message, (str, bytes, bytearray, memoryview)):
            opcode, data = prepare_data(message)
            await self.write_frame(True, opcode, data)

        

        elif isinstance(message, Mapping):
            raise TypeError("data is a dict-like object")

        

        elif isinstance(message, Iterable):
            
            message = cast(Iterable[Data], message)

            iter_message = iter(message)
            try:
                fragment = next(iter_message)
            except StopIteration:
                return
            opcode, data = prepare_data(fragment)

            self._fragmented_message_waiter = self.loop.create_future()
            try:
                
                await self.write_frame(False, opcode, data)

                
                for fragment in iter_message:
                    confirm_opcode, data = prepare_data(fragment)
                    if confirm_opcode != opcode:
                        raise TypeError("data contains inconsistent types")
                    await self.write_frame(False, OP_CONT, data)

                
                await self.write_frame(True, OP_CONT, b"")

            except (Exception, asyncio.CancelledError):
                
                
                self.fail_connection(CloseCode.INTERNAL_ERROR)
                raise

            finally:
                self._fragmented_message_waiter.set_result(None)
                self._fragmented_message_waiter = None

        

        elif isinstance(message, AsyncIterable):
            
            
            aiter_message = cast(
                Callable[[AsyncIterable[Data]], AsyncIterator[Data]],
                type(message).__aiter__,
            )(message)
            try:
                
                
                fragment = await cast(
                    Callable[[AsyncIterator[Data]], Awaitable[Data]],
                    type(aiter_message).__anext__,
                )(aiter_message)
            except StopAsyncIteration:
                return
            opcode, data = prepare_data(fragment)

            self._fragmented_message_waiter = self.loop.create_future()
            try:
                
                await self.write_frame(False, opcode, data)

                
                async for fragment in aiter_message:
                    confirm_opcode, data = prepare_data(fragment)
                    if confirm_opcode != opcode:
                        raise TypeError("data contains inconsistent types")
                    await self.write_frame(False, OP_CONT, data)

                
                await self.write_frame(True, OP_CONT, b"")

            except (Exception, asyncio.CancelledError):
                
                
                self.fail_connection(CloseCode.INTERNAL_ERROR)
                raise

            finally:
                self._fragmented_message_waiter.set_result(None)
                self._fragmented_message_waiter = None

        else:
            raise TypeError("data must be str, bytes-like, or iterable")

    async def close(
        self,
        code: int = CloseCode.NORMAL_CLOSURE,
        reason: str = "",
    ) -> None:
        
        try:
            async with asyncio_timeout(self.close_timeout):
                await self.write_close_frame(Close(code, reason))
        except asyncio.TimeoutError:
            
            
            
            self.fail_connection()

        
        

        
        
        

        try:
            
            
            async with asyncio_timeout(self.close_timeout):
                await self.transfer_data_task
        except (asyncio.TimeoutError, asyncio.CancelledError):
            pass

        
        await asyncio.shield(self.close_connection_task)

    async def wait_closed(self) -> None:
        
        await asyncio.shield(self.connection_lost_waiter)

    async def ping(self, data: Data | None = None) -> Awaitable[float]:
        
        await self.ensure_open()

        if data is not None:
            data = prepare_ctrl(data)

        
        if data in self.pings:
            raise RuntimeError("already waiting for a pong with the same data")

        
        while data is None or data in self.pings:
            data = struct.pack("!I", random.getrandbits(32))

        pong_waiter = self.loop.create_future()
        
        ping_timestamp = time.perf_counter()
        self.pings[data] = (pong_waiter, ping_timestamp)

        await self.write_frame(True, OP_PING, data)

        return asyncio.shield(pong_waiter)

    async def pong(self, data: Data = b"") -> None:
        
        await self.ensure_open()

        data = prepare_ctrl(data)

        await self.write_frame(True, OP_PONG, data)

    

    def connection_closed_exc(self) -> ConnectionClosed:
        exc: ConnectionClosed
        if (
            self.close_rcvd is not None
            and self.close_rcvd.code in OK_CLOSE_CODES
            and self.close_sent is not None
            and self.close_sent.code in OK_CLOSE_CODES
        ):
            exc = ConnectionClosedOK(
                self.close_rcvd,
                self.close_sent,
                self.close_rcvd_then_sent,
            )
        else:
            exc = ConnectionClosedError(
                self.close_rcvd,
                self.close_sent,
                self.close_rcvd_then_sent,
            )
        
        exc.__cause__ = self.transfer_data_exc
        return exc

    async def ensure_open(self) -> None:
        
        
        if self.state is State.OPEN:
            
            
            
            if self.transfer_data_task.done():
                await asyncio.shield(self.close_connection_task)
                raise self.connection_closed_exc()
            else:
                return

        if self.state is State.CLOSED:
            raise self.connection_closed_exc()

        if self.state is State.CLOSING:
            
            
            
            
            
            await asyncio.shield(self.close_connection_task)
            raise self.connection_closed_exc()

        
        assert self.state is State.CONNECTING
        raise InvalidState("WebSocket connection isn't established yet")

    async def transfer_data(self) -> None:
        
        try:
            while True:
                message = await self.read_message()

                
                if message is None:
                    break

                
                if self.max_queue is not None:
                    while len(self.messages) >= self.max_queue:
                        self._put_message_waiter = self.loop.create_future()
                        try:
                            await asyncio.shield(self._put_message_waiter)
                        finally:
                            self._put_message_waiter = None

                
                self.messages.append(message)

                
                if self._pop_message_waiter is not None:
                    self._pop_message_waiter.set_result(None)
                    self._pop_message_waiter = None

        except asyncio.CancelledError as exc:
            self.transfer_data_exc = exc
            
            
            raise

        except ProtocolError as exc:
            self.transfer_data_exc = exc
            self.fail_connection(CloseCode.PROTOCOL_ERROR)

        except (ConnectionError, TimeoutError, EOFError, ssl.SSLError) as exc:
            
            
            
            
            
            
            
            self.transfer_data_exc = exc
            self.fail_connection(CloseCode.ABNORMAL_CLOSURE)

        except UnicodeDecodeError as exc:
            self.transfer_data_exc = exc
            self.fail_connection(CloseCode.INVALID_DATA)

        except PayloadTooBig as exc:
            self.transfer_data_exc = exc
            self.fail_connection(CloseCode.MESSAGE_TOO_BIG)

        except Exception as exc:
            
            
            
            self.logger.error("data transfer failed", exc_info=True)

            self.transfer_data_exc = exc
            self.fail_connection(CloseCode.INTERNAL_ERROR)

    async def read_message(self) -> Data | None:
        
        frame = await self.read_data_frame(max_size=self.max_size)

        
        if frame is None:
            return None

        if frame.opcode == OP_TEXT:
            text = True
        elif frame.opcode == OP_BINARY:
            text = False
        else:  
            raise ProtocolError("unexpected opcode")

        
        if frame.fin:
            return frame.data.decode() if text else frame.data

        
        fragments: list[Data] = []
        max_size = self.max_size
        if text:
            decoder_factory = codecs.getincrementaldecoder("utf-8")
            decoder = decoder_factory(errors="strict")
            if max_size is None:

                def append(frame: Frame) -> None:
                    nonlocal fragments
                    fragments.append(decoder.decode(frame.data, frame.fin))

            else:

                def append(frame: Frame) -> None:
                    nonlocal fragments, max_size
                    fragments.append(decoder.decode(frame.data, frame.fin))
                    assert isinstance(max_size, int)
                    max_size -= len(frame.data)

        else:
            if max_size is None:

                def append(frame: Frame) -> None:
                    nonlocal fragments
                    fragments.append(frame.data)

            else:

                def append(frame: Frame) -> None:
                    nonlocal fragments, max_size
                    fragments.append(frame.data)
                    assert isinstance(max_size, int)
                    max_size -= len(frame.data)

        append(frame)

        while not frame.fin:
            frame = await self.read_data_frame(max_size=max_size)
            if frame is None:
                raise ProtocolError("incomplete fragmented message")
            if frame.opcode != OP_CONT:
                raise ProtocolError("unexpected opcode")
            append(frame)

        return ("" if text else b"").join(fragments)

    async def read_data_frame(self, max_size: int | None) -> Frame | None:
        
        
        while True:
            frame = await self.read_frame(max_size)

            
            if frame.opcode == OP_CLOSE:
                
                
                self.close_rcvd = Close.parse(frame.data)
                if self.close_sent is not None:
                    self.close_rcvd_then_sent = False
                try:
                    
                    
                    
                    await self.write_close_frame(self.close_rcvd, frame.data)
                except ConnectionClosed:
                    
                    pass
                return None

            elif frame.opcode == OP_PING:
                
                if self.state is State.OPEN:
                    try:
                        await self.pong(frame.data)
                    except ConnectionClosed:
                        
                        pass

            elif frame.opcode == OP_PONG:
                if frame.data in self.pings:
                    pong_timestamp = time.perf_counter()
                    
                    
                    ping_id = None
                    ping_ids = []
                    for ping_id, (pong_waiter, ping_timestamp) in self.pings.items():
                        ping_ids.append(ping_id)
                        if not pong_waiter.done():
                            pong_waiter.set_result(pong_timestamp - ping_timestamp)
                        if ping_id == frame.data:
                            self.latency = pong_timestamp - ping_timestamp
                            break
                    else:
                        raise AssertionError("solicited pong not found in pings")
                    
                    for ping_id in ping_ids:
                        del self.pings[ping_id]

            
            else:
                return frame

    async def read_frame(self, max_size: int | None) -> Frame:
        
        frame = await Frame.read(
            self.reader.readexactly,
            mask=not self.is_client,
            max_size=max_size,
            extensions=self.extensions,
        )
        if self.debug:
            self.logger.debug("< %s", frame)
        return frame

    def write_frame_sync(self, fin: bool, opcode: int, data: bytes) -> None:
        frame = Frame(fin, Opcode(opcode), data)
        if self.debug:
            self.logger.debug("> %s", frame)
        frame.write(
            self.transport.write,
            mask=self.is_client,
            extensions=self.extensions,
        )

    async def drain(self) -> None:
        try:
            
            
            
            async with self._drain_lock:
                
                await self._drain()
        except ConnectionError:
            
            self.fail_connection()
            
            
            await self.ensure_open()

    async def write_frame(
        self, fin: bool, opcode: int, data: bytes, *, _state: int = State.OPEN
    ) -> None:
        
        if self.state is not _state:  
            raise InvalidState(
                f"Cannot write to a WebSocket in the {self.state.name} state"
            )
        self.write_frame_sync(fin, opcode, data)
        await self.drain()

    async def write_close_frame(self, close: Close, data: bytes | None = None) -> None:
        
        
        
        if self.state is State.OPEN:
            
            self.state = State.CLOSING
            if self.debug:
                self.logger.debug("= connection is CLOSING")

            self.close_sent = close
            if self.close_rcvd is not None:
                self.close_rcvd_then_sent = True
            if data is None:
                data = close.serialize()

            
            await self.write_frame(True, OP_CLOSE, data, _state=State.CLOSING)

    async def keepalive_ping(self) -> None:
        
        if self.ping_interval is None:
            return

        try:
            while True:
                await asyncio.sleep(self.ping_interval)

                self.logger.debug("% sending keepalive ping")
                pong_waiter = await self.ping()

                if self.ping_timeout is not None:
                    try:
                        async with asyncio_timeout(self.ping_timeout):
                            
                            
                            
                            
                            await pong_waiter
                        self.logger.debug("% received keepalive pong")
                    except asyncio.TimeoutError:
                        if self.debug:
                            self.logger.debug("- timed out waiting for keepalive pong")
                        self.fail_connection(
                            CloseCode.INTERNAL_ERROR,
                            "keepalive ping timeout",
                        )
                        break

        except ConnectionClosed:
            pass

        except Exception:
            self.logger.error("keepalive ping failed", exc_info=True)

    async def close_connection(self) -> None:
        
        try:
            
            if hasattr(self, "transfer_data_task"):
                try:
                    await self.transfer_data_task
                except asyncio.CancelledError:
                    pass

            
            if hasattr(self, "keepalive_ping_task"):
                self.keepalive_ping_task.cancel()

            
            if self.is_client and hasattr(self, "transfer_data_task"):
                if await self.wait_for_connection_lost():
                    return
                if self.debug:
                    self.logger.debug("- timed out waiting for TCP close")

            
            if self.transport.can_write_eof():
                if self.debug:
                    self.logger.debug("x half-closing TCP connection")
                
                
                
                
                try:
                    self.transport.write_eof()
                except (OSError, RuntimeError):  
                    pass

                if await self.wait_for_connection_lost():
                    return
                if self.debug:
                    self.logger.debug("- timed out waiting for TCP close")

        finally:
            
            
            await self.close_transport()

    async def close_transport(self) -> None:
        
        
        
        
        if self.connection_lost_waiter.done() and self.transport.is_closing():
            return

        
        if self.debug:
            self.logger.debug("x closing TCP connection")
        self.transport.close()

        if await self.wait_for_connection_lost():
            return
        if self.debug:
            self.logger.debug("- timed out waiting for TCP close")

        
        if self.debug:
            self.logger.debug("x aborting TCP connection")
        self.transport.abort()

        
        await self.wait_for_connection_lost()

    async def wait_for_connection_lost(self) -> bool:
        
        if not self.connection_lost_waiter.done():
            try:
                async with asyncio_timeout(self.close_timeout):
                    await asyncio.shield(self.connection_lost_waiter)
            except asyncio.TimeoutError:
                pass
        
        
        
        return self.connection_lost_waiter.done()

    def fail_connection(
        self,
        code: int = CloseCode.ABNORMAL_CLOSURE,
        reason: str = "",
    ) -> None:
        
        if self.debug:
            self.logger.debug("! failing connection with code %d", code)

        
        
        if hasattr(self, "transfer_data_task"):
            self.transfer_data_task.cancel()

        
        
        
        
        if code != CloseCode.ABNORMAL_CLOSURE and self.state is State.OPEN:
            close = Close(code, reason)

            

            
            
            

            

            self.state = State.CLOSING
            if self.debug:
                self.logger.debug("= connection is CLOSING")

            
            
            
            assert self.close_rcvd is None
            self.close_sent = close

            self.write_frame_sync(True, OP_CLOSE, close.serialize())

        
        if not hasattr(self, "close_connection_task"):
            self.close_connection_task = self.loop.create_task(self.close_connection())

    def abort_pings(self) -> None:
        
        assert self.state is State.CLOSED
        exc = self.connection_closed_exc()

        for pong_waiter, _ping_timestamp in self.pings.values():
            pong_waiter.set_exception(exc)
            
            
            
            
            pong_waiter.cancel()

    

    def connection_made(self, transport: asyncio.BaseTransport) -> None:
        
        transport = cast(asyncio.Transport, transport)
        transport.set_write_buffer_limits(self.write_limit)
        self.transport = transport

        
        self.reader.set_transport(transport)

    def connection_lost(self, exc: Exception | None) -> None:
        
        self.state = State.CLOSED
        self.logger.debug("= connection is CLOSED")

        self.abort_pings()

        
        
        
        self.connection_lost_waiter.set_result(None)

        if True:  
            
            if self.reader is not None:
                if exc is None:
                    self.reader.feed_eof()
                else:
                    self.reader.set_exception(exc)

            
            
            if not self._paused:
                return
            waiter = self._drain_waiter
            if waiter is None:
                return
            self._drain_waiter = None
            if waiter.done():
                return
            if exc is None:
                waiter.set_result(None)
            else:
                waiter.set_exception(exc)

    def pause_writing(self) -> None:  
        assert not self._paused
        self._paused = True

    def resume_writing(self) -> None:  
        assert self._paused
        self._paused = False

        waiter = self._drain_waiter
        if waiter is not None:
            self._drain_waiter = None
            if not waiter.done():
                waiter.set_result(None)

    def data_received(self, data: bytes) -> None:
        self.reader.feed_data(data)

    def eof_received(self) -> None:
        
        self.reader.feed_eof()








def broadcast(
    websockets: Iterable[WebSocketCommonProtocol],
    message: Data,
    raise_exceptions: bool = False,
) -> None:
    
    if not isinstance(message, (str, bytes, bytearray, memoryview)):
        raise TypeError("data must be str or bytes-like")

    if raise_exceptions:
        if sys.version_info[:2] < (3, 11):  
            raise ValueError("raise_exceptions requires at least Python 3.11")
        exceptions = []

    opcode, data = prepare_data(message)

    for websocket in websockets:
        if websocket.state is not State.OPEN:
            continue

        if websocket._fragmented_message_waiter is not None:
            if raise_exceptions:
                exception = RuntimeError("sending a fragmented message")
                exceptions.append(exception)
            else:
                websocket.logger.warning(
                    "skipped broadcast: sending a fragmented message",
                )
            continue

        try:
            websocket.write_frame_sync(True, opcode, data)
        except Exception as write_exception:
            if raise_exceptions:
                exception = RuntimeError("failed to write message")
                exception.__cause__ = write_exception
                exceptions.append(exception)
            else:
                websocket.logger.warning(
                    "skipped broadcast: failed to write message: %s",
                    traceback.format_exception_only(
                        
                        type(write_exception),
                        write_exception,
                    )[0].strip(),
                )

    if raise_exceptions and exceptions:
        raise ExceptionGroup("skipped broadcast", exceptions)



broadcast.__module__ = "websockets.legacy.server"
