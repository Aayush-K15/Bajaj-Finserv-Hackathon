from __future__ import annotations

import contextlib
import logging
import random
import socket
import struct
import threading
import time
import uuid
from collections.abc import Iterable, Iterator, Mapping
from types import TracebackType
from typing import Any, Literal, overload

from ..exceptions import (
    ConcurrencyError,
    ConnectionClosed,
    ConnectionClosedOK,
    ProtocolError,
)
from ..frames import DATA_OPCODES, BytesLike, CloseCode, Frame, Opcode
from ..http11 import Request, Response
from ..protocol import CLOSED, OPEN, Event, Protocol, State
from ..typing import Data, LoggerLike, Subprotocol
from .messages import Assembler
from .utils import Deadline


__all__ = ["Connection"]


class Connection:
    

    recv_bufsize = 65536

    def __init__(
        self,
        socket: socket.socket,
        protocol: Protocol,
        *,
        ping_interval: float | None = 20,
        ping_timeout: float | None = 20,
        close_timeout: float | None = 10,
        max_queue: int | None | tuple[int | None, int | None] = 16,
    ) -> None:
        self.socket = socket
        self.protocol = protocol
        self.ping_interval = ping_interval
        self.ping_timeout = ping_timeout
        self.close_timeout = close_timeout
        if isinstance(max_queue, int) or max_queue is None:
            max_queue = (max_queue, None)
        self.max_queue = max_queue

        
        self.protocol.logger = logging.LoggerAdapter(
            self.protocol.logger,
            {"websocket": self},
        )

        
        self.id: uuid.UUID = self.protocol.id
        
        self.logger: LoggerLike = self.protocol.logger
        
        self.debug = self.protocol.debug

        
        self.request: Request | None = None
        
        self.response: Response | None = None
        

        
        self.protocol_mutex = threading.Lock()

        
        self.recv_flow_control = threading.Lock()

        
        self.recv_messages = Assembler(
            *self.max_queue,
            pause=self.recv_flow_control.acquire,
            resume=self.recv_flow_control.release,
        )

        
        self.close_deadline: Deadline | None = None

        
        self.send_in_progress = False

        
        self.pong_waiters: dict[bytes, tuple[threading.Event, float, bool]] = {}

        self.latency: float = 0
        

        
        self.keepalive_thread: threading.Thread | None = None

        
        
        self.recv_exc: BaseException | None = None

        
        
        
        self.recv_events_thread = threading.Thread(
            target=self.recv_events,
            daemon=True,
        )

        
        self.recv_events_thread.start()

    

    @property
    def local_address(self) -> Any:
        
        return self.socket.getsockname()

    @property
    def remote_address(self) -> Any:
        
        return self.socket.getpeername()

    @property
    def state(self) -> State:
        
        return self.protocol.state

    @property
    def subprotocol(self) -> Subprotocol | None:
        
        return self.protocol.subprotocol

    @property
    def close_code(self) -> int | None:
        
        return self.protocol.close_code

    @property
    def close_reason(self) -> str | None:
        
        return self.protocol.close_reason

    

    def __enter__(self) -> Connection:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        if exc_type is None:
            self.close()
        else:
            self.close(CloseCode.INTERNAL_ERROR)

    def __iter__(self) -> Iterator[Data]:
        
        try:
            while True:
                yield self.recv()
        except ConnectionClosedOK:
            return

    
    

    @overload
    def recv(self, timeout: float | None, decode: Literal[True]) -> str: ...

    @overload
    def recv(self, timeout: float | None, decode: Literal[False]) -> bytes: ...

    @overload
    def recv(self, timeout: float | None = None, *, decode: Literal[True]) -> str: ...

    @overload
    def recv(
        self, timeout: float | None = None, *, decode: Literal[False]
    ) -> bytes: ...

    @overload
    def recv(
        self, timeout: float | None = None, decode: bool | None = None
    ) -> Data: ...

    def recv(self, timeout: float | None = None, decode: bool | None = None) -> Data:
        
        try:
            return self.recv_messages.get(timeout, decode)
        except EOFError:
            pass
            
        except ConcurrencyError:
            raise ConcurrencyError(
                "cannot call recv while another thread "
                "is already running recv or recv_streaming"
            ) from None
        except UnicodeDecodeError as exc:
            with self.send_context():
                self.protocol.fail(
                    CloseCode.INVALID_DATA,
                    f"{exc.reason} at position {exc.start}",
                )
            

        
        self.recv_events_thread.join()
        raise self.protocol.close_exc from self.recv_exc

    @overload
    def recv_streaming(self, decode: Literal[True]) -> Iterator[str]: ...

    @overload
    def recv_streaming(self, decode: Literal[False]) -> Iterator[bytes]: ...

    @overload
    def recv_streaming(self, decode: bool | None = None) -> Iterator[Data]: ...

    def recv_streaming(self, decode: bool | None = None) -> Iterator[Data]:
        
        try:
            yield from self.recv_messages.get_iter(decode)
            return
        except EOFError:
            pass
            
        except ConcurrencyError:
            raise ConcurrencyError(
                "cannot call recv_streaming while another thread "
                "is already running recv or recv_streaming"
            ) from None
        except UnicodeDecodeError as exc:
            with self.send_context():
                self.protocol.fail(
                    CloseCode.INVALID_DATA,
                    f"{exc.reason} at position {exc.start}",
                )
            

        
        self.recv_events_thread.join()
        raise self.protocol.close_exc from self.recv_exc

    def send(
        self,
        message: Data | Iterable[Data],
        text: bool | None = None,
    ) -> None:
        
        
        

        if isinstance(message, str):
            with self.send_context():
                if self.send_in_progress:
                    raise ConcurrencyError(
                        "cannot call send while another thread is already running send"
                    )
                if text is False:
                    self.protocol.send_binary(message.encode())
                else:
                    self.protocol.send_text(message.encode())

        elif isinstance(message, BytesLike):
            with self.send_context():
                if self.send_in_progress:
                    raise ConcurrencyError(
                        "cannot call send while another thread is already running send"
                    )
                if text is True:
                    self.protocol.send_text(message)
                else:
                    self.protocol.send_binary(message)

        

        elif isinstance(message, Mapping):
            raise TypeError("data is a dict-like object")

        

        elif isinstance(message, Iterable):
            chunks = iter(message)
            try:
                chunk = next(chunks)
            except StopIteration:
                return

            try:
                
                if isinstance(chunk, str):
                    with self.send_context():
                        if self.send_in_progress:
                            raise ConcurrencyError(
                                "cannot call send while another thread "
                                "is already running send"
                            )
                        self.send_in_progress = True
                        if text is False:
                            self.protocol.send_binary(chunk.encode(), fin=False)
                        else:
                            self.protocol.send_text(chunk.encode(), fin=False)
                    encode = True
                elif isinstance(chunk, BytesLike):
                    with self.send_context():
                        if self.send_in_progress:
                            raise ConcurrencyError(
                                "cannot call send while another thread "
                                "is already running send"
                            )
                        self.send_in_progress = True
                        if text is True:
                            self.protocol.send_text(chunk, fin=False)
                        else:
                            self.protocol.send_binary(chunk, fin=False)
                    encode = False
                else:
                    raise TypeError("data iterable must contain bytes or str")

                
                for chunk in chunks:
                    if isinstance(chunk, str) and encode:
                        with self.send_context():
                            assert self.send_in_progress
                            self.protocol.send_continuation(chunk.encode(), fin=False)
                    elif isinstance(chunk, BytesLike) and not encode:
                        with self.send_context():
                            assert self.send_in_progress
                            self.protocol.send_continuation(chunk, fin=False)
                    else:
                        raise TypeError("data iterable must contain uniform types")

                
                with self.send_context():
                    self.protocol.send_continuation(b"", fin=True)
                    self.send_in_progress = False

            except ConcurrencyError:
                
                
                raise

            except Exception:
                
                
                with self.send_context():
                    self.protocol.fail(
                        CloseCode.INTERNAL_ERROR,
                        "error in fragmented message",
                    )
                raise

        else:
            raise TypeError("data must be str, bytes, or iterable")

    def close(self, code: int = CloseCode.NORMAL_CLOSURE, reason: str = "") -> None:
        
        try:
            
            
            with self.send_context():
                if self.send_in_progress:
                    self.protocol.fail(
                        CloseCode.INTERNAL_ERROR,
                        "close during fragmented message",
                    )
                else:
                    self.protocol.send_close(code, reason)
        except ConnectionClosed:
            
            
            pass

    def ping(
        self,
        data: Data | None = None,
        ack_on_close: bool = False,
    ) -> threading.Event:
        
        if isinstance(data, BytesLike):
            data = bytes(data)
        elif isinstance(data, str):
            data = data.encode()
        elif data is not None:
            raise TypeError("data must be str or bytes-like")

        with self.send_context():
            
            if data in self.pong_waiters:
                raise ConcurrencyError("already waiting for a pong with the same data")

            
            while data is None or data in self.pong_waiters:
                data = struct.pack("!I", random.getrandbits(32))

            pong_waiter = threading.Event()
            self.pong_waiters[data] = (pong_waiter, time.monotonic(), ack_on_close)
            self.protocol.send_ping(data)
            return pong_waiter

    def pong(self, data: Data = b"") -> None:
        
        if isinstance(data, BytesLike):
            data = bytes(data)
        elif isinstance(data, str):
            data = data.encode()
        else:
            raise TypeError("data must be str or bytes-like")

        with self.send_context():
            self.protocol.send_pong(data)

    

    def process_event(self, event: Event) -> None:
        
        assert isinstance(event, Frame)
        if event.opcode in DATA_OPCODES:
            self.recv_messages.put(event)

        if event.opcode is Opcode.PONG:
            self.acknowledge_pings(bytes(event.data))

    def acknowledge_pings(self, data: bytes) -> None:
        
        with self.protocol_mutex:
            
            if data not in self.pong_waiters:
                return

            pong_timestamp = time.monotonic()

            
            
            ping_id = None
            ping_ids = []
            for ping_id, (
                pong_waiter,
                ping_timestamp,
                _ack_on_close,
            ) in self.pong_waiters.items():
                ping_ids.append(ping_id)
                pong_waiter.set()
                if ping_id == data:
                    self.latency = pong_timestamp - ping_timestamp
                    break
            else:
                raise AssertionError("solicited pong not found in pings")

            
            for ping_id in ping_ids:
                del self.pong_waiters[ping_id]

    def acknowledge_pending_pings(self) -> None:
        
        assert self.protocol.state is CLOSED

        for pong_waiter, _ping_timestamp, ack_on_close in self.pong_waiters.values():
            if ack_on_close:
                pong_waiter.set()

        self.pong_waiters.clear()

    def keepalive(self) -> None:
        
        assert self.ping_interval is not None
        try:
            while True:
                
                
                
                self.recv_events_thread.join(self.ping_interval - self.latency)
                if not self.recv_events_thread.is_alive():
                    break

                try:
                    pong_waiter = self.ping(ack_on_close=True)
                except ConnectionClosed:
                    break
                if self.debug:
                    self.logger.debug("% sent keepalive ping")

                if self.ping_timeout is not None:
                    
                    if pong_waiter.wait(self.ping_timeout):
                        if self.debug:
                            self.logger.debug("% received keepalive pong")
                    else:
                        if self.debug:
                            self.logger.debug("- timed out waiting for keepalive pong")
                        with self.send_context():
                            self.protocol.fail(
                                CloseCode.INTERNAL_ERROR,
                                "keepalive ping timeout",
                            )
                        break
        except Exception:
            self.logger.error("keepalive ping failed", exc_info=True)

    def start_keepalive(self) -> None:
        
        if self.ping_interval is not None:
            
            self.keepalive_thread = threading.Thread(
                target=self.keepalive,
                daemon=True,
            )
            self.keepalive_thread.start()

    def recv_events(self) -> None:
        
        try:
            while True:
                try:
                    with self.recv_flow_control:
                        if self.close_deadline is not None:
                            self.socket.settimeout(self.close_deadline.timeout())
                    data = self.socket.recv(self.recv_bufsize)
                except Exception as exc:
                    if self.debug:
                        self.logger.debug(
                            "! error while receiving data",
                            exc_info=True,
                        )
                    
                    
                    
                    
                    with self.protocol_mutex:
                        self.set_recv_exc(exc)
                    break

                if data == b"":
                    break

                
                with self.protocol_mutex:
                    
                    self.protocol.receive_data(data)

                    
                    events = self.protocol.events_received()

                    
                    try:
                        self.send_data()
                    except Exception as exc:
                        if self.debug:
                            self.logger.debug(
                                "! error while sending data",
                                exc_info=True,
                            )
                        
                        
                        
                        
                        self.set_recv_exc(exc)
                        break

                    if self.protocol.close_expected():
                        
                        
                        if self.close_deadline is None:
                            self.close_deadline = Deadline(self.close_timeout)

                
                

                
                
                

                for event in events:
                    
                    self.process_event(event)

            
            
            with self.protocol_mutex:
                
                self.protocol.receive_eof()

                
                events = self.protocol.events_received()

                
                
                self.send_data()

            
            
            
            
            
            for event in events:  
                
                self.process_event(event)

        except Exception as exc:
            
            self.logger.error("unexpected internal error", exc_info=True)
            with self.protocol_mutex:
                self.set_recv_exc(exc)
        finally:
            
            self.close_socket()

    @contextlib.contextmanager
    def send_context(
        self,
        *,
        expected_state: State = OPEN,  
    ) -> Iterator[None]:
        
        
        wait_for_close = False
        
        raise_close_exc = False
        
        original_exc: BaseException | None = None

        
        with self.protocol_mutex:
            if self.protocol.state is expected_state:
                
                try:
                    yield
                except (ProtocolError, ConcurrencyError):
                    
                    raise
                except Exception as exc:
                    self.logger.error("unexpected internal error", exc_info=True)
                    
                    
                    
                    wait_for_close = False
                    raise_close_exc = True
                    original_exc = exc
                else:
                    
                    if self.protocol.close_expected():
                        wait_for_close = True
                        
                        
                        
                        
                        
                        assert self.close_deadline is None
                        self.close_deadline = Deadline(self.close_timeout)
                    
                    try:
                        self.send_data()
                    except Exception as exc:
                        if self.debug:
                            self.logger.debug(
                                "! error while sending data",
                                exc_info=True,
                            )
                        
                        
                        wait_for_close = False
                        raise_close_exc = True
                        original_exc = exc

            else:  
                
                
                wait_for_close = True
                raise_close_exc = True

        
        

        
        
        if wait_for_close:
            if self.close_deadline is None:
                timeout = self.close_timeout
            else:
                
                timeout = self.close_deadline.timeout(raise_if_elapsed=False)
            self.recv_events_thread.join(timeout)

            if self.recv_events_thread.is_alive():
                
                
                assert original_exc is None
                original_exc = TimeoutError("timed out while closing connection")
                
                
                raise_close_exc = True
                with self.protocol_mutex:
                    self.set_recv_exc(original_exc)

        
        
        if raise_close_exc:
            self.close_socket()
            
            self.recv_events_thread.join()
            raise self.protocol.close_exc from original_exc

    def send_data(self) -> None:
        
        assert self.protocol_mutex.locked()
        for data in self.protocol.data_to_send():
            if data:
                if self.close_deadline is not None:
                    self.socket.settimeout(self.close_deadline.timeout())
                self.socket.sendall(data)
            else:
                try:
                    self.socket.shutdown(socket.SHUT_WR)
                except OSError:  
                    pass

    def set_recv_exc(self, exc: BaseException | None) -> None:
        
        assert self.protocol_mutex.locked()
        if self.recv_exc is None:  
            self.recv_exc = exc

    def close_socket(self) -> None:
        
        
        try:
            self.socket.shutdown(socket.SHUT_RDWR)
        except OSError:
            pass  
        self.socket.close()

        
        
        with self.protocol_mutex:
            self.protocol.receive_eof()
            assert self.protocol.state is CLOSED

        
        self.recv_messages.close()

        
        self.acknowledge_pending_pings()
