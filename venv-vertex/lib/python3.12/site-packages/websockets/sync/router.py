from __future__ import annotations

import http
import ssl as ssl_module
import urllib.parse
from typing import Any, Callable, Literal

from werkzeug.exceptions import NotFound
from werkzeug.routing import Map, RequestRedirect

from ..http11 import Request, Response
from .server import Server, ServerConnection, serve


__all__ = ["route", "unix_route", "Router"]


class Router:
    

    def __init__(
        self,
        url_map: Map,
        server_name: str | None = None,
        url_scheme: str = "ws",
    ) -> None:
        self.url_map = url_map
        self.server_name = server_name
        self.url_scheme = url_scheme
        for rule in self.url_map.iter_rules():
            rule.websocket = True

    def get_server_name(self, connection: ServerConnection, request: Request) -> str:
        if self.server_name is None:
            return request.headers["Host"]
        else:
            return self.server_name

    def redirect(self, connection: ServerConnection, url: str) -> Response:
        response = connection.respond(http.HTTPStatus.FOUND, f"Found at {url}")
        response.headers["Location"] = url
        return response

    def not_found(self, connection: ServerConnection) -> Response:
        return connection.respond(http.HTTPStatus.NOT_FOUND, "Not Found")

    def route_request(
        self, connection: ServerConnection, request: Request
    ) -> Response | None:
        
        url_map_adapter = self.url_map.bind(
            server_name=self.get_server_name(connection, request),
            url_scheme=self.url_scheme,
        )
        try:
            parsed = urllib.parse.urlparse(request.path)
            handler, kwargs = url_map_adapter.match(
                path_info=parsed.path,
                query_args=parsed.query,
            )
        except RequestRedirect as redirect:
            return self.redirect(connection, redirect.new_url)
        except NotFound:
            return self.not_found(connection)
        connection.handler, connection.handler_kwargs = handler, kwargs
        return None

    def handler(self, connection: ServerConnection) -> None:
        
        return connection.handler(connection, **connection.handler_kwargs)


def route(
    url_map: Map,
    *args: Any,
    server_name: str | None = None,
    ssl: ssl_module.SSLContext | Literal[True] | None = None,
    create_router: type[Router] | None = None,
    **kwargs: Any,
) -> Server:
    
    url_scheme = "ws" if ssl is None else "wss"
    if ssl is not True and ssl is not None:
        kwargs["ssl"] = ssl

    if create_router is None:
        create_router = Router

    router = create_router(url_map, server_name, url_scheme)

    _process_request: (
        Callable[
            [ServerConnection, Request],
            Response | None,
        ]
        | None
    ) = kwargs.pop("process_request", None)
    if _process_request is None:
        process_request: Callable[
            [ServerConnection, Request],
            Response | None,
        ] = router.route_request
    else:

        def process_request(
            connection: ServerConnection, request: Request
        ) -> Response | None:
            response = _process_request(connection, request)
            if response is not None:
                return response
            return router.route_request(connection, request)

    return serve(router.handler, *args, process_request=process_request, **kwargs)


def unix_route(
    url_map: Map,
    path: str | None = None,
    **kwargs: Any,
) -> Server:
    
    return route(url_map, unix=True, path=path, **kwargs)
