from __future__ import annotations

import codecs
import queue
import threading
from typing import Any, Callable, Iterable, Iterator, Literal, overload

from ..exceptions import ConcurrencyError
from ..frames import OP_BINARY, OP_CONT, OP_TEXT, Frame
from ..typing import Data
from .utils import Deadline


__all__ = ["Assembler"]

UTF8Decoder = codecs.getincrementaldecoder("utf-8")


class Assembler:
    

    def __init__(
        self,
        high: int | None = None,
        low: int | None = None,
        pause: Callable[[], Any] = lambda: None,
        resume: Callable[[], Any] = lambda: None,
    ) -> None:
        
        
        self.mutex = threading.Lock()

        
        self.frames: queue.SimpleQueue[Frame | None] = queue.SimpleQueue()

        
        
        
        
        if high is not None and low is None:
            low = high // 4
        if high is None and low is not None:
            high = low * 4
        if high is not None and low is not None:
            if low < 0:
                raise ValueError("low must be positive or equal to zero")
            if high < low:
                raise ValueError("high must be greater than or equal to low")
        self.high, self.low = high, low
        self.pause = pause
        self.resume = resume
        self.paused = False

        
        self.get_in_progress = False

        
        self.closed = False

    def get_next_frame(self, timeout: float | None = None) -> Frame:
        
        
        if self.closed:
            try:
                frame = self.frames.get(block=False)
            except queue.Empty:
                raise EOFError("stream of frames ended") from None
        else:
            try:
                
                
                if timeout is not None and timeout <= 0:
                    frame = self.frames.get(block=False)
                else:
                    frame = self.frames.get(block=True, timeout=timeout)
            except queue.Empty:
                raise TimeoutError(f"timed out in {timeout:.1f}s") from None
        if frame is None:
            raise EOFError("stream of frames ended")
        return frame

    def reset_queue(self, frames: Iterable[Frame]) -> None:
        
        
        
        
        frame: Frame | None
        with self.mutex:
            queued = []
            try:
                while True:
                    queued.append(self.frames.get(block=False))
            except queue.Empty:
                pass
            for frame in frames:
                self.frames.put(frame)
            
            for frame in queued:  
                self.frames.put(frame)

    
    

    @overload
    def get(self, timeout: float | None, decode: Literal[True]) -> str: ...

    @overload
    def get(self, timeout: float | None, decode: Literal[False]) -> bytes: ...

    @overload
    def get(self, timeout: float | None = None, *, decode: Literal[True]) -> str: ...

    @overload
    def get(self, timeout: float | None = None, *, decode: Literal[False]) -> bytes: ...

    @overload
    def get(self, timeout: float | None = None, decode: bool | None = None) -> Data: ...

    def get(self, timeout: float | None = None, decode: bool | None = None) -> Data:
        
        with self.mutex:
            if self.get_in_progress:
                raise ConcurrencyError("get() or get_iter() is already running")
            self.get_in_progress = True

        
        

        try:
            deadline = Deadline(timeout)

            
            frame = self.get_next_frame(deadline.timeout(raise_if_elapsed=False))
            with self.mutex:
                self.maybe_resume()
            assert frame.opcode is OP_TEXT or frame.opcode is OP_BINARY
            if decode is None:
                decode = frame.opcode is OP_TEXT
            frames = [frame]

            
            while not frame.fin:
                try:
                    frame = self.get_next_frame(
                        deadline.timeout(raise_if_elapsed=False)
                    )
                except TimeoutError:
                    
                    
                    self.reset_queue(frames)
                    raise
                with self.mutex:
                    self.maybe_resume()
                assert frame.opcode is OP_CONT
                frames.append(frame)

        finally:
            self.get_in_progress = False

        data = b"".join(frame.data for frame in frames)
        if decode:
            return data.decode()
        else:
            return data

    @overload
    def get_iter(self, decode: Literal[True]) -> Iterator[str]: ...

    @overload
    def get_iter(self, decode: Literal[False]) -> Iterator[bytes]: ...

    @overload
    def get_iter(self, decode: bool | None = None) -> Iterator[Data]: ...

    def get_iter(self, decode: bool | None = None) -> Iterator[Data]:
        
        with self.mutex:
            if self.get_in_progress:
                raise ConcurrencyError("get() or get_iter() is already running")
            self.get_in_progress = True

        
        

        
        

        
        frame = self.get_next_frame()
        with self.mutex:
            self.maybe_resume()
        assert frame.opcode is OP_TEXT or frame.opcode is OP_BINARY
        if decode is None:
            decode = frame.opcode is OP_TEXT
        if decode:
            decoder = UTF8Decoder()
            yield decoder.decode(frame.data, frame.fin)
        else:
            yield frame.data

        
        while not frame.fin:
            frame = self.get_next_frame()
            with self.mutex:
                self.maybe_resume()
            assert frame.opcode is OP_CONT
            if decode:
                yield decoder.decode(frame.data, frame.fin)
            else:
                yield frame.data

        self.get_in_progress = False

    def put(self, frame: Frame) -> None:
        
        with self.mutex:
            if self.closed:
                raise EOFError("stream of frames ended")

            self.frames.put(frame)
            self.maybe_pause()

    
    
    
    

    
    
    
    

    def maybe_pause(self) -> None:
        
        
        if self.high is None:
            return

        assert self.mutex.locked()

        
        if self.frames.qsize() > self.high and not self.paused:
            self.paused = True
            self.pause()

    def maybe_resume(self) -> None:
        
        
        if self.low is None:
            return

        assert self.mutex.locked()

        
        if self.frames.qsize() <= self.low and self.paused:
            self.paused = False
            self.resume()

    def close(self) -> None:
        
        with self.mutex:
            if self.closed:
                return

            self.closed = True

            if self.get_in_progress:
                
                self.frames.put(None)

            if self.paused:
                
                self.paused = False
                self.resume()
