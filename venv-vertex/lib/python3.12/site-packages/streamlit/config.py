















from __future__ import annotations

import copy
import logging
import os
import secrets
import threading
from collections import OrderedDict
from enum import Enum
from typing import Any, Callable, Final, Literal

from blinker import Signal

from streamlit import config_util, development, env_util, file_util, util
from streamlit.config_option import ConfigOption
from streamlit.errors import StreamlitAPIException






_section_descriptions: dict[str, str] = OrderedDict(
    _test="Special test section just used for unit tests."
)



_config_lock = threading.RLock()






_config_options_template: dict[str, ConfigOption] = OrderedDict()


_config_options: dict[str, ConfigOption] | None = None



_main_script_path: str | None = None


_USER_DEFINED: Final = "<user defined>"



_DEFINED_BY_FLAG: Final = "command-line argument or environment variable"


_DEFINED_BY_ENV_VAR: Final = "environment variable"

_LOGGER: Final = logging.getLogger(__name__)


class ShowErrorDetailsConfigOptions(str, Enum):
    

    FULL = "full"
    STACKTRACE = "stacktrace"
    TYPE = "type"
    NONE = "none"

    @staticmethod
    def is_true_variation(val: str | bool) -> bool:
        return val in ["true", "True", True]

    @staticmethod
    def is_false_variation(val: str | bool) -> bool:
        return val in ["false", "False", False]

        
        
        
        


class CustomThemeCategories(str, Enum):
    

    SIDEBAR = "sidebar"


def set_option(key: str, value: Any, where_defined: str = _USER_DEFINED) -> None:
    
    with _config_lock:
        
        get_config_options()
        _set_option(key, value, where_defined)


def set_user_option(key: str, value: Any) -> None:
    
    try:
        opt = _config_options_template[key]
    except KeyError as ke:
        raise StreamlitAPIException(f"Unrecognized config option: {key}") from ke
    
    if opt.scriptable:
        set_option(key, value)
        return

    raise StreamlitAPIException(
        f"{key} cannot be set on the fly. Set as command line option, e.g. "
        f"streamlit run script.py --{key}, or in config.toml instead."
    )


def get_option(key: str) -> Any:
    
    with _config_lock:
        config_options = get_config_options()

        if key not in config_options:
            raise RuntimeError(f'Config key "{key}" not defined.')
        return config_options[key].value


def get_options_for_section(section: str) -> dict[str, Any]:
    
    with _config_lock:
        config_options = get_config_options()

        options_for_section = {}
        for option in config_options.values():
            if option.section == section:
                options_for_section[option.name] = option.value
        return options_for_section


def _create_section(section: str, description: str) -> None:
    
    if section in _section_descriptions:
        raise RuntimeError(f'Cannot define section "{section}" twice.')
    _section_descriptions[section] = description


def _create_option(
    key: str,
    description: str | None = None,
    default_val: Any | None = None,
    scriptable: bool = False,
    visibility: str = "visible",
    deprecated: bool = False,
    deprecation_text: str | None = None,
    expiration_date: str | None = None,
    replaced_by: str | None = None,
    type_: type = str,
    sensitive: bool = False,
    multiple: bool = False,
) -> ConfigOption:
    '''Create a ConfigOption and store it globally in this module.

    There are two ways to create a ConfigOption:

        (1) Simple, constant config options are created as follows:

            _create_option('section.optionName',
                description = 'Put the description here.',
                default_val = 12345)

        (2) More complex, programmable config options use decorator syntax to
        resolve their values at runtime:

            @_create_option('section.optionName')
            def _section_option_name():
                
                return 12345

    To achieve this sugar, _create_option() returns a *callable object* of type
    ConfigObject, which then decorates the function.

    NOTE: ConfigObjects call their evaluation functions *every time* the option
    is requested. To prevent this, use the `streamlit.util.memoize` decorator as
    follows:

            @_create_option('section.memoizedOptionName')
            @util.memoize
            def _section_memoized_option_name():
                

                (This function is only called once.)
                
    Create ConfigOption(s) for a theme-related config option and store it globally in
    this module.

    The same config option can be supported for multiple categories, e.g. "theme"
    and "theme.sidebar".
    Remove a ConfigOption by key from the global store.

    Only for use in testing.
    
        By default, Streamlit displays a warning when a user sets both a widget
        default value in the function defining the widget and a widget value via
        the widget's key in `st.session_state`.

        If you'd like to turn off this warning, set this to True.
    
        If True, will show a warning when you run a Streamlit-enabled script
        via "python my_script.py".
    Are we in development mode.

    This option defaults to True if and only if Streamlit wasn't installed
    normally.
    
        Only cache ForwardMsgs that are greater than or equal to this minimum.
    
        Expire cached ForwardMsgs whose age is greater than this
        value. A message's age is defined by how many times its script has
        finished running since the message has been accessed.
    Level of logging for Streamlit's internal logger: "error", "warning",
    "info", or "debug".

    Default: "info"
    String format for logging messages. If logger.datetimeFormat is set,
    logger messages will default to `%(asctime)s.%(msecs)03d %(message)s`.

    See Python's documentation for available attributes:
    https://docs.python.org/3/library/logging.html

    Default: "%(asctime)s %(message)s"
    
    Controls whether uncaught app exceptions are logged via the rich library.

    If True and if rich is installed, exception tracebacks will be logged with
    syntax highlighting and formatting. Rich tracebacks are easier to read and
    show more code than standard Python tracebacks.

    If set to False, the default Python traceback formatting will be used.

    Defaults to True if rich is installed, False otherwise.
    
        Controls whether uncaught app exceptions and deprecation warnings
        are displayed in the browser. This can be one of the following:

        - "full"       : In the browser, Streamlit displays app deprecation
                         warnings and exceptions, including exception types,
                         exception messages, and associated tracebacks.
        - "stacktrace" : In the browser, Streamlit displays exceptions,
                         including exception types, generic exception messages,
                         and associated tracebacks. Deprecation warnings and
                         full exception messages will only print to the
                         console.
        - "type"       : In the browser, Streamlit displays exception types and
                         generic exception messages. Deprecation warnings, full
                         exception messages, and associated tracebacks only
                         print to the console.
        - "none"       : In the browser, Streamlit displays generic exception
                         messages. Deprecation warnings, full exception
                         messages, associated tracebacks, and exception types
                         will only print to the console.
        - True         : This is deprecated. Streamlit displays "full"
                         error details.
        - False        : This is deprecated. Streamlit displays "stacktrace"
                         error details.
    
        Change the visibility of items in the toolbar, options menu,
        and settings dialog (top right of the app).

        Allowed values:
        - "auto"      : Show the developer options if the app is accessed through
                        localhost or through Streamlit Community Cloud as a developer.
                        Hide them otherwise.
        - "developer" : Show the developer options.
        - "viewer"    : Hide the developer options.
        - "minimal"   : Show only options set externally (e.g. through
                        Streamlit Community Cloud) or through st.set_page_config.
                        If there are no options left, hide the menu.
    
        Controls whether to display the default sidebar page navigation in a
        multi-page app. This only applies when app's pages are defined by the
        `pages/` directory.
    
        Allows you to type a variable or string by itself in a single line of
        Python code to write it to the app.
    
        Run the Python Garbage Collector after each script execution.

        This can help avoid excess memory use in Streamlit apps, but could
        introduce delay in rerunning the app script for high-memory-use
        applications.
    
        Handle script rerun requests immediately, rather than waiting for
        script execution to reach a yield point.

        This makes Streamlit much more responsive to user interaction, but it
        can lead to race conditions in apps that mutate session_state data
        outside of explicit session_state assignment statements.
    
        Raise an exception after adding unserializable data to Session State.

        Some execution environments may require serializing all data in Session
        State, so it may be useful to detect incompatibility during development,
        or when the execution environment will stop supporting it in the future.
    
        Adjust how certain 'options' widgets like radio, selectbox, and
        multiselect coerce Enum members.

        This is useful when the Enum class gets re-defined during a script
        re-run. For more information, check out the docs:
        https://docs.streamlit.io/develop/concepts/design/custom-classes

        Allowed values:
        - "off": Disables Enum coercion.
        - "nameOnly": Enum classes can be coerced if their member names match.
        - "nameAndValue": Enum classes can be coerced if their member names AND
          member values match.
    
        List of directories to watch for changes.

        By default, Streamlit watches files in the current working directory
        and its subdirectories. Use this option to specify additional
        directories to watch. Paths must be absolute.
    
        List of directories to ignore for changes.

        By default, Streamlit watches files in the current working directory
        and its subdirectories. Use this option to specify exceptions within
        watched directories. Paths can be absolute or relative to the current
        working directory.

        Example: ['/home/user1/env', 'relative/path/to/folder']
    
        Change the type of file watcher used by Streamlit, or turn it off
        completely.

        Allowed values:
        - "auto"     : Streamlit will attempt to use the watchdog module, and
                       falls back to polling if watchdog isn't available.
        - "watchdog" : Force Streamlit to use the watchdog module.
        - "poll"     : Force Streamlit to always use polling.
        - "none"     : Streamlit will not watch files.
    Symmetric key used to produce signed cookies. If deploying on multiple
    replicas, this should be set to the same value across all replicas to ensure
    they all share the same secret.

    Default: randomly generated secret key.
    If false, will attempt to open a browser window on start.

    Default: false unless (1) we are on a Linux box where DISPLAY is unset, or
    (2) we are running in the Streamlit Atom plugin.
    
        Whether to show a terminal prompt for the user's email address when
        they run Streamlit (locally) for the first time. If you set
        `server.headless=True`, Streamlit will not show this prompt.
    
        Automatically rerun script when the file is modified on disk.
    
        Allows users to automatically rerun when app is updated.
    The address where the server will listen for client and browser
    connections.

    Use this if you want to bind the server to a specific address.
    If set, the server will only be accessible from this address, and not from
    any aliases (like localhost).

    Default: (unset)
    
        The port where the server will listen for browser connections.
    
        Flag for enabling the script health check endpoint. It's used for checking if
        a script loads successfully. On success, the endpoint will return a 200
        HTTP status code. On failure, the endpoint will return a 503 HTTP status code.

        Note: This is an experimental Streamlit internal API. The API is subject
        to change anytime so this should be used at your own risk
    
        The base path for the URL where Streamlit should be served from.
    
        The base path for the URL where Streamlit should serve custom
        components. If this config var is set and a call to ``declare_component``
        does not specify a URL, the component's URL will be set to
        ``f"{server.customComponentBaseUrlPath}/{component_name}/"``.
    
        Enables support for Cross-Origin Resource Sharing (CORS) protection,
        for added security.

        If XSRF protection is enabled and CORS protection is disabled at the
        same time, Streamlit will enable them both instead.
    
        Allowed list of origins.

        If CORS protection is enabled (`server.enableCORS=True`), use this
        option to set a list of allowed origins that the Streamlit server will
        accept traffic from.

        This config option does nothing if CORS protection is disabled.

        Example: ['http://example.com', 'https://streamlit.io']
    
        Enables support for Cross-Site Request Forgery (XSRF) protection, for
        added security.

        If XSRF protection is enabled and CORS protection is disabled at the
        same time, Streamlit will enable them both instead.
    
        Max size, in megabytes, for files uploaded with the file_uploader.
    
        Max size, in megabytes, of messages that can be sent via the WebSocket
        connection.
    
        Enable automatically truncating all data structures that get serialized
        into Arrow (e.g. DataFrames) to ensure that the size is under
        `server.maxMessageSize`.
    
        Enables support for websocket compression.
    
        Enable serving files from a `static` directory in the running app's
        directory.
    
        TTL in seconds for sessions whose websockets have been disconnected.

        The server may choose to clean up session state, uploaded files, etc
        for a given session with no active websocket connection at any point
        after this time has passed.
    
        Internet address where users should point their browsers in order to
        connect to the app. Can be IP address or DNS name and path.

        This is used to:
        - Set the correct URL for CORS and XSRF protection purposes.
        - Show the URL on the terminal
        - Open the browser
    
        Whether to send usage statistics to Streamlit.
    Port where users should point their browsers in order to connect to the
    app.

    This is used to:
    - Set the correct URL for XSRF protection purposes.
    - Show the URL on the terminal (part of `streamlit run`).
    - Open the browser automatically (part of `streamlit run`).

    This option is for advanced use cases. To change the port of your app, use
    `server.Port` instead.

    Default: whatever value is set in server.port.
    
        Server certificate file for connecting via HTTPS.
        Must be set at the same time as "server.sslKeyFile".

        {_SSL_PRODUCTION_WARNING}
        
        Cryptographic key file for connecting via HTTPS.
        Must be set at the same time as "server.sslCertFile".

        {_SSL_PRODUCTION_WARNING}
        
        Flag to hide most of the UI elements found at the top of a Streamlit app.

        NOTE: This does *not* hide the main menu in the top-right of an app.
    
        If you'd like to show maps using Mapbox rather than Carto, use this
        to pass the Mapbox API token.
    
        Instead of this, you should use either the MAPBOX_API_KEY environment
        variable or PyDeck's `api_keys` argument.
    
        Streamlit's "magic" parser typically skips strings that appear to be
        docstrings. When this flag is set to True, Streamlit will instead display
        the root-level docstring in the app, just like any other magic string.
        This is useful for things like notebooks.
    
        Make Streamlit's "magic" parser always display the last expression in the
        root file if it has no semicolon at the end. This matches the behavior of
        Jupyter notebooks, for example.
    
        The preset Streamlit theme that your custom theme inherits from.

        This can be one of the following: "light" or "dark".
    
        Primary accent color.
    
        Background color of the app.
    
        Background color used for most interactive widgets.
    
        Color used for almost all text.
    
        Color used for all links.
    
        Whether or not links should be displayed with an underline.
    
        Background color used for code blocks.
    
        The font family for all text, except code blocks.

        This can be one of the following:
        - "sans-serif"
        - "serif"
        - "monospace"
        - The `family` value for a custom font table under [[theme.fontFaces]]
        - A comma-separated list of these (as a single string) to specify
          fallbacks

        For example, you can use the following:

            font = "cool-font, fallback-cool-font, sans-serif"
    
        An array of fonts to use in your app.

        Each font in the array is a table (dictionary) that can have the
        following attributes, closely resembling CSS font-face definitions:
        - family
        - url
        - weight (optional)
        - style (optional)
        - unicodeRange (optional)

        To host a font with your app, enable static file serving with
        `server.enableStaticServing=true`.

        You can define multiple [[theme.fontFaces]] tables, including multiple
        tables with the same family if your font is defined by multiple files.

        For example, a font hosted with your app may have a [[theme.fontFaces]]
        table as follows:

            [[theme.fontFaces]]
            family = "font_name"
            url = "app/static/font_file.woff"
            weight = "400"
            style = "normal"
    
        The root font size (in pixels) for the app.

        This determines the overall scale of text and UI elements. This is a
        positive integer.

        If this isn't set, the font size will be 16px.
    
        The root font weight for the app.

        This determines the overall weight of text and UI elements. This is an
        integer multiple of 100. Values can be between 100 and 600, inclusive.

        If this isn't set, the font weight will be set to 400 (normal weight).
    
        The font family to use for headings.

        This can be one of the following:
        - "sans-serif"
        - "serif"
        - "monospace"
        - The `family` value for a custom font table under [[theme.fontFaces]]
        - A comma-separated list of these (as a single string) to specify
          fallbacks

        If this isn't set, Streamlit uses `theme.font` for headings.
    
        One or more font sizes for h1-h6 headings.

        If no sizes are set, Streamlit will use the default sizes for h1-h6
        headings. Heading font sizes set in [theme] are not inherited by
        [theme.sidebar]. The following sizes are used by default:
        [
            "2.75rem", 
            "2.25rem", 
            "1.75rem", 
            "1.5rem",  
            "1.25rem", 
            "1rem",    
        ]

        If you specify an array with fewer than six sizes, the unspecified
        heading sizes will be the default values. For example, you can use the
        following array to set the font sizes for h1-h3 headings while keeping
        h4-h6 headings at their default sizes:
            headingFontSizes = ["3rem", "2.875rem", "2.75rem"]

        Setting a single value (not in an array) will set the font size for all
        h1-h6 headings to that value:
            headingFontSizes = "2.75rem"

        Font sizes can be specified in pixels or rem, but rem is recommended.
    
        One or more font weights for h1-h6 headings.

        If no weights are set, Streamlit will use the default weights for h1-h6
        headings. Heading font weights set in [theme] are not inherited by
        [theme.sidebar]. The following weights are used by default:
        [
            700, 
            600, 
            600, 
            600, 
            600, 
            600, 
        ]

        If you specify an array with fewer than six weights, the unspecified
        heading weights will be the default values. For example, you can use
        the following array to set the font weights for h1-h2 headings while
        keeping h3-h6 headings at their default weights:
            headingFontWeights = [800, 700]

        Setting a single value (not in an array) will set the font weight for
        all h1-h6 headings to that value:
            headingFontWeights = 500
    
        The font family to use for code (monospace) in the sidebar.

        This can be one of the following:
        - "sans-serif"
        - "serif"
        - "monospace"
        - The `family` value for a custom font table under [[theme.fontFaces]]
        - A comma-separated list of these (as a single string) to specify
          fallbacks
    
        The font size (in pixels or rem) for code blocks and code text.

        This applies to font in code blocks, `st.json`, and `st.help`. It
        doesn't apply to inline code, which is set by default to 0.75em.

        If this isn't set, the code font size will be 0.875rem.
    
        The font weight for code blocks and code text.

        This applies to font in inline code, code blocks, `st.json`, and
        `st.help`. This is an integer multiple of 100. Values can be between
        100 and 900, inclusive.

        If this isn't set, the code font weight will be 400 (normal weight).
    
        The radius used as basis for the corners of most UI elements.

        This can be one of the following:
        - "none"
        - "small"
        - "medium"
        - "large"
        - "full"
        - The number in pixels or rem.

        For example, you can use "10px", "0.5rem", or "2rem". To follow best
        practices, use rem instead of pixels when specifying a numeric size.
    
        The radius used as basis for the corners of buttons.

        This can be one of the following:
        - "none"
        - "small"
        - "medium"
        - "large"
        - "full"
        - The number in pixels or rem.

        For example, you can use "10px", "0.5rem", or "2rem". To follow best
        practices, use rem instead of pixels when specifying a numeric size.

        If this isn't set, Streamlit uses `theme.baseRadius` instead.
    
        The color of the border around elements.
    
        The color of the border around dataframes and tables.

        If this isn't set, Streamlit uses `theme.borderColor` instead.
    
        The background color of the dataframe's header.

        This color applies to all non-interior cells of the dataframe. This
        includes the header row, the row-selection column (if present), and
        the bottom row of data editors with a dynamic number of rows. If this
        isn't set, Streamlit uses a mix of `theme.backgroundColor` and
        `theme.secondaryBackgroundColor`.
    
        Whether to show a border around input widgets.
    
        Whether to show a vertical separator between the sidebar and the main
        content area.
    
        An array of colors to use for categorical chart data.

        This is a list of one or more color strings which are applied in order
        to categorical data. These colors apply to Plotly, Altair, and
        Vega-Lite charts.

        Invalid colors are skipped, and colors repeat cyclically if there are
        more categories than colors. If no chart categorical colors are set,
        Streamlit uses a default set of colors.

        For light themes, the following colors are the default:
        [
            "
            "
            "
            "
            "
            "
            "
            "
            "
            "
        ]
        For dark themes, the following colors are the default:
        [
            "
            "
            "
            "
            "
            "
            "
            "
            "
            "
        ]
    
        An array of ten colors to use for sequential or continuous chart data.

        The ten colors create a gradient color scale. These colors apply to
        Plotly, Altair, and Vega-Lite charts.

        Invalid color strings are skipped. If there are not exactly ten
        valid colors specified, Streamlit uses a default set of colors.

         For light themes, the following colors are the default:
        [
            "
            "
            "
            "
            "
            "
            "
            "
            "
            "
        ]
        For dark themes, the following colors are the default:
        [
            "
            "
            "
            "
            "
            "
            "
            "
            "
            "
        ]
    List of locations where secrets are searched.

    An entry can be a path to a TOML file or directory path where
    Kubernetes style secrets are saved. Order is important, import is
    first to last, so secrets in later files will take precedence over
    earlier ones.
    Indicate where (e.g. in which file) this option was defined.

    Parameters
    ----------
    key : str
        The config option key of the form "section.optionName"

    Check if a given option has not been set by the user.

    Parameters
    ----------
    option_name : str
        The option to check


    Returns
    -------
    bool
        True if the option has not been set by the user.

    Check if a given option was actually defined by the user.

    Parameters
    ----------
    option_name : str
        The option to check


    Returns
    -------
    bool
        True if the option has been set by the user.

    Print all config options to the terminal.Set a config option by key / value pair.

    This function assumes that the _config_options dictionary has already been
    populated and thus should only be used within this file and by tests.

    Parameters
    ----------
    key : str
        The key of the option, like "logger.level".
    value
        The value of the option.
    where_defined : str
        Tells the config system where this was set.

    Update the config system by parsing the environment variable.

    This should only be called from get_config_options.
    Update the config system by parsing this string.

    This should only be called from get_config_options.

    Parameters
    ----------
    raw_toml : str
        The TOML file to parse to update the config values.
    where_defined : str
        Tells the config system where this was set.

    Recursively process nested sections of the config file.

        Parameters
        ----------
        section_path : str
            The dot-separated path to the current section (e.g., "server" or "theme")
        section_data : dict[str, Any]
            The dictionary containing configuration values for this section

        Notes
        -----
        TOML's hierarchical structure gets parsed into nested dictionaries.
        For example:
            [main]
            option = "value"

            [main.subsection]
            another = "value2"

        Will be loaded by the TOML parser as:
            {
                "main": {
                    "option": "value",
                    "subsection": {
                        "another": "value2"
                    }
                }
            }

        This function traverses these nested dictionaries and converts them
        to dot-notation config options.
        If value is "env:foo", return value of environment variable "foo".

    If value is not in the shape above, returns the value right back.

    Parameters
    ----------
    value : any
        The value to check

    Returns
    -------
    any
        Either returns value right back, or the value of the environment
        variable.

    Convert v to int or float, or leave it as is.Return the list of config files (e.g. config.toml or secrets.toml) to be parsed.

    Order is important, import is first to last, so options in later files
    will take precedence over earlier ones.
    Create and return a dict mapping config option names to their values,
    returning a cached dict if possible.

    Config option values are sourced from the following locations. Values
    set in locations further down the list overwrite those set earlier.
      1. default values defined in this file
      2. the global `~/.streamlit/config.toml` file
      3. per-project `$CWD/.streamlit/config.toml` files
      4. environment variables such as `STREAMLIT_SERVER_PORT`
      5. command line flags passed to `streamlit run`

    Parameters
    ----------
    force_reparse : bool
        Force config files to be parsed so that we pick up any changes to them.

    options_from_flags : dict[str, any] or None
        Config options that we received via CLI flag.

    Returns
    -------
    dict[str, ConfigOption]
        An ordered dict that maps config option names to their values.
    
Warning: the config option 'server.enableCORS=false' is not compatible with
'server.enableXsrfProtection=true'.
As a result, 'server.enableCORS' is being overridden to 'true'.

More information:
In order to protect against CSRF attacks, we send a cookie with each request.
To do so, we must specify allowable origins, which places a restriction on
cross-origin resource sharing.

If cross origin resource sharing is required, please disable server.enableXsrfProtection.
            Wait for the config file to be parsed then call func.

    If the config file has already been parsed, just calls func immediately
    unless force_connect is set.

    Parameters
    ----------
    func : Callable[[], None]
        A function to run on config parse.

    force_connect : bool
        Wait until the next config file parse to run func, even if config files
        have already been parsed.

    lock : bool
        If set, grab _config_lock before running func.

    Returns
    -------
    Callable[[], None]
        A function that the caller can use to deregister func.
    """

    
    
    
    
    
    def receiver(_: Any) -> None:
        func_with_lock()

    def disconnect() -> None:
        _on_config_parsed.disconnect(receiver)

    def func_with_lock() -> None:
        if lock:
            with _config_lock:
                func()
        else:
            func()

    if force_connect or not _config_options:
        
        
        _on_config_parsed.connect(receiver, weak=False)
    else:
        func_with_lock()

    return disconnect





on_config_parsed(_check_conflicts, lock=True)
on_config_parsed(_set_development_mode)
