















from __future__ import annotations

import os
import threading
from typing import TYPE_CHECKING, Callable, Final, cast

from blinker import ANY, Signal
from typing_extensions import Self
from watchdog import events
from watchdog.observers import Observer

from streamlit.errors import StreamlitMaxRetriesError
from streamlit.logger import get_logger
from streamlit.util import repr_
from streamlit.watcher import util

if TYPE_CHECKING:
    from watchdog.observers.api import ObservedWatch

_LOGGER: Final = get_logger(__name__)


def _get_abs_folder_path(path: str) -> str:
    
    return os.path.realpath(path if os.path.isdir(path) else os.path.dirname(path))


class EventBasedPathWatcher:
    

    @staticmethod
    def close_all() -> None:
        
        path_watcher = _MultiPathWatcher.get_singleton()
        path_watcher.close()
        _LOGGER.debug("Watcher closed")

    def __init__(
        self,
        path: str,
        on_changed: Callable[[str], None],
        *,  
        glob_pattern: str | None = None,
        allow_nonexistent: bool = False,
    ) -> None:
        
        self._path = os.path.realpath(path)
        self._on_changed = on_changed

        path_watcher = _MultiPathWatcher.get_singleton()
        path_watcher.watch_path(
            self._path,
            on_changed,
            glob_pattern=glob_pattern,
            allow_nonexistent=allow_nonexistent,
        )
        _LOGGER.debug("Watcher created for %s", self._path)

    def __repr__(self) -> str:
        return repr_(self)

    def close(self) -> None:
        
        path_watcher = _MultiPathWatcher.get_singleton()
        path_watcher.stop_watching_path(self._path, self._on_changed)


class _MultiPathWatcher:
    

    _singleton: _MultiPathWatcher | None = None

    @classmethod
    def get_singleton(cls) -> _MultiPathWatcher:
        
        if cls._singleton is None:
            _LOGGER.debug("No singleton. Registering one.")
            _MultiPathWatcher()

        return cast("_MultiPathWatcher", _MultiPathWatcher._singleton)

    
    def __new__(cls) -> Self:
        
        if _MultiPathWatcher._singleton is not None:
            raise RuntimeError("Use .get_singleton() instead")
        return super().__new__(cls)

    def __init__(self) -> None:
        
        _MultiPathWatcher._singleton = self

        
        self._folder_handlers: dict[str, _FolderEventHandler] = {}

        
        self._lock = threading.Lock()

        
        
        
        self._observer = Observer()
        self._observer.start()  

    def __repr__(self) -> str:
        return repr_(self)

    def watch_path(
        self,
        path: str,
        callback: Callable[[str], None],
        *,  
        glob_pattern: str | None = None,
        allow_nonexistent: bool = False,
    ) -> None:
        
        folder_path = _get_abs_folder_path(path)

        with self._lock:
            folder_handler = self._folder_handlers.get(folder_path)

            if folder_handler is None:
                folder_handler = _FolderEventHandler()

                try:
                    folder_handler.watch = self._observer.schedule(
                        folder_handler, folder_path, recursive=True
                    )
                    self._folder_handlers[folder_path] = folder_handler
                except Exception as ex:
                    _LOGGER.warning(
                        "Failed to schedule watch observer for path %s",
                        folder_path,
                        exc_info=ex,
                    )
                    return

            folder_handler.add_path_change_listener(
                path,
                callback,
                glob_pattern=glob_pattern,
                allow_nonexistent=allow_nonexistent,
            )

    def stop_watching_path(self, path: str, callback: Callable[[str], None]) -> None:
        
        folder_path = _get_abs_folder_path(path)

        with self._lock:
            folder_handler = self._folder_handlers.get(folder_path)

            if folder_handler is None:
                _LOGGER.debug(
                    "Cannot stop watching path, because it is already not being "
                    "watched. %s",
                    folder_path,
                )
                return

            folder_handler.remove_path_change_listener(path, callback)

            if (
                not folder_handler.is_watching_paths()
                and folder_handler.watch is not None
            ):
                self._observer.unschedule(folder_handler.watch)
                del self._folder_handlers[folder_path]

    def close(self) -> None:
        with self._lock:
            

            if len(self._folder_handlers) != 0:
                _LOGGER.debug(
                    "Stopping observer thread even though there is a non-zero "
                    "number of event observers!"
                )
                self._observer.unschedule_all()
                self._folder_handlers = {}
            else:
                _LOGGER.debug("Stopping observer thread")

            self._observer.stop()
            self._observer.join(timeout=5)


class WatchedPath:
    

    def __init__(
        self,
        md5: str,
        modification_time: float,
        *,  
        glob_pattern: str | None = None,
        allow_nonexistent: bool = False,
    ) -> None:
        self.md5 = md5
        self.modification_time = modification_time

        self.glob_pattern = glob_pattern
        self.allow_nonexistent = allow_nonexistent

        self.on_changed = Signal()

    def __repr__(self) -> str:
        return repr_(self)


class _FolderEventHandler(events.FileSystemEventHandler):
    

    def __init__(self) -> None:
        super().__init__()
        self._watched_paths: dict[str, WatchedPath] = {}
        self._lock = threading.Lock()  
        self.watch: ObservedWatch | None = None

    def __repr__(self) -> str:
        return repr_(self)

    def add_path_change_listener(
        self,
        path: str,
        callback: Callable[[str], None],
        *,  
        glob_pattern: str | None = None,
        allow_nonexistent: bool = False,
    ) -> None:
        
        with self._lock:
            watched_path = self._watched_paths.get(path, None)
            if watched_path is None:
                try:
                    md5 = util.calc_md5_with_blocking_retries(
                        path,
                        glob_pattern=glob_pattern,
                        allow_nonexistent=allow_nonexistent,
                    )
                    modification_time = util.path_modification_time(
                        path, allow_nonexistent
                    )
                    watched_path = WatchedPath(
                        md5=md5,
                        modification_time=modification_time,
                        glob_pattern=glob_pattern,
                        allow_nonexistent=allow_nonexistent,
                    )
                    self._watched_paths[path] = watched_path
                except StreamlitMaxRetriesError as ex:
                    _LOGGER.debug(
                        "Failed to calculate MD5 for path %s",
                        path,
                        exc_info=ex,
                    )
                    return

            watched_path.on_changed.connect(callback, weak=False)

    def remove_path_change_listener(
        self, path: str, callback: Callable[[str], None]
    ) -> None:
        
        with self._lock:
            watched_path = self._watched_paths.get(path, None)
            if watched_path is None:
                return

            watched_path.on_changed.disconnect(callback)
            if not watched_path.on_changed.has_receivers_for(ANY):
                del self._watched_paths[path]

    def is_watching_paths(self) -> bool:
        
        return len(self._watched_paths) > 0

    def handle_path_change_event(self, event: events.FileSystemEvent) -> None:
        

        
        
        if event.event_type == events.EVENT_TYPE_MODIFIED:
            changed_path = event.src_path
        elif event.event_type == events.EVENT_TYPE_MOVED:
            
            
            event = cast("events.FileSystemMovedEvent", event)

            _LOGGER.debug(
                "Move event: src %s; dest %s", event.src_path, event.dest_path
            )
            changed_path = event.dest_path
        
        
        
        elif event.event_type == events.EVENT_TYPE_CREATED:
            changed_path = event.src_path
        else:
            _LOGGER.debug("Don't care about event type %s", event.event_type)
            return

        
        
        
        if isinstance(changed_path, bytes):  
            changed_path = changed_path.decode("utf-8")  

        if changed_path.endswith("~"):
            
            _LOGGER.debug("Ignoring editor backup file: %s", changed_path)
            return

        abs_changed_path = os.path.realpath(changed_path)

        
        
        with self._lock:
            
            changed_path_info = self._watched_paths.get(abs_changed_path, None)

            
            
            
            
            if changed_path_info is None:
                for path, info in self._watched_paths.items():
                    if (
                        os.path.isdir(path)
                        and os.path.commonpath([path, abs_changed_path]) == path
                    ):
                        changed_path_info = info
                        break

        
        if changed_path_info is None:
            _LOGGER.debug(
                "Ignoring changed path %s.\nWatched_paths: %s",
                abs_changed_path,
                self._watched_paths,
            )
            return

        try:
            modification_time = util.path_modification_time(
                abs_changed_path, changed_path_info.allow_nonexistent
            )

            
            
            if (
                modification_time != 0.0
                and modification_time == changed_path_info.modification_time
            ):
                _LOGGER.debug("File/dir timestamp did not change: %s", abs_changed_path)
                return

            changed_path_info.modification_time = modification_time
            new_md5 = util.calc_md5_with_blocking_retries(
                abs_changed_path,
                glob_pattern=changed_path_info.glob_pattern,
                allow_nonexistent=changed_path_info.allow_nonexistent,
            )
            if new_md5 == changed_path_info.md5:
                _LOGGER.debug("File/dir MD5 did not change: %s", abs_changed_path)
                return

            _LOGGER.debug("File/dir MD5 changed: %s", abs_changed_path)
            changed_path_info.md5 = new_md5
            changed_path_info.on_changed.send(abs_changed_path)
        except StreamlitMaxRetriesError as ex:
            _LOGGER.debug(
                "Ignoring file change. Failed to calculate MD5 for path %s",
                abs_changed_path,
                exc_info=ex,
            )
            return

    def on_created(self, event: events.FileSystemEvent) -> None:
        self.handle_path_change_event(event)

    def on_modified(self, event: events.FileSystemEvent) -> None:
        self.handle_path_change_event(event)

    def on_moved(self, event: events.FileSystemEvent) -> None:
        self.handle_path_change_event(event)
