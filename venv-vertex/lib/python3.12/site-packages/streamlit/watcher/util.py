















from __future__ import annotations

import os
import time
from pathlib import Path
from typing import TYPE_CHECKING, Callable, TypeVar

from streamlit.errors import StreamlitMaxRetriesError
from streamlit.util import calc_md5

if TYPE_CHECKING:
    from collections.abc import Generator


_MAX_RETRIES = 5


_RETRY_WAIT_SECS = 0.1


def calc_md5_with_blocking_retries(
    path: str,
    *,  
    glob_pattern: str | None = None,
    allow_nonexistent: bool = False,
) -> str:
    

    if allow_nonexistent and not os.path.exists(path):
        content = path.encode("UTF-8")
    elif os.path.isdir(path):
        glob_pattern = glob_pattern or "*"
        content = _stable_dir_identifier(path, glob_pattern).encode("UTF-8")
    else:
        
        
        
        content = _do_with_retries(
            lambda: _get_file_content(path),
            (FileNotFoundError, PermissionError),
            path,
        )

    return calc_md5(content)


def path_modification_time(path: str, allow_nonexistent: bool = False) -> float:
    
    if allow_nonexistent and not os.path.exists(path):
        return 0.0

    
    
    return _do_with_retries(
        lambda: os.stat(path).st_mtime,
        (FileNotFoundError, PermissionError),
        path,
    )


def _get_file_content(file_path: str) -> bytes:
    with open(file_path, "rb") as f:
        return f.read()


def _dirfiles(dir_path: str, glob_pattern: str) -> str:
    p = Path(dir_path)
    filenames = sorted(
        [f.name for f in p.glob(glob_pattern) if not f.name.startswith(".")]
    )
    return "+".join(filenames)


def _stable_dir_identifier(dir_path: str, glob_pattern: str) -> str:
    
    dirfiles = _dirfiles(dir_path, glob_pattern)

    for _ in _retry_dance():
        new_dirfiles = _dirfiles(dir_path, glob_pattern)
        if dirfiles == new_dirfiles:
            break

        dirfiles = new_dirfiles

    return f"{dir_path}+{dirfiles}"


T = TypeVar("T")


def _do_with_retries(
    orig_fn: Callable[[], T],
    exceptions: type[Exception] | tuple[type[Exception], ...],
    path: str | Path,
) -> T:
    

    for i in _retry_dance():
        try:
            return orig_fn()
        except exceptions as ex:  
            if i >= _MAX_RETRIES - 1:
                raise StreamlitMaxRetriesError(
                    f"Unable to access file or folder: {path}"
                ) from ex
            

    raise StreamlitMaxRetriesError(f"Unable to access file or folder: {path}")


def _retry_dance() -> Generator[int, None, None]:
    
    for i in range(_MAX_RETRIES):
        yield i
        time.sleep(_RETRY_WAIT_SECS)
