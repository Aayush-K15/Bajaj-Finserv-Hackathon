















from __future__ import annotations

import datetime
import re
import textwrap
from typing import Any, Callable

from streamlit.string_util import to_snake_case
from streamlit.util import repr_


class ConfigOption:
    

    
    
    DEFAULT_DEFINITION = "<default>"

    
    
    STREAMLIT_DEFINITION = "<streamlit>"

    def __init__(
        self,
        key: str,
        description: str | None = None,
        default_val: Any | None = None,
        visibility: str = "visible",
        scriptable: bool = False,
        deprecated: bool = False,
        deprecation_text: str | None = None,
        expiration_date: str | None = None,
        replaced_by: str | None = None,
        type_: type = str,
        sensitive: bool = False,
        multiple: bool = False,
    ) -> None:
        
        
        self.key = key
        key_format = (
            
            r"(?P<section>"
            
            
            
            r"\_?[a-z][a-zA-Z0-9]*"
            
            
            r"(\.[a-z][a-zA-Z0-9]*)*"
            r")"
            
            r"\."
            
            r"(?P<name>"
            
            
            
            r"[a-z][a-zA-Z0-9]*"
            r")$"
        )
        match = re.match(key_format, self.key)
        if match is None:
            raise ValueError(f'Key "{self.key}" has invalid format.')
        self.section, self.name = match.group("section"), match.group("name")

        self.description = description

        self.visibility = visibility
        self.scriptable = scriptable
        self.default_val = default_val
        self.deprecated = deprecated
        self.replaced_by = replaced_by
        self.is_default = True
        self._get_val_func: Callable[[], Any] | None = None
        self.where_defined = ConfigOption.DEFAULT_DEFINITION
        self.type = type_
        self.sensitive = sensitive
        self.multiple = multiple

        if self.replaced_by:
            self.deprecated = True
            if deprecation_text is None:
                deprecation_text = f"Replaced by {self.replaced_by}."

        if self.deprecated:
            if not expiration_date:
                raise ValueError("expiration_date is required for deprecated items.")
            if not deprecation_text:
                raise ValueError("deprecation_text is required for deprecated items.")
            self.expiration_date = expiration_date
            self.deprecation_text = textwrap.dedent(deprecation_text)

        self.set_value(default_val)

    def __repr__(self) -> str:
        return repr_(self)

    def __call__(self, get_val_func: Callable[[], Any]) -> ConfigOption:
        
        if get_val_func.__doc__ is None:
            raise RuntimeError(
                "Complex config options require doc strings for their description."
            )
        self.description = get_val_func.__doc__
        self._get_val_func = get_val_func
        return self

    @property
    def value(self) -> Any:
        
        if self._get_val_func is None:
            return None
        return self._get_val_func()

    def set_value(self, value: Any, where_defined: str | None = None) -> None:
        
        self._get_val_func = lambda: value

        if where_defined is None:
            self.where_defined = ConfigOption.DEFAULT_DEFINITION
        else:
            self.where_defined = where_defined

        self.is_default = value == self.default_val

        if self.deprecated and self.where_defined != ConfigOption.DEFAULT_DEFINITION:
            if self.is_expired():
                
                from streamlit.logger import get_logger

                get_logger(__name__).error(
                    textwrap.dedent(
                        f
                    )
                )
            else:
                
                from streamlit.logger import get_logger

                get_logger(__name__).warning(
                    textwrap.dedent(
                        f
                    )
                )

    def is_expired(self) -> bool:
        
        if not self.deprecated:
            return False

        expiration_date = _parse_yyyymmdd_str(self.expiration_date)
        now = datetime.datetime.now()
        return now > expiration_date

    @property
    def env_var(self) -> str:
        
        name = self.key.replace(".", "_")
        return f"STREAMLIT_{to_snake_case(name).upper()}"


def _parse_yyyymmdd_str(date_str: str) -> datetime.datetime:
    year, month, day = (int(token) for token in date_str.split("-", 2))
    return datetime.datetime(year, month, day)
