













from __future__ import annotations

import ast
import contextlib
import re
import textwrap
import traceback
from typing import TYPE_CHECKING, Any, Literal

from streamlit.runtime.metrics_util import gather_metrics

if TYPE_CHECKING:
    from collections.abc import Generator, Iterable

_SPACES_RE = re.compile("\\s*")
_EMPTY_LINE_RE = re.compile("\\s*\n")


@gather_metrics("echo")
@contextlib.contextmanager
def echo(
    code_location: Literal["above", "below"] = "above",
) -> Generator[None, None, None]:
    
    from streamlit import code, empty, source_util, warning

    if code_location == "below":
        show_code = code
        show_warning = warning
    else:
        placeholder = empty()
        show_code = placeholder.code
        show_warning = placeholder.warning

    try:
        
        
        frame = traceback.extract_stack()[-3]
        filename, start_line = frame.filename, frame.lineno or 0

        
        with source_util.open_python_file(filename) as source_file:
            source_lines = source_file.readlines()

        
        root_node = ast.parse("".join(source_lines))
        line_to_node_map: dict[int, Any] = {}

        def collect_body_statements(node: ast.AST) -> None:
            if not hasattr(node, "body"):
                return
            for child in ast.iter_child_nodes(node):
                
                if hasattr(child, "lineno"):
                    line_to_node_map[child.lineno] = child
                    collect_body_statements(child)

        collect_body_statements(root_node)

        
        
        echo_block_start_line = line_to_node_map[start_line].body[0].lineno - 1
        echo_block_end_line = line_to_node_map[start_line].end_lineno
        lines_to_display = source_lines[echo_block_start_line:echo_block_end_line]

        code_string = textwrap.dedent("".join(lines_to_display))

        
        yield

        
        show_code(code_string, "python")

    except FileNotFoundError as err:
        show_warning(f"Unable to display code. {err}")


def _get_initial_indent(lines: Iterable[str]) -> int:
    
    for line in lines:
        indent = _get_indent(line)
        if indent is not None:
            return indent

    return 0


def _get_indent(line: str) -> int | None:
    
    if _EMPTY_LINE_RE.match(line) is not None:
        return None

    match = _SPACES_RE.match(line)
    return match.end() if match is not None else 0
