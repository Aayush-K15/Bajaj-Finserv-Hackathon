













from __future__ import annotations

from functools import wraps
from typing import TYPE_CHECKING, Any, Callable, TypeVar, cast, overload

from streamlit.delta_generator_singletons import (
    get_dg_singleton_instance,
    get_last_dg_added_to_context_stack,
)
from streamlit.deprecation_util import (
    make_deprecated_name_warning,
    show_deprecation_warning,
)
from streamlit.errors import StreamlitAPIException
from streamlit.runtime.fragment import _fragment
from streamlit.runtime.metrics_util import gather_metrics

if TYPE_CHECKING:
    from streamlit.elements.lib.dialog import DialogWidth


def _assert_no_nested_dialogs() -> None:
    
    last_dg_in_current_context = get_last_dg_added_to_context_stack()
    if last_dg_in_current_context and "dialog" in set(
        last_dg_in_current_context._ancestor_block_types
    ):
        raise StreamlitAPIException("Dialogs may not be nested inside other dialogs.")


F = TypeVar("F", bound=Callable[..., None])


def _dialog_decorator(
    non_optional_func: F,
    title: str,
    *,
    width: DialogWidth = "small",
    should_show_deprecation_warning: bool = False,
) -> F:
    if title is None or title == "":
        raise StreamlitAPIException(
            "A non-empty `title` argument has to be provided for dialogs, for example "
            '`@st.dialog("Example Title")`.'
        )

    @wraps(non_optional_func)
    def wrap(*args: Any, **kwargs: Any) -> None:
        _assert_no_nested_dialogs()
        
        
        
        dialog = get_dg_singleton_instance().event_dg._dialog(
            title=title, dismissible=True, width=width
        )
        dialog.open()

        def dialog_content() -> None:
            if should_show_deprecation_warning:
                show_deprecation_warning(
                    make_deprecated_name_warning(
                        "experimental_dialog",
                        "dialog",
                        "2025-01-01",
                    )
                )

            
            
            _ = non_optional_func(*args, **kwargs)

        
        
        fragmented_dialog_content = cast(
            "Callable[[], None]",
            _fragment(
                dialog_content, additional_hash_info=non_optional_func.__qualname__
            ),
        )

        with dialog:
            fragmented_dialog_content()
            return

    return cast("F", wrap)


@overload
def dialog_decorator(
    title: str, *, width: DialogWidth = "small"
) -> Callable[[F], F]: ...








@overload
def dialog_decorator(title: F, *, width: DialogWidth = "small") -> F: ...


@gather_metrics("dialog")
def dialog_decorator(
    title: F | str, *, width: DialogWidth = "small"
) -> F | Callable[[F], F]:
    r

    func_or_title = title
    if isinstance(func_or_title, str):
        
        def wrapper(f: F) -> F:
            title: str = func_or_title
            return _dialog_decorator(non_optional_func=f, title=title, width=width)

        return wrapper

    func: F = func_or_title
    return _dialog_decorator(func, "", width=width)


@overload
def experimental_dialog_decorator(
    title: str, *, width: DialogWidth = "small"
) -> Callable[[F], F]: ...







@overload
def experimental_dialog_decorator(title: F, *, width: DialogWidth = "small") -> F: ...


@gather_metrics("experimental_dialog")
def experimental_dialog_decorator(
    title: F | str, *, width: DialogWidth = "small"
) -> F | Callable[[F], F]:
    
    func_or_title = title
    if isinstance(func_or_title, str):
        
        def wrapper(f: F) -> F:
            title: str = func_or_title
            return _dialog_decorator(
                non_optional_func=f,
                title=title,
                width=width,
                should_show_deprecation_warning=True,
            )

        return wrapper

    func: F = func_or_title
    return _dialog_decorator(
        func, "", width=width, should_show_deprecation_warning=True
    )
