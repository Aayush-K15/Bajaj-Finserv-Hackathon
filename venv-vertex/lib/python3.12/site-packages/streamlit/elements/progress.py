













from __future__ import annotations

import math
from typing import TYPE_CHECKING, Union, cast

from typing_extensions import TypeAlias

from streamlit.elements.lib.layout_utils import LayoutConfig, validate_width
from streamlit.errors import StreamlitAPIException
from streamlit.proto.Progress_pb2 import Progress as ProgressProto
from streamlit.string_util import clean_text

if TYPE_CHECKING:
    from streamlit.delta_generator import DeltaGenerator
    from streamlit.elements.lib.layout_utils import WidthWithoutContent




FloatOrInt: TypeAlias = Union[int, float]


def _check_float_between(value: float, low: float = 0.0, high: float = 1.0) -> bool:
    
    return (
        (low <= value <= high)
        or math.isclose(value, low, rel_tol=1e-9, abs_tol=1e-9)
        or math.isclose(value, high, rel_tol=1e-9, abs_tol=1e-9)
    )


def _get_value(value: FloatOrInt) -> int:
    if isinstance(value, int):
        if 0 <= value <= 100:
            return value
        raise StreamlitAPIException(
            f"Progress Value has invalid value [0, 100]: {value}"
        )

    if isinstance(value, float):
        if _check_float_between(value, low=0.0, high=1.0):
            return int(value * 100)
        raise StreamlitAPIException(
            f"Progress Value has invalid value [0.0, 1.0]: {value}"
        )
    raise StreamlitAPIException(
        f"Progress Value has invalid type: {type(value).__name__}"
    )


def _get_text(text: str | None) -> str | None:
    if text is None:
        return None
    if isinstance(text, str):
        return clean_text(text)
    raise StreamlitAPIException(
        f"Progress Text is of type {type(text)}, which is not an accepted type."
        "Text only accepts: str. Please convert the text to an accepted type."
    )


class ProgressMixin:
    def progress(
        self,
        value: FloatOrInt,
        text: str | None = None,
        width: WidthWithoutContent = "stretch",
    ) -> DeltaGenerator:
        r
        
        progress_proto = ProgressProto()
        progress_proto.value = _get_value(value)
        text = _get_text(text)
        if text is not None:
            progress_proto.text = text

        validate_width(width)
        layout_config = LayoutConfig(width=width)

        return self.dg._enqueue("progress", progress_proto, layout_config=layout_config)

    @property
    def dg(self) -> DeltaGenerator:
        
        return cast("DeltaGenerator", self)
