













from __future__ import annotations

import os
import re
from pathlib import Path
from typing import TYPE_CHECKING, Any, cast

from streamlit.delta_generator_singletons import get_dg_singleton_instance
from streamlit.elements.lib.layout_utils import (
    LayoutConfig,
    Width,
    validate_width,
)
from streamlit.errors import StreamlitAPIException
from streamlit.proto.Html_pb2 import Html as HtmlProto
from streamlit.runtime.metrics_util import gather_metrics
from streamlit.string_util import clean_text
from streamlit.type_util import SupportsReprHtml, SupportsStr, has_callable_attr

if TYPE_CHECKING:
    from streamlit.delta_generator import DeltaGenerator


class HtmlMixin:
    @gather_metrics("html")
    def html(
        self,
        body: str | Path | SupportsStr | SupportsReprHtml,
        *,  
        width: Width = "stretch",
    ) -> DeltaGenerator:
        
        html_proto = HtmlProto()

        
        if has_callable_attr(body, "_repr_html_"):
            html_content = cast("SupportsReprHtml", body)._repr_html_()

        
        elif isinstance(body, Path) or _is_file(body):
            file_path = str(body)
            with open(file_path, encoding="utf-8") as f:
                html_content = f.read()

            
            if Path(file_path).suffix.lower() == ".css":
                html_content = f"<style>{html_content}</style>"

        
        else:
            html_content = clean_text(cast("SupportsStr", body))

        
        if html_content == "":
            raise StreamlitAPIException("`st.html` body cannot be empty")

        validate_width(width, allow_content=True)
        layout_config = LayoutConfig(width=width)

        
        
        if _html_only_style_tags(html_content):
            
            html_proto.body = html_content
            return self._event_dg._enqueue("html", html_proto)
        
        html_proto.body = html_content
        return self.dg._enqueue("html", html_proto, layout_config=layout_config)

    @property
    def dg(self) -> DeltaGenerator:
        
        return cast("DeltaGenerator", self)

    @property
    def _event_dg(self) -> DeltaGenerator:
        
        return get_dg_singleton_instance().event_dg


def _html_only_style_tags(html_content: str) -> bool:
    
    
    comment_pattern = r"<!--.*?-->"
    
    style_pattern = r"<style[^>]*>.*?</style>"

    
    html_without_comments = re.sub(comment_pattern, "", html_content, flags=re.DOTALL)
    html_without_styles_and_comments = re.sub(
        style_pattern, "", html_without_comments, flags=re.DOTALL | re.IGNORECASE
    )

    
    return html_without_styles_and_comments.strip() == ""


def _is_file(obj: Any) -> bool:
    
    try:
        return os.path.isfile(obj)
    except TypeError:
        return False
