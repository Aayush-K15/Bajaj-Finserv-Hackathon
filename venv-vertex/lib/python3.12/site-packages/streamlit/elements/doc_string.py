















from __future__ import annotations

import ast
import contextlib
import inspect
import re
import types
from typing import TYPE_CHECKING, Any, Final, cast

import streamlit
from streamlit.elements.lib.layout_utils import LayoutConfig, validate_width
from streamlit.proto.DocString_pb2 import DocString as DocStringProto
from streamlit.proto.DocString_pb2 import Member as MemberProto
from streamlit.runtime.caching.cache_utils import CachedFunc
from streamlit.runtime.metrics_util import gather_metrics
from streamlit.runtime.scriptrunner.script_runner import (
    __file__ as SCRIPTRUNNER_FILENAME,  
)
from streamlit.runtime.secrets import Secrets
from streamlit.string_util import is_mem_address_str

if TYPE_CHECKING:
    from streamlit.delta_generator import DeltaGenerator
    from streamlit.elements.lib.layout_utils import WidthWithoutContent


CONFUSING_STREAMLIT_SIG_PREFIXES: Final = ("(element, ",)


class HelpMixin:
    @gather_metrics("help")
    def help(
        self, obj: Any = streamlit, *, width: WidthWithoutContent = "stretch"
    ) -> DeltaGenerator:
        
        doc_string_proto = DocStringProto()

        validate_width(width, allow_content=False)
        layout_config = LayoutConfig(width=width)
        _marshall(doc_string_proto, obj)

        return self.dg._enqueue(
            "doc_string", doc_string_proto, layout_config=layout_config
        )

    @property
    def dg(self) -> DeltaGenerator:
        
        return cast("DeltaGenerator", self)


def _marshall(doc_string_proto: DocStringProto, obj: Any) -> None:
    
    var_name = _get_variable_name()
    if var_name is not None:
        doc_string_proto.name = var_name

    obj_type = _get_type_as_str(obj)
    doc_string_proto.type = obj_type

    obj_docs = _get_docstring(obj)
    if obj_docs is not None:
        doc_string_proto.doc_string = obj_docs

    obj_value = _get_value(obj, var_name)
    if obj_value is not None:
        doc_string_proto.value = obj_value

    doc_string_proto.members.extend(_get_members(obj))


def _get_name(obj: object) -> str | None:
    
    
    
    name = getattr(obj, "__qualname__", None)
    if name:
        return cast("str", name)

    
    
    
    return cast("str | None", getattr(obj, "__name__", None))


def _get_module(obj: object) -> str | None:
    return getattr(obj, "__module__", None)


def _get_signature(obj: object) -> str | None:
    if not inspect.isclass(obj) and not callable(obj):
        return None

    sig = ""

    try:
        sig = str(inspect.signature(obj))
    except ValueError:
        sig = "(...)"
    except TypeError:
        return None

    is_delta_gen = False
    with contextlib.suppress(AttributeError):
        is_delta_gen = obj.__module__ == "streamlit.delta_generator"
        
        
        

    if is_delta_gen:
        for prefix in CONFUSING_STREAMLIT_SIG_PREFIXES:
            if sig.startswith(prefix):
                sig = sig.replace(prefix, "(")
                break

    return sig


def _get_docstring(obj: object) -> str | None:
    doc_string = inspect.getdoc(obj)

    
    
    
    
    
    if doc_string is None:
        obj_type = type(obj)

        if (
            obj_type is not type
            and obj_type is not types.ModuleType
            and not inspect.isfunction(obj)
            and not inspect.ismethod(obj)
            and obj_type is not CachedFunc
        ):
            doc_string = inspect.getdoc(obj_type)

    if doc_string:
        return doc_string.strip()

    return None


def _get_variable_name() -> str | None:
    
    code = _get_current_line_of_code_as_str()

    if code is None:
        return None

    return _get_variable_name_from_code_str(code)


def _get_variable_name_from_code_str(code: str) -> str | None:
    tree = ast.parse(code)

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    if not _is_stcommand(tree, command_name="help") and not _is_stcommand(
        tree, command_name="write"
    ):
        
        
        return code.removesuffix(",")

    arg_node = _get_stcommand_arg(tree)

    
    if not arg_node:
        return None

    
    
    if type(arg_node) is ast.NamedExpr:
        
        
        if type(arg_node.target) is ast.Name:
            return arg_node.target.id

    
    
    elif type(arg_node) is ast.Constant:
        return None

    

    
    code_lines = code.split("\n")
    is_multiline = len(code_lines) > 1

    start_offset = arg_node.col_offset

    if is_multiline:
        first_lineno = arg_node.lineno - 1  
        first_line = code_lines[first_lineno]
        end_offset = None

    else:
        first_line = code_lines[0]
        end_offset = getattr(arg_node, "end_col_offset", -1)

    return first_line[start_offset:end_offset]


_NEWLINES = re.compile(r"[\n\r]+")


def _get_current_line_of_code_as_str() -> str | None:
    scriptrunner_frame = _get_scriptrunner_frame()

    if scriptrunner_frame is None:
        
        
        
        
        return None

    code_context = scriptrunner_frame.code_context

    if not code_context:
        
        
        
        
        return None

    code_as_string = "".join(code_context)
    return re.sub(_NEWLINES, "", code_as_string.strip())


def _get_scriptrunner_frame() -> inspect.FrameInfo | None:
    prev_frame = None
    scriptrunner_frame = None

    
    
    
    
    for frame in inspect.stack():
        
        
        if frame.code_context is None:
            return None

        if frame.filename == SCRIPTRUNNER_FILENAME:
            scriptrunner_frame = prev_frame
            break

        prev_frame = frame

    return scriptrunner_frame


def _is_stcommand(tree: Any, command_name: str) -> bool:
    
    root_node = tree.body[0].value

    if not isinstance(root_node, ast.Call):
        return False

    return (
        
        getattr(root_node.func, "id", None) == command_name
        or
        
        getattr(root_node.func, "attr", None) == command_name
    )


def _get_stcommand_arg(tree: ast.Module) -> ast.expr | None:
    

    root_node = tree.body[0].value  

    if root_node.args:
        return cast("ast.expr", root_node.args[0])

    return None


def _get_type_as_str(obj: object) -> str:
    if inspect.isclass(obj):
        return "class"

    return str(type(obj).__name__)


def _get_first_line(text: str) -> str:
    if not text:
        return ""

    left, _, _ = text.partition("\n")
    return left


def _get_weight(value: Any) -> int:
    if inspect.ismodule(value):
        return 3
    if inspect.isclass(value):
        return 2
    if callable(value):
        return 1
    return 0


def _get_value(obj: object, var_name: str | None) -> str | None:
    obj_value = _get_human_readable_value(obj)

    if obj_value is not None:
        return obj_value

    
    
    name = _get_name(obj)

    if name:
        name_obj = obj
    else:
        
        
        name_obj = type(obj)
        name = _get_name(name_obj)

    module = _get_module(name_obj)
    sig = _get_signature(name_obj) or ""

    if name:
        obj_value = f"{module}.{name}{sig}" if module else f"{name}{sig}"

    if obj_value == var_name:
        
        
        obj_value = None

    return obj_value


def _get_human_readable_value(value: Any) -> str | None:
    if isinstance(value, Secrets):
        
        
        return None

    if inspect.isclass(value) or inspect.ismodule(value) or callable(value):
        return None

    value_str = repr(value)

    if isinstance(value, str):
        
        
        return _shorten(value_str)

    if is_mem_address_str(value_str):
        
        return None

    return _shorten(value_str)


def _shorten(s: str, length: int = 300) -> str:
    s = s.strip()
    return s[:length] + "..." if len(s) > length else s


def _is_computed_property(obj: object, attr_name: str) -> bool:
    obj_class = getattr(obj, "__class__", None)

    if not obj_class:
        return False

    
    
    for parent_class in inspect.getmro(obj_class):
        class_attr = getattr(parent_class, attr_name, None)

        if class_attr is None:
            continue

        
        if isinstance(class_attr, property) or inspect.isgetsetdescriptor(class_attr):
            return True

    return False


def _get_members(obj: object) -> list[MemberProto]:
    members_for_sorting = []

    for attr_name in dir(obj):
        if attr_name.startswith("_"):
            continue

        try:
            is_computed_value = _is_computed_property(obj, attr_name)
            if is_computed_value:
                parent_attr = getattr(obj.__class__, attr_name)

                member_type = "property"

                weight = 0
                member_docs = _get_docstring(parent_attr)
                member_value = None
            else:
                attr_value = getattr(obj, attr_name)
                weight = _get_weight(attr_value)

                human_readable_value = _get_human_readable_value(attr_value)

                member_type = _get_type_as_str(attr_value)

                if human_readable_value is None:
                    member_docs = _get_docstring(attr_value)
                    member_value = None
                else:
                    member_docs = None
                    member_value = human_readable_value
        except AttributeError:
            
            
            
            continue

        if member_type == "module":
            
            continue

        member = MemberProto()
        member.name = attr_name
        member.type = member_type

        if member_docs is not None:
            member.doc_string = _get_first_line(member_docs)

        if member_value is not None:
            member.value = member_value

        members_for_sorting.append((weight, member))

    if members_for_sorting:
        sorted_members = sorted(members_for_sorting, key=lambda x: (x[0], x[1].name))
        return [m for _, m in sorted_members]

    return []
