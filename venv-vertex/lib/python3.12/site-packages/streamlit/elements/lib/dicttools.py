















from __future__ import annotations

from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from collections.abc import Mapping


def _unflatten_single_dict(flat_dict: dict[Any, Any]) -> dict[Any, Any]:
    
    out: dict[str, Any] = {}
    for pathstr, v in flat_dict.items():
        path = pathstr.split("_")

        prev_dict: dict[str, Any] | None = None
        curr_dict = out

        for k in path:
            if k not in curr_dict:
                curr_dict[k] = {}
            prev_dict = curr_dict
            curr_dict = curr_dict[k]

        if prev_dict is not None:
            prev_dict[k] = v

    return out


def unflatten(
    flat_dict: dict[Any, Any], encodings: set[str] | None = None
) -> dict[Any, Any]:
    
    if encodings is None:
        encodings = set()

    out_dict = _unflatten_single_dict(flat_dict)

    for k, v in list(out_dict.items()):
        
        if isinstance(v, dict):
            v = unflatten(v, encodings)  
        elif hasattr(v, "__iter__"):
            for i, child in enumerate(v):
                if isinstance(child, dict):
                    v[i] = unflatten(child, encodings)

        
        if k in encodings:
            if "encoding" not in out_dict:
                out_dict["encoding"] = {}
            out_dict["encoding"][k] = v
            out_dict.pop(k)

    return out_dict


def remove_none_values(input_dict: Mapping[Any, Any]) -> dict[Any, Any]:
    
    new_dict = {}
    for key, val in input_dict.items():
        if val is not None:
            new_dict[key] = remove_none_values(val) if isinstance(val, dict) else val
    return new_dict
