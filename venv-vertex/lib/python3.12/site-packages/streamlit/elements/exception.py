













from __future__ import annotations

import os
import traceback
from typing import TYPE_CHECKING, Callable, Final, TypeVar, cast

from streamlit import config
from streamlit.elements.lib.layout_utils import validate_width
from streamlit.errors import (
    MarkdownFormattedException,
    StreamlitAPIWarning,
)
from streamlit.logger import get_logger
from streamlit.proto.Exception_pb2 import Exception as ExceptionProto
from streamlit.proto.WidthConfig_pb2 import WidthConfig
from streamlit.runtime.metrics_util import gather_metrics
from streamlit.runtime.scriptrunner_utils.script_run_context import get_script_run_ctx

if TYPE_CHECKING:
    from streamlit.delta_generator import DeltaGenerator
    from streamlit.elements.lib.layout_utils import WidthWithoutContent

_LOGGER: Final = get_logger(__name__)



_GENERIC_UNCAUGHT_EXCEPTION_TEXT: Final = (
    "This app has encountered an error. The original error message is redacted "
    "to prevent data leaks. Full error details have been recorded in the logs "
    "(if you're on Streamlit Cloud, click on 'Manage app' in the lower right of your app)."
)


class ExceptionMixin:
    @gather_metrics("exception")
    def exception(
        self, exception: BaseException, width: WidthWithoutContent = "stretch"
    ) -> DeltaGenerator:
        
        return _exception(self.dg, exception, width=width)

    @property
    def dg(self) -> DeltaGenerator:
        
        return cast("DeltaGenerator", self)



@gather_metrics("exception")
def _exception(
    dg: DeltaGenerator,
    exception: BaseException,
    width: WidthWithoutContent = "stretch",
    is_uncaught_app_exception: bool = False,
) -> DeltaGenerator:
    exception_proto = ExceptionProto()
    marshall(exception_proto, exception, width, is_uncaught_app_exception)
    return dg._enqueue("exception", exception_proto)


def marshall(
    exception_proto: ExceptionProto,
    exception: BaseException,
    width: WidthWithoutContent = "stretch",
    is_uncaught_app_exception: bool = False,
) -> None:
    
    validate_width(width)

    is_markdown_exception = isinstance(exception, MarkdownFormattedException)

    
    
    if getattr(exception, "alternate_name", None) is not None:
        exception_proto.type = exception.alternate_name  
    else:
        exception_proto.type = type(exception).__name__

    stack_trace = _get_stack_trace_str_list(exception)

    exception_proto.stack_trace.extend(stack_trace)
    exception_proto.is_warning = isinstance(exception, Warning)

    width_config = WidthConfig()

    if isinstance(width, int):
        width_config.pixel_width = width
    else:
        width_config.use_stretch = True

    exception_proto.width_config.CopyFrom(width_config)

    try:
        if isinstance(exception, SyntaxError):
            
            
            
            exception_proto.message = _format_syntax_error_message(exception)
        else:
            exception_proto.message = str(exception).strip()
            exception_proto.message_is_markdown = is_markdown_exception

    except Exception as str_exception:
        
        
        exception_proto.message = ""
        _LOGGER.warning(
            ,
            type(exception).__name__,
            str_exception,
            "\n".join(_get_stack_trace_str_list(str_exception)),
        )

    if is_uncaught_app_exception:
        show_error_details = config.get_option("client.showErrorDetails")

        show_message = (
            show_error_details == config.ShowErrorDetailsConfigOptions.FULL
            or config.ShowErrorDetailsConfigOptions.is_true_variation(
                show_error_details
            )
        )
        
        
        show_trace = (
            show_message
            or show_error_details == config.ShowErrorDetailsConfigOptions.STACKTRACE
            or config.ShowErrorDetailsConfigOptions.is_false_variation(
                show_error_details
            )
        )
        show_type = (
            show_trace
            or show_error_details == config.ShowErrorDetailsConfigOptions.TYPE
        )

        if not show_message:
            exception_proto.message = _GENERIC_UNCAUGHT_EXCEPTION_TEXT
        if not show_type:
            exception_proto.ClearField("type")
        else:
            type_str = str(type(exception))
            exception_proto.type = type_str.replace("<class '", "").replace("'>", "")
        if not show_trace:
            exception_proto.ClearField("stack_trace")


def _format_syntax_error_message(exception: SyntaxError) -> str:
    
    if exception.text:
        caret_indent = (
            " " * max(exception.offset - 1, 0) if exception.offset is not None else ""
        )

        return (
            f'File "{exception.filename}", line {exception.lineno}\n'
            f"  {exception.text.rstrip()}\n"
            f"  {caret_indent}^\n"
            f"{type(exception).__name__}: {exception.msg}"
        )
    
    
    
    return str(exception)


def _get_stack_trace_str_list(exception: BaseException) -> list[str]:
    
    extracted_traceback: traceback.StackSummary | None = None
    if isinstance(exception, StreamlitAPIWarning):
        extracted_traceback = exception.tacked_on_stack
    elif hasattr(exception, "__traceback__"):
        extracted_traceback = traceback.extract_tb(exception.__traceback__)

    
    if extracted_traceback is None:
        trace_str_list = [
            "Cannot extract the stack trace for this exception. "
            "Try calling exception() within the `catch` block."
        ]
    else:
        internal_frames, external_frames = _split_internal_streamlit_frames(
            extracted_traceback
        )

        if external_frames:
            trace_str_list = traceback.format_list(external_frames)
        else:
            trace_str_list = traceback.format_list(internal_frames)

        trace_str_list = [item.strip() for item in trace_str_list]

    return trace_str_list


def _is_in_package(file: str, package_path: str) -> bool:
    
    try:
        common_prefix = os.path.commonprefix([os.path.realpath(file), package_path])
    except ValueError:
        
        return False

    return common_prefix == package_path


def _split_internal_streamlit_frames(
    extracted_tb: traceback.StackSummary,
) -> tuple[list[traceback.FrameSummary], list[traceback.FrameSummary]]:
    

    ctx = get_script_run_ctx()

    if not ctx:
        return [], list(extracted_tb)

    package_path = os.path.join(os.path.realpath(str(ctx.main_script_parent)), "")

    return _split_list(
        extracted_tb,
        split_point=lambda tb: _is_in_package(tb.filename, package_path),
    )


T = TypeVar("T")


def _split_list(
    orig_list: list[T], split_point: Callable[[T], bool]
) -> tuple[list[T], list[T]]:
    before: list[T] = []
    after: list[T] = []

    saw_split_point = False

    for item in orig_list:
        if not saw_split_point and split_point(item):
            saw_split_point = True

        if saw_split_point:
            after.append(item)
        else:
            before.append(item)

    return before, after
