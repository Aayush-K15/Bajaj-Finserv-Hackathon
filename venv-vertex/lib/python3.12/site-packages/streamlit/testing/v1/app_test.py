












from __future__ import annotations

import inspect
import tempfile
import textwrap
import traceback
from pathlib import Path
from typing import TYPE_CHECKING, Any, Callable
from unittest.mock import MagicMock
from urllib import parse

from streamlit.runtime import Runtime
from streamlit.runtime.caching.storage.dummy_cache_storage import (
    MemoryCacheStorageManager,
)
from streamlit.runtime.media_file_manager import MediaFileManager
from streamlit.runtime.memory_media_file_storage import MemoryMediaFileStorage
from streamlit.runtime.pages_manager import PagesManager
from streamlit.runtime.scriptrunner.script_cache import ScriptCache
from streamlit.runtime.secrets import Secrets
from streamlit.runtime.state.common import TESTING_KEY
from streamlit.runtime.state.safe_session_state import SafeSessionState
from streamlit.runtime.state.session_state import SessionState
from streamlit.source_util import page_icon_and_name
from streamlit.testing.v1.element_tree import (
    Block,
    Button,
    ButtonGroup,
    Caption,
    ChatInput,
    ChatMessage,
    Checkbox,
    Code,
    ColorPicker,
    Column,
    Dataframe,
    DateInput,
    Divider,
    ElementList,
    ElementTree,
    Error,
    Exception,  
    Expander,
    Header,
    Info,
    Json,
    Latex,
    Markdown,
    Metric,
    Multiselect,
    Node,
    NumberInput,
    Radio,
    Selectbox,
    SelectSlider,
    Slider,
    Status,
    Subheader,
    Success,
    Tab,
    Table,
    Text,
    TextArea,
    TextInput,
    TimeInput,
    Title,
    Toast,
    Toggle,
    Warning,  
    WidgetList,
    repr_,
)
from streamlit.testing.v1.local_script_runner import LocalScriptRunner
from streamlit.testing.v1.util import patch_config_options
from streamlit.util import calc_md5

if TYPE_CHECKING:
    from collections.abc import Iterator, Sequence

    from streamlit.proto.WidgetStates_pb2 import WidgetStates

TMP_DIR = tempfile.TemporaryDirectory()


class AppTest:
    

    def __init__(
        self,
        script_path: str | Path,
        *,
        default_timeout: float,
        args: tuple[Any, ...] | None = None,
        kwargs: dict[str, Any] | None = None,
    ) -> None:
        self._script_path = str(script_path)
        self.default_timeout = default_timeout
        session_state = SessionState()
        session_state[TESTING_KEY] = {}
        self.session_state = SafeSessionState(session_state, lambda: None)
        self.query_params: dict[str, Any] = {}
        self.secrets: dict[str, Any] = {}
        self.args = args
        self.kwargs = kwargs
        self._page_hash = ""

        tree = ElementTree()
        tree._runner = self
        self._tree = tree

    @classmethod
    def from_string(cls, script: str, *, default_timeout: float = 3) -> AppTest:
        
        return cls._from_string(script, default_timeout=default_timeout)

    @classmethod
    def _from_string(
        cls,
        script: str,
        *,
        default_timeout: float = 3,
        args: tuple[Any, ...] | None = None,
        kwargs: dict[str, Any] | None = None,
    ) -> AppTest:
        script_name = calc_md5(bytes(script, "utf-8"))

        path = Path(TMP_DIR.name, script_name)
        aligned_script = textwrap.dedent(script)
        path.write_text(aligned_script)
        return AppTest(
            str(path), default_timeout=default_timeout, args=args, kwargs=kwargs
        )

    @classmethod
    def from_function(
        cls,
        script: Callable[..., Any],
        *,
        default_timeout: float = 3,
        args: tuple[Any, ...] | None = None,
        kwargs: dict[str, Any] | None = None,
    ) -> AppTest:
        
        source_lines, _ = inspect.getsourcelines(script)
        source = textwrap.dedent("".join(source_lines))
        module = source + f"\n{script.__name__}(*__args, **__kwargs)"
        return cls._from_string(
            module, default_timeout=default_timeout, args=args, kwargs=kwargs
        )

    @classmethod
    def from_file(
        cls, script_path: str | Path, *, default_timeout: float = 3
    ) -> AppTest:
        
        script_path = Path(script_path)
        if script_path.is_file():
            path = script_path
        else:
            
            
            
            stack = traceback.StackSummary.extract(traceback.walk_stack(None))
            filepath = Path(stack[1].filename)
            path = filepath.parent / script_path
        return AppTest(path, default_timeout=default_timeout)

    def _run(
        self,
        widget_state: WidgetStates | None = None,
        timeout: float | None = None,
    ) -> AppTest:
        
        
        
        import streamlit as st

        if timeout is None:
            timeout = self.default_timeout

        
        mock_runtime = MagicMock(spec=Runtime)
        mock_runtime.media_file_mgr = MediaFileManager(
            MemoryMediaFileStorage("/mock/media")
        )
        mock_runtime.cache_storage_manager = MemoryCacheStorageManager()
        Runtime._instance = mock_runtime
        script_cache = ScriptCache()
        pages_manager = PagesManager(
            self._script_path, script_cache, setup_watcher=False
        )

        saved_secrets: Secrets = st.secrets
        
        if self.secrets:
            new_secrets = Secrets()
            new_secrets._secrets = self.secrets
            st.secrets = new_secrets

        script_runner = LocalScriptRunner(
            self._script_path,
            self.session_state,
            pages_manager,
            args=self.args,
            kwargs=self.kwargs,
        )
        with patch_config_options({"global.appTest": True}):
            self._tree = script_runner.run(
                widget_state, self.query_params, timeout, self._page_hash
            )
            self._tree._runner = self
        
        query_string = script_runner.event_data[-1]["client_state"].query_string
        self.query_params = parse.parse_qs(query_string)

        if self.secrets:
            if st.secrets._secrets is not None:
                self.secrets = dict(st.secrets._secrets)
            st.secrets = saved_secrets
        Runtime._instance = None

        return self

    def run(self, *, timeout: float | None = None) -> AppTest:
        
        return self._tree.run(timeout=timeout)

    def switch_page(self, page_path: str) -> AppTest:
        
        main_dir = Path(self._script_path).parent
        full_page_path = main_dir / page_path
        if not full_page_path.is_file():
            raise ValueError(
                f"Unable to find script at {page_path}, make sure the page given is relative to the main script."
            )
        page_path_str = str(full_page_path.resolve())
        _, page_name = page_icon_and_name(Path(page_path_str))
        self._page_hash = calc_md5(page_name)
        return self

    @property
    def main(self) -> Block:
        
        return self._tree.main

    @property
    def sidebar(self) -> Block:
        
        return self._tree.sidebar

    @property
    def button(self) -> WidgetList[Button]:
        
        return self._tree.button

    @property
    def button_group(self) -> WidgetList[ButtonGroup[Any]]:
        
        return self._tree.button_group

    @property
    def caption(self) -> ElementList[Caption]:
        
        return self._tree.caption

    @property
    def chat_input(self) -> WidgetList[ChatInput]:
        
        return self._tree.chat_input

    @property
    def chat_message(self) -> Sequence[ChatMessage]:
        
        return self._tree.chat_message

    @property
    def checkbox(self) -> WidgetList[Checkbox]:
        
        return self._tree.checkbox

    @property
    def code(self) -> ElementList[Code]:
        
        return self._tree.code

    @property
    def color_picker(self) -> WidgetList[ColorPicker]:
        
        return self._tree.color_picker

    @property
    def columns(self) -> Sequence[Column]:
        
        return self._tree.columns

    @property
    def dataframe(self) -> ElementList[Dataframe]:
        
        return self._tree.dataframe

    @property
    def date_input(self) -> WidgetList[DateInput]:
        
        return self._tree.date_input

    @property
    def divider(self) -> ElementList[Divider]:
        
        return self._tree.divider

    @property
    def error(self) -> ElementList[Error]:
        
        return self._tree.error

    @property
    def exception(self) -> ElementList[Exception]:
        
        return self._tree.exception

    @property
    def expander(self) -> Sequence[Expander]:
        
        return self._tree.expander

    @property
    def header(self) -> ElementList[Header]:
        
        return self._tree.header

    @property
    def info(self) -> ElementList[Info]:
        
        return self._tree.info

    @property
    def json(self) -> ElementList[Json]:
        
        return self._tree.json

    @property
    def latex(self) -> ElementList[Latex]:
        
        return self._tree.latex

    @property
    def markdown(self) -> ElementList[Markdown]:
        
        return self._tree.markdown

    @property
    def metric(self) -> ElementList[Metric]:
        
        return self._tree.metric

    @property
    def multiselect(self) -> WidgetList[Multiselect[Any]]:
        
        return self._tree.multiselect

    @property
    def number_input(self) -> WidgetList[NumberInput]:
        
        return self._tree.number_input

    @property
    def radio(self) -> WidgetList[Radio[Any]]:
        
        return self._tree.radio

    @property
    def select_slider(self) -> WidgetList[SelectSlider[Any]]:
        
        return self._tree.select_slider

    @property
    def selectbox(self) -> WidgetList[Selectbox[Any]]:
        
        return self._tree.selectbox

    @property
    def slider(self) -> WidgetList[Slider[Any]]:
        
        return self._tree.slider

    @property
    def subheader(self) -> ElementList[Subheader]:
        
        return self._tree.subheader

    @property
    def success(self) -> ElementList[Success]:
        
        return self._tree.success

    @property
    def status(self) -> Sequence[Status]:
        
        return self._tree.status

    @property
    def table(self) -> ElementList[Table]:
        
        return self._tree.table

    @property
    def tabs(self) -> Sequence[Tab]:
        
        return self._tree.tabs

    @property
    def text(self) -> ElementList[Text]:
        
        return self._tree.text

    @property
    def text_area(self) -> WidgetList[TextArea]:
        
        return self._tree.text_area

    @property
    def text_input(self) -> WidgetList[TextInput]:
        
        return self._tree.text_input

    @property
    def time_input(self) -> WidgetList[TimeInput]:
        
        return self._tree.time_input

    @property
    def title(self) -> ElementList[Title]:
        
        return self._tree.title

    @property
    def toast(self) -> ElementList[Toast]:
        
        return self._tree.toast

    @property
    def toggle(self) -> WidgetList[Toggle]:
        
        return self._tree.toggle

    @property
    def warning(self) -> ElementList[Warning]:
        
        return self._tree.warning

    def __len__(self) -> int:
        return len(self._tree)

    def __iter__(self) -> Iterator[Node]:
        yield from self._tree

    def __getitem__(self, idx: int) -> Node:
        return self._tree[idx]

    def get(self, element_type: str) -> Sequence[Node]:
        
        return self._tree.get(element_type)

    def __repr__(self) -> str:
        return repr_(self)
