





import sys
import types as Types
from typing import Any
import warnings
import weakref as Weakref
from inspect import isbuiltin, isclass, iscode, isframe, isfunction, ismethod, ismodule
from math import log
from os import curdir, linesep
from struct import calcsize

__all__ = ["asizeof"]
__version__ = "22.06.30"

_NN = ""
_Not_vari = _NN  



_ignored_modules = {
    int.__module__,
    "types",
    Exception.__module__,  
    __name__,
}  



_sizeof_Cbyte = calcsize("c")  
_sizeof_Clong = calcsize("l")  
_sizeof_Cvoidp = calcsize("P")  


_z_P_L = "P" if _sizeof_Clong < _sizeof_Cvoidp else "L"


def _calcsize(fmt):
    
    return calcsize(fmt.replace("z", _z_P_L))



_sizeof_CPyCodeObject = _calcsize("Pz10P5i0P")  
_sizeof_CPyFrameObject = _calcsize("Pzz13P63i0P")  
_sizeof_CPyModuleObject = _calcsize("PzP0P")  


_sizeof_CPyDictEntry = _calcsize("z2P")  
_sizeof_Csetentry = _calcsize("lP")  


u = "\0".encode("utf-8")
_sizeof_Cunicode = len(u)
del u

try:  
    import _testcapi as t

    _sizeof_CPyGC_Head = t.SIZEOF_PYGC_HEAD  
except (ImportError, AttributeError):  
    
    
    t = calcsize("2d") - 1
    _sizeof_CPyGC_Head = (_calcsize("2Pz") + t) & ~t


t = hasattr(sys, "gettotalrefcount")
_sizeof_Crefcounts = _calcsize("2z") if t else 0
del t


_Py_TPFLAGS_HEAPTYPE = 1 << 9  
_Py_TPFLAGS_HAVE_GC = 1 << 14  

_Type_type = type(type)  

from gc import get_objects as _getobjects
from gc import get_referents as _getreferents  

if sys.platform == "ios":  
    _gc_getobjects = _getobjects

    def _getobjects():  
        
        return tuple(o for o in _gc_getobjects() if not _isNULL(o))


_getsizeof = sys.getsizeof  






def _items(obj):  
    
    o = getattr(obj, "iteritems", obj.items)
    return o() if callable(o) else (o or ())


def _keys(obj):  
    
    o = getattr(obj, "iterkeys", obj.keys)
    return o() if callable(o) else (o or ())


def _values(obj):  
    
    o = getattr(obj, "itervalues", obj.values)
    return o() if callable(o) else (o or ())



c = (lambda unused: (lambda: unused))(None)
_cell_type = type(c.__closure__[0])  
del c





def _basicsize(t, base=0, heap=False, obj=None):
    
    s = max(getattr(t, "__basicsize__", 0), base)
    
    if t != _Type_type:
        h = getattr(t, "__flags__", 0) & _Py_TPFLAGS_HAVE_GC
    elif heap:  
        h = True
    else:  
        h = getattr(obj, "__flags__", 0) & _Py_TPFLAGS_HEAPTYPE
    if h:
        s += _sizeof_CPyGC_Head
    
    return s + _sizeof_Crefcounts


def _classof(obj, dflt=None):
    
    return getattr(obj, "__class__", dflt)


def _derive_typedef(typ):
    
    v = [v for v in _values(_typedefs) if _issubclass(typ, v.type)]
    return v[0] if len(v) == 1 else None


def _dir2(obj, pref=_NN, excl=(), slots=None, itor=_NN):
    
    if slots:  
        if hasattr(obj, slots):
            
            
            
            s = {}
            for c in type(obj).mro():
                n = _nameof(c)
                for a in getattr(c, slots, ()):
                    if a.startswith("__"):
                        a = "_" + n + a
                    if hasattr(obj, a):
                        s.setdefault(a, getattr(obj, a))
            
            
            
            for t in _items(s):
                yield t  
    elif itor:  
        for o in obj:  
            yield itor, o
    else:  
        for a in dir(obj):
            if a.startswith(pref) and hasattr(obj, a) and a not in excl:
                yield a, getattr(obj, a)


def _infer_dict(obj):
    
    for attrs in (("items", "keys", "values"), ("iteritems", "iterkeys", "itervalues")):
        attrs += "__len__", "get", "has_key"  
        if all(callable(getattr(obj, a, None)) for a in attrs):
            return True
    return False


def _isbuiltin2(typ):
    
    
    return isbuiltin(typ) or (typ is range)


def _iscell(obj):
    
    return isinstance(obj, _cell_type)


def _isdictype(obj):
    
    c = _classof(obj)
    n = _nameof(c)
    return n and n in _dict_types.get(_moduleof(c), ())


def _isframe(obj):
    
    try:
        return isframe(obj)
    except ReferenceError:
        return False


def _isignored(typ):
    
    return _moduleof(typ) in _ignored_modules


def _isnamedtuple(obj):
    
    return isinstance(obj, tuple) and hasattr(obj, "_fields")


def _isNULL(obj):
    
    return isinstance(obj, tuple) and len(obj) == 1 and repr(obj) == "(<NULL>,)"


def _issubclass(obj, Super):
    
    if Super is not object:
        try:
            return issubclass(obj, Super)
        except TypeError:
            pass
    return None


def _itemsize(t, item=0):
    
    
    return getattr(t, "__itemsize__", 0) or item


def _kwdstr(**kwds):
    
    return ", ".join(sorted("%s=%r" % kv for kv in _items(kwds)))


def _lengstr(obj):
    
    n = leng(obj)
    if n is None:  
        r = _NN
    else:
        x = "!" if n > _len(obj) else _NN  
        r = " leng %d%s" % (n, x)
    return r


def _moduleof(obj, dflt=_NN):
    
    return getattr(obj, "__module__", dflt)


def _nameof(obj, dflt=_NN):
    
    return getattr(obj, "__name__", dflt)


def _objs_opts_x(where, objs, all=None, **opts):
    
    if objs:  
        t, x = objs, False
    elif all in (False, None):
        t, x = (), True
    elif all is True:  
        t, x = _getobjects(), True
    else:
        raise _OptionError(where, all=all)
    return t, opts, x


def _OptionError(where, Error=ValueError, **options):
    
    t = _plural(len(options)), _nameof(where), _kwdstr(**options)
    return Error("invalid option%s: %s(%s)" % t)


def _p100(part, total, prec=1):
    
    t = float(total)
    if t > 0:
        p = part * 100.0 / t
        r = "%.*f%%" % (prec, p)
    else:
        r = "n/a"
    return r


def _plural(num):
    
    return "s" if num != 1 else _NN


def _power_of_2(n):
    
    p2 = 2 ** int(log(n, 2))
    while n > p2:
        p2 += p2
    return p2


def _prepr(obj, clip=0):
    
    return _repr(obj, clip=clip).strip("<>").replace("'", _NN)  


def _printf(fmt, *args, **print3options):
    
    if print3options:  
        f = print3options.get("file", None) or sys.stdout
        if args:
            f.write(fmt % args)
        else:
            f.write(fmt)
        f.write(print3options.get("end", linesep))
        if print3options.get("flush", False):
            f.flush()
    elif args:
        print(fmt % args)
    else:
        print(fmt)


def _refs(obj, named, *attrs, **kwds):
    
    if named:
        _N = _NamedRef
    else:

        def _N(unused, o):
            return o

    for a in attrs:  
        if hasattr(obj, a):
            yield _N(a, getattr(obj, a))
    if kwds:  
        for a, o in _dir2(obj, **kwds):
            yield _N(a, o)


def _repr(obj, clip=80):
    
    try:  
        r = repr(obj).replace(linesep, "\\n")
    except Exception:
        r = "N/A"
    if len(r) > clip > 0:
        h = (clip // 2) - 2
        if h > 0:
            r = r[:h] + "...." + r[-h:]
    return r


def _SI(size, K=1024, i="i"):
    
    if 1 < K <= size:
        f = float(size)
        for si in iter("KMGPTE"):
            f /= K
            if f < K:
                return " or %.1f %s%sB" % (f, si, i)
    return _NN


def _SI2(size, **kwds):
    
    return str(size) + _SI(size, **kwds)





def _cell_refs(obj, named):
    try:  
        o = obj.cell_contents
        if named:
            o = _NamedRef("cell_contents", o)
        yield o
    except (AttributeError, ValueError):
        pass


def _class_refs(obj, named):
    
    return _refs(
        obj,
        named,
        "__class__",
        "__doc__",
        "__mro__",
        "__name__",
        "__slots__",
        "__weakref__",
        "__dict__",
    )  


def _co_refs(obj, named):
    
    return _refs(obj, named, pref="co_")


def _dict_refs(obj, named):
    
    try:
        if named:
            for k, v in _items(obj):
                s = str(k)
                yield _NamedRef("[K] " + s, k)
                s += ": " + _repr(v)
                yield _NamedRef("[V] " + s, v)
        else:
            for k, v in _items(obj):
                yield k
                yield v
    except (KeyError, ReferenceError, TypeError) as x:
        warnings.warn("Iterating '%s': %r" % (_classof(obj), x))


def _enum_refs(obj, named):
    
    return _refs(obj, named, "__doc__")


def _exc_refs(obj, named):
    
    
    return _refs(
        obj, named, "args", "filename", "lineno", "msg", "text"
    )  


def _file_refs(obj, named):
    
    return _refs(obj, named, "mode", "name")


def _frame_refs(obj, named):
    
    return _refs(obj, named, pref="f_")


def _func_refs(obj, named):
    
    return _refs(
        obj,
        named,
        "__doc__",
        "__name__",
        "__code__",
        "__closure__",
        pref="func_",
        excl=("func_globals",),
    )


def _gen_refs(obj, named):
    
    
    
    f = getattr(obj, "gi_frame", None)
    return _refs(f, named, "f_locals", "f_code")


def _im_refs(obj, named):
    
    return _refs(obj, named, "__doc__", "__name__", "__code__", pref="im_")


def _inst_refs(obj, named):
    
    return _refs(obj, named, "__dict__", "__class__", slots="__slots__")


def _iter_refs(obj, named):
    
    r = _getreferents(obj)  
    return _refs(r, named, itor=_nameof(obj) or "iteref")


def _module_refs(obj, named):
    
    n = _nameof(obj) == __name__  
    
    return () if n else _dict_refs(obj.__dict__, named)


def _namedtuple_refs(obj, named):
    
    for r in _refs(obj, named, "__class__", slots="__slots__"):
        yield r
    for r in obj:
        yield r


def _prop_refs(obj, named):
    
    return _refs(obj, named, "__doc__", pref="f")


def _seq_refs(obj, unused):  
    
    return obj  


def _stat_refs(obj, named):
    
    return _refs(obj, named, pref="st_")


def _statvfs_refs(obj, named):
    
    return _refs(obj, named, pref="f_")


def _tb_refs(obj, named):
    
    return _refs(obj, named, pref="tb_")


def _type_refs(obj, named):
    
    return _refs(
        obj,
        named,
        "__doc__",
        "__mro__",
        "__name__",
        "__slots__",
        "__weakref__",
        "__dict__",
    )


def _weak_refs(obj, unused):  
    
    try:  
        return (obj(),)
    except Exception:  
        return ()


_all_refs = {
    None,
    _cell_refs,
    _class_refs,
    _co_refs,
    _dict_refs,
    _enum_refs,
    _exc_refs,
    _file_refs,
    _frame_refs,
    _func_refs,
    _gen_refs,
    _im_refs,
    _inst_refs,
    _iter_refs,
    _module_refs,
    _namedtuple_refs,
    _prop_refs,
    _seq_refs,
    _stat_refs,
    _statvfs_refs,
    _tb_refs,
    _type_refs,
    _weak_refs,
}  





def _len(obj):
    
    try:
        return len(obj)
    except TypeError:  
        return 0


def _len_bytearray(obj):
    
    return obj.__alloc__()


def _len_code(obj):  
    
    return (
        _len(obj.co_freevars)
        + obj.co_stacksize
        + _len(obj.co_cellvars)
        + obj.co_nlocals
        - 1
    )


def _len_dict(obj):
    
    n = len(obj)  
    if n < 6:  
        n = 0  
    else:  
        n = _power_of_2(n + 1)
    return n


def _len_frame(obj):
    
    c = getattr(obj, "f_code", None)
    return _len_code(c) if c else 0








def _len_int(obj):
    
    n = _getsizeof(obj, 0) - int.__basicsize__
    return (n // int.__itemsize__) if n > 0 else 0


def _len_iter(obj):
    
    n = getattr(obj, "__length_hint__", None)
    return n() if n and callable(n) else _len(obj)


def _len_list(obj):
    
    n = len(obj)
    
    if n > 8:
        n += 6 + (n >> 3)
    elif n:
        n += 4
    return n


def _len_module(obj):
    
    return _len(obj.__dict__)  


def _len_set(obj):
    
    n = len(obj)
    if n > 8:  
        n = _power_of_2(n + n - 2)
    elif n:  
        n = 8
    return n


def _len_slice(obj):
    
    try:
        return (obj.stop - obj.start + 1) // obj.step
    except (AttributeError, TypeError):
        return 0









def _len_struct(obj):
    
    try:
        return obj.size
    except AttributeError:
        return 0


def _len_unicode(obj):
    
    return len(obj) + 1


_all_lens = {
    None,
    _len,
    _len_bytearray,
    _len_code,
    _len_dict,
    _len_frame,
    _len_int,
    _len_iter,
    _len_list,
    _len_module,
    _len_set,
    _len_slice,
    _len_struct,
    _len_unicode,
}  








class _Claskey(object):
    

    __slots__ = ("_obj",)  

    def __init__(self, obj):
        self._obj = obj  

    

    def __str__(self):
        r = str(self._obj)
        return (r[:-1] + " def>") if r.endswith(">") else (r + " def")

    __repr__ = __str__










_claskeys = {}  
_NoneNone = None, None  


def _claskey(obj):
    
    i = id(obj)
    try:
        k = _claskeys[i]
    except KeyError:
        _claskeys[i] = k = _Claskey(obj)
    return k


def _key2tuple(obj):  
    
    t = type(obj) is _Type_type  
    return (_claskey(obj), obj) if t else _NoneNone


def _objkey(obj):  
    
    k = type(obj)
    if k is _Type_type:  
        k = _claskey(obj)
    return k


class _NamedRef(object):
    

    __slots__ = ("name", "ref")

    def __init__(self, name, ref):
        self.name = name
        self.ref = ref














i = sys.intern  
t = (_kind_static, _kind_dynamic, _kind_derived, _kind_ignored, _kind_inferred) = (
    i("static"),
    i("dynamic"),
    i("derived"),
    i("ignored"),
    i("inferred"),
)
_all_kinds = set(t)
del i, t


class _Typedef(object):
    

    base = 0  
    both = None  
    item = 0  
    kind = None  
    leng = None  
    refs = None  
    type = None  
    vari = None  
    xtyp = None  

    def __init__(self, **kwds):
        self.reset(**kwds)

    def __lt__(self, unused):  
        return True

    def __repr__(self):
        return repr(self.args())

    def __str__(self):
        t = [str(self.base), str(self.item)]
        for f in (self.leng, self.refs):
            t.append(_nameof(f) or "n/a")
        if not self.both:
            t.append("(code only)")
        return ", ".join(t)

    def args(self):  
        
        return (
            self.base,
            self.item,
            self.leng,
            self.refs,
            self.both,
            self.kind,
            self.type,
            self.xtyp,
        )

    def dup(self, other=None, **kwds):
        
        t = other or _dict_typedef
        d = t.kwds()
        d.update(kwds)
        self.reset(**d)

    def flat(self, obj, mask=0):
        
        s = self.base
        if self.leng and self.item > 0:  
            s += self.leng(obj) * self.item
        
        
        
        if not self.xtyp:
            s = _getsizeof(obj, s)
        if mask:  
            s = (s + mask) & ~mask
        
        
        return s

    def format(self):
        
        a = _nameof(self.leng)
        return dict(
            leng=((" (%s)" % (a,)) if a else _NN),
            item="var" if self.vari else self.item,
            code=_NN if self.both else " (code only)",
            base=self.base,
            kind=self.kind,
        )

    def kwds(self):
        
        return dict(
            base=self.base,
            both=self.both,
            item=self.item,
            kind=self.kind,
            leng=self.leng,
            refs=self.refs,
            type=self.type,
            vari=self.vari,
            xtyp=self.xtyp,
        )

    def reset(
        self,
        base=0,
        item=0,
        leng=None,
        refs=None,
        both=True,
        kind=None,
        type=None,
        vari=_Not_vari,
        xtyp=False,
        **extra,
    ):
        
        v = vari or _Not_vari
        if v != str(v):  
            e = dict(vari=v)
        elif base < 0:
            e = dict(base=base)
        elif both not in (False, True):
            e = dict(both=both)
        elif item < 0:
            e = dict(item=item)
        elif kind not in _all_kinds:
            e = dict(kind=kind)
        elif leng not in _all_lens:  
            e = dict(leng=leng)
        elif refs not in _all_refs:  
            e = dict(refs=refs)
        elif xtyp not in (False, True):
            e = dict(xtyp=xtyp)
        elif extra:
            e = {}
        else:
            self.base = base
            self.both = both
            self.item = item
            self.kind = kind
            self.leng = leng
            self.refs = refs
            self.type = type  
            self.vari = v
            self.xtyp = xtyp
            return
        e.update(extra)
        raise _OptionError(self.reset, **e)

    def save(self, t, base=0, heap=False):
        
        c, k = _key2tuple(t)
        if k and k not in _typedefs:  
            _typedefs[k] = self
            if c and c not in _typedefs:  
                b = _basicsize(type(t), base=base, heap=heap)
                k = _kind_ignored if _isignored(t) else self.kind
                _typedefs[c] = _Typedef(
                    base=b, both=False, kind=k, type=t, refs=_type_refs
                )
        elif t not in _typedefs:
            if not _isbuiltin2(t):  
                s = " ".join((self.vari, _moduleof(t), _nameof(t)))
                s = "%r %s %s" % ((c, k), self.both, s.strip())
                raise KeyError("typedef %r bad: %s" % (self, s))

            _typedefs[t] = _Typedef(
                base=_basicsize(t, base=base), both=False, kind=_kind_ignored, type=t
            )

    def set(self, safe_len=False, **kwds):
        
        if kwds:  
            d = self.kwds()
            d.update(kwds)
            self.reset(**d)
        if safe_len and self.item:
            self.leng = _len


_typedefs = {}  


def _typedef_both(
    t,
    base=0,
    item=0,
    leng=None,
    refs=None,
    kind=_kind_static,
    heap=False,
    vari=_Not_vari,
):
    
    v = _Typedef(
        base=_basicsize(t, base=base),
        item=_itemsize(t, item),
        refs=refs,
        leng=leng,
        both=True,
        kind=kind,
        type=t,
        vari=vari,
    )
    v.save(t, base=base, heap=heap)
    return v  


def _typedef_code(t, base=0, refs=None, kind=_kind_static, heap=False):
    
    v = _Typedef(
        base=_basicsize(t, base=base), refs=refs, both=False, kind=kind, type=t
    )
    v.save(t, base=base, heap=heap)
    return v  



_typedef_both(complex)
_typedef_both(float)
_typedef_both(int, leng=_len_int)  
_typedef_both(
    list, refs=_seq_refs, leng=_len_list, item=_sizeof_Cvoidp
)  
_typedef_both(
    tuple, refs=_seq_refs, leng=_len, item=_sizeof_Cvoidp
)  
_typedef_both(property, refs=_prop_refs)
_typedef_both(type(Ellipsis))
_typedef_both(type(None))








_dict_typedef = _typedef_both(
    dict, item=_sizeof_CPyDictEntry, leng=_len_dict, refs=_dict_refs
)

_typedef_both(
    type(_Typedef.__dict__), item=_sizeof_CPyDictEntry, leng=_len_dict, refs=_dict_refs
)



_dict_types = dict(
    UserDict=("IterableUserDict", "UserDict"),
    weakref=("WeakKeyDictionary", "WeakValueDictionary"),
)
try:  
    _typedef_both(
        Types.ModuleType,
        base=_dict_typedef.base,
        item=_dict_typedef.item + _sizeof_CPyModuleObject,
        leng=_len_module,
        refs=_module_refs,
    )
except AttributeError:  
    pass



from array import array as _array  


def _len_array(obj):
    
    return len(obj) * obj.itemsize


def _array_kwds(obj):
    
    
    
    b = max(56, _getsizeof(obj, 0) - _len_array(obj))
    return dict(
        base=b,
        leng=_len_array,
        item=_sizeof_Cbyte,
        vari="itemsize",  
        xtyp=True,
    )  


_all_lens.add(_len_array)  

try:  
    _typedef_both(bool)
except NameError:  
    pass

try:
    _typedef_both(bytearray, item=_sizeof_Cbyte, leng=_len_bytearray)
except NameError:  
    pass
try:
    if type(bytes) is not type(str):  
        _typedef_both(bytes, item=_sizeof_Cbyte, leng=_len)  
except NameError:  
    pass





try:
    _typedef_both(enumerate, refs=_enum_refs)
except NameError:  
    pass

try:  
    _typedef_both(Exception, refs=_exc_refs)
except Exception:  
    pass

try:
    _typedef_both(frozenset, item=_sizeof_Csetentry, leng=_len_set, refs=_seq_refs)
except NameError:  
    pass
try:
    _typedef_both(set, item=_sizeof_Csetentry, leng=_len_set, refs=_seq_refs)
except NameError:  
    pass

try:  
    _typedef_both(Types.GetSetDescriptorType)
except AttributeError:  
    pass

try:  
    _typedef_both(Types.MemberDescriptorType)
except AttributeError:  
    pass

try:
    _typedef_both(type(NotImplemented))  
except NameError:  
    pass

try:  
    import numpy as _numpy  

    try:
        _numpy_memmap = _numpy.memmap
    except AttributeError:
        _numpy_memmap = None
    try:
        from mmap import PAGESIZE as _PAGESIZE

        if _PAGESIZE < 1024:
            raise ImportError
    except ImportError:
        _PAGESIZE = 4096  

    def _isnumpy(obj):
        
        
        if (
            hasattr(obj, "dtype")
            and hasattr(obj, "itemsize")
            and hasattr(obj, "nbytes")
        ):
            try:
                return _moduleof(_classof(obj)).startswith("numpy") or _moduleof(
                    type(obj)
                ).startswith("numpy")
            except (AttributeError, OSError, ValueError):  
                pass
        return False

    def _len_numpy(obj):
        
        return obj.nbytes  

    def _len_numpy_memmap(obj):
        
        nb = int(obj.nbytes * _amapped)
        
        return ((nb + _PAGESIZE - 1) // _PAGESIZE) * _PAGESIZE

    def _numpy_kwds(obj):
        t = type(obj)
        
        
        
        
        if t is _numpy_memmap:  
            b, _len_, nb = 144, _len_numpy_memmap, 0
        else:  
            b, _len_, nb = 96, _len_numpy, obj.nbytes
        
        
        
        
        return dict(
            base=_getsizeof(obj, b) - nb,
            item=_sizeof_Cbyte,  
            leng=_len_,
            refs=_numpy_refs,
            vari="itemsize",  
            xtyp=True,
        )  

    def _numpy_refs(obj, named):
        
        return _refs(obj, named, "base")

    _all_lens.add(_len_numpy)  
    _all_lens.add(_len_numpy_memmap)  
    _all_refs.add(_numpy_refs)  

except ImportError:  
    _numpy = _numpy_kwds = None  

    def _isnumpy(unused):  
        
        return False


try:
    _typedef_both(range)
except NameError:  
    pass

try:
    _typedef_both(reversed, refs=_enum_refs)
except NameError:  
    pass

try:
    _typedef_both(
        slice, item=_sizeof_Cvoidp, leng=_len_slice
    )  
except NameError:  
    pass

try:
    from os import stat

    _typedef_both(type(stat(curdir)), refs=_stat_refs)  
except ImportError:  
    pass

try:
    from os import statvfs

    _typedef_both(
        type(statvfs(curdir)),
        refs=_statvfs_refs,  
        item=_sizeof_Cvoidp,
        leng=_len,
    )
except ImportError:  
    pass

try:
    from struct import Struct  

    _typedef_both(Struct, item=_sizeof_Cbyte, leng=_len_struct)  
except ImportError:  
    pass

try:
    _typedef_both(Types.TracebackType, refs=_tb_refs)
except AttributeError:  
    pass

_typedef_both(str, leng=_len_unicode, item=_sizeof_Cunicode)

try:  
    _typedef_both(Weakref.KeyedRef, refs=_weak_refs, heap=True)  
except AttributeError:  
    pass

try:  
    _typedef_both(Weakref.ProxyType)
except AttributeError:  
    pass

try:  
    _typedef_both(Weakref.ReferenceType, refs=_weak_refs)
except AttributeError:  
    pass


_typedef_code(object, kind=_kind_ignored)
_typedef_code(super, kind=_kind_ignored)
_typedef_code(_Type_type, kind=_kind_ignored)

try:
    _typedef_code(classmethod, refs=_im_refs)
except NameError:
    pass
try:
    _typedef_code(staticmethod, refs=_im_refs)
except NameError:
    pass
try:
    _typedef_code(Types.MethodType, refs=_im_refs)
except NameError:
    pass

try:  
    _typedef_both(Types.GeneratorType, refs=_gen_refs)
except AttributeError:  
    pass

try:  
    _typedef_code(Weakref.CallableProxyType, refs=_weak_refs)
except AttributeError:  
    pass


s = [_items({}), _keys({}), _values({})]
try:  
    s.extend([reversed([]), reversed(())])
except NameError:  
    pass

try:  
    from re import finditer

    s.append(finditer(_NN, _NN))
    del finditer
except ImportError:  
    pass

for t in _values(_typedefs):
    if t.type and t.leng:
        try:  
            s.append(t.type())
        except TypeError:
            pass
for t in s:
    try:
        i = iter(t)
        _typedef_both(type(i), leng=_len_iter, refs=_iter_refs, item=0)  
    except (KeyError, TypeError):  
        pass
del i, s, t


def _typedef(obj, derive=False, frames=False, infer=False):  
    
    t = type(obj)
    v = _Typedef(base=_basicsize(t, obj=obj), kind=_kind_dynamic, type=t)
    
    if ismodule(obj):  
        v.dup(
            item=_dict_typedef.item + _sizeof_CPyModuleObject,
            leng=_len_module,
            refs=_module_refs,
        )
    elif _isframe(obj):
        v.set(
            base=_basicsize(t, base=_sizeof_CPyFrameObject, obj=obj),
            item=_itemsize(t),
            leng=_len_frame,
            refs=_frame_refs,
        )
        if not frames:  
            v.set(kind=_kind_ignored)
    elif iscode(obj):
        v.set(
            base=_basicsize(t, base=_sizeof_CPyCodeObject, obj=obj),
            item=_sizeof_Cvoidp,
            leng=_len_code,
            refs=_co_refs,
            both=False,
        )  
    elif callable(obj):
        if isclass(obj):  
            v.set(refs=_class_refs, both=False)  
            if _isignored(obj):
                v.set(kind=_kind_ignored)
        elif isbuiltin(obj):  
            v.set(both=False, kind=_kind_ignored)  
        elif isfunction(obj):
            v.set(refs=_func_refs, both=False)  
        elif ismethod(obj):
            v.set(refs=_im_refs, both=False)  
        elif isclass(t):  
            
            v.set(item=_itemsize(t), safe_len=True, refs=_inst_refs)  
        else:
            v.set(both=False)  
    elif _issubclass(t, dict):
        v.dup(kind=_kind_derived)
    elif _isdictype(obj) or (infer and _infer_dict(obj)):
        v.dup(kind=_kind_inferred)
    elif _iscell(obj):
        v.set(item=_itemsize(t), refs=_cell_refs)
    elif _isnamedtuple(obj):
        v.set(refs=_namedtuple_refs)
    elif _numpy and _isnumpy(obj):
        v.set(**_numpy_kwds(obj))
    elif isinstance(obj, _array):
        v.set(**_array_kwds(obj))
    elif _isignored(obj):
        v.set(kind=_kind_ignored)
    else:  
        if derive:
            p = _derive_typedef(t)
            if p:  
                v.dup(other=p, kind=_kind_derived)
                return v
        if _issubclass(t, Exception):
            v.set(item=_itemsize(t), safe_len=True, refs=_exc_refs, kind=_kind_derived)
        elif isinstance(obj, Exception):
            v.set(item=_itemsize(t), safe_len=True, refs=_exc_refs)
        else:
            v.set(item=_itemsize(t), safe_len=True, refs=_inst_refs)
    return v


class _Prof(object):
    

    high = 0  
    number = 0  
    objref = None  
    total = 0  
    weak = False  

    def __cmp__(self, other):
        if self.total < other.total:
            return -1
        elif self.total > other.total:
            return +1
        elif self.number < other.number:
            return -1
        elif self.number > other.number:
            return +1
        return 0

    def __lt__(self, other):  
        return self.__cmp__(other) < 0

    def format(self, clip=0, grand=None):
        
        if self.number > 1:  
            a, p = int(self.total / self.number), "s"
        else:
            a, p = self.total, _NN
        o = self.objref
        if self.weak:
            o = o()
        t = _SI2(self.total)
        if grand:
            t += " (%s)" % _p100(self.total, grand, prec=0)
        return dict(
            avg=_SI2(a),
            high=_SI2(self.high),
            lengstr=_lengstr(o),
            obj=_repr(o, clip=clip),
            plural=p,
            total=t,
        )

    def update(self, obj, size):
        
        self.number += 1
        self.total += size
        if self.high < size:  
            self.high = size
            try:  
                self.objref, self.weak = Weakref.ref(obj), True
            except TypeError:
                self.objref, self.weak = obj, False


class _Rank(object):
    

    deep = 0  
    id = 0  
    key = None  
    objref = None  
    pid = 0  
    size = 0  
    weak = False  

    def __init__(self, key, obj, size, deep, pid):
        self.deep = deep
        self.id = id(obj)
        self.key = key
        try:  
            self.objref, self.weak = Weakref.ref(obj), True
        except TypeError:
            self.objref, self.weak = obj, False
        self.pid = pid
        self.size = size

    def format(self, clip=0, id2x={}):
        

        def _ix(_id):  
            return id2x.get(_id, "?")

        o = self.objref() if self.weak else self.objref
        d = (" (at %s)" % (self.deep,)) if self.deep > 0 else _NN
        p = (", pix %s" % (_ix(self.pid),)) if self.pid else _NN
        return "%s: %s%s, ix %s%s%s" % (
            _prepr(self.key, clip=clip),
            _repr(o, clip=clip),
            _lengstr(o),
            _ix(self.id),
            d,
            p,
        )


class _Seen(dict):
    

    def again(self, key):
        try:
            s = self[key] + 1
        except KeyError:
            s = 1
        if s > 0:
            self[key] = s





class Asized(object):
    

    __slots__ = ("flat", "name", "refs", "size")

    def __init__(self, size, flat, refs=(), name=None):
        self.size = size  
        self.flat = flat  
        self.name = name  
        self.refs = tuple(refs)

    def __str__(self):
        return "size %r, flat %r, refs[%d], name %r" % (
            self.size,
            self.flat,
            len(self.refs),
            self.name,
        )

    def format(
        self,
        format="%(name)s size=%(size)d flat=%(flat)d",
        depth=-1,
        order_by="size",
        indent=_NN,
    ):
        
        t = indent + (format % dict(size=self.size, flat=self.flat, name=self.name))
        if depth and self.refs:
            rs = sorted(
                self.refs,
                key=lambda x: getattr(x, order_by),
                reverse=order_by in ("size", "flat"),
            )
            rs = [
                r.format(
                    format=format,
                    depth=depth - 1,
                    order_by=order_by,
                    indent=indent + "    ",
                )
                for r in rs
            ]
            t = "\n".join([t] + rs)
        return t

    def get(self, name, dflt=None):
        
        for ref in self.refs:
            if name == ref.name:
                return ref
        return dflt


class Asizer(object):
    

    _above_ = 1024  
    _align_ = 8  
    _clip_ = 80
    _code_ = False
    _cutoff_ = 0  
    _derive_ = False
    _detail_ = 0  
    _frames_ = False
    _infer_ = False
    _limit_ = 100
    _stats_ = 0

    _depth = 0  
    _excl_d = None  
    _ign_d = _kind_ignored
    _incl = _NN  
    _mask = 7  
    _missed = 0  
    _profile = False  
    _profs = None  
    _ranked = 0
    _ranks = []  
    _seen = None  
    _stream = None  
    _total = 0  

    def __init__(self, **opts):
        
        self._excl_d = {}
        self.reset(**opts)

    def _c100(self, stats):
        
        s = int(stats)
        c = int((stats - s) * 100.0 + 0.5) or self.cutoff
        return s, c

    def _clear(self):
        
        self._depth = 0  
        self._incl = _NN  
        self._missed = 0  
        self._profile = False
        self._profs = {}
        self._ranked = 0
        self._ranks = []
        self._seen = _Seen()
        self._total = 0  
        for k in _keys(self._excl_d):
            self._excl_d[k] = 0
        
        m = sys.modules[__name__]
        self.exclude_objs(
            self,
            self._excl_d,
            self._profs,
            self._ranks,
            self._seen,
            m,
            m.__dict__,
            m.__doc__,
            _typedefs,
        )

    def _nameof(self, obj):
        
        return _nameof(obj, _NN) or self._repr(obj)

    def _prepr(self, obj):
        
        return _prepr(obj, clip=self._clip_)

    def _printf(self, fmt, *args, **print3options):
        
        if self._stream and not print3options.get("file", None):
            if args:
                fmt = fmt % args
            _printf(fmt, file=self._stream, **print3options)
        else:
            _printf(fmt, *args, **print3options)

    def _prof(self, key):
        
        p = self._profs.get(key, None)
        if not p:
            self._profs[key] = p = _Prof()
            self.exclude_objs(p)  
        return p

    def _rank(self, key, obj, size, deep, pid):
        
        rs = self._ranks
        
        i, j = 0, len(rs)
        while i < j:
            m = (i + j) // 2
            if size < rs[m].size:
                i = m + 1
            else:
                j = m
        if i < 100:
            r = _Rank(key, obj, size, deep, pid)
            rs.insert(i, r)
            self.exclude_objs(r)  
            while len(rs) > 100:
                rs.pop()
            
        self._ranked += 1

    def _repr(self, obj):
        
        return _repr(obj, clip=self._clip_)

    def _sizer(self, obj, pid, deep, sized):  
        
        s, f, i = 0, 0, id(obj)
        if i not in self._seen:
            self._seen[i] = 1
        elif deep or self._seen[i]:
            
            
            self._seen.again(i)
            if sized:
                s = sized(s, f, name=self._nameof(obj))
                self.exclude_objs(s)
            return s  
        else:  
            self._seen.again(i)
        try:
            k, rs = _objkey(obj), []
            if k in self._excl_d:
                self._excl_d[k] += 1
            else:
                v = _typedefs.get(k, None)
                if not v:  
                    _typedefs[k] = v = _typedef(
                        obj,
                        derive=self._derive_,
                        frames=self._frames_,
                        infer=self._infer_,
                    )
                if (v.both or self._code_) and v.kind is not self._ign_d:
                    s = f = v.flat(obj, self._mask)  
                    if self._profile:
                        
                        self._prof(k).update(obj, s)
                    
                    if v.refs and deep < self._limit_ and not (deep and ismodule(obj)):
                        
                        z, d = self._sizer, deep + 1
                        if sized and deep < self._detail_:
                            
                            self.exclude_objs(rs)
                            for o in v.refs(obj, True):
                                if isinstance(o, _NamedRef):
                                    r = z(o.ref, i, d, sized)
                                    r.name = o.name
                                else:
                                    r = z(o, i, d, sized)
                                    r.name = self._nameof(o)
                                rs.append(r)
                                s += r.size
                        else:  
                            for o in v.refs(obj, False):
                                s += z(o, i, d, None)
                        
                        if self._depth < d:
                            self._depth = d
                if self._stats_ and s > self._above_ > 0:
                    
                    self._rank(k, obj, s, deep, pid)
        except RuntimeError:  
            self._missed += 1
        if not deep:
            self._total += s  
        if sized:
            s = sized(s, f, name=self._nameof(obj), refs=rs)
            self.exclude_objs(s)
        return s

    def _sizes(self, objs, sized=None):
        
        self.exclude_refs(*objs)  
        s, t = {}, []
        self.exclude_objs(s, t)
        for o in objs:
            i = id(o)
            if i in s:  
                self._seen.again(i)
            else:
                s[i] = self._sizer(o, 0, 0, sized)
            t.append(s[i])
        return tuple(t)

    @property
    def above(self):
        
        return self._above_

    @property
    def align(self):
        
        return self._align_

    def asized(self, *objs, **opts):
        
        if opts:
            self.set(**opts)
        t = self._sizes(objs, Asized)
        return t[0] if len(t) == 1 else t

    def asizeof(self, *objs, **opts):
        
        if opts:
            self.set(**opts)
        self.exclude_refs(*objs)  
        return sum(self._sizer(o, 0, 0, None) for o in objs)

    def asizesof(self, *objs, **opts):
        
        if opts:
            self.set(**opts)
        return self._sizes(objs, None)

    @property
    def clip(self):
        
        return self._clip_

    @property
    def code(self):
        
        return self._code_

    @property
    def cutoff(self):
        
        return self._cutoff_

    @property
    def derive(self):
        
        return self._derive_

    @property
    def detail(self):
        
        return self._detail_

    @property
    def duplicate(self):
        
        return sum(1 for v in _values(self._seen) if v > 1)  

    def exclude_objs(self, *objs):
        
        for o in objs:
            self._seen.setdefault(id(o), -1)

    def exclude_refs(self, *objs):
        
        for o in objs:
            self._seen.setdefault(id(o), 0)

    def exclude_types(self, *objs):
        
        for o in objs:
            for t in _key2tuple(o):
                if t and t not in self._excl_d:
                    self._excl_d[t] = 0

    @property
    def excluded(self):
        
        return tuple(_keys(self._excl_d))

    @property
    def frames(self):
        
        return self._frames_

    @property
    def ignored(self):
        
        return True if self._ign_d else False

    @property
    def infer(self):
        
        return self._infer_

    @property
    def limit(self):
        
        return self._limit_

    @property
    def missed(self):
        
        return self._missed

    def print_largest(self, w=0, cutoff=0, **print3options):
        
        c = int(cutoff) if cutoff else self._cutoff_
        n = min(len(self._ranks), max(c, 0))
        s = self._above_
        if n > 0 and s > 0:
            self._printf(
                "%s%*d largest object%s (of %d over %d bytes%s)",
                linesep,
                w,
                n,
                _plural(n),
                self._ranked,
                s,
                _SI(s),
                **print3options,
            )
            id2x = dict((r.id, i) for i, r in enumerate(self._ranks))
            for r in self._ranks[:n]:
                s, t = r.size, r.format(self._clip_, id2x)
                self._printf("%*d bytes%s: %s", w, s, _SI(s), t, **print3options)

    def print_profiles(self, w=0, cutoff=0, **print3options):
        
        
        t = [(v, k) for k, v in _items(self._profs) if v.total > 0 or v.number > 1]
        if (len(self._profs) - len(t)) < 9:  
            t = [(v, k) for k, v in _items(self._profs)]
        if t:
            s = _NN
            if self._total:
                s = " (% of grand total)"
                c = int(cutoff) if cutoff else self._cutoff_
                C = int(c * 0.01 * self._total)
            else:
                C = c = 0
            self._printf(
                "%s%*d profile%s:  total%s, average, and largest flat size%s:  largest object",
                linesep,
                w,
                len(t),
                _plural(len(t)),
                s,
                self._incl,
                **print3options,
            )
            r = len(t)
            t = [
                (v, self._prepr(k)) for v, k in t
            ]  
            for v, k in sorted(t, reverse=True):
                s = (
                    "object%(plural)s:  %(total)s, %(avg)s, %(high)s:  %(obj)s%(lengstr)s"
                    % v.format(self._clip_, self._total)
                )
                self._printf("%*d %s %s", w, v.number, k, s, **print3options)
                r -= 1
                if r > 1 and v.total < C:
                    self._printf("%+*d profiles below cutoff (%.0f%%)", w, r, c)
                    break
            z = len(self._profs) - len(t)
            if z > 0:
                self._printf(
                    "%+*d %r object%s", w, z, "zero", _plural(z), **print3options
                )

    def print_stats(
        self, objs=(), opts={}, sized=(), sizes=(), stats=3, **print3options
    ):
        
        s = min(opts.get("stats", stats) or 0, self.stats)
        if s > 0:  
            w = len(str(self.missed + self.seen + self.total)) + 1
            t = c = _NN
            o = _kwdstr(**opts)
            if o and objs:
                c = ", "
            
            if sized and objs:
                n = len(objs)
                if n > 1:
                    self._printf(
                        "%sasized(...%s%s) ...", linesep, c, o, **print3options
                    )
                    for i in range(n):  
                        self._printf("%*d: %s", w - 1, i, sized[i], **print3options)
                else:
                    self._printf("%sasized(%s): %s", linesep, o, sized, **print3options)
            elif sizes and objs:
                self._printf("%sasizesof(...%s%s) ...", linesep, c, o, **print3options)
                for z, o in zip(sizes, objs):
                    self._printf(
                        "%*d bytes%s%s:  %s",
                        w,
                        z,
                        _SI(z),
                        self._incl,
                        self._repr(o),
                        **print3options,
                    )
            else:
                if objs:
                    t = self._repr(objs)
                self._printf("%sasizeof(%s%s%s) ...", linesep, t, c, o, **print3options)
            
            self.print_summary(w=w, objs=objs, **print3options)
            
            s, c = self._c100(s)
            self.print_largest(w=w, cutoff=c if s < 2 else 10, **print3options)
            if s > 1:  
                self.print_profiles(w=w, cutoff=c, **print3options)
                if s > 2:  
                    self.print_typedefs(w=w, **print3options)  

    def print_summary(self, w=0, objs=(), **print3options):
        
        self._printf(
            "%*d bytes%s%s",
            w,
            self._total,
            _SI(self._total),
            self._incl,
            **print3options,
        )
        if self._mask:
            self._printf("%*d byte aligned", w, self._mask + 1, **print3options)
        self._printf("%*d byte sizeof(void*)", w, _sizeof_Cvoidp, **print3options)
        n = len(objs or ())
        self._printf("%*d object%s %s", w, n, _plural(n), "given", **print3options)
        n = self.sized
        self._printf("%*d object%s %s", w, n, _plural(n), "sized", **print3options)
        if self._excl_d:
            n = sum(_values(self._excl_d))
            self._printf(
                "%*d object%s %s", w, n, _plural(n), "excluded", **print3options
            )
        n = self.seen
        self._printf("%*d object%s %s", w, n, _plural(n), "seen", **print3options)
        n = self.ranked
        if n > 0:
            self._printf("%*d object%s %s", w, n, _plural(n), "ranked", **print3options)
        n = self.missed
        self._printf("%*d object%s %s", w, n, _plural(n), "missed", **print3options)
        n = self.duplicate
        self._printf("%*d duplicate%s", w, n, _plural(n), **print3options)
        if self._depth > 0:
            self._printf("%*d deepest recursion", w, self._depth, **print3options)

    def print_typedefs(self, w=0, **print3options):
        
        for k in _all_kinds:
            
            t = [
                (self._prepr(a), v)
                for a, v in _items(_typedefs)
                if v.kind == k and (v.both or self._code_)
            ]
            if t:
                self._printf(
                    "%s%*d %s type%s:  basicsize, itemsize, _len_(), _refs()",
                    linesep,
                    w,
                    len(t),
                    k,
                    _plural(len(t)),
                    **print3options,
                )
                for a, v in sorted(t):
                    self._printf("%*s %s:  %s", w, _NN, a, v, **print3options)
        
        t = sum(len(v) for v in _values(_dict_types))
        if t:
            self._printf("%s%*d dict/-like classes:", linesep, w, t, **print3options)
            for m, v in _items(_dict_types):
                self._printf("%*s %s:  %s", w, _NN, m, self._prepr(v), **print3options)

    @property
    def ranked(self):
        
        return self._ranked

    def reset(
        self,
        above=1024,
        align=8,
        clip=80,
        code=False,  
        cutoff=10,
        derive=False,
        detail=0,
        frames=False,
        ignored=True,
        infer=False,
        limit=100,
        stats=0,
        stream=None,
        **extra,
    ):
        
        if extra:
            raise _OptionError(self.reset, Error=KeyError, **extra)
        
        self._above_ = above
        self._align_ = align
        self._clip_ = clip
        self._code_ = code
        self._cutoff_ = cutoff
        self._derive_ = derive
        self._detail_ = detail  
        self._frames_ = frames
        self._infer_ = infer
        self._limit_ = limit
        self._stats_ = stats
        self._stream = stream
        if ignored:
            self._ign_d = _kind_ignored
        else:
            self._ign_d = None
        
        self._clear()
        self.set(align=align, code=code, cutoff=cutoff, stats=stats)

    @property
    def seen(self):
        
        return sum(v for v in _values(self._seen) if v > 0)

    def set(
        self,
        above=None,
        align=None,
        code=None,
        cutoff=None,
        frames=None,
        detail=None,
        limit=None,
        stats=None,
    ):
        
        
        if above is not None:
            self._above_ = int(above)
        if align is not None:
            if align > 1:
                m = align - 1
                if m & align:
                    raise _OptionError(self.set, align=align)
            else:
                m = 0
            self._align_ = align
            self._mask = m
        if code is not None:
            self._code_ = code
            if code:  
                self._incl = " (incl. code)"
        if detail is not None:
            self._detail_ = detail
        if frames is not None:
            self._frames_ = frames
        if limit is not None:
            self._limit_ = limit
        if stats is not None:
            if stats < 0:
                raise _OptionError(self.set, stats=stats)
            
            s, c = self._c100(stats)
            self._cutoff_ = int(cutoff) if cutoff else c
            self._stats_ = s
            self._profile = s > 1  

    @property
    def sized(self):
        
        return sum(1 for v in _values(self._seen) if v > 0)

    @property
    def stats(self):
        
        return self._stats_  

    @property
    def total(self):
        
        return self._total


def amapped(percentage=None):
    
    global _amapped
    p = _amapped * 100.0
    if percentage is not None:
        _amapped = max(0, min(1, percentage * 0.01))
    return p


_amapped = 0.01  
_asizer = Asizer()


def asized(*objs, **opts):
    
    _asizer.reset(**opts)
    if objs:
        t = _asizer.asized(*objs)
        _asizer.print_stats(objs, opts=opts, sized=t)  
        _asizer._clear()
    else:
        t = ()
    return t


def asizeof(*objs: Any, **opts: Any) -> int:
    
    t, p, x = _objs_opts_x(asizeof, objs, **opts)
    _asizer.reset(**p)
    if t:
        if x:  
            _asizer.exclude_objs(t)
        s = _asizer.asizeof(*t)
        _asizer.print_stats(objs=t, opts=opts)  
        _asizer._clear()
    else:
        s = 0
    return s


def asizesof(*objs, **opts):
    
    _asizer.reset(**opts)
    if objs:
        t = _asizer.asizesof(*objs)
        _asizer.print_stats(objs, opts=opts, sizes=t)  
        _asizer._clear()
    else:
        t = ()
    return t


def _typedefof(obj, save=False, **opts):
    
    k = _objkey(obj)
    v = _typedefs.get(k, None)
    if not v:  
        v = _typedef(obj, **opts)
        if save:
            _typedefs[k] = v
    return v


def basicsize(obj, **opts):
    
    b = t = _typedefof(obj, **opts)
    if t:
        b = t.base
    return b


def flatsize(obj, align=0, **opts):
    
    f = t = _typedefof(obj, **opts)
    if t:
        if align > 1:
            m = align - 1
            if m & align:
                raise _OptionError(flatsize, align=align)
        else:
            m = 0
        f = t.flat(obj, mask=m)
    return f


def itemsize(obj, **opts):
    
    i = t = _typedefof(obj, **opts)
    if t:
        i, v = t.item, t.vari
        if v and i == _sizeof_Cbyte:
            i = getattr(obj, v, i)
    return i


def leng(obj, **opts):
    
    n = t = _typedefof(obj, **opts)
    if t:
        n = t.leng
        if n and callable(n):
            i, v, n = t.item, t.vari, n(obj)
            if v and i == _sizeof_Cbyte:
                i = getattr(obj, v, i)
                if i > _sizeof_Cbyte:
                    n = n // i
    return n


def named_refs(obj, **opts):
    
    rs = []
    v = _typedefof(obj, **opts)
    if v:
        v = v.refs
        if v and callable(v):
            for r in v(obj, True):
                try:
                    rs.append((r.name, r.ref))
                except AttributeError:
                    pass
    return rs


def refs(obj, **opts):
    
    v = _typedefof(obj, **opts)
    if v:
        v = v.refs
        if v and callable(v):
            v = v(obj, False)
    return v






































