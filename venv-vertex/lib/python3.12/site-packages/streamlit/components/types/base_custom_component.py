













from __future__ import annotations

import os
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, Any

from streamlit import util
from streamlit.errors import StreamlitAPIException

if TYPE_CHECKING:
    from streamlit.runtime.state.common import WidgetCallback


class MarshallComponentException(StreamlitAPIException):
    

    pass


class BaseCustomComponent(ABC):
    

    def __init__(
        self,
        name: str,
        path: str | None = None,
        url: str | None = None,
        module_name: str | None = None,
    ) -> None:
        if path is None and url is None:
            raise StreamlitAPIException("Either 'path' or 'url' must be set.")

        self._name = name
        self._path = path
        self._url = url
        self._module_name = module_name

    def __repr__(self) -> str:
        return util.repr_(self)

    def __call__(
        self,
        *args: Any,
        default: Any = None,
        key: str | None = None,
        on_change: WidgetCallback | None = None,
        tab_index: int | None = None,
        **kwargs: Any,
    ) -> Any:
        
        return self.create_instance(
            *args,
            default=default,
            key=key,
            on_change=on_change,
            tab_index=tab_index,
            **kwargs,
        )

    @property
    def abspath(self) -> str | None:
        if self._path is None:
            return None
        return os.path.abspath(self._path)

    @property
    def module_name(self) -> str | None:
        return self._module_name

    @property
    def name(self) -> str:
        return self._name

    @property
    def path(self) -> str | None:
        return self._path

    @property
    def url(self) -> str | None:
        return self._url

    def __str__(self) -> str:
        return f"'{self.name}': {self.path if self.path is not None else self.url}"

    def __hash__(self) -> int:
        return hash((self.name, self.path, self.url, self.module_name))

    @abstractmethod
    def __eq__(self, other: object) -> bool:
        
        return NotImplemented

    @abstractmethod
    def __ne__(self, other: object) -> bool:
        
        return NotImplemented

    @abstractmethod
    def create_instance(
        self,
        *args: Any,
        default: Any = None,
        key: str | None = None,
        on_change: WidgetCallback | None = None,
        tab_index: int | None = None,
        **kwargs: Any,
    ) -> Any:
        
        raise NotImplementedError
