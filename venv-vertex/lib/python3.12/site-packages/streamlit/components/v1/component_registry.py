













from __future__ import annotations

import inspect
import os
from pathlib import Path
from typing import TYPE_CHECKING

from streamlit import config
from streamlit.components.v1.custom_component import CustomComponent
from streamlit.runtime import get_instance
from streamlit.runtime.scriptrunner_utils.script_run_context import get_script_run_ctx

if TYPE_CHECKING:
    from types import FrameType

    from streamlit.components.types.base_component_registry import BaseComponentRegistry


def _get_module_name(caller_frame: FrameType) -> str:
    
    
    module = inspect.getmodule(caller_frame)
    if module is None:
        raise RuntimeError("module is None. This should never happen.")
    module_name = module.__name__

    
    
    
    
    if module_name == "__main__":
        file_path = inspect.getfile(caller_frame)
        filename = os.path.basename(file_path)
        module_name, _ = os.path.splitext(filename)

    return module_name


def declare_component(
    name: str,
    path: str | Path | None = None,
    url: str | None = None,
) -> CustomComponent:
    
    if path is not None and isinstance(path, Path):
        path = str(path)

    
    current_frame: FrameType | None = inspect.currentframe()
    if current_frame is None:
        raise RuntimeError("current_frame is None. This should never happen.")
    
    caller_frame = current_frame.f_back
    if caller_frame is None:
        raise RuntimeError("caller_frame is None. This should never happen.")

    module_name = _get_module_name(caller_frame)

    
    component_name = f"{module_name}.{name}"

    
    
    
    
    if not url and (
        component_base_path := config.get_option("server.customComponentBaseUrlPath")
    ):
        url = f"{component_base_path}/{component_name}/"

    
    component = CustomComponent(
        name=component_name, path=path, url=url, module_name=module_name
    )
    
    ctx = get_script_run_ctx()
    if ctx is not None:
        get_instance().component_registry.register_component(component)
    return component








class ComponentRegistry:
    @classmethod
    def instance(cls) -> BaseComponentRegistry:
        

        return get_instance().component_registry
