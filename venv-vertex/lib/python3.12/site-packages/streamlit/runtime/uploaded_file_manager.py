













from __future__ import annotations

import io
from abc import abstractmethod
from typing import TYPE_CHECKING, NamedTuple, Protocol

from streamlit import util
from streamlit.runtime.stats import CacheStatsProvider

if TYPE_CHECKING:
    from collections.abc import Sequence

    from streamlit.proto.Common_pb2 import FileURLs as FileURLsProto


class UploadedFileRec(NamedTuple):
    

    file_id: str
    name: str
    type: str
    data: bytes


class UploadFileUrlInfo(NamedTuple):
    

    file_id: str
    upload_url: str
    delete_url: str


class DeletedFile(NamedTuple):
    

    file_id: str


class UploadedFile(io.BytesIO):
    

    def __init__(self, record: UploadedFileRec, file_urls: FileURLsProto) -> None:
        
        
        
        
        super().__init__(record.data)
        self.file_id = record.file_id
        self.name = record.name
        self.type = record.type
        self.size = len(record.data)
        self._file_urls = file_urls

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, UploadedFile):
            return NotImplemented
        return self.file_id == other.file_id

    def __hash__(self) -> int:
        return hash(self.file_id)

    def __repr__(self) -> str:
        return util.repr_(self)


class UploadedFileManager(CacheStatsProvider, Protocol):
    

    @abstractmethod
    def get_files(
        self, session_id: str, file_ids: Sequence[str]
    ) -> list[UploadedFileRec]:
        
        raise NotImplementedError

    @abstractmethod
    def remove_session_files(self, session_id: str) -> None:
        
        raise NotImplementedError

    def get_upload_urls(
        self, session_id: str, file_names: Sequence[str]
    ) -> list[UploadFileUrlInfo]:
        
        raise NotImplementedError
