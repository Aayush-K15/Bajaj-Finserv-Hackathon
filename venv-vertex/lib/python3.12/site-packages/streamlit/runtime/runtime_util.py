















from __future__ import annotations

from logging import getLogger
from typing import TYPE_CHECKING, Any, Final, cast

from streamlit import config
from streamlit.errors import MarkdownFormattedException, StreamlitAPIException

if TYPE_CHECKING:
    from streamlit.proto.ForwardMsg_pb2 import ForwardMsg

_LOGGER: Final = getLogger(__name__)


class MessageSizeError(MarkdownFormattedException):
    

    def __init__(self, failed_msg_str: Any) -> None:
        msg = self._get_message(failed_msg_str)
        super().__init__(msg)

    def _get_message(self, failed_msg_str: Any) -> str:
        
        return (
            f
        ).strip("\n")


class BadDurationStringError(StreamlitAPIException):
    

    def __init__(self, duration: str) -> None:
        MarkdownFormattedException.__init__(
            self,
            "TTL string doesn't look right. It should be formatted as"
            f"`'1d2h34m'` or `2 days`, for example. Got: {duration}",
        )


def serialize_forward_msg(msg: ForwardMsg) -> bytes:
    

    msg_str = msg.SerializeToString()

    if len(msg_str) > get_max_message_size_bytes():
        
        
        from streamlit.elements import exception

        msg_size_error = MessageSizeError(msg_str)
        _LOGGER.warning(
            "Websocket message size limit exceeded. Showing error to the user: %s",
            msg_size_error,
        )
        exception.marshall(msg.delta.new_element.exception, msg_size_error)
        
        msg.metadata.cacheable = False
        msg_str = msg.SerializeToString()

    return msg_str




_max_message_size_bytes: int | None = None


def get_max_message_size_bytes() -> int:
    
    global _max_message_size_bytes  

    if _max_message_size_bytes is None:
        _max_message_size_bytes = config.get_option("server.maxMessageSize") * int(1e6)

    return cast("int", _max_message_size_bytes)
