













from __future__ import annotations

from abc import abstractmethod
from dataclasses import dataclass
from typing import TYPE_CHECKING, Callable, Protocol, cast

if TYPE_CHECKING:
    from streamlit.proto.ForwardMsg_pb2 import ForwardMsg
    from streamlit.runtime.app_session import AppSession
    from streamlit.runtime.script_data import ScriptData
    from streamlit.runtime.scriptrunner.script_cache import ScriptCache
    from streamlit.runtime.uploaded_file_manager import UploadedFileManager


class SessionClientDisconnectedError(Exception):
    


class SessionClient(Protocol):
    

    @abstractmethod
    def write_forward_msg(self, msg: ForwardMsg) -> None:
        
        raise NotImplementedError


@dataclass
class ActiveSessionInfo:
    

    client: SessionClient
    session: AppSession
    
    
    script_run_count: int = 0


@dataclass
class SessionInfo:
    

    client: SessionClient | None
    session: AppSession
    
    
    script_run_count: int = 0

    def is_active(self) -> bool:
        return self.client is not None

    def to_active(self) -> ActiveSessionInfo:
        if not self.is_active():
            raise RuntimeError("A SessionInfo with no client cannot be active!")

        
        
        
        return cast("ActiveSessionInfo", self)


class SessionStorageError(Exception):
    


class SessionStorage(Protocol):
    @abstractmethod
    def get(self, session_id: str) -> SessionInfo | None:
        
        raise NotImplementedError

    @abstractmethod
    def save(self, session_info: SessionInfo) -> None:
        
        raise NotImplementedError

    @abstractmethod
    def delete(self, session_id: str) -> None:
        
        raise NotImplementedError

    @abstractmethod
    def list(self) -> list[SessionInfo]:
        
        raise NotImplementedError


class SessionManager(Protocol):
    

    @abstractmethod
    def __init__(
        self,
        session_storage: SessionStorage,
        uploaded_file_manager: UploadedFileManager,
        script_cache: ScriptCache,
        message_enqueued_callback: Callable[[], None] | None,
    ) -> None:
        
        raise NotImplementedError

    @abstractmethod
    def connect_session(
        self,
        client: SessionClient,
        script_data: ScriptData,
        user_info: dict[str, str | bool | None],
        existing_session_id: str | None = None,
        session_id_override: str | None = None,
    ) -> str:
        
        raise NotImplementedError

    @abstractmethod
    def close_session(self, session_id: str) -> None:
        
        raise NotImplementedError

    @abstractmethod
    def get_session_info(self, session_id: str) -> SessionInfo | None:
        
        raise NotImplementedError

    @abstractmethod
    def list_sessions(self) -> list[SessionInfo]:
        
        raise NotImplementedError

    def num_sessions(self) -> int:
        
        return len(self.list_sessions())

    
    
    
    

    def disconnect_session(self, session_id: str) -> None:
        
        self.close_session(session_id)

    def get_active_session_info(self, session_id: str) -> ActiveSessionInfo | None:
        
        session = self.get_session_info(session_id)
        if session is None or not session.is_active():
            return None
        return session.to_active()

    def is_active_session(self, session_id: str) -> bool:
        
        return self.get_active_session_info(session_id) is not None

    def list_active_sessions(self) -> list[ActiveSessionInfo]:
        
        return [s.to_active() for s in self.list_sessions()]

    def num_active_sessions(self) -> int:
        
        return len(self.list_active_sessions())
