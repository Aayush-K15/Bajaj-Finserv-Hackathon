













from __future__ import annotations

import gc
import sys
import threading
import types
from contextlib import contextmanager
from enum import Enum
from timeit import default_timer as timer
from typing import TYPE_CHECKING, Callable, Final, Literal, cast

from blinker import Signal

from streamlit import config, runtime, util
from streamlit.errors import FragmentStorageKeyError
from streamlit.logger import get_logger
from streamlit.proto.ClientState_pb2 import ClientState
from streamlit.proto.ForwardMsg_pb2 import ForwardMsg
from streamlit.runtime.metrics_util import (
    create_page_profile_message,
    to_microseconds,
)
from streamlit.runtime.pages_manager import PagesManager
from streamlit.runtime.scriptrunner.exec_code import (
    exec_func_with_error_handling,
    modified_sys_path,
)
from streamlit.runtime.scriptrunner.script_cache import ScriptCache
from streamlit.runtime.scriptrunner_utils.exceptions import (
    RerunException,
    StopException,
)
from streamlit.runtime.scriptrunner_utils.script_requests import (
    RerunData,
    ScriptRequests,
    ScriptRequestType,
)
from streamlit.runtime.scriptrunner_utils.script_run_context import (
    ScriptRunContext,
    add_script_run_ctx,
    get_script_run_ctx,
)
from streamlit.runtime.state import (
    SCRIPT_RUN_WITHOUT_ERRORS_KEY,
    SafeSessionState,
    SessionState,
)
from streamlit.source_util import page_sort_key

if TYPE_CHECKING:
    from collections.abc import Generator

    from streamlit.runtime.fragment import FragmentStorage
    from streamlit.runtime.scriptrunner.script_cache import ScriptCache
    from streamlit.runtime.uploaded_file_manager import UploadedFileManager

_LOGGER: Final = get_logger(__name__)


class ScriptRunnerEvent(Enum):
    

    
    SCRIPT_STARTED = "SCRIPT_STARTED"

    
    SCRIPT_STOPPED_WITH_COMPILE_ERROR = "SCRIPT_STOPPED_WITH_COMPILE_ERROR"

    
    
    SCRIPT_STOPPED_WITH_SUCCESS = "SCRIPT_STOPPED_WITH_SUCCESS"

    
    SCRIPT_STOPPED_FOR_RERUN = "SCRIPT_STOPPED_FOR_RERUN"

    
    
    FRAGMENT_STOPPED_WITH_SUCCESS = "FRAGMENT_STOPPED_WITH_SUCCESS"

    
    
    SHUTDOWN = "SHUTDOWN"

    
    

    
    ENQUEUE_FORWARD_MSG = "ENQUEUE_FORWARD_MSG"









def _mpa_v1(main_script_path: str) -> None:
    from pathlib import Path

    from streamlit.commands.navigation import PageType, _navigation
    from streamlit.navigation.page import StreamlitPage

    
    resolved_main_script_path: Final = Path(main_script_path).resolve()
    pages_folder: Final = resolved_main_script_path.parent / "pages"

    
    pages = sorted(
        [
            page
            for page in pages_folder.glob("*.py")
            if page.name.endswith(".py")
            and not page.name.startswith(".")
            and page.name != "__init__.py"
        ],
        key=page_sort_key,
    )

    
    main_page = StreamlitPage(resolved_main_script_path, default=True)
    all_pages = [main_page] + [
        StreamlitPage(pages_folder / page.name) for page in pages
    ]
    
    position: Literal["sidebar", "hidden", "top"] = (
        "hidden"
        if config.get_option("client.showSidebarNavigation") is False
        else "sidebar"
    )
    page = _navigation(
        cast("list[PageType]", all_pages),
        position=position,
        expanded=False,
    )

    page.run()


class ScriptRunner:
    def __init__(
        self,
        session_id: str,
        main_script_path: str,
        session_state: SessionState,
        uploaded_file_mgr: UploadedFileManager,
        script_cache: ScriptCache,
        initial_rerun_data: RerunData,
        user_info: dict[str, str | bool | None],
        fragment_storage: FragmentStorage,
        pages_manager: PagesManager,
    ) -> None:
        
        self._session_id = session_id
        self._main_script_path = main_script_path
        self._session_state = SafeSessionState(
            session_state, yield_callback=self._maybe_handle_execution_control_request
        )
        self._uploaded_file_mgr = uploaded_file_mgr
        self._script_cache = script_cache
        self._user_info = user_info
        self._fragment_storage = fragment_storage

        self._pages_manager = pages_manager
        self._requests = ScriptRequests()
        self._requests.request_rerun(initial_rerun_data)

        self.on_event = Signal(
            doc=
        )

        
        
        self._execing = False

        
        self._script_thread: threading.Thread | None = None

    def __repr__(self) -> str:
        return util.repr_(self)

    def request_stop(self) -> None:
        
        self._requests.request_stop()

    def request_rerun(self, rerun_data: RerunData) -> bool:
        
        return self._requests.request_rerun(rerun_data)

    def start(self) -> None:
        
        if self._script_thread is not None:
            raise RuntimeError("ScriptRunner was already started")

        self._script_thread = threading.Thread(
            target=self._run_script_thread,
            name="ScriptRunner.scriptThread",
        )
        self._script_thread.start()

    def _get_script_run_ctx(self) -> ScriptRunContext:
        
        if not self._is_in_script_thread():
            raise RuntimeError(
                "ScriptRunner._get_script_run_ctx must be called from the script thread."
            )

        ctx = get_script_run_ctx()
        if ctx is None:
            
            raise RuntimeError(
                "ScriptRunner thread has a null ScriptRunContext. "
                "Something has gone very wrong!"
            )
        return ctx

    def _run_script_thread(self) -> None:
        
        if not self._is_in_script_thread():
            raise RuntimeError(
                "ScriptRunner._run_script_thread must be called from the script thread."
            )

        _LOGGER.debug("Beginning script thread")

        
        ctx = ScriptRunContext(
            session_id=self._session_id,
            _enqueue=self._enqueue_forward_msg,
            script_requests=self._requests,
            query_string="",
            session_state=self._session_state,
            uploaded_file_mgr=self._uploaded_file_mgr,
            main_script_path=self._main_script_path,
            user_info=self._user_info,
            gather_usage_stats=bool(config.get_option("browser.gatherUsageStats")),
            fragment_storage=self._fragment_storage,
            pages_manager=self._pages_manager,
            context_info=None,
        )
        add_script_run_ctx(threading.current_thread(), ctx)

        request = self._requests.on_scriptrunner_ready()
        while request.type == ScriptRequestType.RERUN:
            
            
            
            
            self._run_script(request.rerun_data)
            request = self._requests.on_scriptrunner_ready()

        if request.type != ScriptRequestType.STOP:
            raise RuntimeError(
                f"Unrecognized ScriptRequestType: {request.type}. This should never happen."
            )

        
        
        client_state = ClientState()
        client_state.query_string = ctx.query_string
        client_state.page_script_hash = ctx.page_script_hash
        if ctx.context_info:
            client_state.context_info.CopyFrom(ctx.context_info)
        self.on_event.send(
            self, event=ScriptRunnerEvent.SHUTDOWN, client_state=client_state
        )

    def _is_in_script_thread(self) -> bool:
        
        return self._script_thread == threading.current_thread()

    def _enqueue_forward_msg(self, msg: ForwardMsg) -> None:
        
        
        
        
        self._maybe_handle_execution_control_request()

        
        self.on_event.send(
            self, event=ScriptRunnerEvent.ENQUEUE_FORWARD_MSG, forward_msg=msg
        )

    def _maybe_handle_execution_control_request(self) -> None:
        
        if not self._is_in_script_thread():
            
            
            
            
            return

        if not self._execing:
            
            
            
            
            return

        request = self._requests.on_scriptrunner_yield()
        if request is None:
            
            return

        if request.type == ScriptRequestType.RERUN:
            raise RerunException(request.rerun_data)

        if request.type != ScriptRequestType.STOP:
            raise RuntimeError(
                f"Unrecognized ScriptRequestType: {request.type}. This should never happen."
            )
        raise StopException()

    @contextmanager
    def _set_execing_flag(self) -> Generator[None, None, None]:
        
        if self._execing:
            raise RuntimeError("Nested set_execing_flag call")
        self._execing = True
        try:
            yield
        finally:
            self._execing = False

    def _run_script(self, rerun_data: RerunData) -> None:
        

        if not self._is_in_script_thread():
            raise RuntimeError(
                "ScriptRunner._run_script must be called from the script thread."
            )

        
        while True:
            _LOGGER.debug("Running script %s", rerun_data)
            start_time: float = timer()
            prep_time: float = 0  

            if not rerun_data.fragment_id_queue:
                
                
                
                
                runtime.get_instance().media_file_mgr.clear_session_refs()

            self._pages_manager.set_script_intent(
                rerun_data.page_script_hash, rerun_data.page_name
            )
            active_script = self._pages_manager.get_initial_active_script(
                rerun_data.page_script_hash
            )
            main_page_info = self._pages_manager.get_main_page()

            page_script_hash = (
                active_script["page_script_hash"]
                if active_script is not None
                else main_page_info["page_script_hash"]
            )

            ctx = self._get_script_run_ctx()
            
            
            
            previous_page_script_hash = ctx.page_script_hash
            if previous_page_script_hash != page_script_hash:
                
                
                
                
                
                
                widget_ids: set[str] = set()

                if (
                    rerun_data.widget_states is not None
                    and rerun_data.widget_states.widgets is not None
                ):
                    widget_ids = {w.id for w in rerun_data.widget_states.widgets}
                self._session_state.on_script_finished(widget_ids)

            fragment_ids_this_run = list(rerun_data.fragment_id_queue)

            ctx.reset(
                query_string=rerun_data.query_string,
                page_script_hash=page_script_hash,
                fragment_ids_this_run=fragment_ids_this_run,
                cached_message_hashes=rerun_data.cached_message_hashes,
                context_info=rerun_data.context_info,
            )

            self.on_event.send(
                self,
                event=ScriptRunnerEvent.SCRIPT_STARTED,
                page_script_hash=page_script_hash,
                fragment_ids_this_run=fragment_ids_this_run,
                pages=self._pages_manager.get_pages(),
            )

            
            
            
            try:
                if active_script is not None:
                    script_path = active_script["script_path"]
                else:
                    
                    script_path = main_page_info["script_path"]

                    
                    
                    
                    
                    
                    
                    
                    msg = ForwardMsg()
                    msg.page_not_found.page_name = rerun_data.page_name
                    ctx.enqueue(msg)

                code = self._script_cache.get_bytecode(script_path)

            except Exception as ex:
                
                _LOGGER.exception("Script compilation error", exc_info=ex)
                self._session_state[SCRIPT_RUN_WITHOUT_ERRORS_KEY] = False
                self.on_event.send(
                    self,
                    event=ScriptRunnerEvent.SCRIPT_STOPPED_WITH_COMPILE_ERROR,
                    exception=ex,
                )
                return

            
            
            

            
            
            module = self._new_module("__main__")

            
            
            
            
            
            sys.modules["__main__"] = module

            
            
            
            
            
            module.__dict__["__file__"] = script_path

            def code_to_exec(
                code: str = code,
                module: types.ModuleType = module,
                ctx: ScriptRunContext = ctx,
                rerun_data: RerunData = rerun_data,
            ) -> None:
                with (
                    modified_sys_path(self._main_script_path),
                    self._set_execing_flag(),
                ):
                    
                    if rerun_data.widget_states is not None:
                        self._session_state.on_script_will_rerun(
                            rerun_data.widget_states
                        )

                    ctx.on_script_start()

                    if rerun_data.fragment_id_queue:
                        for fragment_id in rerun_data.fragment_id_queue:
                            try:
                                wrapped_fragment = self._fragment_storage.get(
                                    fragment_id
                                )
                                wrapped_fragment()

                            except FragmentStorageKeyError:  
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                if not rerun_data.is_auto_rerun:
                                    _LOGGER.warning(
                                        "Couldn't find fragment with id %s."
                                        " This can happen if the fragment does not"
                                        " exist anymore when this request is processed,"
                                        " for example because a full app rerun happened"
                                        " that did not register the fragment."
                                        " Usually this doesn't happen or no action is"
                                        " required, so its mainly for debugging.",
                                        fragment_id,
                                    )
                            except (RerunException, StopException):
                                
                                
                                
                                raise
                            except Exception:  
                                
                                
                                
                                
                                pass

                    else:
                        if PagesManager.uses_pages_directory:
                            _mpa_v1(self._main_script_path)
                        else:
                            exec(code, module.__dict__)  
                        self._fragment_storage.clear(
                            new_fragment_ids=ctx.new_fragment_ids
                        )

                    self._session_state.maybe_check_serializable()
                    
                    self._maybe_handle_execution_control_request()

            prep_time = timer() - start_time
            (
                _,
                run_without_errors,
                rerun_exception_data,
                premature_stop,
                uncaught_exception,
            ) = exec_func_with_error_handling(code_to_exec, ctx)
            
            
            self._session_state[SCRIPT_RUN_WITHOUT_ERRORS_KEY] = run_without_errors

            if rerun_exception_data:
                
                
                finished_event = ScriptRunnerEvent.SCRIPT_STOPPED_FOR_RERUN
            elif rerun_data.fragment_id_queue:
                finished_event = ScriptRunnerEvent.FRAGMENT_STOPPED_WITH_SUCCESS
            else:
                finished_event = ScriptRunnerEvent.SCRIPT_STOPPED_WITH_SUCCESS

            if ctx.gather_usage_stats:
                try:
                    
                    ctx.enqueue(
                        create_page_profile_message(
                            commands=ctx.tracked_commands,
                            exec_time=to_microseconds(timer() - start_time),
                            prep_time=to_microseconds(prep_time),
                            uncaught_exception=(
                                type(uncaught_exception).__name__
                                if uncaught_exception
                                else None
                            ),
                        )
                    )
                except Exception as ex:
                    
                    
                    _LOGGER.debug("Failed to create page profile", exc_info=ex)
            self._on_script_finished(ctx, finished_event, premature_stop)

            
            
            _log_if_error(_clean_problem_modules)

            if rerun_exception_data is not None:
                rerun_data = rerun_exception_data
            else:
                break

    def _on_script_finished(
        self, ctx: ScriptRunContext, event: ScriptRunnerEvent, premature_stop: bool
    ) -> None:
        
        
        if not premature_stop:
            self._session_state.on_script_finished(ctx.widget_ids_this_run)

        
        
        self.on_event.send(self, event=event)

        
        
        runtime.get_instance().media_file_mgr.remove_orphaned_files()

        
        
        
        
        if config.get_option("runner.postScriptGC"):
            gc.collect(2)

    def _new_module(self, name: str) -> types.ModuleType:
        
        return types.ModuleType(name)


def _clean_problem_modules() -> None:
    

    if "keras" in sys.modules:
        try:
            keras = sys.modules["keras"]
            keras.backend.clear_session()
        except Exception:  
            
            pass

    if "matplotlib.pyplot" in sys.modules:
        try:
            plt = sys.modules["matplotlib.pyplot"]
            plt.close("all")
        except Exception:  
            
            pass




def _log_if_error(fn: Callable[[], None]) -> None:
    try:
        fn()
    except Exception as e:
        _LOGGER.warning(e)
