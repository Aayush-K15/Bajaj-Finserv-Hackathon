

import warnings

import numpy as np

from shapely import lib
from shapely.decorators import multithreading_enabled

__all__ = [
    "area",
    "bounds",
    "distance",
    "frechet_distance",
    "hausdorff_distance",
    "length",
    "minimum_bounding_radius",
    "minimum_clearance",
    "total_bounds",
]


@multithreading_enabled
def area(geometry, **kwargs):
    
    return lib.area(geometry, **kwargs)


@multithreading_enabled
def distance(a, b, **kwargs):
    
    return lib.distance(a, b, **kwargs)


@multithreading_enabled
def bounds(geometry, **kwargs):
    
    return lib.bounds(geometry, **kwargs)


def total_bounds(geometry, **kwargs):
    
    b = bounds(geometry, **kwargs)
    if b.ndim == 1:
        return b

    with warnings.catch_warnings():
        
        warnings.simplefilter("ignore", RuntimeWarning)
        return np.array(
            [
                np.nanmin(b[..., 0]),
                np.nanmin(b[..., 1]),
                np.nanmax(b[..., 2]),
                np.nanmax(b[..., 3]),
            ]
        )


@multithreading_enabled
def length(geometry, **kwargs):
    
    return lib.length(geometry, **kwargs)


@multithreading_enabled
def hausdorff_distance(a, b, densify=None, **kwargs):
    
    if densify is None:
        return lib.hausdorff_distance(a, b, **kwargs)
    else:
        return lib.hausdorff_distance_densify(a, b, densify, **kwargs)


@multithreading_enabled
def frechet_distance(a, b, densify=None, **kwargs):
    
    if densify is None:
        return lib.frechet_distance(a, b, **kwargs)
    return lib.frechet_distance_densify(a, b, densify, **kwargs)


@multithreading_enabled
def minimum_clearance(geometry, **kwargs):
    
    return lib.minimum_clearance(geometry, **kwargs)


@multithreading_enabled
def minimum_bounding_radius(geometry, **kwargs):
    
    return lib.minimum_bounding_radius(geometry, **kwargs)
