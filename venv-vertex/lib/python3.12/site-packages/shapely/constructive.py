

import numpy as np

from shapely import lib
from shapely._enum import ParamEnum
from shapely.algorithms._oriented_envelope import _oriented_envelope_min_area_vectorized
from shapely.algorithms.cga import _orient_polygons_vectorized
from shapely.decorators import (
    deprecate_positional,
    multithreading_enabled,
    requires_geos,
)
from shapely.errors import UnsupportedGEOSVersionError

__all__ = [
    "BufferCapStyle",
    "BufferJoinStyle",
    "boundary",
    "buffer",
    "build_area",
    "centroid",
    "clip_by_rect",
    "concave_hull",
    "constrained_delaunay_triangles",
    "convex_hull",
    "delaunay_triangles",
    "envelope",
    "extract_unique_points",
    "make_valid",
    "maximum_inscribed_circle",
    "minimum_bounding_circle",
    "minimum_clearance_line",
    "minimum_rotated_rectangle",
    "node",
    "normalize",
    "offset_curve",
    "orient_polygons",
    "oriented_envelope",
    "point_on_surface",
    "polygonize",
    "polygonize_full",
    "remove_repeated_points",
    "reverse",
    "segmentize",
    "simplify",
    "snap",
    "voronoi_polygons",
]


class BufferCapStyle(ParamEnum):
    

    round = 1
    flat = 2
    square = 3


class BufferJoinStyle(ParamEnum):
    

    round = 1
    mitre = 2
    bevel = 3


@multithreading_enabled
def boundary(geometry, **kwargs):
    
    return lib.boundary(geometry, **kwargs)











@deprecate_positional(
    ["quad_segs", "cap_style", "join_style", "mitre_limit", "single_sided"],
    category=DeprecationWarning,
)
@multithreading_enabled
def buffer(
    geometry,
    distance,
    quad_segs=8,
    cap_style="round",
    join_style="round",
    mitre_limit=5.0,
    single_sided=False,
    **kwargs,
):
    
    if isinstance(cap_style, str):
        cap_style = BufferCapStyle.get_value(cap_style)
    if isinstance(join_style, str):
        join_style = BufferJoinStyle.get_value(join_style)
    if not np.isscalar(quad_segs):
        raise TypeError("quad_segs only accepts scalar values")
    if not np.isscalar(cap_style):
        raise TypeError("cap_style only accepts scalar values")
    if not np.isscalar(join_style):
        raise TypeError("join_style only accepts scalar values")
    if not np.isscalar(mitre_limit):
        raise TypeError("mitre_limit only accepts scalar values")
    if not np.isscalar(single_sided):
        raise TypeError("single_sided only accepts scalar values")
    return lib.buffer(
        geometry,
        distance,
        np.intc(quad_segs),
        np.intc(cap_style),
        np.intc(join_style),
        mitre_limit,
        np.bool_(single_sided),
        **kwargs,
    )











@deprecate_positional(
    ["quad_segs", "join_style", "mitre_limit"], category=DeprecationWarning
)
@multithreading_enabled
def offset_curve(
    geometry, distance, quad_segs=8, join_style="round", mitre_limit=5.0, **kwargs
):
    
    if isinstance(join_style, str):
        join_style = BufferJoinStyle.get_value(join_style)
    if not np.isscalar(quad_segs):
        raise TypeError("quad_segs only accepts scalar values")
    if not np.isscalar(join_style):
        raise TypeError("join_style only accepts scalar values")
    if not np.isscalar(mitre_limit):
        raise TypeError("mitre_limit only accepts scalar values")
    return lib.offset_curve(
        geometry,
        distance,
        np.intc(quad_segs),
        np.intc(join_style),
        np.double(mitre_limit),
        **kwargs,
    )


@multithreading_enabled
def centroid(geometry, **kwargs):
    
    return lib.centroid(geometry, **kwargs)


@multithreading_enabled
def clip_by_rect(geometry, xmin, ymin, xmax, ymax, **kwargs):
    
    if not all(np.isscalar(val) for val in [xmin, ymin, xmax, ymax]):
        raise TypeError("xmin/ymin/xmax/ymax only accepts scalar values")
    return lib.clip_by_rect(
        geometry,
        np.double(xmin),
        np.double(ymin),
        np.double(xmax),
        np.double(ymax),
        **kwargs,
    )


@requires_geos("3.11.0")
@multithreading_enabled
def concave_hull(geometry, ratio=0.0, allow_holes=False, **kwargs):
    
    if not np.isscalar(ratio):
        raise TypeError("ratio must be scalar")
    if not np.isscalar(allow_holes):
        raise TypeError("allow_holes must be scalar")
    return lib.concave_hull(geometry, np.double(ratio), np.bool_(allow_holes), **kwargs)


@multithreading_enabled
def convex_hull(geometry, **kwargs):
    
    return lib.convex_hull(geometry, **kwargs)


@multithreading_enabled
def delaunay_triangles(geometry, tolerance=0.0, only_edges=False, **kwargs):
    
    return lib.delaunay_triangles(geometry, tolerance, only_edges, **kwargs)


@requires_geos("3.10.0")
@multithreading_enabled
def constrained_delaunay_triangles(geometry, **kwargs):
      
    return lib.constrained_delaunay_triangles(geometry, **kwargs)


@multithreading_enabled
def envelope(geometry, **kwargs):
    
    return lib.envelope(geometry, **kwargs)


@multithreading_enabled
def extract_unique_points(geometry, **kwargs):
    
    return lib.extract_unique_points(geometry, **kwargs)


@multithreading_enabled
def build_area(geometry, **kwargs):
    
    return lib.build_area(geometry, **kwargs)


@multithreading_enabled
def make_valid(geometry, *, method="linework", keep_collapsed=True, **kwargs):
    
    if not np.isscalar(method):
        raise TypeError("method only accepts scalar values")
    if not np.isscalar(keep_collapsed):
        raise TypeError("keep_collapsed only accepts scalar values")

    if method == "linework":
        if keep_collapsed is False:
            raise ValueError(
                "The 'linework' method does not support 'keep_collapsed=False'"
            )

        
        
        
        
        return lib.make_valid(geometry, **kwargs)

    elif method == "structure":
        if lib.geos_version < (3, 10, 0):
            raise ValueError(
                "The 'structure' method is only available in GEOS >= 3.10.0"
            )

        return lib.make_valid_with_params(
            geometry, np.intc(1), np.bool_(keep_collapsed), **kwargs
        )

    else:
        raise ValueError(f"Unknown method: {method}")


@multithreading_enabled
def minimum_clearance_line(geometry, **kwargs):
    
    return lib.minimum_clearance_line(geometry, **kwargs)


@multithreading_enabled
def normalize(geometry, **kwargs):
    
    return lib.normalize(geometry, **kwargs)


@multithreading_enabled
def point_on_surface(geometry, **kwargs):
    
    return lib.point_on_surface(geometry, **kwargs)


@multithreading_enabled
def node(geometry, **kwargs):
    
    return lib.node(geometry, **kwargs)


def polygonize(geometries, **kwargs):
    
    return lib.polygonize(geometries, **kwargs)


def polygonize_full(geometries, **kwargs):
    
    return lib.polygonize_full(geometries, **kwargs)


@requires_geos("3.11.0")
@multithreading_enabled
def remove_repeated_points(geometry, tolerance=0.0, **kwargs):
      
    return lib.remove_repeated_points(geometry, tolerance, **kwargs)


@multithreading_enabled
def reverse(geometry, **kwargs):
    
    return lib.reverse(geometry, **kwargs)


@requires_geos("3.10.0")
@multithreading_enabled
def segmentize(geometry, max_segment_length, **kwargs):
    
    return lib.segmentize(geometry, max_segment_length, **kwargs)











@deprecate_positional(["preserve_topology"], category=DeprecationWarning)
@multithreading_enabled
def simplify(geometry, tolerance, preserve_topology=True, **kwargs):
    
    if preserve_topology:
        return lib.simplify_preserve_topology(geometry, tolerance, **kwargs)
    else:
        return lib.simplify(geometry, tolerance, **kwargs)


@multithreading_enabled
def snap(geometry, reference, tolerance, **kwargs):
    
    return lib.snap(geometry, reference, tolerance, **kwargs)











@deprecate_positional(
    ["extend_to", "only_edges", "ordered"], category=DeprecationWarning
)
@multithreading_enabled
def voronoi_polygons(
    geometry, tolerance=0.0, extend_to=None, only_edges=False, ordered=False, **kwargs
):
      
    if ordered is not False and lib.geos_version < (3, 12, 0):
        raise UnsupportedGEOSVersionError(
            "Ordered Voronoi polygons require GEOS >= 3.12.0, "
            f"found {lib.geos_version_string}"
        )
    return lib.voronoi_polygons(
        geometry, tolerance, extend_to, only_edges, ordered, **kwargs
    )


@multithreading_enabled
def _oriented_envelope_geos(geometry, **kwargs):
    return lib.oriented_envelope(geometry, **kwargs)


def oriented_envelope(geometry, **kwargs):
    
    if lib.geos_version < (3, 12, 0):
        f = _oriented_envelope_min_area_vectorized
    else:
        f = _oriented_envelope_geos
    return f(geometry, **kwargs)


minimum_rotated_rectangle = oriented_envelope


@multithreading_enabled
def minimum_bounding_circle(geometry, **kwargs):
    
    return lib.minimum_bounding_circle(geometry, **kwargs)


@multithreading_enabled
def maximum_inscribed_circle(geometry, tolerance=None, **kwargs):
    
    if tolerance is None:
        tolerance = 0.0
    elif np.isscalar(tolerance) and tolerance < 0:
        raise ValueError("'tolerance' should be positive")
    return lib.maximum_inscribed_circle(geometry, tolerance, **kwargs)


@multithreading_enabled
def _orient_polygons_geos(geometry, exterior_cw=False, **kwargs):
    return lib.orient_polygons(geometry, exterior_cw, **kwargs)


@multithreading_enabled
def orient_polygons(geometry, *, exterior_cw=False, **kwargs):
    
    if lib.geos_version < (3, 12, 0):
        f = _orient_polygons_vectorized
    else:
        f = _orient_polygons_geos
    return f(geometry, exterior_cw, **kwargs)
