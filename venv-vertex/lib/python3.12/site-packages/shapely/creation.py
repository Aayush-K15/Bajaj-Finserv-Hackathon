

import numpy as np

from shapely import Geometry, GeometryType, lib
from shapely._enum import ParamEnum
from shapely._geometry_helpers import collections_1d, simple_geometries_1d
from shapely.decorators import deprecate_positional, multithreading_enabled
from shapely.io import from_wkt

__all__ = [
    "box",
    "destroy_prepared",
    "empty",
    "geometrycollections",
    "linearrings",
    "linestrings",
    "multilinestrings",
    "multipoints",
    "multipolygons",
    "points",
    "polygons",
    "prepare",
]


class HandleNaN(ParamEnum):
    allow = 0
    skip = 1
    error = 2


def _xyz_to_coords(x, y, z):
    if y is None:
        return x
    if z is None:
        coords = np.broadcast_arrays(x, y)
    else:
        coords = np.broadcast_arrays(x, y, z)
    return np.stack(coords, axis=-1)











@deprecate_positional(["indices"], category=DeprecationWarning)
@multithreading_enabled
def points(
    coords,
    y=None,
    z=None,
    indices=None,
    *,
    handle_nan=HandleNaN.allow,
    out=None,
    **kwargs,
):
    
    coords = _xyz_to_coords(coords, y, z)
    if isinstance(handle_nan, str):
        handle_nan = HandleNaN.get_value(handle_nan)
    if indices is None:
        return lib.points(coords, np.intc(handle_nan), out=out, **kwargs)
    else:
        return simple_geometries_1d(
            coords, indices, GeometryType.POINT, handle_nan=handle_nan, out=out
        )











@deprecate_positional(["indices"], category=DeprecationWarning)
@multithreading_enabled
def linestrings(
    coords,
    y=None,
    z=None,
    indices=None,
    *,
    handle_nan=HandleNaN.allow,
    out=None,
    **kwargs,
):
    
    coords = _xyz_to_coords(coords, y, z)
    if isinstance(handle_nan, str):
        handle_nan = HandleNaN.get_value(handle_nan)
    if indices is None:
        return lib.linestrings(coords, np.intc(handle_nan), out=out, **kwargs)
    else:
        return simple_geometries_1d(
            coords, indices, GeometryType.LINESTRING, handle_nan=handle_nan, out=out
        )











@deprecate_positional(["indices"], category=DeprecationWarning)
@multithreading_enabled
def linearrings(
    coords,
    y=None,
    z=None,
    indices=None,
    *,
    handle_nan=HandleNaN.allow,
    out=None,
    **kwargs,
):
    
    coords = _xyz_to_coords(coords, y, z)
    if isinstance(handle_nan, str):
        handle_nan = HandleNaN.get_value(handle_nan)
    if indices is None:
        return lib.linearrings(coords, np.intc(handle_nan), out=out, **kwargs)
    else:
        return simple_geometries_1d(
            coords, indices, GeometryType.LINEARRING, handle_nan=handle_nan, out=out
        )











@deprecate_positional(["indices"], category=DeprecationWarning)
@multithreading_enabled
def polygons(geometries, holes=None, indices=None, *, out=None, **kwargs):
    
    geometries = np.asarray(geometries)
    if not isinstance(geometries, Geometry) and np.issubdtype(
        geometries.dtype, np.number
    ):
        geometries = linearrings(geometries)

    if indices is not None:
        if holes is not None:
            raise TypeError("Cannot specify separate holes array when using indices.")
        return collections_1d(geometries, indices, GeometryType.POLYGON, out=out)

    if holes is None:
        
        shape = geometries.shape + (0,) if isinstance(geometries, np.ndarray) else (0,)
        holes = np.empty(shape, dtype=object)
    else:
        holes = np.asarray(holes)
        
        if np.issubdtype(holes.dtype, np.number):
            holes = linearrings(holes)

    return lib.polygons(geometries, holes, out=out, **kwargs)











@deprecate_positional(["ccw"], category=DeprecationWarning)
@multithreading_enabled
def box(xmin, ymin, xmax, ymax, ccw=True, **kwargs):
    
    return lib.box(xmin, ymin, xmax, ymax, ccw, **kwargs)











@deprecate_positional(["indices"], category=DeprecationWarning)
@multithreading_enabled
def multipoints(geometries, indices=None, *, out=None, **kwargs):
    
    typ = GeometryType.MULTIPOINT
    geometries = np.asarray(geometries)
    if not isinstance(geometries, Geometry) and np.issubdtype(
        geometries.dtype, np.number
    ):
        geometries = points(geometries)
    if indices is None:
        return lib.create_collection(geometries, np.intc(typ), out=out, **kwargs)
    else:
        return collections_1d(geometries, indices, typ, out=out)











@deprecate_positional(["indices"], category=DeprecationWarning)
@multithreading_enabled
def multilinestrings(geometries, indices=None, *, out=None, **kwargs):
    
    typ = GeometryType.MULTILINESTRING
    geometries = np.asarray(geometries)
    if not isinstance(geometries, Geometry) and np.issubdtype(
        geometries.dtype, np.number
    ):
        geometries = linestrings(geometries)

    if indices is None:
        return lib.create_collection(geometries, np.intc(typ), out=out, **kwargs)
    else:
        return collections_1d(geometries, indices, typ, out=out)











@deprecate_positional(["indices"], category=DeprecationWarning)
@multithreading_enabled
def multipolygons(geometries, indices=None, *, out=None, **kwargs):
    
    typ = GeometryType.MULTIPOLYGON
    geometries = np.asarray(geometries)
    if not isinstance(geometries, Geometry) and np.issubdtype(
        geometries.dtype, np.number
    ):
        geometries = polygons(geometries)
    if indices is None:
        return lib.create_collection(geometries, np.intc(typ), out=out, **kwargs)
    else:
        return collections_1d(geometries, indices, typ, out=out)











@deprecate_positional(["indices"], category=DeprecationWarning)
@multithreading_enabled
def geometrycollections(geometries, indices=None, out=None, **kwargs):
    
    typ = GeometryType.GEOMETRYCOLLECTION
    if indices is None:
        return lib.create_collection(geometries, np.intc(typ), out=out, **kwargs)
    else:
        return collections_1d(geometries, indices, typ, out=out)


def prepare(geometry, **kwargs):
    
    lib.prepare(geometry, **kwargs)


def destroy_prepared(geometry, **kwargs):
    
    lib.destroy_prepared(geometry, **kwargs)


def empty(shape, geom_type=None, order="C"):
    
    if geom_type is None:
        return np.empty(shape, dtype=object, order=order)

    geom_type = GeometryType(geom_type)  
    if geom_type is GeometryType.MISSING:
        return np.empty(shape, dtype=object, order=order)

    fill_value = from_wkt(geom_type.name + " EMPTY")
    return np.full(shape, fill_value, dtype=object, order=order)
