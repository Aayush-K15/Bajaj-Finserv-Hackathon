

import re
from warnings import warn

import numpy as np

import shapely
from shapely._geometry_helpers import _geom_factory
from shapely.constructive import BufferCapStyle, BufferJoinStyle
from shapely.coords import CoordinateSequence
from shapely.decorators import deprecate_positional
from shapely.errors import GeometryTypeError, GEOSException, ShapelyDeprecationWarning

GEOMETRY_TYPES = [
    "Point",
    "LineString",
    "LinearRing",
    "Polygon",
    "MultiPoint",
    "MultiLineString",
    "MultiPolygon",
    "GeometryCollection",
]

_geos_ge_312 = shapely.geos_version >= (3, 12, 0)


def geom_factory(g, parent=None):
    
    warn(
        "The 'geom_factory' function is deprecated in Shapely 2.0, and will be "
        "removed in a future version",
        FutureWarning,
        stacklevel=2,
    )
    return _geom_factory(g)


def dump_coords(geom):
    
    if not isinstance(geom, BaseGeometry):
        raise ValueError(
            "Must be instance of a geometry class; found " + geom.__class__.__name__
        )
    elif geom.geom_type in ("Point", "LineString", "LinearRing"):
        return geom.coords[:]
    elif geom.geom_type == "Polygon":
        return geom.exterior.coords[:] + [i.coords[:] for i in geom.interiors]
    elif geom.geom_type.startswith("Multi") or geom.geom_type == "GeometryCollection":
        
        return [dump_coords(part) for part in geom.geoms]
    else:
        raise GeometryTypeError("Unhandled geometry type: " + repr(geom.geom_type))


def _maybe_unpack(result):
    if result.ndim == 0:
        
        return result.item()
    else:
        
        return result


class CAP_STYLE:
    

    round = BufferCapStyle.round
    flat = BufferCapStyle.flat
    square = BufferCapStyle.square


class JOIN_STYLE:
    

    round = BufferJoinStyle.round
    mitre = BufferJoinStyle.mitre
    bevel = BufferJoinStyle.bevel


class BaseGeometry(shapely.Geometry):
    

    __slots__ = []

    def __new__(self):
        
        warn(
            "Directly calling the base class 'BaseGeometry()' is deprecated, and "
            "will raise an error in the future. To create an empty geometry, "
            "use one of the subclasses instead, for example 'GeometryCollection()'.",
            ShapelyDeprecationWarning,
            stacklevel=2,
        )
        return shapely.from_wkt("GEOMETRYCOLLECTION EMPTY")

    @property
    def _ndim(self):
        return shapely.get_coordinate_dimension(self)

    def __bool__(self):
        
        return self.is_empty is False

    def __nonzero__(self):
        
        return self.__bool__()

    def __format__(self, format_spec):
        
        
        if format_spec == "":
            return shapely.to_wkt(self, rounding_precision=-1)
        elif format_spec == "x":
            return shapely.to_wkb(self, hex=True).lower()
        elif format_spec == "X":
            return shapely.to_wkb(self, hex=True)

        
        format_spec_regexp = (
            "(?:0?\\.(?P<prec>[0-9]+))?"
            "(?P<fmt_code>[fFgGxX]?)"
        )
        
        match = re.fullmatch(format_spec_regexp, format_spec)
        if match is None:
            raise ValueError(f"invalid format specifier: {format_spec}")

        prec, fmt_code = match.groups()

        if prec:
            prec = int(prec)
        else:
            
            prec = -1

        if not fmt_code:
            fmt_code = "g"

        if fmt_code in ("g", "G"):
            res = shapely.to_wkt(self, rounding_precision=prec, trim=True)
        elif fmt_code in ("f", "F"):
            res = shapely.to_wkt(self, rounding_precision=prec, trim=False)
        elif fmt_code in ("x", "X"):
            raise ValueError("hex representation does not specify precision")
        else:
            raise NotImplementedError(f"unhandled fmt_code: {fmt_code}")

        if fmt_code.isupper():
            return res.upper()
        else:
            return res

    def __repr__(self):
        
        try:
            wkt = super().__str__()
        except (GEOSException, ValueError):
            
            return f"<shapely.{self.__class__.__name__} Exception in WKT writer>"

        
        max_length = 78
        if len(wkt) > max_length:
            return f"<{wkt[: max_length - 3]}...>"

        return f"<{wkt}>"

    def __str__(self):
        
        return self.wkt

    def __reduce__(self):
        
        return (shapely.from_wkb, (shapely.to_wkb(self, include_srid=True),))

    
    

    def __and__(self, other):
        
        return self.intersection(other)

    def __or__(self, other):
        
        return self.union(other)

    def __sub__(self, other):
        
        return self.difference(other)

    def __xor__(self, other):
        
        return self.symmetric_difference(other)

    
    

    @property
    def coords(self):
        
        has_z = self.has_z
        has_m = self.has_m if _geos_ge_312 else False
        coords_array = shapely.get_coordinates(self, include_z=has_z, include_m=has_m)
        return CoordinateSequence(coords_array)

    @property
    def xy(self):
        
        raise NotImplementedError

    

    @property
    def __geo_interface__(self):
        
        raise NotImplementedError

    
    

    def geometryType(self):
        
        warn(
            "The 'GeometryType()' method is deprecated, and will be removed in "
            "the future. You can use the 'geom_type' attribute instead.",
            ShapelyDeprecationWarning,
            stacklevel=2,
        )
        return self.geom_type

    @property
    def type(self):
        
        warn(
            "The 'type' attribute is deprecated, and will be removed in "
            "the future. You can use the 'geom_type' attribute instead.",
            ShapelyDeprecationWarning,
            stacklevel=2,
        )
        return self.geom_type

    @property
    def wkt(self):
        
        
        return shapely.to_wkt(self, rounding_precision=-1)

    @property
    def wkb(self):
        
        return shapely.to_wkb(self)

    @property
    def wkb_hex(self):
        
        return shapely.to_wkb(self, hex=True)

    def svg(self, scale_factor=1.0, **kwargs):
        
        raise NotImplementedError

    def _repr_svg_(self):
        
        svg_top = (
            '<svg xmlns="http://www.w3.org/2000/svg" '
            'xmlns:xlink="http://www.w3.org/1999/xlink" '
        )
        if self.is_empty:
            return svg_top + "/>"
        else:
            
            xmin, ymin, xmax, ymax = self.bounds
            if xmin == xmax and ymin == ymax:
                
                xmin, ymin, xmax, ymax = self.buffer(1).bounds
            else:
                
                expand = 0.04  
                widest_part = max([xmax - xmin, ymax - ymin])
                expand_amount = widest_part * expand
                xmin -= expand_amount
                ymin -= expand_amount
                xmax += expand_amount
                ymax += expand_amount
            dx = xmax - xmin
            dy = ymax - ymin
            width = min([max([100.0, dx]), 300])
            height = min([max([100.0, dy]), 300])
            try:
                scale_factor = max([dx, dy]) / max([width, height])
            except ZeroDivisionError:
                scale_factor = 1.0
            view_box = f"{xmin} {ymin} {dx} {dy}"
            transform = f"matrix(1,0,0,-1,0,{ymax + ymin})"
            return (
                f'{svg_top}width="{width}" height="{height}" viewBox="{view_box}" '
                'preserveAspectRatio="xMinYMin meet">'
                f'<g transform="{transform}">{self.svg(scale_factor)}</g></svg>'
            )

    @property
    def geom_type(self):
        
        return GEOMETRY_TYPES[shapely.get_type_id(self)]

    
    

    @property
    def area(self):
        
        return float(shapely.area(self))

    def distance(self, other):
        
        return _maybe_unpack(shapely.distance(self, other))

    def hausdorff_distance(self, other):
        
        return _maybe_unpack(shapely.hausdorff_distance(self, other))

    @property
    def length(self):
        
        return float(shapely.length(self))

    @property
    def minimum_clearance(self):
          
        return float(shapely.minimum_clearance(self))

    
    

    @property
    def boundary(self):
        
        return shapely.boundary(self)

    @property
    def bounds(self):
        
        return tuple(shapely.bounds(self).tolist())

    @property
    def centroid(self):
        
        return shapely.centroid(self)

    def point_on_surface(self):
        
        return shapely.point_on_surface(self)

    def representative_point(self):
        
        return shapely.point_on_surface(self)

    @property
    def convex_hull(self):
        
        return shapely.convex_hull(self)

    @property
    def envelope(self):
        
        return shapely.envelope(self)

    @property
    def oriented_envelope(self):
        
        return shapely.oriented_envelope(self)

    @property
    def minimum_rotated_rectangle(self):
        
        return shapely.oriented_envelope(self)

    
    
    
    
    
    
    
    @deprecate_positional(
        ["cap_style", "join_style", "mitre_limit", "single_sided"],
        category=DeprecationWarning,
    )
    def buffer(
        self,
        distance,
        quad_segs=16,
        cap_style="round",
        join_style="round",
        mitre_limit=5.0,
        single_sided=False,
        **kwargs,
    ):
          
        quadsegs = kwargs.pop("quadsegs", None)
        if quadsegs is not None:
            warn(
                "The `quadsegs` argument is deprecated. Use `quad_segs` instead.",
                FutureWarning,
                stacklevel=2,
            )
            quad_segs = quadsegs

        resolution = kwargs.pop("resolution", None)
        if resolution is not None:
            warn(
                "The 'resolution' argument is deprecated. Use 'quad_segs' instead",
                DeprecationWarning,
                stacklevel=2,
            )
            quad_segs = resolution
        if kwargs:
            kwarg = list(kwargs.keys())[0]  
            raise TypeError(f"buffer() got an unexpected keyword argument '{kwarg}'")

        if mitre_limit == 0.0:
            raise ValueError("Cannot compute offset from zero-length line segment")
        elif not np.isfinite(distance).all():
            raise ValueError("buffer distance must be finite")

        return shapely.buffer(
            self,
            distance,
            quad_segs=quad_segs,
            cap_style=cap_style,
            join_style=join_style,
            mitre_limit=mitre_limit,
            single_sided=single_sided,
        )

    
    
    
    
    
    
    

    @deprecate_positional(["preserve_topology"], category=DeprecationWarning)
    def simplify(self, tolerance, preserve_topology=True):
        
        return shapely.simplify(self, tolerance, preserve_topology=preserve_topology)

    def normalize(self):
        
        return shapely.normalize(self)

    
    

    
    
    
    
    
    
    

    @deprecate_positional(["grid_size"], category=DeprecationWarning)
    def difference(self, other, grid_size=None):
        
        return shapely.difference(self, other, grid_size=grid_size)

    
    
    
    
    
    
    

    @deprecate_positional(["grid_size"], category=DeprecationWarning)
    def intersection(self, other, grid_size=None):
        
        return shapely.intersection(self, other, grid_size=grid_size)

    
    
    
    
    
    
    

    @deprecate_positional(["grid_size"], category=DeprecationWarning)
    def symmetric_difference(self, other, grid_size=None):
        
        return shapely.symmetric_difference(self, other, grid_size=grid_size)

    
    
    
    
    
    
    

    @deprecate_positional(["grid_size"], category=DeprecationWarning)
    def union(self, other, grid_size=None):
        
        return shapely.union(self, other, grid_size=grid_size)

    
    

    @property
    def has_z(self):
        
        return bool(shapely.has_z(self))

    @property
    def has_m(self):
        
        return bool(shapely.has_m(self))

    @property
    def is_empty(self):
        
        return bool(shapely.is_empty(self))

    @property
    def is_ring(self):
        
        return bool(shapely.is_ring(self))

    @property
    def is_closed(self):
        
        if self.geom_type == "LinearRing":
            return True
        return bool(shapely.is_closed(self))

    @property
    def is_simple(self):
        
        return bool(shapely.is_simple(self))

    @property
    def is_valid(self):
        
        return bool(shapely.is_valid(self))

    
    

    def relate(self, other):
        
        return shapely.relate(self, other)

    def covers(self, other):
        
        return _maybe_unpack(shapely.covers(self, other))

    def covered_by(self, other):
        
        return _maybe_unpack(shapely.covered_by(self, other))

    def contains(self, other):
        
        return _maybe_unpack(shapely.contains(self, other))

    def contains_properly(self, other):
        
        return _maybe_unpack(shapely.contains_properly(self, other))

    def crosses(self, other):
        
        return _maybe_unpack(shapely.crosses(self, other))

    def disjoint(self, other):
        
        return _maybe_unpack(shapely.disjoint(self, other))

    def equals(self, other):
        
        return _maybe_unpack(shapely.equals(self, other))

    def intersects(self, other):
        
        return _maybe_unpack(shapely.intersects(self, other))

    def overlaps(self, other):
        
        return _maybe_unpack(shapely.overlaps(self, other))

    def touches(self, other):
        
        return _maybe_unpack(shapely.touches(self, other))

    def within(self, other):
        
        return _maybe_unpack(shapely.within(self, other))

    def dwithin(self, other, distance):
        
        return _maybe_unpack(shapely.dwithin(self, other, distance))

    def equals_exact(self, other, tolerance=0.0, *, normalize=False):
        
        return _maybe_unpack(
            shapely.equals_exact(self, other, tolerance, normalize=normalize)
        )

    def relate_pattern(self, other, pattern):
        
        return _maybe_unpack(shapely.relate_pattern(self, other, pattern))

    
    

    
    
    
    
    
    
    

    @deprecate_positional(["normalized"], category=DeprecationWarning)
    def line_locate_point(self, other, normalized=False):
        
        return _maybe_unpack(
            shapely.line_locate_point(self, other, normalized=normalized)
        )

    
    
    
    
    
    
    

    @deprecate_positional(["normalized"], category=DeprecationWarning)
    def project(self, other, normalized=False):
        
        return _maybe_unpack(
            shapely.line_locate_point(self, other, normalized=normalized)
        )

    
    
    
    
    
    
    

    @deprecate_positional(["normalized"], category=DeprecationWarning)
    def line_interpolate_point(self, distance, normalized=False):
        
        return shapely.line_interpolate_point(self, distance, normalized=normalized)

    
    
    
    
    
    
    

    @deprecate_positional(["normalized"], category=DeprecationWarning)
    def interpolate(self, distance, normalized=False):
        
        return shapely.line_interpolate_point(self, distance, normalized=normalized)

    def segmentize(self, max_segment_length):
          
        return shapely.segmentize(self, max_segment_length)

    def reverse(self):
        
        return shapely.reverse(self)


class BaseMultipartGeometry(BaseGeometry):
    

    __slots__ = []

    @property
    def coords(self):
        
        raise NotImplementedError(
            "Sub-geometries may have coordinate sequences, "
            "but multi-part geometries do not"
        )

    @property
    def geoms(self):
        
        return GeometrySequence(self)

    def __bool__(self):
        
        return self.is_empty is False

    def __eq__(self, other):
        
        if not isinstance(other, BaseGeometry):
            return NotImplemented
        return (
            type(other) is type(self)
            and len(self.geoms) == len(other.geoms)
            and all(a == b for a, b in zip(self.geoms, other.geoms))
        )

    def __hash__(self):
        
        return super().__hash__()

    def svg(self, scale_factor=1.0, color=None):
        
        if self.is_empty:
            return "<g />"
        if color is None:
            color = "
        return "<g>" + "".join(p.svg(scale_factor, color) for p in self.geoms) + "</g>"


class GeometrySequence:
    

    
    
    
    
    _parent = None

    def __init__(self, parent):
        
        self._parent = parent

    def _get_geom_item(self, i):
        return shapely.get_geometry(self._parent, i)

    def __iter__(self):
        
        for i in range(self.__len__()):
            yield self._get_geom_item(i)

    def __len__(self):
        
        return shapely.get_num_geometries(self._parent)

    def __getitem__(self, key):
        
        m = self.__len__()
        if isinstance(key, (int, np.integer)):
            if key + m < 0 or key >= m:
                raise IndexError("index out of range")
            if key < 0:
                i = m + key
            else:
                i = key
            return self._get_geom_item(i)
        elif isinstance(key, slice):
            res = []
            start, stop, stride = key.indices(m)
            for i in range(start, stop, stride):
                res.append(self._get_geom_item(i))
            return type(self._parent)(res or None)
        else:
            raise TypeError("key must be an index or slice")


class EmptyGeometry(BaseGeometry):
    

    def __new__(self):
        
        warn(
            "The 'EmptyGeometry()' constructor to create an empty geometry is "
            "deprecated, and will raise an error in the future. Use one of the "
            "geometry subclasses instead, for example 'GeometryCollection()'.",
            ShapelyDeprecationWarning,
            stacklevel=2,
        )
        return shapely.from_wkt("GEOMETRYCOLLECTION EMPTY")
