
from __future__ import annotations

import itertools
import railroad
import pyparsing
import dataclasses
import typing
from typing import (
    Generic,
    TypeVar,
    Callable,
    Iterable,
)
from jinja2 import Template
from io import StringIO
import inspect
import re


jinja2_template_source = 

template = Template(jinja2_template_source)


_bookmark_lookup = {}
_bookmark_ids = itertools.count(start=1)

def _make_bookmark(s: str) -> str:
    
    if s in _bookmark_lookup:
        return _bookmark_lookup[s]

    
    bookmark = re.sub(r'[^a-zA-Z0-9-]+', '-', s)

    
    if not bookmark[:1].isalpha():
        bookmark = f"z{bookmark}"

    
    bookmark = bookmark.lower().strip('-')

    _bookmark_lookup[s] = bookmark = f"{bookmark}-{next(_bookmark_ids):04d}"

    return bookmark


def _collapse_verbose_regex(regex_str: str) -> str:
    if "\n" not in regex_str:
        return regex_str
    collapsed = pyparsing.Regex(r"
    collapsed = re.sub(r"\s*\n\s*", "", collapsed)
    return collapsed


@dataclasses.dataclass
class NamedDiagram:
    

    name: str
    index: int
    diagram: railroad.DiagramItem = None

    @property
    def bookmark(self):
        bookmark = _make_bookmark(self.name)
        return bookmark


T = TypeVar("T")


class EachItem(railroad.Group):
    

    all_label = "[ALL]"

    def __init__(self, *items) -> None:
        choice_item = railroad.Choice(len(items) - 1, *items)
        one_or_more_item = railroad.OneOrMore(item=choice_item)
        super().__init__(one_or_more_item, label=self.all_label)


class AnnotatedItem(railroad.Group):
    

    def __init__(self, label: str, item) -> None:
        super().__init__(item=item, label=f"[{label}]" if label else "")


class EditablePartial(Generic[T]):
    

    
    

    def __init__(self, func: Callable[..., T], args: list, kwargs: dict) -> None:
        self.func = func
        self.args = args
        self.kwargs = kwargs

    @classmethod
    def from_call(cls, func: Callable[..., T], *args, **kwargs) -> EditablePartial[T]:
        
        return EditablePartial(func=func, args=list(args), kwargs=kwargs)

    @property
    def name(self):
        return self.kwargs["name"]

    def __call__(self) -> T:
        
        args = self.args.copy()
        kwargs = self.kwargs.copy()

        
        
        arg_spec = inspect.getfullargspec(self.func)
        if arg_spec.varargs in self.kwargs:
            args += kwargs.pop(arg_spec.varargs)

        return self.func(*args, **kwargs)


def railroad_to_html(diagrams: list[NamedDiagram], embed=False, **kwargs) -> str:
    
    data = []
    for diagram in diagrams:
        if diagram.diagram is None:
            continue
        io = StringIO()
        try:
            css = kwargs.get("css")
            diagram.diagram.writeStandalone(io.write, css=css)
        except AttributeError:
            diagram.diagram.writeSvg(io.write)
        title = diagram.name
        if diagram.index == 0:
            title += " (root)"
        data.append(
            {
                "title": title, "text": "", "svg": io.getvalue(), "bookmark": diagram.bookmark
            }
        )

    return template.render(diagrams=data, embed=embed, **kwargs)


def resolve_partial(partial: EditablePartial[T]) -> T:
    
    if isinstance(partial, EditablePartial):
        partial.args = resolve_partial(partial.args)
        partial.kwargs = resolve_partial(partial.kwargs)
        return partial()
    elif isinstance(partial, list):
        return [resolve_partial(x) for x in partial]
    elif isinstance(partial, dict):
        return {key: resolve_partial(x) for key, x in partial.items()}
    else:
        return partial


def to_railroad(
    element: pyparsing.ParserElement,
    diagram_kwargs: typing.Optional[dict] = None,
    vertical: int = 3,
    show_results_names: bool = False,
    show_groups: bool = False,
    show_hidden: bool = False,
) -> list[NamedDiagram]:
    
    
    lookup = ConverterState(diagram_kwargs=diagram_kwargs or {})
    _to_diagram_element(
        element,
        lookup=lookup,
        parent=None,
        vertical=vertical,
        show_results_names=show_results_names,
        show_groups=show_groups,
        show_hidden=show_hidden,
    )

    root_id = id(element)
    
    if root_id in lookup:
        if not element.customName:
            lookup[root_id].name = ""
        lookup[root_id].mark_for_extraction(root_id, lookup, force=True)

    
    diags = list(lookup.diagrams.values())
    if len(diags) > 1:
        
        seen = set()
        deduped_diags = []
        for d in diags:
            
            if d.name == "...":
                continue
            if d.name is not None and d.name not in seen:
                seen.add(d.name)
                deduped_diags.append(d)
        resolved = [resolve_partial(partial) for partial in deduped_diags]
    else:
        
        
        resolved = [resolve_partial(partial) for partial in diags]
    return sorted(resolved, key=lambda diag: diag.index)


def _should_vertical(
    specification: int, exprs: Iterable[pyparsing.ParserElement]
) -> bool:
    
    if specification is None:
        return False
    else:
        return len(_visible_exprs(exprs)) >= specification


@dataclasses.dataclass
class ElementState:
    

    
    element: pyparsing.ParserElement
    
    converted: EditablePartial
    
    parent: EditablePartial
    
    number: int
    
    name: str = None
    
    parent_index: typing.Optional[int] = None
    
    extract: bool = False
    
    complete: bool = False

    def mark_for_extraction(
        self, el_id: int, state: ConverterState, name: str = None, force: bool = False
    ):
        
        self.extract = True

        
        if not self.name:
            if name:
                
                self.name = name
            elif self.element.customName:
                self.name = self.element.customName
            else:
                self.name = ""

        
        
        
        if force or (self.complete and _worth_extracting(self.element)):
            state.extract_into_diagram(el_id)


class ConverterState:
    

    def __init__(self, diagram_kwargs: typing.Optional[dict] = None) -> None:
        
        self._element_diagram_states: dict[int, ElementState] = {}
        
        self.diagrams: dict[int, EditablePartial[NamedDiagram]] = {}
        
        self.unnamed_index: int = 1
        
        self.index: int = 0
        
        self.diagram_kwargs: dict = diagram_kwargs or {}
        self.extracted_diagram_names: set[str] = set()

    def __setitem__(self, key: int, value: ElementState):
        self._element_diagram_states[key] = value

    def __getitem__(self, key: int) -> ElementState:
        return self._element_diagram_states[key]

    def __delitem__(self, key: int):
        del self._element_diagram_states[key]

    def __contains__(self, key: int):
        return key in self._element_diagram_states

    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default

    def generate_unnamed(self) -> int:
        
        self.unnamed_index += 1
        return self.unnamed_index

    def generate_index(self) -> int:
        
        self.index += 1
        return self.index

    def extract_into_diagram(self, el_id: int):
        
        position = self[el_id]

        
        if position.parent:
            href = f"
            ret = EditablePartial.from_call(railroad.NonTerminal, text=position.name, href=href)
            if "item" in position.parent.kwargs:
                position.parent.kwargs["item"] = ret
            elif "items" in position.parent.kwargs:
                position.parent.kwargs["items"][position.parent_index] = ret

        
        if position.converted.func == railroad.Group:
            content = position.converted.kwargs["item"]
        else:
            content = position.converted

        self.diagrams[el_id] = EditablePartial.from_call(
            NamedDiagram,
            name=position.name,
            diagram=EditablePartial.from_call(
                railroad.Diagram, content, **self.diagram_kwargs
            ),
            index=position.number,
        )

        del self[el_id]


def _worth_extracting(element: pyparsing.ParserElement) -> bool:
    
    children = element.recurse()
    return any(child.recurse() for child in children)


def _apply_diagram_item_enhancements(fn):
    

    def _inner(
        element: pyparsing.ParserElement,
        parent: typing.Optional[EditablePartial],
        lookup: ConverterState = None,
        vertical: int = None,
        index: int = 0,
        name_hint: str = None,
        show_results_names: bool = False,
        show_groups: bool = False,
        show_hidden: bool = False,
    ) -> typing.Optional[EditablePartial]:
        ret = fn(
            element,
            parent,
            lookup,
            vertical,
            index,
            name_hint,
            show_results_names,
            show_groups,
            show_hidden,
        )

        
        if show_results_names and ret is not None:
            element_results_name = element.resultsName
            if element_results_name:
                
                modal_tag = "" if element.modalResults else "*"
                ret = EditablePartial.from_call(
                    railroad.Group,
                    item=ret,
                    label=f"{repr(element_results_name)}{modal_tag}",
                )

        return ret

    return _inner


def _visible_exprs(exprs: Iterable[pyparsing.ParserElement]):
    non_diagramming_exprs = (
        pyparsing.ParseElementEnhance,
        pyparsing.PositionToken,
        pyparsing.And._ErrorStop,
    )
    return [
        e
        for e in exprs
        if not isinstance(e, non_diagramming_exprs)
    ]


@_apply_diagram_item_enhancements
def _to_diagram_element(
    element: pyparsing.ParserElement,
    parent: typing.Optional[EditablePartial],
    lookup: ConverterState = None,
    vertical: int = None,
    index: int = 0,
    name_hint: str = None,
    show_results_names: bool = False,
    show_groups: bool = False,
    show_hidden: bool = False,
) -> typing.Optional[EditablePartial]:
    
    exprs = element.recurse()
    name = name_hint or element.customName or type(element).__name__

    
    el_id = id(element)

    element_results_name = element.resultsName

    
    if not element.customName:
        if isinstance(
            element,
            (
                
                pyparsing.Forward,
                pyparsing.Located,
            ),
        ):
            
            if exprs:
                if not exprs[0].customName:
                    propagated_name = name
                else:
                    propagated_name = None

                return _to_diagram_element(
                    element.expr,
                    parent=parent,
                    lookup=lookup,
                    vertical=vertical,
                    index=index,
                    name_hint=propagated_name,
                    show_results_names=show_results_names,
                    show_groups=show_groups,
                    show_hidden=show_hidden,
                )

    
    if _worth_extracting(element):
        looked_up = lookup.get(el_id)
        if looked_up and looked_up.name is not None:
            
            
            looked_up.mark_for_extraction(el_id, lookup, name=name_hint)
            href = f"
            ret = EditablePartial.from_call(railroad.NonTerminal, text=looked_up.name, href=href)
            return ret

        elif el_id in lookup.diagrams:
            
            
            text = lookup.diagrams[el_id].kwargs["name"]
            ret = EditablePartial.from_call(
                railroad.NonTerminal, text=text, href=f"
            )
            return ret

    
    
    

    
    
    if not element.show_in_diagram and not show_hidden:
        return None

    if isinstance(element, pyparsing.And):
        
        
        if not exprs:
            return None
        if len(set((e.name, e.resultsName) for e in exprs)) == 1 and len(exprs) > 2:
            ret = EditablePartial.from_call(
                railroad.OneOrMore, item="", repeat=str(len(exprs))
            )
        elif _should_vertical(vertical, exprs):
            ret = EditablePartial.from_call(railroad.Stack, items=[])
        else:
            ret = EditablePartial.from_call(railroad.Sequence, items=[])
    elif isinstance(element, (pyparsing.Or, pyparsing.MatchFirst)):
        if not exprs:
            return None
        if _should_vertical(vertical, exprs):
            ret = EditablePartial.from_call(railroad.Choice, 0, items=[])
        else:
            ret = EditablePartial.from_call(railroad.HorizontalChoice, items=[])
    elif isinstance(element, pyparsing.Each):
        if not exprs:
            return None
        ret = EditablePartial.from_call(EachItem, items=[])
    elif isinstance(element, pyparsing.NotAny):
        ret = EditablePartial.from_call(AnnotatedItem, label="NOT", item="")
    elif isinstance(element, pyparsing.FollowedBy):
        ret = EditablePartial.from_call(AnnotatedItem, label="LOOKAHEAD", item="")
    elif isinstance(element, pyparsing.PrecededBy):
        ret = EditablePartial.from_call(AnnotatedItem, label="LOOKBEHIND", item="")
    elif isinstance(element, pyparsing.Group):
        if show_groups:
            ret = EditablePartial.from_call(AnnotatedItem, label="", item="")
        else:
            ret = EditablePartial.from_call(
                railroad.Group, item=None, label=element_results_name
            )
    elif isinstance(element, pyparsing.TokenConverter):
        label = type(element).__name__.lower()
        if label == "tokenconverter":
            ret = EditablePartial.from_call(railroad.Sequence, items=[])
        else:
            ret = EditablePartial.from_call(AnnotatedItem, label=label, item="")
    elif isinstance(element, pyparsing.Opt):
        ret = EditablePartial.from_call(railroad.Optional, item="")
    elif isinstance(element, pyparsing.OneOrMore):
        if element.not_ender is not None:
            args = [
                parent,
                lookup,
                vertical,
                index,
                name_hint,
                show_results_names,
                show_groups,
                show_hidden,
            ]
            return _to_diagram_element(
                (~element.not_ender.expr + element.expr)[1, ...].set_name(element.name),
                *args,
            )
        ret = EditablePartial.from_call(railroad.OneOrMore, item=None)
    elif isinstance(element, pyparsing.ZeroOrMore):
        if element.not_ender is not None:
            args = [
                parent,
                lookup,
                vertical,
                index,
                name_hint,
                show_results_names,
                show_groups,
                show_hidden,
            ]
            return _to_diagram_element(
                (~element.not_ender.expr + element.expr)[...].set_name(element.name),
                *args,
            )
        ret = EditablePartial.from_call(railroad.ZeroOrMore, item="")
    elif isinstance(element, pyparsing.Empty) and not element.customName:
        
        ret = None
    elif isinstance(element, pyparsing.ParseElementEnhance):
        ret = EditablePartial.from_call(railroad.Sequence, items=[])
    elif len(exprs) > 0 and not element_results_name:
        ret = EditablePartial.from_call(railroad.Group, item="", label=name)
    elif isinstance(element, pyparsing.Regex):
        collapsed_patt = _collapse_verbose_regex(element.pattern)
        ret = EditablePartial.from_call(railroad.Terminal, collapsed_patt)
    elif len(exprs) > 0:
        ret = EditablePartial.from_call(railroad.Sequence, items=[])
    else:
        terminal = EditablePartial.from_call(railroad.Terminal, element.defaultName)
        ret = terminal

    if ret is None:
        return

    
    lookup[el_id] = ElementState(
        element=element,
        converted=ret,
        parent=parent,
        parent_index=index,
        number=lookup.generate_index(),
    )
    if element.customName:
        lookup[el_id].mark_for_extraction(el_id, lookup, element.customName)

    i = 0
    for expr in exprs:
        
        if "items" in ret.kwargs:
            ret.kwargs["items"].insert(i, None)

        item = _to_diagram_element(
            expr,
            parent=ret,
            lookup=lookup,
            vertical=vertical,
            index=i,
            show_results_names=show_results_names,
            show_groups=show_groups,
            show_hidden=show_hidden,
        )

        
        if item is not None:
            if "item" in ret.kwargs:
                ret.kwargs["item"] = item
            elif "items" in ret.kwargs:
                
                ret.kwargs["items"][i] = item
                i += 1
        elif "items" in ret.kwargs:
            
            del ret.kwargs["items"][i]

    
    if ret and (
        ("items" in ret.kwargs and len(ret.kwargs["items"]) == 0)
        or ("item" in ret.kwargs and ret.kwargs["item"] is None)
    ):
        ret = EditablePartial.from_call(railroad.Terminal, name)

    
    if el_id in lookup:
        lookup[el_id].complete = True

    if el_id in lookup and lookup[el_id].extract and lookup[el_id].complete:
        lookup.extract_into_diagram(el_id)
        if ret is not None:
            text = lookup.diagrams[el_id].kwargs["name"]
            href = f"
            ret = EditablePartial.from_call(
                railroad.NonTerminal, text=text, href=href
            )

    return ret
